<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MongoDB-基础</title>
      <link href="/202210/2036978.html"/>
      <url>/202210/2036978.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 MongoDB使用基础 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><strong>MongoDB</strong>：是一个基于分布式文件存储的、开源、高性能、无模式的 Nosql数据库；支持的数据结构非常松散，可以通过 <strong>BSON</strong>（类似于 JSON 的 格式） 来存储数据；既可以存储比较复杂的数据类型，又相当的灵活；MongoDB 中的记录是一个文档，由字段和值对（fifield:value）组成；<strong>MongoDB是最像关系型数据库（MySQL）的非关系型数据库</strong>；<a href="https://www.mongodb.com/"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></p><p><strong>BSON</strong>：Binary Serialized Document Format，是一种类json的一种二进制形式的存储格式，简称Binary JSON；支持内嵌的文档对象和数组对象，具备丰富的数据类型</p><h2 id="1-1-应用场景"><a href="#1-1-应用场景" class="headerlink" title="1.1 应用场景"></a>1.1 应用场景</h2><p><strong>三高需求</strong>：高可用、高性能、高并发</p><p>High performance：高并发</p><p>Huge Storage：高性能</p><p>High Scalability &amp; High Availability：高可扩展性和高可用</p><h2 id="1-2-区别"><a href="#1-2-区别" class="headerlink" title="1.2 区别"></a>1.2 区别</h2><table><thead><tr><th><strong>SQL术语/概念</strong></th><th><strong>MongoDB术语/概念</strong></th><th><strong>解释说明</strong></th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>fifield</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td>嵌入文档</td><td>表连接；MongoDB不支持表连接；通过嵌入式文档来替代多表连接</td></tr><tr><td>primary key</td><td>primary key</td><td>主键；MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h2 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h2><p><strong>高性能</strong>：MongoDB提供高性能的数据持久性；对嵌入式数据模型的支持减少了数据库系统上的I/O活动；索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键（文本索引解决搜索的需求、TTL索引解决历史数据自动过期的需求、地理位置索引可用于构建各种 O2O 应用）；mmapv1、wiredtiger、mongorocks（rocksdb）、in-memory 等多引擎支持满足多种场景，Gridfs解决文件存储</p><p><strong>高可用性</strong>：MongoDB的复制工具称为副本集（replica set），提供自动故障转移和数据冗余</p><p><strong>高扩展性</strong>：MongoDB提供水平可扩展性；分片将数据分布在一组集群的机器上；从3.4开始，MongoDB支持基于片键创建数据区域，在一个平衡的集群中，MongoDB将一个区域所覆盖的读写只定向到指定区域内的指定片</p><p><strong>丰富的查询支持</strong>：MongoDB支持丰富的查询语言，支持读和写操作(CRUD)，比如数据聚合、文本搜索和地理空间查询等</p><p><strong>其他特点</strong>：无模式（动态模式）、灵活的文档模型</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="2-1-Windows安装"><a href="#2-1-Windows安装" class="headerlink" title="2.1 Windows安装"></a>2.1 Windows安装</h2><p><a href="https://www.mongodb.com/download-center#community"><font face = "微软雅黑" color = 1E90FF size = 5>下载地址</font></a>，选择合适的版本进行下载安装</p><ol><li><p>将压缩包解压到一个目标目录中（自定义）</p></li><li><p>在解压目录中，手动建立一个目录用于存放数据文件，data/db；推荐与 bin 同级</p></li><li><p>启动服务：默认端口是27017</p><ul><li><p>命令启动：在 bin 目录中打开 cmd命令行提示符，输入命令：<strong>mongod –dbpath=..\data\db</strong></p></li><li><p>配置文件启动：在解压目录中新建 config 文件夹（与 bin 同级），该文件夹中新建配置文件 mongod.conf；更多配置参考：<a href="https://docs.mongodb.com/manual/reference/confifiguration-options/"><font face = "微软雅黑" color = 1E90FF size = 5>配置文件参考地址</font></a></p><pre class="line-numbers language-none"><code class="language-none">storage:    # 设置数据文件路径，D:\02_Server\DBServer\mongodb-win32-x86_64-2008plus-ssl-4.0.1，需要修改为自己的路径    dbPath: D:\02_Server\DBServer\mongodb-win32-x86_64-2008plus-ssl-4.0.1\data启动：mongod --config ..&#x2F;config&#x2F;mongod.conf （在 bin 目录中打开 cmd命令行提示符，运行）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li><p>远程连接：在命令行提示符运行：<strong>mongo –host=127.0.0.1 –port=27017</strong> 完成登录，可通过 <strong>mongo –help</strong> 查看帮助</p></li></ol><h2 id="2-2-安装图形化界面-Compass"><a href="#2-2-安装图形化界面-Compass" class="headerlink" title="2.2 安装图形化界面-Compass"></a>2.2 安装图形化界面-Compass</h2><p><a href="https://www.mongodb.com/download-center/v2/compass?initial=true"><font face = "微软雅黑" color = 1E90FF size = 5>下载地址</font></a>，选择合适的版本进行下载安装；如果是下载安装版，则按照步骤安装；如果是下载加压缩版，直接解压，执行里面的 MongoDBCompassCommunity.exe 文件即可</p><p>连接：在打开的界面中，输入主机地址、端口等相关信息，点击连接；完成与本地 MongoDB 连接，以后操作可在 Compass 中进行</p><h2 id="2-3-Linux安装"><a href="#2-3-Linux安装" class="headerlink" title="2.3 Linux安装"></a>2.3 Linux安装</h2><ol><li><p><a href="https://www.mongodb.com/download-center#community"><font face = "微软雅黑" color = 1E90FF size = 5>下载地址</font></a>，官网下载压缩包 mongod-linux-x86_64-x.x.x.tgz</p></li><li><p>上传压缩包到Linux中，解压到当前目录：tar -xvf mongodb-linux-x86_64-x.x.x.tgz</p></li><li><p>移动解压后的文件夹到指定的目录：mv mongodb-linux-x86_64-x.x.x /usr/local/mongodb</p></li><li><p>新建目录：用来存储数据和日志</p><pre class="line-numbers language-none"><code class="language-none"># 数据存储目录mkdir -p &#x2F;mongodb&#x2F;single&#x2F;data&#x2F;db# 日志存储目录mkdir -p &#x2F;mongodb&#x2F;single&#x2F;log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>新建配置文件：vi /mongodb/single/mongod.conf</p><pre class="line-numbers language-none"><code class="language-none"># 内容如下：systemLog:    # MongoDB发送所有日志输出的目标指定为文件    # The path of the log file to which mongod or mongos should send all diagnostic logging information    destination: file    # mongod或mongos应向其发送所有诊断日志记录信息的日志文件的路径    path: &quot;&#x2F;mongodb&#x2F;single&#x2F;log&#x2F;mongod.log&quot;    # 当mongos或mongod实例重新启动时，mongos或mongod会将新条目附加到现有日志文件的末尾。    logAppend: truestorage:    # mongod实例存储其数据的目录。storage.dbPath设置仅适用于mongod。    # The directory where the mongod instance stores its data.Default Value is &quot;&#x2F;data&#x2F;db&quot;.    dbPath: &quot;&#x2F;mongodb&#x2F;single&#x2F;data&#x2F;db&quot;    journal:        # 启用或禁用持久性日志以确保数据文件保持有效和可恢复。        enabled: trueprocessManagement:    # 启用在后台运行mongos或mongod进程的守护进程模式。    fork: truenet:    # 服务实例绑定的IP，默认是localhost    bindIp: localhost,192.168.0.2    # bindIp    # 绑定的端口，默认是27017    port: 27017<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动MongoDB服务： /usr/local/mongodb/bin/mongod -f /mongodb/single/mongod.conf，如果启动失败，原因基本上就是配置文件</p></li><li><p>使用mongo命令和compass工具来连接测试</p><pre class="line-numbers language-none"><code class="language-none"># 如果远程连接不上，需要配置防火墙放行，或直接关闭linux防火墙# 查看防火墙状态systemctl status firewalld# 临时关闭防火墙systemctl stop firewalld# 开机禁止启动防火墙systemctl disable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>停止关闭服务</p><pre class="line-numbers language-none"><code class="language-none"># 切换到admin库use admin# 关闭服务db.shutdownServer()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><table><thead><tr><th><strong>数据类型</strong></th><th><strong>描述</strong></th><th><strong>举例</strong></th></tr></thead><tbody><tr><td>字符串</td><td>UTF-8字符串都可表示为字符串类型的数据</td><td>{“x” : “foobar”}</td></tr><tr><td>对象id</td><td>对象id是文档的12字节的唯一 ID</td><td>{“X” :ObjectId() }</td></tr><tr><td>布尔值</td><td>真或者假：true或者false</td><td>{“x”:true}+</td></tr><tr><td>数组</td><td>值的集合或者列表可以表示成数组</td><td>{“x” ： [“a”, “b”, “c”]}</td></tr><tr><td>32位整数</td><td>类型不可用；JavaScript仅支持64位浮点数，所以32位整数会被自动转换</td><td>shell是不支持该类型的，shell中默认会转换成64位浮点数</td></tr><tr><td>64位整数</td><td>不支持；shell会使用一个特殊的内嵌文档来显示64位整数</td><td>shell是不支持该类型的，shell中默认会转换成64位浮点数</td></tr><tr><td>64位浮点数</td><td>shell中的数字就是这一种类型</td><td>{“x”：3.14159，”y”：3}</td></tr><tr><td>null</td><td>表示空值或者未定义的对象</td><td>{“x”:null}</td></tr><tr><td>undefifined</td><td>文档中也可以使用未定义类型</td><td>{“x”:undefifined}</td></tr><tr><td>符号</td><td>shell不支持，shell会将数据库中的符号类型的数据自动转换成字符串</td><td></td></tr><tr><td>正则表达式</td><td>文档中可以包含正则表达式，采用JavaScript的正则表达式语法</td><td>{“x” ： /foobar/i}</td></tr><tr><td>代码</td><td>文档中还可以包含JavaScript代码</td><td>{“x” ： function() { /* …… */ }}</td></tr><tr><td>二进制数据</td><td>二进制数据可以由任意字节的串组成，不过shell中无法使用</td><td></td></tr><tr><td>最大值/最小值</td><td></td><td>BSON包括一个特殊类型，表示可能的最大值；shell中没有这个类型</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch-基础</title>
      <link href="/202210/1811009.html"/>
      <url>/202210/1811009.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 ElasticSearch使用基础 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><strong>ELK</strong>：Elasticsearch、Logstash、Kibana 三大开源框架首字母大写简称，也被称为 <strong>Elastic Stack</strong>；ELK 不仅是一个<strong>日志分析架构技术栈</strong>的总称，还可以支持其它任何数据的收集和分析的场景；<a href="https://www.elastic.co/cn/"><font face = "微软雅黑" color = 1E90FF size = 5>Elastic Stack官网</font></a></p><ul><li><strong>ElasticSearch</strong>：简称 ES，是一个开源的<strong>高扩展</strong>的<strong>分布式全文搜索引擎</strong>，可近乎<strong>实时存储、检索数据</strong>；扩展性好，可处理 PB级别的数据；使用 Java 语言基于 Lucene 为核心实现所有索引和搜索功能，通过简单的 <strong>REST-ful API</strong> 隐藏 Lucene 的复杂性，简化全文搜索；简言：<strong>Elasticsearch 是一个基于Lucene、分布式、通过Restful方式进行交互的近实时搜索平台框架</strong>；是 ELK 三大开源框架之一；<a href="https://www.elastic.co/cn/downloads/enterprise-search"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></li><li><strong>Logstash</strong>：是ELK的<strong>中央数据流引擎</strong>，用于从不同目标（文件 / 数据存储 / MQ）收集的不同格式数据，经过过滤后支持输出到不同目的地（文件 / MQ / redis / elasticsearch / kafka等）；<a href="https://www.elastic.co/cn/downloads/logstash"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></li><li><strong>Kibana</strong>：是一个针对 Elasticsearch 的<strong>开源分析及可视化平台</strong>，用来搜索、查看交互存储在 Elasticsearch 索引中的数据，可以通过各种图表进行高级数据分析及展示；基于浏览器的用户界面可以<strong>快速创建仪表板</strong>（dashboard）<strong>实时显示</strong> Elasticsearch 的查询动态；<a href="https://www.elastic.co/cn/kibana/"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></li></ul><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/ElasticSearch/ELK_Logic.png" alt="ELK_Logic"></p><p>注：安装部署时，需要保证 Elasticsearch、Logstash、Kibana 三者的版本一致；且 ELK 解压即安装</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p>前置条件：最低要求安装 jdk1.8 和 Node.js</p><p><a href="https://www.elastic.co/cn/downloads/enterprise-search"><font face = "微软雅黑" color = 1E90FF size = 5>最新版下载地址</font></a>，<a href="https://www.elastic.co/cn/downloads/past-releases#elasticsearch"><font face = "微软雅黑" color = 1E90FF size = 5>其他版本下载地址</font></a>；选择合适的系统、版本后，解压即安装</p><h2 id="2-1-熟悉目录"><a href="#2-1-熟悉目录" class="headerlink" title="2.1 熟悉目录"></a>2.1 熟悉目录</h2><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/ElasticSearch/ElasticSearch_files.png" alt="ElasticSearch_files"></p><ul><li><p>bin：启动文件</p></li><li><p>config：配置文件</p><pre><code> log4j2：日志配置文件 jvm.options：java虚拟机相关的配置 elasticsearch.yml：elasticsearch的配置文件！默认9200端口！跨域！</code></pre></li><li><p>lib：相关jar包</p></li><li><p>logs：日志</p></li><li><p>modules：功能模块</p></li><li><p>plugins：插件</p></li></ul><h2 id="2-2-测试"><a href="#2-2-测试" class="headerlink" title="2.2 测试"></a>2.2 测试</h2><ol><li>启动 双击bin文件夹下的 elasticsearch.bat；</li><li>修改配置文件 /config/elasticsearch.yml；注：启动时会去更新地图的一些数据库，可以直接禁掉，用到时再起</li></ol><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/ElasticSearch/Start_Config.jpg" alt="Start_Config"></p><ol start="3"><li>访问测试：浏览器访问 localhost:9200；能出现内容，则访问成功</li></ol><h2 id="2-3-安装es可视化界面-head的插件"><a href="#2-3-安装es可视化界面-head的插件" class="headerlink" title="2.3 安装es可视化界面-head的插件"></a>2.3 安装es可视化界面-head的插件</h2><ol><li><p>git克隆下载：git clone git://github.com/mobz/elasticsearch-head.git</p></li><li><p>解压即可（推荐与 elasticsearch 同级目录）</p></li><li><p>进入目录：cd elasticsearch-head</p></li><li><p>npm 安装：npm install ；也可以通过淘宝镜像安装 ：cnpm install</p></li><li><p>启动：npm run start</p></li><li><p>访问：浏览器访问 localhost:9100 ，可成功连接 localhost:9200 即可</p></li></ol><p>注：存在跨域问题，需要在 /config/elasticsearch.yml 中新增配置</p><pre class="line-numbers language-none"><code class="language-none">http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-4-安装Kibana"><a href="#2-4-安装Kibana" class="headerlink" title="2.4 安装Kibana"></a>2.4 安装Kibana</h2><p><a href="https://www.elastic.co/cn/downloads/kibana"><font face = "微软雅黑" color = 1E90FF size = 5>下载地址</font></a>，选择合适的版本下载完成之后，解压即安装</p><ol><li>启动：双击bin文件夹下的 Kibana.bat ；访问：浏览器访问 localhost:5601</li><li>汉化：修改 /config/Kibana.yml文件：添加配置(115行)  i18n.locale: “zh-CN” ；重启 Kibana</li></ol><p><strong>注</strong>：Kibana 只执行光标所在的行</p><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><h2 id="3-1-核心概念"><a href="#3-1-核心概念" class="headerlink" title="3.1 核心概念"></a>3.1 核心概念</h2><table><thead><tr><th align="left">Relational DB</th><th align="left">ElasticSearch</th></tr></thead><tbody><tr><td align="left">数据库(database)</td><td align="left">索引(indices)</td></tr><tr><td align="left">表(tables)</td><td align="left">类型types(会被弃用)</td></tr><tr><td align="left">行(rows)</td><td align="left">documents</td></tr><tr><td align="left">字段(columns)</td><td align="left">fields</td></tr></tbody></table><p>ElasticSearch (集群：默认搭建集群，集群名为 elasticsearch，一台机器就是一个集群)中可以包含多个索引(数据库)，每个索引中可以包含多个类型(表)，每个类型下又包含多个文档(行)，每个文档中又包含多个字段(列)；数据以 <strong>Json格式</strong>进行存储；索引和搜索数据的最小单位是文档</p><p><strong>文档</strong>：类比于关系型数据库里面的一条记录</p><ul><li><strong>自我包含</strong>：一篇文档同时包含字段和对应的值，也就是同时包含 key:value</li><li><strong>层次型</strong>：一个文档中包含自文档（本身是一个<strong>json对象</strong>，可通过 fastjson 自动转换）</li><li><strong>结构灵活</strong>：文档不依赖预先定义的模式，可以忽略该字段，或者动态的添加一个新的字段；elasticsearch 会保存字段和类型之间的映射及其他的设置，因此在elasticsearch中类型有时候也称为映射类型</li></ul><p><strong>类型</strong>：类型是文档的逻辑容器，类似于表是记录的容器；类型中对于字段的定义称为映射：如name映射为字符串类型；新增一个字段时，elasticsearch会自动的将新字段加入映射</p><p><strong>索引</strong>：类比于数据库，是映射类型的容器；索引存储映射类型的字段和其他设置；然后将它们进行分片存储</p><p><strong>物理设计</strong>：elasticsearch 在后台把每个索引划分成多个分片，每个分片可以在集群中的不同服务器间迁移；集群中每一个节点都有一个 elasticsearch 进程，节点可以有多个索引默认；创建索引时，默认会有5个分片（primary shard，又称主分片）构成，每一个主分片会有一个副本（replica shard，又称复制分片），主分片和对应的复制分片都不会在同一个节点内；一个分片是一个Lucene索引，一个包含<strong>倒排索引</strong>的文件目录，倒排索引的结构使得 elasticsearch在 不扫描全部文档的情况下，可以返回文档包含特定的关键字</p><ul><li><strong>倒排索引</strong>：elasticsearch 使用倒排索引：采用Lucene倒排索作为底层；适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表；创建倒排索引，首先要将每个文档拆分成独立的词（或词条、tokens），然后创建一个包含所有不重复的词条的排序列表，然后列出每个词条出现的文档ID</li></ul><p><strong>逻辑设计</strong>：一个索引类型中，包含多个文档；索引一篇文档时，通过 索引&gt;类型&gt;文档ID 组合索引到指定文档；ID不必是整数，实际上ID是个字符串</p><h2 id="3-2-Rest风格介绍"><a href="#3-2-Rest风格介绍" class="headerlink" title="3.2 Rest风格介绍"></a>3.2 Rest风格介绍</h2><p><strong>Rest</strong>：是一种软件架构风格，提供一组设计原则和约束条件，而不是标准；主要用于客户端和服务器交互类的软件；更简洁，更有层次，更易于实现缓存等</p><table><thead><tr><th align="center">命令</th><th align="center">url地址</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">PUT</td><td align="center">localhost:9200/索引名称/类型名称/文档id</td><td align="center">创建文档（指定文档id）</td></tr><tr><td align="center">POST</td><td align="center">localhost:9200/索引名称/类型名称</td><td align="center">创建文档（随机文档id）</td></tr><tr><td align="center">POST</td><td align="center">localhost:9200/索引名称/类型名称/文档id/_update</td><td align="center">修改文档</td></tr><tr><td align="center">DELETE</td><td align="center">localhost:9200/索引名称/类型名称/文档id</td><td align="center">删除文档</td></tr><tr><td align="center">GET</td><td align="center">localhost:9200/索引名称/类型名称/文档id</td><td align="center">查询文档通过文档id</td></tr><tr><td align="center">POST</td><td align="center">localhost:9200/索引名称/类型名称/_search</td><td align="center">查询所有数据</td></tr></tbody></table><p><strong>注</strong>：使用命令是都需要大写</p><h2 id="3-3-操作"><a href="#3-3-操作" class="headerlink" title="3.3 操作"></a>3.3 操作</h2><h3 id="3-3-1-数据类型"><a href="#3-3-1-数据类型" class="headerlink" title="3.3.1 数据类型"></a>3.3.1 数据类型</h3><p><strong>数据类型</strong>：<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/keyword.html"><font face = "微软雅黑" color = 1E90FF size = 5>官网类型文档地址</font></a></p><ul><li>字符串类型：text（会被分词器解析）、keyword（不会被分词器解析）</li><li>数值类型：long，integer，short，byte，double，float，half float，scaled float</li><li>日期类型：date</li><li>布尔值类型：boolean</li><li>二进制类型：binary</li></ul><h3 id="3-3-2-索引操作"><a href="#3-3-2-索引操作" class="headerlink" title="3.3.2 索引操作"></a>3.3.2 索引操作</h3><p><strong>新建</strong>：PUT /idx_name</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 创建索引规则，即数据属性定义；不指定时， elasticsearch 会默认指定PUT &#x2F;idx_name    &#x2F;&#x2F; 创建空索引&#123;&quot;mapping&quot;: &#123;&quot;properties&quot;: &#123;&quot;name&quot;: &#123;&quot;type&quot;: &quot;text&quot;    &#x2F;&#x2F; 指定数据类型&#125;,&quot;age&quot;: &#123;&quot;type&quot;: &quot;int&quot;&#125;,&quot;sex&quot;: &#123;&quot;type&quot;: &quot;boolean&quot;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除</strong>：DELETE idx_name</p><p><strong>查询</strong>：GET idx_name</p><pre class="line-numbers language-none"><code class="language-none">GET idx_name         &#x2F;&#x2F; 查看索引规则信息GET _cat&#x2F;health      &#x2F;&#x2F; 查看健康值GET _cat&#x2F;indices?v   &#x2F;&#x2F; 查看所有东西的版本信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-3-文档操作"><a href="#3-3-3-文档操作" class="headerlink" title="3.3.3 文档操作"></a>3.3.3 文档操作</h3><p><strong>新增数据</strong>：PUT /idx_name/_doc/doc_id；指明文档：/索引名/类型名/文档id，ElasticSearch 8以后，类型弃用，默认使用_doc，即：PUT /索引名/_doc/文档id</p><pre class="line-numbers language-none"><code class="language-none">PUT &#x2F;es_study&#x2F;_user&#x2F;1&#123;&#x2F;&#x2F; 请求体，传入 json 数据&quot;name&quot;: &quot;zhang&quot;,&quot;age&quot;: 18,&quot;sex&quot;: &quot;true&quot;,   &#x2F;&#x2F; true 表示男性&quot;job&quot;: &quot;computer&quot;&#125;PUT &#x2F;es_study&#x2F;_user&#x2F;2&#123;&quot;name&quot;: &quot;li&quot;,&quot;age&quot;: 40,&quot;sex&quot;: &quot;true&quot;,&quot;job&quot;: &quot;farmer&quot;&#125;PUT &#x2F;es_study&#x2F;_user&#x2F;3&#123;&quot;name&quot;: &quot;wang&quot;,&quot;age&quot;: 18,&quot;sex&quot;: &quot;false&quot;,&quot;job&quot;: &quot;free&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除</strong>：DELETE idx_name/_doc/doc_id</p><p><strong>修改</strong>：POST /idx_name/_doc/doc_id/<strong>_update</strong>；修改后 _version 的值会加1</p><pre class="line-numbers language-none"><code class="language-none">POST &#x2F;es_study&#x2F;_user&#x2F;1&#x2F;_update&#123;&quot;doc&quot;: &#123;&quot;name&quot;: &quot;zhangs&quot;&#125;&#125;PUT &#x2F;es_study&#x2F;_user&#x2F;1    &#x2F;&#x2F; 再次新增相同的文档会在原有文档基础上进行修改&#123;&quot;name&quot;: &quot;zhangs&quot;,&quot;age&quot;: 20,&quot;sex&quot;: &quot;true&quot;,&quot;job&quot;: &quot;computer&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查询</strong>：GET idx_name/_doc/doc_id 或者 GET idx_name/_doc/_search?q=condition</p><pre class="line-numbers language-none"><code class="language-none">GET idx_name&#x2F;_doc&#x2F;doc_id   &#x2F;&#x2F; 搜索文档所有的数据GET &#x2F;es_study&#x2F;_user&#x2F;_search?q&#x3D;name:zhangs  &#x2F;&#x2F; 进行条件检索，多个文档满足条件时，会有 _score分数关键字，衡量文档的相关性，数值越大，相关性越高<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; 通过 json构建参数体进行查询GET &#x2F;es_study&#x2F;_search&#123;&quot;query&quot;: &#123;      &#x2F;&#x2F; 通过 query 指定查询条件&quot;match&quot;: &#123;  &#x2F;&#x2F; 使用分词器先解析文档，再进行查询，term：通过倒排索引指定的词条进行精确查找；text：会被分词器解析、keyword：不会被分词器解析&quot;name&quot;: &quot;zhang&quot;&#125;&#125;,&quot;_source&quot;: [&quot;name&quot;, &quot;age&quot;],  &#x2F;&#x2F; 限定查询的字段&quot;sort&quot;: &#123;       &#x2F;&#x2F; 指定字段排序&quot;age&quot;: &#123;&quot;order&quot;: &quot;desc&quot;&#125;&#125;,&quot;form&quot;: 0, &quot;size&quot;: 2,        &#x2F;&#x2F; 相当于 limit form, size：从form处开始检索，返回size条数据&quot;highlight&quot;: &#123;    &#x2F;&#x2F; 配置高亮显示&quot;fields&quot;: &#123;   &#x2F;&#x2F; 配置高亮显示的区域&quot;name&quot;: &#123;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">GET &#x2F;es_study&#x2F;_search&#123;&quot;query&quot;: &#123;&quot;bool&quot;: &#123;        &#x2F;&#x2F; 设置多条件查询&quot;must&quot;: [    &#x2F;&#x2F; must：多条件精确查询，类比于 and；should：类比于 or；must_not：类比于 not                &#123;                    &quot;match&quot;: &#123;                        &quot;name&quot;: &quot;zhang&quot;                    &#125;                &#125;,                &#123;                    &quot;match&quot;: &#123;                        &quot;age&quot;: &quot;18&quot;                    &#125;                &#125;,                &#123;                    &quot;match&quot;: &#123;                        &quot;job&quot;: &quot;free computer&quot;    &#x2F;&#x2F; 多条件使用空格进行分隔                    &#125;                &#125;],&quot;filter&quot;: &#123;          &#x2F;&#x2F; 进行数据过滤&#123;&quot;range&quot;: &#123;&quot;age&quot;: &#123;&quot;gte&quot;: 18,    &#x2F;&#x2F; gt：大于；gte：大于等于；lt：小于；lte：小于等于&quot;lt&quot;: 50&#125;&#125;&#125;&#125;&#125;&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;aggs&quot;:&#123;        &quot;age-group&quot;:&#123;            &#x2F;&#x2F; 分组名任意            &quot;terms&quot;:&#123;            &#x2F;&#x2F; 分组，改为avg就是求平均值                &quot;field&quot;:&quot;age&quot;    &#x2F;&#x2F; 根据什么分组            &#125;        &#125;    &#125;,    &quot;size&quot;:0     &#x2F;&#x2F; 取除原始数据&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&#123;    &quot;properties&quot;:&#123;        &quot;name&quot;:&#123;            &quot;type&quot;:&quot;text&quot;,            &quot;index&quot;:true        &#125;,        &quot;sex&quot;:&#123;            &quot;type&quot;:&quot;keyword&quot;,            &quot;index&quot;:true        &#125;,        &quot;tel&quot;:&#123;            &quot;type&quot;:&quot;keyword&quot;            &quot;index&quot;:false        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-应用"><a href="#4-应用" class="headerlink" title="4. 应用"></a>4. 应用</h1><h2 id="4-1-IK分词器"><a href="#4-1-IK分词器" class="headerlink" title="4.1 IK分词器"></a>4.1 IK分词器</h2><h3 id="4-1-1-简介"><a href="#4-1-1-简介" class="headerlink" title="4.1.1 简介"></a>4.1.1 简介</h3><p><strong>分词</strong>：即把一段文字划分成一个个的关键字；在搜索时候会把信息进行分词，同时把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，显然不总能符合要求<br><strong>ik分词器</strong>：实现分词操作的一个工具，提供两个分词算法：<strong>ik_smart(最少切分：数据不会有重复)</strong> 和 <strong>ik_max_word(最细粒度划分：穷尽词库)</strong></p><p><a href="https://github.com/medcl/elasticsearch-analysis-ik/releases"><font face = "微软雅黑" color = 1E90FF size = 5>下载地址</font></a>，选择合适的版本下载完成之后，解压放在 elasticsearch 的 plugins目录下即可；完成后需要重启 ES；可通过 elasticsearch-plugin list 命令查看加载的插件</p><h3 id="4-1-2-使用"><a href="#4-1-2-使用" class="headerlink" title="4.1.2 使用"></a>4.1.2 使用</h3><pre class="line-numbers language-none"><code class="language-none">GET _analyze         # _analyze 为方法名，可自定义&#123;    &quot;analyzer&quot;: &quot;ik_smart&quot;,    &quot;text&quot;: &quot;你好，世界&quot;&#125;GET _analyze&#123;    &quot;analyzer&quot;: &quot;ik_max_word&quot;,    &quot;text&quot;: &quot;你好，世界&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>自定义配置词典</strong>：</p><ol><li><p>新建自定义字典，文件后缀 .dic ，文件编码使用UTF-8，不同词语通过换行符进行分隔</p></li><li><p>将自定义字典配置添加到 IKAnalyzer.cfg.xml 配置文件中<br><img src="https://qizhongyi.gitee.io/images/Data/DataBase/ElasticSearch/IK_Dic.jpg" alt="IK_Dic"></p></li><li><p>重启ES，再次连接  Kibana</p></li></ol><h2 id="4-2-集群"><a href="#4-2-集群" class="headerlink" title="4.2 集群"></a>4.2 集群</h2><p><strong>Cluster</strong>：代表一个集群，集群中有多个节点，其中有一个为主节点，可以通过选举产生</p><p><strong>Shards</strong>：代表索引分片，es可以把一个完整的索引分成多个分片，分布到不同的节点上，构成分布式搜索；分片的数量只能在索引创建前指定，并且索引创建后不能更改</p><ul><li>每个分片本质上就是一个Lucene索引，会消耗相应的文件句柄，内存和CPU资源</li></ul><p><strong>Replicas</strong>：代表索引副本，es可以设置多个索引的副本；作用：一是提高系统的容错性，当某个节点某个分片损坏或丢失时可以从副本中恢复；二是提高es的查询效率，es会自动对搜索请求进行负载均衡</p><p><strong>Recovery</strong>：代表数据恢复或叫数据重新分布，es在有节点加入或退出时会根据机器的负载对索引分片进行重新分配，挂掉的节点重新启动时也会进行数据恢复</p><p>在单台ES服务器节点上，随着业务量的发展索引文件慢慢增多，会影响到效率和内存存储问题，将单个索引的分片到多个不同分布式物理机器上存储，从而可以实现高可用、容错性等</p><p><strong>Master</strong>：node.master: true 节点可以作为主节点</p><p><strong>DataNode</strong>：node.data: true 默认是数据节点</p><p><strong>Coordinate node</strong>：协调节点：一个节点只作为接收请求、转发请求到其他节点、汇总各个节点返回数据等功能的节点；担任协调节点，需要将上两个配置设为false</p><p><strong>脑裂问题</strong>：一个集群中只有一个A主节点，A主节点因为需要处理的东西太多或者网络过于繁忙，从而导致其他从节点ping不通A主节点，其他从节点就会认为A主节点不可用，就会重新选出一个新的主节点B；一段时间后一会正常了，这样就会出现两个主节点，导致一部分数据来源于A主节点，另外一部分数据来源于B主节点，出现数据不一致问题；可以通过 <strong>discovery.zen.minimum_master_nodes</strong> 参数（选举主节点时需要看到最少多少个具有master资格的活节点，才能进行选举）进行控制，推荐值是(N/2)+1，其中N是具有master资格的节点的数量</p><h3 id="4-2-1-集群核心原理分析"><a href="#4-2-1-集群核心原理分析" class="headerlink" title="4.2.1 集群核心原理分析"></a>4.2.1 集群核心原理分析</h3><ol><li>每个索引会被分成多个分片shards进行存储，默认创建索引是分配5个分片进行存储；每个分片都会分布式部署在多个不同的节点上进行部署，该分片成为primary shards；<strong>注意</strong>：索引的主分片primary shards定义好后，后面不能做修改</li><li>为了实现高可用数据的高可用，主分片可以有对应的备分片replics shards，replic shards分片承载了负责容错、以及请求的负载均衡；<strong>注意</strong>：每一个主分片为了实现高可用，都会有自己对应的备分片，主分片对应的备分片不能存放同一台服务器上，主分片primary shards可以和其他replics shards存放在同一个node节点上</li><li>documnet routing（数据路由）：当客户端发起创建document的时候，es需要确定这个document放在该index存放shard位置的过程；<strong>路由算法</strong>：shard = hash(routing) % number_of_primary_shards，如果number_of_primary_shards在查询的时候取余发生的变化，无法获取到该数据；<strong>注意</strong>：索引的主分片数量定义好后，不能被修改</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> ElasticSearch </tag>
            
            <tag> NoSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Neo4j-基础</title>
      <link href="/202210/142374.html"/>
      <url>/202210/142374.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Neo4j使用基础 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><strong>图数据库</strong>：基于图论实现的一种NoSQL数据库，以图数据机构进行数据存储和查询；处理海量复杂关系运算的数据库</p><p><strong>Neo4j</strong>：开源的NoSQL图数据库，使用 Scala 和 Java 开发，与2007年发布；使用属性图模型（Property graph model）进行图数据存储、查询（使用 Cypher 语言进行查询）和处理，<a href="https://neo4j.com/"><font face = "微软雅黑" color = 1E90FF size = 5>英文官网</font></a></p><p><strong>图论基础</strong>：图是一组节点和连接这些节点的关系，图形以属性的形式将数据存储在节点和关系中，属性是用于表示数据的键值对</p><p><strong>属性图模型</strong>：主要有节点、关系和属性组成，用于表示节点、关系和属性中的数据</p><ul><li>节点用圆圈表示，关系用方向键表示，具有方向：单向和双向</li><li>节点和关系都包含属性</li><li>关系连接节点，属性是键值对</li><li>每个关系包含 开始节点 / 从节点 和 结束节点 / 到节点</li></ul><h2 id="1-1-特性"><a href="#1-1-特性" class="headerlink" title="1.1 特性"></a>1.1 特性</h2><p>通过 Apache Lucence 支持索引<br>支持 Unique 约束<br>支持完整的 ACID 事务特性<br>使用原生图形库与本地 GPE（图形处理引擎）<br>支持导出 Json 和 Excel 文档<br>提供 REST API ，支持多语言调用</p><h2 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h2><p><strong>优点</strong>：</p><ul><li>易于表示连接数据</li><li>快速方便碱性检索、遍历、导航连接数据</li><li>支持表示半结构化数据</li><li>使用 CQL查询语言，类似于 SQL语言，易学可读</li><li>具有简单强大的数据模型</li></ul><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p><a href="https://neo4j.com/download-center/"><font face = "微软雅黑" color = 1E90FF size = 5>官网下载地址</font></a></p><ol><li>访问官网，选择合适的系统和版本进行下载</li><li>Windows 解压安装</li><li>neo4j console</li></ol><h1 id="3-CQL"><a href="#3-CQL" class="headerlink" title="3. CQL"></a>3. CQL</h1><p><strong>CQL</strong>：代表Cypher查询语言，为处理图形数据而构建；遵循SQL语法，是一种声明性模式匹配语言，<a href="https://neo4j.com/docs/cypher-manual/3.5/clauses/"><font face = "微软雅黑" color = 1E90FF size = 5>常用命令</font></a></p><table><thead><tr><th>CQL命令</th><th><strong>用法</strong></th></tr></thead><tbody><tr><td>CREATE</td><td>创建节点，并指定关系和属性</td></tr><tr><td>MATCH</td><td>检索指定节点的关系和属性数据</td></tr><tr><td>RETURN</td><td>返回查询结果</td></tr><tr><td>WHERE</td><td>提供条件过滤检索数据</td></tr><tr><td>DELETE</td><td>删除节点和关系</td></tr><tr><td>REMOVE</td><td>删除节点和关系的属性</td></tr><tr><td>ORDER BY</td><td>排序检索数据</td></tr><tr><td>SET</td><td>添加或更新标签</td></tr></tbody></table><h2 id="3-1-增删改查"><a href="#3-1-增删改查" class="headerlink" title="3.1 增删改查"></a>3.1 增删改查</h2><p><strong>创建节点</strong>：() 包裹一个节点，{} 包裹节点的标签，[] 包裹关系名称</p><pre class="line-numbers language-none"><code class="language-none"># 创建节点create (n)       # 创建单个空节点create (n),(m)   # 创建多个空节点create (n:xiyouPerson &#123;name:&#39;如来&#39;&#125;)   # 创建单个带标签 person 和属性 name:&#39;如来&#39;的节点，n 表示节点名称、person 表示节点标签，name 表示属性名称、 &#39;如来&#39; 表示属性值；NULL值：创建一个节点时，指定了标签名称，但未指定其属性值的节点，则对应的属性值为 NULLcreate (n:xiyouPerson &#123;name:&#39;沙僧&#39;&#125;),(m:person&#123;name:&#39;唐僧&#39;&#125;)   # 创建多个带标签和属性的节点create (n:person:student &#123;name:&quot;zhang&quot;, age:18&#125;)         # 创建多标签节点# 创建关系create (n:xiyouPerson &#123;name:&#39;杨戬&#39;&#125;)-[r:师傅]-&gt;(m:person &#123;name:&#39;玉鼎真人&#39;&#125;)   # 使用新节点创建关系match (n:xiyouPerson &#123;name:&#39;沙僧&#39;&#125;),(m:person&#123;name:&#39;唐僧&#39;&#125;) create (n)-[r:&#96;师傅&#96; &#123;relation:&#39;师傅&#39;&#125;]-&gt;(m)   # 使用已知节点创建带属性的关系 # 创建全路径create p&#x3D;(:xiyouPerson&#123;name:&#39;蛟魔王&#39;&#125;)-[:义兄]-&gt;(:xiyouPerson&#123;name:&#39;牛魔王&#39;&#125;)&lt;-[:义兄]- (:xiyouPerson &#123;name:&#39;鹏魔王&#39;&#125;) return p MATCH (n:&#96;西游&#96;) RETURN n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 1. 创建节点load csv from &#39;file:&#x2F;&#x2F;&#x2F;西游关系.csv&#39; as line   # 需要先将csv拷贝到 %NEO4J_HOME%\import目录，再执行 load 操作create(:xiyouRelation &#123;f_name:line[1],relation:line[3]&#125;,t_name:line[0])   # 创建多个节点，都拥有标签 xiyouRelation；包含 f_name、relation、t_name 三个属性，分别取 line[1],line[3],line[0]（取通过 , 分隔的数据下标，从 0 开始）load csv from &#39;file:&#x2F;&#x2F;&#x2F;西游人物.csv&#39; as personcreate (:xiyouPerson &#123;name:person[0]&#125;)# 2. 创建关系match (n:xiyouPerson),(m:xiyouRelation),(s:person) where n.name &#x3D; m.f_name and m.t_name &#x3D; s.name create (n)-[r:XYR &#123;relation:m.relation&#125;]-&gt;(s) return n.name, m.relation, s.namematch (n:xiyouPerson &#123;name:&quot;孙悟空&quot;&#125;),(m:xiyouRelation),(s:person) where n.name &#x3D; m.f_name and m.t_name &#x3D; s.name create (n)-[r:XYR &#123;relation:m.relation&#125;]-&gt;(s) return n.name, m.relation, s.name   # 仅创建 孙悟空 节点的关系# 3. 查看match p&#x3D;()-[r:XYR]-&gt;() return pmatch p&#x3D;(:xiyouPerson &#123;name:&quot;孙悟空&quot;&#125;)-[r:XYR]-&gt;() return p   # 仅显示 孙悟空 节点的关系<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除</strong>：</p><pre class="line-numbers language-none"><code class="language-none">delete node_name       # 删除节点 （前提：节点不存在关系）match (n:xiyouPerson &#123;name:&quot;白龙马&quot;&#125;) delete ndelete relation_name   # 删除节点关系match (n:xiyouPerson &#123;name:&quot;沙僧&quot;&#125;)&lt;-[r]-(m) delete r return type(r)  # 删除所有关系match (n:xiyouPerson &#123;name:&quot;沙僧&quot;&#125;)&lt;-[r:xiyouRelation &#123;relation:&quot;师兄&quot;&#125;]-(m) delete r return type(r)  # 删除指定关系create (n:person:student &#123;name:&quot;zhang&quot;, age:18&#125;) remove node_name:label_name  # 删除标签match (m:person &#123;name:&quot;zhang&quot;&#125;) remove m:person return mremove node_name.col_name  # 删除属性match (n:person &#123;name:&quot;zhang&quot;&#125;) remove n.age return n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改</strong>：</p><pre class="line-numbers language-none"><code class="language-none">match (n:person &#123;name:&quot;zhang&quot;&#125;) set n.name &#x3D; &quot;zhangs&quot; return n<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查询返回</strong>：</p><pre class="line-numbers language-none"><code class="language-none">match (n:person) return id(n),n,n.name               # 使用 match 检索节点，使用 return 返回节点的详细信息，id(n)，返回节点id-系统自定义，可通过 . 访问节点属性match (n:person)-[r]-(m:person) return n,m,type(r)   # 检索关系节点并返回节点的详细信息，type(r)返回关系信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">match (n:person) where n.name &#x3D; &quot;唐僧&quot; return n       # 使用 where 过滤节点，也可以使用 match (n:person &#123;name:&quot;唐僧&quot;&#125;) return n# in 操作符match (n:person) where n.name in[&quot;唐僧&quot;, &quot;孙悟空&quot;] return n# is 判断match (n:person) where n.name is null return n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">match (n:person) return n order by id(n) [asc|desc]  # 返回节点，并进行排序，默认asc升序match (n:person) return n limit 25                   # 对返回数据进行数量限制match (n:person) return n skip 25                    # 从头跳过指定数量的数据match (n:person) return distinct(n.name)             # 进行数据去重<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>聚合</strong>：Union；要求结果为列类型，并且来自两组结果的名称必须匹配（列名称相同，列的数据类型相同）</p><ul><li>union：将两组结果中的公共行组合并返回到一组结果；不返回两个节点中重复的行</li><li>union all：将两组结果中的公共行组合并返回到一组结果；返回两个节点中重复的行</li></ul><pre class="line-numbers language-none"><code class="language-none">MATCH (n:xiyouRelation) RETURN n.name as nameUNIONMATCH (m:xiyouRelation) RETURN m.name as nameMATCH (n:xiyouRelation) RETURN n.name as nameUNIONMATCH (m:xiyouRelation) RETURN m.name as name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-其他"><a href="#3-2-其他" class="headerlink" title="3.2 其他"></a>3.2 其他</h2><h3 id="3-2-1-索引"><a href="#3-2-1-索引" class="headerlink" title="3.2.1 索引"></a>3.2.1 索引</h3><p><strong>索引</strong>：可以为具有相同标签名称的所有节点的属性创建索引，以提高应用程序的性能；支持节点或关系属性上的索引</p><pre class="line-numbers language-none"><code class="language-none"># 创建索引： create index on :label_name (col_name)create index on :xiyouRelation (name)# 删除索引： drop index on :label_name (col_name)drop index on :xiyouRelation (name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-Unique约束"><a href="#3-2-2-Unique约束" class="headerlink" title="3.2.2 Unique约束"></a>3.2.2 Unique约束</h3><p><strong>Unique约束</strong>：在Neo4j数据库中，CQL CREATE命令始终创建新的节点或关系，即使数据重复也会插入一个新行；支持对NODE或Relationship的属性的UNIQUE约束，保证数据的唯一性、避免重复记录和强制执行数据完整性规则</p><pre class="line-numbers language-none"><code class="language-none"># 创建唯一约束： create constraint on (node_name:label_name) assert node_name.col_name is uniquecreate constraint on (n:xiyouRelation) assert n.name is unique# 删除唯一约束： drop constraint on (node_name:label_name) assert node_name.col_name is uniquedrop constraint on (n:xiyouRelation) assert n.name is unique<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-3-常见函数"><a href="#3-2-3-常见函数" class="headerlink" title="3.2.3 常见函数"></a>3.2.3 常见函数</h3><p><strong>String 字符串</strong> ：</p><table><thead><tr><th><strong>功能</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>UPPER</td><td>将所有字母更改为大写字母</td></tr><tr><td>LOWER</td><td>将所有字母改为小写字母</td></tr><tr><td>SUBSTRING</td><td>获取给定String的子字符串</td></tr><tr><td>REPLACE</td><td>替换一个字符串的子字符串</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">MATCH (e) RETURN id(e),e.name,substring(e.name,0,2)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>AGGREGATION聚合</strong>：</p><table><thead><tr><th><strong>聚集功能</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>COUNT</td><td>返回由MATCH命令返回的行数</td></tr><tr><td>MAX</td><td>返回由MATCH命令返回的一组行中的最大值</td></tr><tr><td>MIN</td><td>返回由MATCH命令返回的一组行中的最小值</td></tr><tr><td>SUM</td><td>返回由MATCH命令返回的一组行中的求和</td></tr><tr><td>AVG</td><td>返回由MATCH命令返回的一组行中的平局值</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">MATCH (e) RETURN count(e)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>关系函数</strong>：</p><table><thead><tr><th><strong>功能</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>STARTNODE</td><td>返回关系的开始节点</td></tr><tr><td>ENDNODE</td><td>返回关系的结束节点</td></tr><tr><td>ID</td><td>返回关系的ID</td></tr><tr><td>TYPE</td><td>返回一个关系的字符串表示</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">match (a)-[r] -&gt;(b) return id(r),type(r)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="3-2-4-neo4j-admin使用"><a href="#3-2-4-neo4j-admin使用" class="headerlink" title="3.2.4 neo4j-admin使用"></a>3.2.4 neo4j-admin使用</h3><p><strong>数据库备份恢复</strong>：对Neo4j数据进行备份、还原、迁移的操作</p><pre class="line-numbers language-none"><code class="language-none"># 1. 进入 bin目录cd %NEO4J_HOME%&#x2F;bin# 2. 关闭neo4j，需要先执行 neo4j install-service neo4j stop# 3. 备份neo4j-admin dump --database&#x3D;graph.db --to&#x3D;&#x2F;neo4j&#x2F;backup&#x2F;graph_backup.dump# 4. 数据导入neo4j-admin load --from&#x3D;&#x2F;neo4j&#x2F;backup&#x2F;graph_backup.dump --database&#x3D;graph.db --force# 5. 重启服务neo4j start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Neo4j </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶-配置</title>
      <link href="/202210/1250764.html"/>
      <url>/202210/1250764.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Redis进阶-配置 的相关基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶-常见问题</title>
      <link href="/202209/2964950.html"/>
      <url>/202209/2964950.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Redis进阶-常见问题 的相关基础知识</p><span id="more"></span><h1 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1. 缓存穿透"></a>1. 缓存穿透</h1><p><strong>缓存穿透</strong>：应用服务器访问量变大（大量非正常的访问），同时 Redis缓存中的命中率降低（数据库中不存在对应数据），请求就会一直数据库，从而压垮数据源<br><strong>解决方案</strong>：</p><ul><li><p><strong>对空值缓存</strong>：如果一个查询返回的数据为空（不管是数据是否不存在），仍然把这个空结果（null）进行缓存，设置空结果的过期时间会很短，最长不超过五分钟</p></li><li><p><strong>设置可访问白名单</strong>：使用bitmaps类型定义一个可以访问的名单，名单id作为bitmaps的偏移量，每次访问和bitmap里面的id进行比较，如果访问id不在bitmaps里面，则进行拦截，不允许访问</p></li><li><p><strong>采用布隆过滤器</strong>：将所有可能存在的数据哈希到一个足够大的bitmaps中，一个一定不存在的数据会被这个bitmaps拦截掉，从而避免了对底层存储系统的查询压力</p><p>布隆过滤器（Bloom Filter）是1970年由布隆提出；实际上是一个很长的二进制向量（位图）和一系列随机映射函数（哈希函数）；布隆过滤器可以用于检索一个元素是否在一个集合中</p><ul><li>优点是空间效率和查询时间都远远超过一般的算法</li><li>缺点是有一定的误识别率和删除困难；会缓存较多空值，占用空间；缓存过期时间内，可能存在缓存层与存储层数据不一致的情况，影响一致性业务</li></ul></li><li><p><strong>进行实时监控</strong>：当发现Redis的命中率开始急速降低，需要排查访问对象和访问的数据，和运维人员配合，可以设置黑名单限制服务</p></li></ul><h1 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2. 缓存击穿"></a>2. 缓存击穿</h1><p><strong>缓存击穿</strong>：数据库访问压力瞬时增大，redis正常运行，且并没有出现大量 key过期；<strong>原因</strong>：redis中某个 key过期，而大量的访问需要使用这个 key</p><p><strong>解决方案</strong>：</p><ul><li><strong>预先设置热门数据</strong>：在redis高峰访问之前，把一些热门数据提前存入到redis里面，加大这些热门数据key的时长</li><li><strong>实时调整</strong>：实时监控热门数据，实时调整key的过期时长</li><li><strong>使用分布式锁</strong>：效率较低<ol><li>在缓存失效的时候，判断拿出来的值是否为空；不立即去 load db</li><li>先使用缓存工具的带成功操作返回值的操作（如：Redis的SETNX）set一个 mutex key</li><li>当操作返回成功时，再进行 load db的操作，并回设缓存，最后删除 mutex key；</li><li>当操作返回失败，证明有线程在 load db，当前线程睡眠一段时间再重试整个get缓存的方法</li></ol></li></ul><h1 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3. 缓存雪崩"></a>3. 缓存雪崩</h1><p><strong>缓存雪崩</strong>：数据库访问压力增大，导致应用访问相应变慢，导致 redis出现大量的访问等待，造成，数据库崩溃、redis崩溃和应用崩溃</p><p><strong>解决方案</strong>：</p><ul><li><strong>构建多级缓存架构</strong>：nginx缓存 + redis缓存 +其他缓存（ehcache等）</li><li><strong>限流降级</strong>：使用加锁或者队列的方式来空值读数据库写缓存的线程数量，保证不会有大量的线程对数据库一次性进行读写（如只允许一个线程查询数据和写缓存，其他线程等待），从而避免失效时大量的并发请求落到底层存储系统上；不适用高并发情况</li><li><strong>数据预热</strong>：设置过期标志更新缓存，记录缓存数据是否过期（设置提前量），如果过期会触发通知另外的线程在后台去更新实际key的缓存</li><li><strong>将缓存失效时间分散开</strong>：比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件</li></ul>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶-集群</title>
      <link href="/202209/2723360.html"/>
      <url>/202209/2723360.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Redis进阶-集群 的相关基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>Redis集群</strong>：实现对 Redis的水平扩容，即启动N个redis节点，将整个数据库分布存储在这N个节点中，每个节点存储总数据的1/N；通过分区（partition）来提供一定程度的可用性（availability）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求</p><p><strong>代理主机</strong>：通过代理服务器进行集群访问</p><p><strong>无中心化集群</strong>：所有服务器都可以作为集群入口，服务器之间进行请求联通</p><pre class="line-numbers language-none"><code class="language-none">cluster-enabled yes                  # 打开集群模式cluster-config-file nodes-6379.conf  # 设定节点配置文件名cluster-node-timeout 15000           # 设定节点失联时间，超过该时间（毫秒），集群自动进行主从切换 --cluster-replicas 1 表示为集群中的每个主节点创建一个从节点：分配原则尽量保证每个主数据库运行在不同的IP地址，每个从库和主库不在一个IP地址上 slots：一个 Redis 集群包含 16384 个插槽（hash slot）， 数据库中的每个键都属于这 16384 个插槽的其中一个；集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和redis-cli -c -p port：-c：集群方式连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>优点</strong>：实现扩容，分摊压力，无中心配置相对简单<br><strong>缺点</strong>：不支持多键操作；不支持多键的Redis事务；不支持 lua脚本</p><p><strong>集群配置</strong>：</p><ol><li>端口号</li><li>pid 文件名称</li><li>log 文件名称</li><li>dump.rdb 文件名称</li></ol><h1 id="2-主从复制"><a href="#2-主从复制" class="headerlink" title="2. 主从复制"></a>2. 主从复制</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p><strong>主从复制</strong>：主机数据更新后根据配置和策略， 自动同步到备机的 master/slaver 机制，<strong>Master以写为主，Slave以读为主</strong></p><p><strong>优点</strong>：读写分离，性能扩展；容灾快速恢复</p><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/Redis/Master_Slave.png" alt="Master_Slave"></p><p><strong>原理</strong>：</p><ol><li>Slave启动成功连接到 master后，向master发送一个 sync命令：请求进行数据同步</li><li>Master接到 sync命令后，启动后台的存盘持久化进程，收集所有用于修改数据集命令， 在后台进程执行完毕后得到 rdb文件，master将整个 rdb数据文件传送到 slave</li><li>全量复制：slave服务器在接收到 master服务器的 rdb数据文件后，将其存盘并加载到内存中</li><li>增量复制：Master会持续将新的修改命令依次传给slave，完成同步；但是重新连接master后，会自动执行一次性完全同步（全量复制）</li></ol><h2 id="2-2-配置"><a href="#2-2-配置" class="headerlink" title="2.2 配置"></a>2.2 配置</h2><ol><li><p><strong>配置开启</strong>：daemonize yes</p></li><li><p><strong>配置主服务器</strong>：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">include &#x2F;myredis&#x2F;redis_master.conf   # 指定配置文件路径pidfile &#x2F;var&#x2F;run&#x2F;redis_master.pid    # 配置数据文件位置dbfilename dump_master.rdb           # 配置 rdb文件位置和名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="3"><li><strong>配置从服务器</strong>：</li></ol><pre class="line-numbers language-none"><code class="language-none">include &#x2F;myredis&#x2F;redis_slave.conf   # 指定配置文件路径pidfile &#x2F;var&#x2F;run&#x2F;redis_slave.pid    # 配置数据文件位置dbfilename dump_slave.rdb           # 配置 rdb文件位置和名称# replicationreplicaof master_ip master_port     # 配置主机的ip和端口号，配置文件配置，服务器重启后，主从配置任然有效masterauth master_pwd               # 配置主机的认证密码 <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>启动服务</strong>：</li></ol><pre class="line-numbers language-none"><code class="language-none">redis-server redis_master.conf  # masterredis-server redis_slave.conf   # slaveslaveof master_ip master_port   # slave运行，命令行配置，服务器重启后，主从配置失效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><strong>查看服务器运行状况</strong>：info replication<ul><li>role：服务器角色，分为 master|slave</li><li>connected_slaves：从机连接数</li></ul></li></ol><h2 id="2-3-运行介绍"><a href="#2-3-运行介绍" class="headerlink" title="2.3 运行介绍"></a>2.3 运行介绍</h2><p><strong>普通配置</strong>：</p><ul><li>主机 shutdown 后：从机默认不会升级成主机；重启后，仍然是之前配置的主机</li><li>从机 shutdown 后：命令行配置重启后，默认会变成另外的主机，不会恢复成原来的从机（在配置文件中配置重启后依然是从机）；再次进行从机配置后，会完全加载主机的数据</li><li>从机无法进行数据写操作</li></ul><p><strong>从机传递</strong>：从服务器指定特定从服务器为次主服务器；主服务器的操作会同步到特定从服务器中，其余从服务器同步特定从服务器的数据；当特定从服务器 shutdown 后，主服务器无法直接向其余从服务器同步操作</p><p><strong>从机升主</strong>：主机宕机后，可通过<strong>slaveof no one</strong> 将当前从机升级为集群的主服务器，即其他从机会成为当前从机的从机；需要手动执行；原来的主机恢复，则会默认成为单独的新主机，原来的从机配置不会生效</p><p><strong>哨兵模式</strong>：自动实现从机升主，主机重启后变为从机</p><ol><li>主观下线：单个哨兵监测到主机宕机，系统认为单个哨兵<strong>主观</strong>认为主机宕机，不会马上进行 failover 故障转移过程</li><li>客观下线：当达到阈值数量的哨兵监测到主机宕机后，系统才会进行 failover 故障转移操作，按照一定算法挑选出新的主机，称为<strong>客观下线</strong></li></ol><pre class="line-numbers language-none"><code class="language-none"># 新建哨兵配置文件sentinel monitor mymaster master_ip master_port num- mymaster：为监控对象起的服务器名称- num：设置哨兵同意迁移的数量阈值redis-sentinel  &#x2F;myredis&#x2F;sentinel.conf   # 指定哨兵配置文件路径<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>选举顺序</strong>：</p><ol><li><strong>replica-priority num</strong>；选择 num 的最小值；num 的值越小，优先级越高，默认为 100</li><li><strong>偏移量</strong>：选择偏移量最大；偏移量指获得原主机数据数量</li><li><strong>runid</strong>：选择 runid最小值；redis实例启动后都会随机生成一个40位的 runid</li></ol><h1 id="3-分布式锁"><a href="#3-分布式锁" class="headerlink" title="3. 分布式锁"></a>3. 分布式锁</h1><p><strong>分布式锁</strong>：一种跨数据库服务器的互斥机制，用来来控制共享资源的访问；分布式系统多线程、多进程并且分布在不同机器上，使原单机部署情况下的并发控制锁策略失效</p><p><strong>实施方案</strong>：</p><ol><li>基于数据库实现分布式锁</li><li>基于缓存（Redis等）：性能最高</li><li>基于Zookeeper：可靠性最高</li></ol><h2 id="3-1-数据库实现分布式锁"><a href="#3-1-数据库实现分布式锁" class="headerlink" title="3.1 数据库实现分布式锁"></a>3.1 数据库实现分布式锁</h2><h2 id="3-2-缓存-Redis实现分布式锁"><a href="#3-2-缓存-Redis实现分布式锁" class="headerlink" title="3.2 缓存-Redis实现分布式锁"></a>3.2 缓存-Redis实现分布式锁</h2><pre class="line-numbers language-none"><code class="language-none">set sku “OK” NX PX 10000- EX second ：设置键的过期时间为 second 秒SETEX key second value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-Zookeeper实现分布式锁"><a href="#3-3-Zookeeper实现分布式锁" class="headerlink" title="3.3 Zookeeper实现分布式锁"></a>3.3 Zookeeper实现分布式锁</h2>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis进阶-事务</title>
      <link href="/202209/2741646.html"/>
      <url>/202209/2741646.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Redis进阶-事务 的相关基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>Redis事务</strong>：是一组命令的集合，指事务中的所有命令都会序列化、按顺序地执行；事务在执行的过程中，不会被其他客户端发送来的命令请求所打断；<strong>串联多个命令防止命令插队</strong></p><p><strong>事务特性</strong>：一次性、顺序性、排他性</p><ul><li><strong>单独的隔离操作</strong>：事务中的所有命令都会序列化、按顺序地执行；事务在执行的过程中，不会被其他客户端发送来的命令请求所打断</li><li><strong>没有隔离级别的概念</strong>：队列中的命令没有提交之前都不会实际被执行，因为事务提交前任何指令都不会被实际执行</li><li><strong>不保证原子性</strong>：事务中如果有一条命令执行失败，其后的命令仍然会被执行，没有回滚；单条命令具有原子性，事务不具有原子性</li></ul><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><h2 id="2-1-基础命令"><a href="#2-1-基础命令" class="headerlink" title="2.1 基础命令"></a>2.1 基础命令</h2><p><strong>Multi</strong>：输入的命令都会依次进入命令队列中，进行命令组队，不进行执行；输入命令，提示  queued；组队阶段任务命令报错，任务提交失败，所有任务都不执行</p><p><strong>Exec</strong>：将之前的命令队列中的命令依次执行；执行阶段任务命令报错，仅错误任务不执行</p><p><strong>Discard</strong>：放弃命令组队组队，命令队列最终都不会执行</p><p><strong>watch</strong>：监视key，watch k_name_1 [k_name_2 … ] ；在执行multi之前执行，如果事务执行之前被监视的 key被其他命令改动，则事务将被打断</p><p><strong>unwatch</strong>：取消 watch 命令进监视的所有 key；如果 Exec 命令或 Discard 命令已经被执行，就不需要再执行 unwatch</p><h2 id="2-2-锁机制"><a href="#2-2-锁机制" class="headerlink" title="2.2 锁机制"></a>2.2 锁机制</h2><h3 id="2-2-1-悲观锁"><a href="#2-2-1-悲观锁" class="headerlink" title="2.2.1 悲观锁"></a>2.2.1 悲观锁</h3><p><strong>悲观锁</strong>：Pessimistic Lock，每次去读取操作数据的时候都认为其他事务会修改数据，每次在读取操作数据的时候都会上锁；常用于传统的关系型数据库，如：行锁，表锁，读锁，写锁等；<strong>在做操作之前先上锁</strong>；效率较低</p><h3 id="2-2-2-乐观锁"><a href="#2-2-2-乐观锁" class="headerlink" title="2.2.2 乐观锁"></a>2.2.2 乐观锁</h3><p><strong>乐观锁</strong>：Optimistic Lock，每次去读取操作数据的时候都认为其他事务不会修改数据，每次在读取操作数据的时候都不会上锁，在更新的时候通过版本号（每一次数据更新操作，不仅会修改数据，还会更新数据版本）判断在此期间有没有其他事务更新这个数据；乐观锁适用于多读的应用类型，可以提高吞吐量；<strong>Redis利用check-and-set乐观锁机制实现事务</strong></p><h1 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3. 持久化"></a>3. 持久化</h1><h2 id="3-1-RDB"><a href="#3-1-RDB" class="headerlink" title="3.1 RDB"></a>3.1 RDB</h2><h3 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h3><p><strong>RDB</strong>：Redis DataBase，在指定的时间间隔内将内存中的数据集快照-Snapshot 写入磁盘；Redis会单独创建一个子进程（fork）来进行持久化：先将数据写入到 一个临时文件中，待持久化过程全部结束，再用这个临时文件替换上次持久化好的文件（dump.rdb：持久化文件）；整个过程中，主进程不进行任何IO操作（确保极高的性能）；<strong>如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，RDB方式要比AOF方式更加的高效；RDB的缺点是最后一次持久化后的数据可能丢失</strong></p><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/Redis/Save_RDB.png" alt="Save_RDB"></p><ul><li>Fork的作用是复制一个与当前进程一样的进程；新进程的所有数据（包括变量、环境变量、程序计数器等） 数值都和原进程一致，作为原进程的子进程；通过 <strong>写时复制技术</strong> 进行exec系统调用</li><li>一般情况父进程和子进程会共用同一段物理内存，只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程</li></ul><p><strong>优点</strong>：</p><ul><li>适合大规模的数据恢复</li><li>对数据完整性和一致性要求不高更适合使用</li><li>节省磁盘空间</li><li>恢复速度快</li></ul><p><strong>缺点</strong>：</p><ul><li>Fork的时候，内存中的数据被克隆了一份，会占用大致1倍的空间</li><li>在备份周期在一定间隔时间做一次备份，如果 Redis 意外 down 掉，会丢失最后一次快照后的所有修改</li></ul><h3 id="3-1-2-RDB配置"><a href="#3-1-2-RDB配置" class="headerlink" title="3.1.2 RDB配置"></a>3.1.2 RDB配置</h3><p><strong>文件路径</strong>：</p><pre class="line-numbers language-none"><code class="language-none">dir &#x2F;path  # 默认为 Redis启动时命令行所在的同级目录下<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>取消配置</strong>：</p><pre class="line-numbers language-none"><code class="language-none">redis-cli config set save  # save后给空值，表示禁用保存策略；默认开启<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-2-AOF"><a href="#3-2-AOF" class="headerlink" title="3.2 AOF"></a>3.2 AOF</h2><h3 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h3><p><strong>AOF</strong>：Append Of File，以日志的形式来记录每个写操作（增量保存），记录 Redis执行过的所有写指令（读操作不记录）， 只许追加文件但不可以改写文件，Redis启动之初会读取该文件重新构建数据，即 Redis 重启时根据日志文件的内容将写指令从前到后执        行一次以完成数据的恢复工作；默认不开启，开启需要修改配置文件 appendonly 和 appendfilename 两个参数</p><pre class="line-numbers language-none"><code class="language-none">appendonly yes      # 设置开启 AOF持久化appendfilename appendonly.aof  # 配置持久化文件存储路径和文件名，默认在与 RDB 相同路径下生成 appendonly.aof 文件# 注：需要重启后才会生效；AOF和RDB同时开启，系统默认取AOF的数据（数据不会存在丢失）# 注：如果AOF文件损坏，通过 redis-check-aof文件进行恢复：&#x2F;usr&#x2F;local&#x2F;bin&#x2F;redis-check-aof --fix appendonly.aof<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/Redis/Save_AOF.png" alt="Save_AOF"></p><p><strong>备份过程</strong>：</p><ol><li>客户端的请求写命令会被append追加到AOF缓冲区内；</li><li>AOF缓冲区根据AOF持久化策略[always,everysec,no]将操作sync同步到磁盘的AOF文件中；</li><li>AOF文件大小超过重写策略或手动重写时，会对AOF文件rewrite重写，压缩AOF文件容量；</li><li>Redis服务重启时，会重新load加载AOF文件中的写操作达到数据恢复的目的</li></ol><p><strong>优点</strong>：</p><ul><li>n 备份机制更稳健，丢失数据概率更低</li><li>可读的日志文本，通过操作AOF稳健，可以处理误操作</li></ul><p><strong>缺点</strong>：</p><ul><li>比起RDB占用更多的磁盘空间</li><li>恢复备份速度要慢</li><li>每次读写都同步的话，有一定的性能压力</li><li>存在个别Bug，造成恢复不能</li></ul><h3 id="3-2-2-AOF配置"><a href="#3-2-2-AOF配置" class="headerlink" title="3.2.2 AOF配置"></a>3.2.2 AOF配置</h3><p><strong>同步频率</strong>：</p><pre class="line-numbers language-none"><code class="language-none">appendfsync always|everysec|no- always：始终同步，每次Redis的写入都会立刻记入日志；性能较差但数据完整性比较好- everysec：每秒同步，每秒记入日志一次，如果宕机，本秒的数据可能丢失- no：不主动进行同步，把同步时机交给操作系统<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重写-Rewrite</strong>：AOF文件过大时，Redis会 fork出一条新进程来将文件重写（也是先写临时文件最后再rename）：是指上就是把rdb 的快照，以二级制的形式附在新的aof头部，作为已有的历史数据，替换掉原来的流水账操作；默认配置当AOF文件大小是上次rewrite后的一倍且文件大于64M时触发</p><p><strong>Rewrite压缩</strong>：AOF采用文件追加方式，会导致文件越来越大；当AOF文件的大小超过设定的阈值时，Redis会启动AOF文件的内容压缩， 只保留可以恢复数据的最小指令集</p><pre class="line-numbers language-none"><code class="language-none">auto-aof-rewrite-percentage：设置重写的基准值auto-aof-rewrite-min-size：设置重写的基准值当 AOF当前大小 &gt;&#x3D; base_size + base_size * auto-aof-rewrite-percentage(默认100%)；且 AOF当前大小 &gt;&#x3D; auto-aof-rewrite-min-size(默认64M)时；Redis会对AOF进行重写；bgrewriteaof配置触发重写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-总结"><a href="#3-3-总结" class="headerlink" title="3.3 总结"></a>3.3 总结</h2><p>官方推荐两个都启用</p><ul><li>如果对数据不敏感，可以选单独用RDB</li><li>不建议单独用 AOF，因为可能会出现Bug</li><li>如果只是做纯内存缓存，可以都不用</li></ul><h1 id="4-发布订阅"><a href="#4-发布订阅" class="headerlink" title="4. 发布订阅"></a>4. 发布订阅</h1><p><strong>发布订阅</strong>：Redis 发布订阅（pub/sub）是一种信息通信模式，发送者-pub发送消息，订阅者-sub接收消息；可以订阅任意数量的频道</p><p><strong>PSUBSCRIBE pattern</strong> ：订阅一个或多个符合给定模式的频道</p><p><strong>SUBSCRIBE channel</strong> ：订阅给定的一个或多个频道的信息</p><p><strong>PUBLISH channel message</strong> ：将信息发送到指定的频道</p><p><strong>PUNSUBSCRIBE [pattern]</strong> ：退订所有给定模式的频道</p><p><strong>UNSUBSCRIBE [channel]</strong> ：指退订给定的频道</p>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL-安装使用</title>
      <link href="/202209/2363083.html"/>
      <url>/202209/2363083.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍 PostgreSQL的安装、卸载和简单使用 的相关基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>PostgreSQL</strong>：是一个免费的对象-关系数据库服务器(ORDBMS)，在灵活的BSD许可证下发行；PostgreSQL开发者把它念作 post-gress-Q-L，<a href="https://www.postgresql.org/"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a>，<a href="http://www.postgres.cn/docs/12/index.html"><font face = "微软雅黑" color = 1E90FF size = 5>PostgreSQL 12.2 中文手册</font></a>，可在左上角进行版本切换</p><p><strong>特点</strong>：</p><ul><li>免费开源</li><li>速度快</li><li>平台可移植</li><li>拥有丰富接口</li><li>具备面向对象特性</li><li>安全</li></ul><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="2-1-Windows"><a href="#2-1-Windows" class="headerlink" title="2.1 Windows"></a>2.1 Windows</h2><h2 id="2-2-Linux"><a href="#2-2-Linux" class="headerlink" title="2.2 Linux"></a>2.2 Linux</h2><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><p>启停服务：</p><pre class="line-numbers language-none"><code class="language-none">Windows：在计算机管理器的服务下面找到 postgresql-12.2，右键进行启停服务Linux：先切换至主目录下.&#x2F;pg_ctl start -D 数据文件目录 -l 日志文件目录.&#x2F;pg_ctl start -D &#x2F;PostgreSQL&#x2F;12.2&#x2F;data -l &#x2F;PostgreSQL&#x2F;12.2&#x2F;dataserver.log.&#x2F;pg_ctl stop -D 数据文件目录.&#x2F;pg_ctl stop -D &#x2F;PostgreSQL&#x2F;12.2&#x2F;data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-1-客户端工具"><a href="#3-1-客户端工具" class="headerlink" title="3.1 客户端工具"></a>3.1 客户端工具</h2><p><strong>客户端工具</strong>：pgAdmin</p><h2 id="3-2-数据类型"><a href="#3-2-数据类型" class="headerlink" title="3.2 数据类型"></a>3.2 数据类型</h2><table><thead><tr><th>数据类型</th><th>描述</th><th>占用字节</th><th>取值范围</th></tr></thead><tbody><tr><td>smallint</td><td>小范围整数</td><td></td><td>-32768~32767</td></tr><tr><td>int</td><td>普通大小整数</td><td></td><td>-2147483648~2147483647</td></tr><tr><td>real</td><td>6位十进制精度</td><td></td><td></td></tr><tr><td>numeric(m, n)</td><td>任意精度类型；m为长度，n为精度，小数点不算位数</td><td></td><td></td></tr><tr><td>time</td><td>时间类型</td><td>8</td><td>例：16:12:23</td></tr><tr><td>date</td><td>日期类型</td><td>4</td><td>例：2022-09-23</td></tr><tr><td>timestemp</td><td>日期时间类型</td><td>8</td><td>例：2022-09-23 16:12:23</td></tr><tr><td>char(n)</td><td>固定长度字符串，不足补空白</td><td></td><td></td></tr><tr><td>varchar(n)</td><td>可变长度字符串，有长度限制</td><td></td><td></td></tr><tr><td>text</td><td>可变长度字符串，无长度限制</td><td></td><td></td></tr></tbody></table><p><strong>选择正确的数据类型可以优化存储，提高数据库性能</strong></p><h2 id="3-3-运算符"><a href="#3-3-运算符" class="headerlink" title="3.3 运算符"></a>3.3 运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">实例</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td align="center">1 + 1，结果为2</td></tr><tr><td align="center">-</td><td align="center">减</td><td align="center">1 - 1，结果为0</td></tr><tr><td align="center">*</td><td align="center">乘</td><td align="center">1 * 1</td></tr><tr><td align="center">/</td><td align="center">除</td><td align="center">1 / 1，结果为1</td></tr><tr><td align="center">%</td><td align="center">取余</td><td align="center">1 %1，结果为0</td></tr><tr><td align="center">=</td><td align="center">等于</td><td align="center">左右两边是否相等，是返回True</td></tr><tr><td align="center">!= (&lt;&gt;)</td><td align="center">不等于</td><td align="center">左右两边是否不等，是返回True</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">左边是否大于右边，是返回True</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">左边是否小于右边，是返回True</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td><td align="center">左边是否大于等于右边，是返回True</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td><td align="center">左边是否小于等于右边，是返回True</td></tr><tr><td align="center">least</td><td align="center">最小值</td><td align="center">返回多个数据中的最小值</td></tr><tr><td align="center">greatest</td><td align="center">最大值</td><td align="center">返回多个数据中的最大值</td></tr><tr><td align="center">between … and …</td><td align="center">之间</td><td align="center">在给定范围之间</td></tr><tr><td align="center">[not] in</td><td align="center">是否在里面</td><td align="center">是否在给定范围里面</td></tr><tr><td align="center">like</td><td align="center">通配符匹配</td><td align="center">返回与给定条件形似的字符串</td></tr><tr><td align="center">and</td><td align="center">逻辑与</td><td align="center">当运算符两边的表达式的结果都为true时，整个运算结果才为true</td></tr><tr><td align="center">not</td><td align="center">逻辑非</td><td align="center">取本来值的相反值</td></tr><tr><td align="center">or</td><td align="center">逻辑或</td><td align="center">当运算符有一边为true时，整个运算结果为true</td></tr></tbody></table><table><thead><tr><th align="center">优先级</th><th align="center">运算符</th></tr></thead><tbody><tr><td align="center">最高</td><td align="center">!</td></tr><tr><td align="center"></td><td align="center">-（负号）</td></tr><tr><td align="center"></td><td align="center">*、/、%</td></tr><tr><td align="center"></td><td align="center">-、+</td></tr><tr><td align="center"></td><td align="center">=（比较运算符）、&gt;、&lt;、!= (&lt;&gt;)、&gt;=、&lt;=、[not] in、like、in</td></tr><tr><td align="center"></td><td align="center">between … and …、case、when、then、else</td></tr><tr><td align="center"></td><td align="center">not</td></tr><tr><td align="center"></td><td align="center">and</td></tr><tr><td align="center"></td><td align="center">or</td></tr><tr><td align="center">最低</td><td align="center">=（赋值运算符）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶-文件介绍</title>
      <link href="/202209/1855778.html"/>
      <url>/202209/1855778.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 MySQL进阶-文件介绍 的相关基础知识</p><span id="more"></span><h1 id="1-配置文件"><a href="#1-配置文件" class="headerlink" title="1. 配置文件"></a>1. 配置文件</h1><p>Windows是 my.ini 文件（通常位于MySQL安装主目录下，即与 bin 目录同级）；Linux 默认位于 /etc/my.cnf 的文件</p><h2 id="1-1-语法校验规则-sql-mode"><a href="#1-1-语法校验规则-sql-mode" class="headerlink" title="1.1 语法校验规则-sql_mode"></a>1.1 语法校验规则-sql_mode</h2><p><strong>查看sql_mode</strong></p><pre class="line-numbers language-none"><code class="language-none">全局：select @@global.sql_mode;当前进程：select @@SESSION.sql_mode;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>设置sql_mode</strong>：set @@sql_mode = sql_mode选项列表<br>仅对当前进程有效，想要永久有效，需要修改MySQL的配置文件（Wnidows：my.ini/my_dufault.ini；Linux：my.cnf），sql_mode选项如下：</p><ul><li><strong>ANSI_QUOTES</strong>：启用ANSI_QUOTES后，双引号将被解释为识别符，不能再用来引用字符串</li><li><strong>ERROR_FOR_DIVISION_BY_ZERO</strong>：启用ERROR_FOR_DIVISION_BY_ZERO后，在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告；如果未给出该模式，那么数据被零除时返回NULL</li><li><strong>NO_AUTO_CREATE_USER</strong>：启用NO_AUTO_CREATE_USER后，禁止GRANT创建密码为空的用户</li><li><strong>NO_AUTO_VALUE_ON_ZERO</strong>：默认设置下，插入0或NULL代表生成下一个自增长值，启用NO_AUTO_VALUE_ON_ZERO后，可以在自增长列插入0值</li><li><strong>NO_ENGINE_SUBSTITUTION</strong>：启用NO_ENGINE_SUBSTITUTION后，如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常</li><li><strong>NO_ZERO_DATE</strong>：启用NO_ZERO_DATE后，在严格模式下，不接受’0000-00-00’做为合法日期，可以使用IGNORE选项插入；在非严格模式下，可以接受’0000-00-00’做为合法日期，但会生成警告</li><li><strong>NO_ZERO_IN_DATE</strong>：启用NO_ZERO_IN_DATE后，在严格模式下，不接受月或日部分为0的日期，可以使用IGNORE选项插入；在非严格模式下，可以接受月或日部分为0的日期，但会生成警告</li><li><strong>ONLY_FULL_GROUP_BY</strong>：启用ONLY_FULL_GROUP_BY后，出现在select语句、HAVING条件和ORDER BY语句中的列，必须是GROUP BY的列或者依赖于GROUP BY列的函数列；MySQL 5.7 默认启用，MySQL 8.0 默认不启用</li><li><strong>PIPES_AS_CONCAT</strong>：启用PIPES_AS_CONCAT后，将”||”视为字符串的连接操作符而非或运算符，与字符串的拼接函数Concat相功能类似</li><li><strong>STRICT_TRANS_TABLES</strong>：启用STRICT_TRANS_TABLES后，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制</li></ul><h1 id="2-数据文件"><a href="#2-数据文件" class="headerlink" title="2. 数据文件"></a>2. 数据文件</h1><p>Windows：位于安装的主目录下的 data 目录下；Linux：通常位于 /var/lib/mysql 下</p><p><strong>MyISAM</strong> 存储引擎下，会为每一张表创建三个文件：</p><ul><li><p>表结构文件（xxx.frm）：存放表结构</p></li><li><p>索引文件（xxx.myi）：存放查找索引</p></li><li><p>数据文件（xxx.myd）：存放数据</p></li></ul><h1 id="3-日志文件"><a href="#3-日志文件" class="headerlink" title="3. 日志文件"></a>3. 日志文件</h1><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/Data_Logfile.png" alt="Data_Logfile"></p><h2 id="3-1-重做日志"><a href="#3-1-重做日志" class="headerlink" title="3.1 重做日志"></a>3.1 重做日志</h2><p><strong>重做日志(redo log)</strong></p><ul><li>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务时，根据redo log进行重做，确保事物的持久性</li><li>物理格式的日志，记录物理数据页面的修改信息，redo log的顺序写入到redo log file中，通常位于数据库data目录下的ib_logfile中，一般有两个ib_logfile0、ib_logfile1，可以循环使用</li><li>事务开始时就产生redo log，在事务执行过程中就开始写入redo log文件中</li><li>当对应事务的数据脏页写入磁盘后，reodo log占用的磁盘空间会被覆盖</li></ul><h2 id="3-2-错误日志"><a href="#3-2-错误日志" class="headerlink" title="3.2 错误日志"></a>3.2 错误日志</h2><p>**错误日志(error log)**：名称：xxx.err，记录运行过程中所有的严重错误信息和每次启动关闭的详细信息，默认关闭，通过log_err(是否启用和日志存储位置)和log_warning(是否加入警告信息，包括访问失败和访问拒绝等)来定义</p><h2 id="3-3-二进制日志"><a href="#3-3-二进制日志" class="headerlink" title="3.3 二进制日志"></a>3.3 二进制日志</h2><p>**二进制日志(binlog)**：名称(前缀：mysql-bin，加上数字编号)，默认关闭，存储所有的DDL语句(直接提交)和DML语句(通过事务提交)，语句以事件形式保存，描述了数据的变更顺序，还保存更新语句的执行时间，主要用于主从复制、数据备份和数据恢复</p><p>  <strong>binlog的录入格式</strong>：</p><ul><li><strong>Statement</strong>：每一条会修改数据的 sql 都会记录在 binlog 中，不需要记录每一行的变化，减少了 binlog 日志量，节约I/O，提高性能；需要记录SQL 的上下文信息，有一些使用了函数之类的语句无法被记录</li><li><strong>Row</strong>：不记录 sql 语句的上下文信息，金宝村修改的记录行，记录每一行的改动，理论上可以全部记录下来，这种方式保存的信息太多，日志量较大</li><li><strong>Mixed</strong>：折中方案，普通操作使用 statement 记录，无法使用 statement 时使用 row</li></ul><p><strong>中继日志(relay log)</strong></p><h2 id="3-4-查询日志"><a href="#3-4-查询日志" class="headerlink" title="3.4 查询日志"></a>3.4 查询日志</h2><p>**通用查询日志(general query log)**：也叫全局查询日志，记录查询的 SQL语句，不建议在正式环境开启</p><pre class="line-numbers language-none"><code class="language-none">general_log&#x3D;1general_log_fil&#x3D;&#x2F;path&#x2F;f_name  # 默认创建 host_name.general_log进行存储log_output&#x3D;f_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>**慢查询日志(slow query log)**：文件名称：host_name-slow.log，记录MySQL中响应时间超过阈值的语句，具体指运行时间超过 long_query_time设定值（默认值为10s）的SQL语句；默认不开启慢查询日志，需要手动开启，支持将日志记录写入文件；一般不建议开启慢查询日志记录，会影响性能；可通过slow_query_log，slow_query_log_file定义</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;%slow_query_log%&#39;;  -- 查看当前 slow_query_log 的开启情况set global slow_query_log &#x3D; 1;  -- 开启慢查询日志，仅对当前数据库生效，且数据库重启后失效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-- 修改 long_query_time，判断为大于 long_query_time阈值才会记录show variables like &#39;long_query_time%&#39;;  -- 查看慢查询SQL阈值set global long_query_time &#x3D; 3;  -- 修改慢查询SQL阈值为3sshow global variables like &#39;long_query_time%&#39;;  -- 修改后查看，或者重新连接、新开一个会话show global status like &#39;%Slow_queries%&#39;;  -- 查看系统的慢SQL数量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-- 永久生效需要修改配置文件[mysqld]slow_query_log&#x3D;1slow_query_log_file&#x3D;&#x2F;path&#x2F;f_name.log  # 设置慢查询日志存储位置，默认会创建缺省文件 host_name-slow.loglong_query_time&#x3D;3log_output&#x3D;f_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>回滚日志(undo log)</strong></p><ul><li>分为 insert undo log 和 update undo log 两种</li><li>保证事务的隔离性</li><li>逻辑格式的日志，执行undo时，仅将数据从逻辑上恢复到事务之前的状态，并没有在物理层面恢复</li><li>保存事务发生之前的一个数据版本，用于返回之前的数据版本，支持多版本并发控制下的读(非锁定读：MVCC)</li><li>在事务开始之前保存当前版本的undo log，在undo log中也会保存redo，来保证数据的一致性</li><li>当事务提交之后，undo log并不会被马上删除，而是放入待清理的链表，由purge线程判断undo段中表的上一个数据版本是否在使用，决定是否删除undo log的日志空间</li></ul><h2 id="3-5-日志分析工具"><a href="#3-5-日志分析工具" class="headerlink" title="3.5 日志分析工具"></a>3.5 日志分析工具</h2><p><strong>日志分析工具</strong>：mysqldumpslow –help</p><ul><li>s：指定排序方式<ul><li>c：访问次数</li><li>l：锁定时间</li><li>r：返回记录数</li><li>t：查询时间</li><li>al：平均锁定时间</li><li>ar：平均返回记录数</li><li>at：平局查询时间</li></ul></li><li>t：指定返回的数据条数</li><li>g：搭配正则表达式，大小写不敏感</li></ul><pre class="line-numbers language-none"><code class="language-none">mysqldumpslow -s r -t 10 &#x2F;path&#x2F;f_name.log  -- 慢查询日志文件位置-- 返回查找结果记录集最多的10个SQLmysqldumpslow -s c -t 10 &#x2F;path&#x2F;f_name.log-- 返回访问次数最多的10个SQLmysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;path&#x2F;f_name.log-- 返回按时间排序的前10个包含 left join的SQLmysqldumpslow -s t -t 10 -g &quot;left join&quot; &#x2F;path&#x2F;f_name.log | more   -- 可结合| more使用，避免爆屏<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析工具-Tableau安装使用</title>
      <link href="/202209/15799.html"/>
      <url>/202209/15799.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据分析工具-Tableau安装使用 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析工具-SPSS安装使用</title>
      <link href="/202209/1549675.html"/>
      <url>/202209/1549675.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据分析工具-SPSS安装使用 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><h2 id="1-1-发展"><a href="#1-1-发展" class="headerlink" title="1.1 发展"></a>1.1 发展</h2><p><strong>SPSS</strong>：Statistical Product and Service Solutions，世界上最早的统计分析软件，已被IBM收购；可以跟python、R等连接使用；xxx.sav 为文件存储名称；[数据集] 为文件工作名称<br>60年代：美国斯坦福三位研究生研发<br>70年代：1975年成立法人组织、在芝加哥组建了SPSS总部，退出SPSS中小型机版-SPSSX<br>80年代：微机版(V1<del>4)SPSS/PC+<br>90年代：Windows版(V6</del>10)<br>本世纪：11~25，中文版，2010年被IBM收购</p><p>注：SAS：统计分析软件，有一定难度，难上手，收费</p><h2 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h2><p><strong>优点</strong>：</p><ul><li>功能强大</li><li>兼容性好</li><li>易用性强，是应用统计人员的首选</li><li>扩展性高（以一种不同的方式）</li></ul><p><strong>缺点</strong>：</p><ul><li>计算速度相对较慢</li><li>在统计模型的纳入上速度较慢</li></ul><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><p><strong>四大窗口</strong>：</p><p>数据窗口：包括数据视图和变量视图（标签表示字段描述，值表示数据字典）</p><p>输出窗口：分析 -&gt; 描述统计 -&gt; …</p><p>语法窗口：文件 -&gt; 新建/打开 -&gt; 语法，输入语法 -&gt; 点击运行，查看器窗口查看运行结果</p><p>脚本窗口：文件 -&gt; 新建/打开 -&gt; 脚本，选择 Python、Basic等</p><p><strong>五个标准按钮</strong>：</p><ul><li>确定、取消</li><li>粘贴：用于自动生成SPSS程序</li><li>重置：恢复对话框为初始状态</li><li>帮助：方法，用法介绍</li></ul><p><strong>变量存储类型</strong>：</p><ul><li>数值型：应用最为广泛</li><li>字符型：由于分析、整理都较困难，建议少量使用，改为编码录入；可通过值标签进行字符和字典的切换</li><li>日期型：实际是特殊的数值型变量，尽量少用</li></ul><p><strong>标量</strong>：连续的数值型变量</p><p><strong>有序</strong>：有序的分类标签</p><p><strong>名义</strong>：无序的分类标签</p><h2 id="2-1-数据I-O"><a href="#2-1-数据I-O" class="headerlink" title="2.1 数据I/O"></a>2.1 数据I/O</h2><h3 id="2-1-1-导入"><a href="#2-1-1-导入" class="headerlink" title="2.1.1 导入"></a>2.1.1 导入</h3><p><strong>Excel</strong>：点击文件 -&gt; 选择导入数据 -&gt; 选择Excel -&gt; 在弹出的对话框中选择文件打开位置 -&gt; 选择文件类型为Excel -&gt; 选择需要打开的数据文件 -&gt; 选择需要打开的工作表名称 -&gt; 点击确定</p><p><strong>MySQL</strong>：点击文件 -&gt; 选择导入数据 -&gt; 选择数据库 -&gt; 选择新建查询 -&gt; 添加 ODBC 的数据源 -&gt; 配置连接信息和数据库信息 -&gt; 点击确认 -&gt; 选择数据表 -&gt; 点击确认</p><p><strong>文本数据</strong>：点击文件 -&gt; 选择导入数据 -&gt; 选择文本数据 -&gt; 选择需要打开的数据文件 -&gt; 点击打开，进入文本导入向导 -&gt; 默认下一步 -&gt; 默认下一步 -&gt; 默认下一步（SPSS中一条数据成为个案） -&gt; 默认下一步 -&gt; 针对每一个变量（SPSS中称数据字段为变量）选择合适的数据格式，点击下一步 -&gt; 勾选粘贴语法，点击完成 -&gt; 在弹出的语法编辑器中运行粘贴出来的语法，才能完成文本数据的导入</p><h3 id="2-1-2-导出"><a href="#2-1-2-导出" class="headerlink" title="2.1.2 导出"></a>2.1.2 导出</h3><p>导出数据视图：点击文件 -&gt; 选择导出数据 -&gt; 选择导出数据数据类型 -&gt; 可选择导出的变量列表，也可以勾选将工作表追加到现有文件中 -&gt; 选择导出位置 -&gt; 点击将文件存储到存储库</p><h2 id="2-2-操作"><a href="#2-2-操作" class="headerlink" title="2.2 操作"></a>2.2 操作</h2><p><strong>新增录入</strong>：在变量视图输入新增的变量，按 Enter 可以直接自动识别对应的数据类型</p><p><strong>查找替换</strong>：Ctrl + F 查找时会自动筛选列 </p><p><strong>计算变量</strong>：点击转换 -&gt; 选择计算字段 -&gt; 在弹出的计算变量对话框输入计算算法（支持新增变量和原变量计算） -&gt; 点击确认，完成数据计算</p><p>排序</p><ul><li>个案排序：点击数据 -&gt; 选择个案排序 -&gt; 在弹出的对话框中进行排序，支持多变量不同排序方式</li><li>变量排序：点击数据 -&gt; 选择变量排序 -&gt; 选择排序方式，实现变量排序</li></ul><h2 id="2-3-数据管理"><a href="#2-3-数据管理" class="headerlink" title="2.3 数据管理"></a>2.3 数据管理</h2><h3 id="2-3-1-数据选择"><a href="#2-3-1-数据选择" class="headerlink" title="2.3.1 数据选择"></a>2.3.1 数据选择</h3><p><strong>数据拆分</strong>：点击数据 -&gt; 选择拆分文件 -&gt; 在弹出的对话框中勾选比较组，选择分组依据 -&gt; 再进行分析的时候会按照分组变量进行分组统计分析；分析结束后需要取消拆分，否则后续统计分析会默认进行分组</p><p><strong>数据筛选</strong>：点击数据 -&gt; 选择 选择个案 -&gt; 在弹出的对话框中勾选 如果条件满足… -&gt; 在弹出的对话框中输入筛选条件，可以完成筛选；分析结束后需要取消筛选，否则后续统计分析会默认进行筛选</p><h3 id="2-3-2-数据汇总"><a href="#2-3-2-数据汇总" class="headerlink" title="2.3.2 数据汇总"></a>2.3.2 数据汇总</h3><p>数据汇总：点击数据 -&gt; 选择 汇总 -&gt; 在弹出的对话框中选择分解变量（分组变量）、变量摘要（需要汇总展示的变量列表），可针对每一个变量指定数据汇总方式</p><p>数据 -&gt; 重构（一条数据转化成多条数据）</p><p>合并文件：数据 -&gt; 合并文件 -&gt; 添加个案，可针对列名不一致的内容可以进行配对</p><p>标识重复个案：数据 -&gt; 标识重复个案 -&gt; 在 定义匹配个案的依据中选择判定重复的变量</p><h2 id="2-4-图表"><a href="#2-4-图表" class="headerlink" title="2.4 图表"></a>2.4 图表</h2><p>图形 -&gt; 图标构建器，采用拖动方式实现图标构建</p>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel进阶-数据透视表</title>
      <link href="/202209/0749777.html"/>
      <url>/202209/0749777.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Office-Excel进阶-数据透视表 的相关基础内容</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>数据透视表</strong>：把明细表进行分类汇总形成的汇总表</p><h2 id="1-1-使用场景"><a href="#1-1-使用场景" class="headerlink" title="1.1 使用场景"></a>1.1 使用场景</h2><ol><li>有大量的数据，使用函数计算慢、繁琐</li><li>希望快速制作、整理、分析各类报表</li><li>数据源经常发生变化，并且要经常分析和处理最新的数据</li><li>想快速洞察数据背后隐藏的意义</li></ol><h2 id="1-2-使用条件"><a href="#1-2-使用条件" class="headerlink" title="1.2 使用条件"></a>1.2 使用条件</h2><ol><li><strong>不能包含空字段</strong>：包含空字段，无法制作数据透视表</li><li><strong>不包含相同字段</strong> ：相同的字段名，会自动添加序号，以示区别</li><li><strong>不能有合并单元格</strong> ：字段所在行有合并单元格，等同于空字段，也无法创建数据透视表</li><li><strong>不能有空行</strong>：如果有空行，会当成空值处理</li><li><strong>不包含有文本型数字</strong>：文本型数字会导致汇总求和的结果错误</li></ol><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><p><strong>新建</strong>：点击 插入菜单栏 -&gt; 点击 数据透视表 -&gt; 选择合适的行标签和列标签 -&gt; 选择列标签值汇总方式方式（包括：求和、计数、平均值、最值、乘积、标准差、方差等统计指标，默认为求和）和值显示方式（包括百分比、排序方式等）-&gt; 点击确认，即可完成</p><h2 id="2-1-更新数据源"><a href="#2-1-更新数据源" class="headerlink" title="2.1 更新数据源"></a>2.1 更新数据源</h2><ul><li><strong>修改单个单元格</strong>：源数据表里面的数据更新后，进行数据刷新（默认源数据和数据透视表数据不会同步更新）；点击数据透视表，召唤上下文选项卡 -&gt; 选择选择 -&gt; 点击刷新，选择全部刷新，即可完成数据刷新</li><li><strong>源范围内新增行</strong>：源数据表里面的数据更新后，进行数据刷新；点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击刷新，选择全部刷新，即可完成数据刷新</li><li><strong>源范围外新增行</strong>：源数据表里面的数据更新后，进行数据源更改；点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击更改数据源，重新设置数据员范围，即可完成数据更新</li></ul><h2 id="2-2-新增行列"><a href="#2-2-新增行列" class="headerlink" title="2.2  新增行列"></a>2.2  新增行列</h2><ul><li>**新增行(计算项)**：对数据透视表内部的数据进行二次计算，形成新行；点击数据透视表行标签上，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击 域、项目和集 -&gt; 点击计算项 -&gt; 自定义新列名称和计算方式 -&gt; 点击确认，即可完成新增行</li><li>**新增列(计算字段)**：对数据透视表内部的字段进行二次计算，形成新列；点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击 域、项目和集 -&gt; 点击计算字段 -&gt; 自定义新列名称和计算方式 -&gt; 点击确认，即可完成新增列</li></ul><h2 id="2-3-筛选"><a href="#2-3-筛选" class="headerlink" title="2.3 筛选"></a>2.3 筛选</h2><ul><li><strong>切片器</strong>：对数据透视表进行筛选；点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击 插入切片器 -&gt; 选择合适的筛选列，可插入多个切片器</li><li><strong>筛选</strong>：点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击 字段列表(最右侧) -&gt; 显示数据透视表字段列表 -&gt; 将筛选字段拉入筛选框 -&gt; 点击出现的筛选框，可按照取值进行筛选（可筛选多项）<br><strong>拆分表</strong>：完成筛选后，点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击选项下拉框(最左侧) -&gt; 点击 显示报表筛选页，可以实现按照筛选值创建新的 Sheet</li></ul><h2 id="2-4-合并工作表"><a href="#2-4-合并工作表" class="headerlink" title="2.4 合并工作表"></a>2.4 合并工作表</h2><p><strong>数据透视表和数据透视图向导</strong>：（需要格式相同、内容相似）</p><ol><li>默认在功能区里面没有，需要 <strong>新增</strong> ：点击文件菜单栏 -&gt; 点击选项 -&gt; 选择自定义工功能区 -&gt; 在左侧筛选框筛选 不在功能区的命令 -&gt; 将 数据透视表和数据透视图向导 添加至合适的功能选项卡（点击新建组，通常为数据组下 -&gt; 选中新建组，选择重命名 -&gt; 点击添加 -&gt; 将 数据透视表和数据透视图向导 添加至新建的数据组中 -&gt;  点击确认，完成添加功能区）</li><li>打开 数据透视表和数据透视图向导（快捷键：Alt + D + P）-&gt; 选择 多重合并计算数据区域，点击下一步 -&gt; 默认选择 新建单页字段 -&gt; 选择 需要合并计算的区域，点击添加，完成全部添加后，点击下一步 -&gt; 选择 数据透视表显示位置为 新工作表，点击完成</li></ol><h2 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h2><ul><li><strong>排序</strong>：点击行标签下拉框 -&gt; 选择其它排序选项 -&gt; 选择排序方式(升序和降序) -&gt; 选择排序列标签 -&gt; 点击确定，完成排序</li><li><strong>表格样式调整</strong>：<ol><li>关闭加减按钮：点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击 +/- 按钮(最右侧)，实现 +/- 按钮 的开启关闭</li><li>表格形式显示：点击数据透视表，召唤上下文选项卡 -&gt; 选择设计 -&gt; 点击报表布局下拉框 -&gt; 选择 已表格形式显示</li><li>合并居中：点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击选项下拉框(最左侧) -&gt; 在布局和格式中 勾选合并且居中排列带标签的单元格</li></ol></li><li><strong>开关字段对话框</strong>：点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 点击 字段列表(最右侧)</li><li><strong>图形展示</strong>：点击数据透视表，召唤上下文选项卡 -&gt; 选择选项 -&gt; 选择数据透视图 -&gt; 选择合适图形，即完成对数据透视表的图形化展示（可以进行数据切换）</li></ul><p><strong>数据分析</strong>：用于计算两组数据的相关关系，默认在功能区里面没有，需要新增 </p><ul><li><strong>新增</strong>：点击文件菜单栏 -&gt; 点击选项 -&gt; 选择加载项 -&gt; 点击转到(最下方) -&gt; 勾选分析工具库 -&gt; 点击确定，完成 数据分析 功能的添加，默认在数据选项卡中</li><li><strong>使用</strong>：先选中需要进行计算的数据区域(纯数据区域) -&gt;  点击 数据菜单栏 -&gt; 点击 数据分析 -&gt; 选择相关系数，点击确定 -&gt; 选择输出数据区域 -&gt; 点击确定，完成相关系数的计算</li></ul>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel进阶-公式与函数</title>
      <link href="/202209/063347.html"/>
      <url>/202209/063347.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Office-Excel进阶-公式与函数 的相关基础内容</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>公式</strong>：以=开头的，对地址进行引用的计算形式</p><p><strong>函数</strong>：是Excel 预定义的一种内置公式；通过参数来按特定的顺序或结构执行计算</p><h2 id="1-1-地址引用"><a href="#1-1-地址引用" class="headerlink" title="1.1 地址引用"></a>1.1 地址引用</h2><p><strong>地址引用</strong>：</p><ul><li><p>相对引用：范围拉动时会随着拉动不断改变；A2：A5</p></li><li><p>绝对引用：范围拉动时位置不会改变；$A$2；可以通过 F4 快速添加 $ 符号</p></li><li><p>混合引用：设置改变范围；$A2：拉动改变行数，$A3、$A4等；A$2：拉动改变列数，B$2、C$2等</p></li></ul><h2 id="1-2-运算符"><a href="#1-2-运算符" class="headerlink" title="1.2 运算符"></a>1.2 运算符</h2><p><strong>算术运算符</strong>：对数值数据的变量进行运算</p><table><thead><tr><th align="center">运算符</th><th align="center">实例</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td align="center">1 + 1，结果为2</td></tr><tr><td align="center">-</td><td align="center">减</td><td align="center">1 - 1，结果为0</td></tr><tr><td align="center">*</td><td align="center">乘</td><td align="center">1 * 1，结果为1</td></tr><tr><td align="center">/</td><td align="center">除</td><td align="center">1 / 1，结果为1</td></tr><tr><td align="center">%</td><td align="center">百分比</td><td align="center">1 % 1，结果为100%</td></tr><tr><td align="center">^</td><td align="center">幂</td><td align="center">1 ** 1，结果为1</td></tr></tbody></table><p><strong>关系运算符</strong>：判断两数的大小关系</p><table><thead><tr><th align="center">运算符</th><th align="center">实例</th><th align="center">范例</th><th>结果</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td><td align="center">1 = 1</td><td>true</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等于</td><td align="center">1 != 1</td><td>false</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">1 &gt; 1</td><td>false</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">1 &lt; 1</td><td>false</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td><td align="center">1 &gt;= 1</td><td>true</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td><td align="center">1 &lt;= 1</td><td>true</td></tr></tbody></table><h1 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h1><h2 id="2-1-文本函数"><a href="#2-1-文本函数" class="headerlink" title="2.1 文本函数"></a>2.1 文本函数</h2><p><strong>len(text)</strong> ：返回指定文本字符串 text 中字符的个数（文本长度），不分中英文和数字，都是1个字符，=len(A1)<br><strong>left(text [, num_chars])</strong> ：从文本字符串左边（开头）起第一个字符开始返回指定个数的字符，=left(A1, 3)；**right(text [, num_chars])**：从文本字符串右边（末尾）起第一个字符开始返回指定个数的字符，=right(A1, 3)</p><blockquote><p>text：文本内容<br>[num_chars] ：指定提取字符的个数，默认值为1；可选</p></blockquote><p>**mid(text, start_num, num_chars)**：从文本字符串的指定位置提取指定长度的字符，=mid(A1, 3, 5)</p><blockquote><p>text：文本内容<br>start_num：开始提取的位置<br>num_chars：提取的字符数</p></blockquote><p>**text(内容, 格式)**：将给定的内容按照特定格式进行转换，=text(A1, “yyyy-mm-dd”)；指定格式可以查看单元格中数字的自定义格式模板</p><p>**replace(old_text, start_num, num_chars, new_text)**：根据指定的内容，将原文本部分内容替换成新的内容，=replace(A1, 1, 3, “*“)：将A1单元格从第1位开始后面3位的内容替换为 *；</p><blockquote><p>old_text ：原来的文本<br>start_num：开始替换的位置<br>num_chars：替换的字符数<br>new_text：替换的新内容</p></blockquote><p>**find(find_text, within_text [, start_num])**：根据指定内容查找，返回查找文本所在位置的起始值，=find(“f”, A1, 2)：从A1单元格第2位开始查找 f</p><blockquote><p>find_text: 要查找的文本<br>within_text：查找的范围<br>start_num：指定开始查找的位置，可选</p></blockquote><h2 id="2-2-统计函数"><a href="#2-2-统计函数" class="headerlink" title="2.2 统计函数"></a>2.2 统计函数</h2><p>**int(number)**：向下舍入取整（仅保留整数部分），number一般是个小数，正负都可以；=int(5.7)，返回5；=int(-5.7)，返回-6</p><p>**round(number, num_digits)**：将数字四舍五入到指定的小数位；=round(3.1415926, 3)，返回3.142</p><blockquote><p>number ：需要进行四舍五入的数字<br>num_digits：进行四舍五入运算的位置，即保留的小数位数</p></blockquote><p>**mod(number, divisor)**：计算两数相除的余数；=mod(10, 3)，返回1</p><blockquote><p>number：被除数<br>divisor：除数</p></blockquote><p>**count(number1 [, number2, …])**：计数；count(A1:A10)<br>**max(number1 [, number2, …])**：求最大值；max(A1:A10)<br>**min(number1 [, number2, …])**：求最小值；min(A1:A10)<br>**sum(number1 [, number2, …])**：求和；sum(A1:A10)<br>**average(number1 [, number2, …])**：求平均数；average(A1:A10)<br>**countif(range, criteria)**：条件计数；=count(A1:A10, “A”)：统计A1到A10取值为 “A” 的数量</p><blockquote><p>range：统计非空单元格数目的区域<br>criteria：给定的条件</p></blockquote><p>**countifs(criteria_range1, criteria1 [, criteria_range2, criteria2, …])**：多条件计数</p><blockquote><p>criteria_range1 ：条件区域1<br>criteria1：条件1</p></blockquote><p>**sumif(range, criteria [, sum_range])**：条件求和；=sumif(A1:A10, “&gt;5”, B1:B10)，A1到A10取值为大于5时，计算对应B列的和</p><blockquote><p>range：条件所在的数据区域<br>criteria：给定求和的筛选条件<br>sum_range：求和区域；若省略，则代表求和区域与条件所在区域一致</p></blockquote><p>**sumifs(sum_range, criteria_range1, criteria1 [, criteria_range2, criteria2, …])**：多条件求和</p><blockquote><p>sum_range：求和范围<br>criteria_range1：条件范围<br>criteria1：条件</p></blockquote><h2 id="2-3-查找与引用函数"><a href="#2-3-查找与引用函数" class="headerlink" title="2.3 查找与引用函数"></a>2.3 查找与引用函数</h2><p>**vlookup(lookup_value,table_array,col_index_num,range_lookup)**：查找匹配数据</p><blockquote><p>lookup_value：想要查找的内容<br>table_array：想要查找的区域<br>col_index_num：指定返回的列号<br>range_lookup：指定匹配方式，是否近似匹配：1/True 表示近似匹配， 0/False 表示精确匹配</p></blockquote><p>**match(lookup_value, lookup_array [, match_type])**：返回查找值所在区域的位置</p><blockquote><p>lookup_value：查找的值<br>lookup_array：查找区域<br>match_type：查找方式：为1时，查找小于或等于lookup_value的位置；为0时，查找等于lookup_value的位置；为-1时，查找大于或等于lookup_value的位置；默认为 1</p></blockquote><h2 id="2-4-日期函数"><a href="#2-4-日期函数" class="headerlink" title="2.4 日期函数"></a>2.4 日期函数</h2><p><strong>today()</strong> ：返回当前的系统日期<br><strong>now()</strong> ：返回当前系统的日期和时间<br><strong>year(value)</strong> ：返回 value 所在的年份<br><strong>month(value)</strong> ：返回 value 所在的月份<br><strong>day(value)</strong> ：返回 value 所在的日<br>**date(year, month, day)**：拼接日期格式；=date(2022, 09, 07)，返回 2022/9/7，默认不会保留前面的0<br>**datedif(start_date, end_date, unit)**：计算日期之间的差值；</p><blockquote><p>start_date：开始时间<br>end_date：结束时间<br>unit：计算单位，有效值 “Y”（年）、”M”（月）、”D”（日）</p></blockquote><h2 id="2-5-其他"><a href="#2-5-其他" class="headerlink" title="2.5 其他"></a>2.5 其他</h2><h3 id="2-5-1-逻辑函数"><a href="#2-5-1-逻辑函数" class="headerlink" title="2.5.1 逻辑函数"></a>2.5.1 逻辑函数</h3><p>**if(logical_test,value_if_true,value_if_false)**：逻辑判断，根据判断结果返回对应结果</p><blockquote><p>logical_test ：给定的判断条件<br>value_if_true ： 条件成立则返回的值<br>value_if_false ：条件不成立则返回的值</p></blockquote><ol><li>单一条件判断：if(A1 &gt; 0, 1, -1) ：如果A1单元格的数值大于0，返回1；否则返回-1</li><li>多条件判断：if(A1 &gt; 0, 1, if(A1 = 0, 0, -1)) ：如果A1单元格的数值大于0，返回1；等于0，返回0；小于0，返回-1</li><li>与and和or联合使用：if(and(A1 &gt; 0, B1 = 1), 1, -1) ：如果A1单元格的数值大于0，并且B1单元格的数值等于0，返回1；否则返回-1<ul><li>and(逻辑判断1，逻辑判断2…) 判断条件都为真时，返回True，否则False</li><li>or   (逻辑判断1，逻辑判断2…) 判断条件存在真时，返回True，否则False</li></ul></li></ol><h3 id="2-5-2-常见出错信息"><a href="#2-5-2-常见出错信息" class="headerlink" title="2.5.2 常见出错信息"></a>2.5.2 常见出错信息</h3><p>**DIV/0!**：零作除数<br>**NAME?**：不能识别名称（删除了公式中引用的名称、使用不存在的名称或者函数名拼写错误）<br>**VALUE!**：不正确的参数或运算符<br>**REF!**：引用了无效的单元格地址（删除或移动了由其它公式引用的单元格）<br>**NULL!**：指定了两个并不相交的区域<br><strong>N/A</strong>：当在函数或公式中引用了无法使用的数值<br>**NUM!**：数字类型不正确<br>**######**：列宽设置问题，不是错误值 ，输入到单元格中的数值太长，在单元格中显示不下</p>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学-基础</title>
      <link href="/202209/0511258.html"/>
      <url>/202209/0511258.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 统计学 的相关基础内容</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><ul><li>**统计学(statistics)**：收集、处理、分析、解释数据并从数据中得出结论的科学。</li><li>**描述统计(discriptive statistics)**：研究的是数据收集、处理、汇总、图表描述、概括与分析等统计方法。<br>描述统计其实就是对数据进行总体特征的概述，例子：说一下班级这次考试的情况如何</li><li><strong>推断统计(inferential statistics)<strong>：是研究如何利用样本数据来推断总体特征的统计方法；推断统计其实是建立在描述统计的基础之上，在对总体数据有了大致的了解之后，运用一些分析方法，对数据进行预测，并达到统计决策的目的；分析的终极目的就是</strong>得出结论，支持决策</strong></li></ul><h2 id="1-1-统计研究步骤"><a href="#1-1-统计研究步骤" class="headerlink" title="1.1 统计研究步骤"></a>1.1 统计研究步骤</h2><ol><li><strong>设计</strong>：选题 -&gt; 明确研究目的 -&gt; 提出假设 -&gt; 明确总体范围 -&gt; 确立观察指标 -&gt; 控制研究中的偏移 -&gt; 给出具体的研究方案</li><li><strong>收集</strong>：收集数据，来源数据库，问卷等</li><li><strong>整理</strong>：把数据清洗干净，以便得出正确的结论</li><li><strong>分析</strong>：<strong>统计描述</strong>：了解样本数据的情况，是全部工作的基础，是尽量精确、直观而全面的对所获得的样本进行呈现；<strong>统计推断</strong>：从样本信息外推到总体，以获得对所感兴趣问题的解答</li></ol><h2 id="1-2-概念介绍"><a href="#1-2-概念介绍" class="headerlink" title="1.2 概念介绍"></a>1.2 概念介绍</h2><h3 id="1-2-1-变量"><a href="#1-2-1-变量" class="headerlink" title="1.2.1 变量"></a>1.2.1 变量</h3><p><strong>分类变量</strong></p><ul><li><p><strong>无序分类变量</strong>：说明事物类别的一个名称，如性别有男女两种，二者无大小之分，无顺序之分，还有如血型、民族等</p></li><li><p><strong>有序分类变量</strong>：也是说明事物类型的一个名称，但是有次序之分，例如：满意度分为满意 一般 不满意，三者是有顺序的，但是无大小之分</p></li></ul><p> <strong>数值型变量</strong></p><ul><li><p><strong>连续型变量</strong>：取值范围是一个区间，它可以在该区间中连续取值，即连续型变量可以取到区间中的任意值，并且有度量单位。例如：身高、年龄、体重、金额</p></li><li><p><strong>离散型变量</strong>：取值范围是有限个值或者一个数列构成的，表示分类情况，如：企业数量 产品数量等</p></li></ul><p>无序分类变量：无大小之分，无顺序之分，仅知道属于哪个类别</p><p>有序分类变量：无大小之分，但是有顺序之分，各个类别客户划分等级</p><p>连续型变量：有大小之分，一定区间范围内取值个数无法确定</p><p>离散型变量：有小大之分，一定区间范围内取值个数是有限的，可数的</p><h3 id="1-2-2-概率"><a href="#1-2-2-概率" class="headerlink" title="1.2.2 概率"></a>1.2.2 概率</h3><p><strong>随机事件</strong>：随机现象某种可能的观察结果称为随机事件</p><p><strong>概率</strong>：刻画随机事件发生可能性大小，取值介于0-1之间，是经过大量的重复的独立的实验而得出的结论</p><ul><li><strong>小概率事件</strong>：在统计学中，如果随机事件发生的概率小于或等于0.05，则认为是一个小概率事件，表示该事件在大多数情况下不会发生，并且一般认为小概率事件在一次随机抽样中不会发生，这就是小概率原理；<strong>小概率原理是推断统计的基础</strong></li></ul><p><strong>随机变量</strong>：随机事件的数量化</p><ul><li><strong>离散型随机变量</strong>：随机变量X可以一一列举出来，在一定区间范围内X是有限个，可数的</li><li><strong>连续型随机变量</strong>：随机变量X无法一一列举，在一定区间范围内是无限个</li></ul><p><strong>总体</strong>：根据研究目的确定的所有个体某指标观察值（测量值）的集合</p><p><strong>样本</strong>：在一个较大范围的研究对象中随机抽出一部分个体进行观察或预测，这些个体的测量值构成的集合称为样本</p><p><strong>随机抽样</strong>：在抽样研究中，随机抽取一部分个体进行观察和测量的过程称为随机抽样；随机抽样的本质：每个个体最终是否入选在抽样进行前是不可知的，但是其入选的可能性是确切可知的（每个个体被抽到的概率是相等的）；随机≠随便</p><p><strong>总体参数</strong>：刻画总体特征的指标称为总体参数，例如：总体均值（μ），总体标准差（σ）,总体比例 （π）</p><p><strong>统计量</strong>：刻画样本特征的指标称为统计量，例如：样本均值（x-bar），样本标准差（s），样本比例（p）</p><p><strong>抽样误差</strong>：sampling error，由随机抽样造成的样本统计量与总体指标之间的差异称为抽样误差</p><p><strong>概率分布</strong>：随机变量的概率存在的一定规律；<strong>离散型随机变量的概率分布有：二项分布、泊松分布；连续型随机变量的概率分布：正态分布</strong></p><h1 id="2-描述统计"><a href="#2-描述统计" class="headerlink" title="2. 描述统计"></a>2. 描述统计</h1><h2 id="2-1-集中趋势"><a href="#2-1-集中趋势" class="headerlink" title="2.1 集中趋势"></a>2.1 集中趋势</h2><ul><li><p><strong>均数（mean）</strong>：描述一组数据在数量上的平均水平<br><strong>优点</strong>：</p><ul><li>使大量的观测数据转变成一个代表性的数值；比较敏感，数据任何一个值发生变化，均数都会随之改变</li><li>大家熟知、常用、便于比较和传播</li></ul><p><strong>缺点</strong>：</p><ul><li>掩盖了各个观测数据之间的差异性</li><li>均数受极值的影响很大</li></ul></li><li><p><strong>中位数（median）</strong>：将全体数据从小到大排列，在整个数列中处于中间位置的那个值就是中位数</p><p><strong>优点</strong>：不受极端值的影响，在具有个别极大或极小值的分布数列中，中位数比均数更具有代表性，如上面例子，用中位数则是4500，至少代表了前三个人的工资水平</p><p><strong>缺点</strong>：</p><ul><li>不是所有人都能理解</li><li>损失信息：只考虑居中位置，其他变量值比中位数大多少或小多少，它无法反映出来，所以我们也是只能看到部分信息</li></ul></li><li><p><strong>众数（mode）</strong>：一组数据当中，出现次数最多的那个数</p></li></ul><h2 id="2-2-离散趋势"><a href="#2-2-离散趋势" class="headerlink" title="2.2 离散趋势"></a>2.2 离散趋势</h2><ul><li><strong>离均差</strong>：个体偏离均值的程度；<strong>离均差的平方和</strong></li><li><strong>总体方差</strong>：总体方差 = 离均差的平方和 / 样本量</li><li><strong>总体标准差</strong>：总体标准差 = 方差开根号；<strong>样本标准差</strong></li><li><strong>变异系数</strong>：变异系数 = 标准差 / 均值<ol><li>测量尺度的相差太大</li><li>计算单位不同</li></ol></li><li><strong>百分位数</strong>：一个位置指标，用Px表示，一个百分位数Px将一组观察值分为两部分，理论上有x%的观察值比它小，有（100-x）%的观察值比它大</li><li><strong>四分位数</strong>：P25、P50和P75分位数分别称作下四分位数，中位数 上四分位数</li></ul><h2 id="2-3-分布形状"><a href="#2-3-分布形状" class="headerlink" title="2.3 分布形状"></a>2.3 分布形状</h2><p><strong>分布形状</strong>：针对某种分布进行进一步的特征描述</p><ul><li>偏度系数 正态 正偏态(左偏) 负偏态(右偏) ；skew()</li><li>峰度系数 正态 平阔峰(高尖)  尖峭峰(矮胖) ；kurt()</li></ul><h1 id="3-推断统计"><a href="#3-推断统计" class="headerlink" title="3. 推断统计"></a>3. 推断统计</h1><h2 id="3-1-概率分布"><a href="#3-1-概率分布" class="headerlink" title="3.1 概率分布"></a>3.1 概率分布</h2><p><strong>概率分布</strong>：随机变量的概率存在的规律</p><h3 id="3-1-1-离散型随机变量的概率分布"><a href="#3-1-1-离散型随机变量的概率分布" class="headerlink" title="3.1.1 离散型随机变量的概率分布"></a>3.1.1 离散型随机变量的概率分布</h3><p><strong>伯努利试验</strong>：只有两个结果事件，其概率分布称为<strong>伯努利分布</strong>(Bernoulli distribution)，也称为 <strong>两点分布</strong> 或者 <strong>0-1分布</strong></p><p><strong>二项分布</strong>：是指在只有两个结果的n次独立的伯努利试验中，所期望的结果出现次数的概率；<strong>二项分布的均值和方差分别为np和npq</strong></p><p><strong>泊松分布</strong>：描述在一指定时间范围内或在指定的面积或体积内某一事件出现的次数的分布；在n重伯努利实验中，当成功的概率很小，实验次数很大时，二项分布可近似等于泊松分布</p><h3 id="3-1-2-连续型型随机变量的概率分布"><a href="#3-1-2-连续型型随机变量的概率分布" class="headerlink" title="3.1.2 连续型型随机变量的概率分布"></a>3.1.2 连续型型随机变量的概率分布</h3><p><strong>正态分布</strong>：直条的面积实质上就是频率 = 直条高度 X 宽度(组距)；当样本量越来越大，频率(面积) 趋向概率，并且组距越来越小时，直方条的顶缩成点并且各个直方条的顶连接成一条曲线，这条曲线就是 <strong>概率密度分布曲线</strong></p><p><strong>标准正态分布</strong>：均数为0，标准差为1的正态分布N(0,1)曲线</p><p><strong>自由度</strong>：可以自由取值的个数；通过样本推估总体时，取n个样本，自由度为n-1；仅对样本进行计算，则自由度为 n</p><ul><li><strong>卡方分布</strong>：chi-square distribution，若n个相互独立的随机变量ξ₁, ξ₂, … , ξn ，均服从标准正态分布（也称独立同分布于标准正态分布），则这n个服从标准正态分布的随机变量的平方和构成一新的随机变量，其分布规律称为卡方分布；<strong>卡方分布是多个标准整套分布的平方和，解决方差相关的问题</strong>  拟合优度检验和独立性检验</li><li><strong>t分布</strong>：若随机变量X服从标准正态分布N（0,1），随机变量Y服从自由度为n的卡方分布，且X与Y独立；则X、Y服从t分布；<strong>t分布就是标准正态分布除以均方（一组数的平方和的平均值）的根，主要用于处理小样本问题</strong></li><li><strong>F分布</strong>：均方之比，用来对比两个方差</li></ul><h2 id="3-2-抽样分布"><a href="#3-2-抽样分布" class="headerlink" title="3.2 抽样分布"></a>3.2 抽样分布</h2><p><strong>统计推断</strong>：statistical inference，从数据得到关于现实世界的结论的过程就叫做统计推断</p><h2 id="3-3-参数估计"><a href="#3-3-参数估计" class="headerlink" title="3.3 参数估计"></a>3.3 参数估计</h2><p><strong>点估计</strong>：样本均数直接作为总体均数</p><p><strong>区间估计</strong>：根据响应标准误的大小，按照一定的可信度给出一个总体参数可能的取值范围</p><p>置信区间</p><p>置信水平：置信区间中</p><h2 id="3-4-假设检验"><a href="#3-4-假设检验" class="headerlink" title="3.4 假设检验"></a>3.4 假设检验</h2><p><strong>假设检验原理</strong>：基于小概率反证法，小概率原理，即认为小概率事件在一次随机抽样中不会发生</p><h3 id="3-4-1-基本步骤"><a href="#3-4-1-基本步骤" class="headerlink" title="3.4.1 基本步骤"></a>3.4.1 基本步骤</h3><ol><li><strong>建立假设</strong>：根据统计推断的目的而提出对总体特征的原假设：H0，备择假设：H1</li><li><strong>确定检验水准</strong>：确定拒绝H0时的最大允许误差的概率；<strong>检验水准</strong>：size of test，常用 a 表示，常用的检验水准为 a = 0.05</li><li>计算统计量和P值</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析-数据分析报告</title>
      <link href="/202209/0351844.html"/>
      <url>/202209/0351844.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据分析-数据分析报告 的基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><p>表现现状<br>反映问题<br>预测趋势<br>评估目标<br>决策调整</p><h2 id="1-2-内容"><a href="#1-2-内容" class="headerlink" title="1.2 内容"></a>1.2 内容</h2><p>分析背景<br>分析目的<br>分析内容<br>数据介绍<br>分析概述<br>结论汇总<br>改进建议</p><h2 id="1-3-要求"><a href="#1-3-要求" class="headerlink" title="1.3 要求"></a>1.3 要求</h2><p>数据可靠<br>每个分析都有要有结论<br>尽量图表化<br>有解决方案和建议方案<br>通俗易懂</p><h1 id="2-数据指标"><a href="#2-数据指标" class="headerlink" title="2. 数据指标"></a>2. 数据指标</h1><p><strong>作用</strong>：快速高效地定位问题</p><ol><li>表现现状（展现公司组织的运营现状）</li><li>反映问题（反映业务推进过程中存在的问题）</li><li>预测趋势（预测未来发展趋势）</li><li>评估目标（预期目标GAP）</li><li>决策调整（调整执行方案）</li></ol><p><strong>搭建过程</strong></p><ol><li>了解业务</li><li>了解架构</li><li>了解数据库</li></ol><h1 id="3-埋点"><a href="#3-埋点" class="headerlink" title="3. 埋点"></a>3. 埋点</h1><p><strong>分类</strong><br>前端埋点<br>后端埋点<br>SDK埋点<br>无埋点<br>全埋点</p><p><strong>目标</strong><br>用户体验<br>功能校验<br>运营活动</p><p><strong>步骤</strong><br>了解产品形态：小程序、APP、H5<br>了解业务逻辑：用户操作路径、功能能模块、逻辑关系和数据流向<br>业务流程图<br>设计埋点方案：添加统计事件和统计参数<br>交付设计文档</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> 数据分析报告 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python进阶-数据清洗</title>
      <link href="/202209/024812.html"/>
      <url>/202209/024812.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录-Python进阶-数据清洗-的基础知识</p><span id="more"></span><h1 id="1-数据清洗"><a href="#1-数据清洗" class="headerlink" title="1. 数据清洗"></a>1. 数据清洗</h1><p><strong>数据清洗</strong>：是指按照一定的规则对数据进行重新审查和校验的过程，目的在于处理异常值（包括 <strong>删除重复信息、填充缺失信息、纠正异常信息、数据一致化处理</strong> 等），并检查数据一致性</p><p><strong>清洗过程</strong></p><ol><li>选择子集</li><li>删除重复值</li><li>填充缺失值</li><li>处理异常值</li><li>一致化处理（时间日期格式、薪资转换成数字进行处理）</li></ol><h1 id="2-异常信息处理"><a href="#2-异常信息处理" class="headerlink" title="2. 异常信息处理"></a>2. 异常信息处理</h1><h2 id="2-1-重复值"><a href="#2-1-重复值" class="headerlink" title="2.1 重复值"></a>2.1 重复值</h2><ol><li>查找重复值；</li><li>明确重复原因，判断是否业务需要保留；</li><li>处理重复值（需要则保留，否则进行删除处理，删除数据需要慎重！！！）</li></ol><h2 id="2-2-缺失值"><a href="#2-2-缺失值" class="headerlink" title="2.2 缺失值"></a>2.2 缺失值</h2><p><strong>缺失值处理</strong>：确定缺失值范围，根据字段的重要性和缺失率指定不同的清洗策略</p><ul><li>重要缺失多：重新取数</li><li>重要缺失少：算法填充或业务逻辑填充等</li><li>不重要缺失多：考虑删除或统一置数，为零、平均数、中位数、众数等</li><li>不重要缺失少：统一置数，也可以进行删除处理；对于文本型，可以进行人为判断填充</li></ul><p><strong>注</strong>：在 numpy、pandas 中，缺失值由 <strong>nan</strong> 表示，而不是 <strong>null</strong></p><p><strong>nan</strong>：not a number，表示不是一个数字，浮点类型数据；读取数据时如果出现缺失，会出现 nan；或者进行不合适的运算</p><ul><li>np.nan != np.nan 两个 nan 不相等</li><li>nan 和任何数值计算结果都为 nan</li></ul><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport pandas as pddf &#x3D; pd.DataFrame(np.random.randint(1, 20, size &#x3D; (4, 6)))df[df &lt; 10] &#x3D; np.nanarr &#x3D; np.array(df[0])# 1. 判断空值 nan# numpy.isnan(x, &#x2F;, out&#x3D;None, *, where&#x3D;True, casting&#x3D;&#39;same_kind&#39;, order&#x3D;&#39;K&#39;, dtype&#x3D;None, subok&#x3D;True[, signature, extobj]); 是一个ufunc，判断是否为 np.nan，返回与原 ndarray 同形状的布尔数组np.isnan(arr)   # 返回与 arr 相同形状的布尔数组# pandas.isna(obj), DataFrame.isna(), Series.isna()# pandas.isnull(obj), DataFrame.isnull(), Series.isnull() # 功能与 isna 相同pd.isna(df)     # df.isna(),pd.isnull(df) 结果相同；返回与 DataFrame 相同形状的布尔数组df[0].isna()    # 返回与 df[0] 相同形状的布尔数组# 2. 统计空值的个数# numpy.count_nonzero(a, axis&#x3D;None, *, keepdims&#x3D;False); 统计非零的个数，包括 np.nancount_n &#x3D; np.count_nonzero(arr)             # 返回4，np.nan 也是非零数count_nb &#x3D; np.count_nonzero(arr !&#x3D; arr)     # 返回2，arr !&#x3D; arr 返回与 df[0] 相同形状的布尔数组，只有 np.nan 时返回为 True，用 1(非0) 表示；对应 True 的个数就是 np.nan 的个数count_ni &#x3D; np.count_nonzero(np.isnan(arr))  # 返回2count_ns &#x3D; np.isnan(arr).sum()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DataFrame.<strong>fillna</strong>(value=None, method=None, axis=None, inplace=False, limit=None, downcast=None)</p><ol><li>value：填充的数据；method：填充的方法；axis：填充的方向</li><li>inplace：执行后覆盖原数据；limit：限制填充的条数</li></ol><p>DataFrame.<strong>dropna</strong>(axis=0, how=’any’, thresh=None, subset=None, inplace=False)</p><ol><li>axis：删除的方向；how：删除的方式，有效值：’any’(任何一处为 pd.nan ，删除整行), ‘all’(所有列为 pd.nan ，删除整行)，默认值：’any’</li></ol><pre class="line-numbers language-none"><code class="language-none"># 2. 填充空值：所有空值填充为统一值或同一函数计算出来的值# df_f &#x3D; df_copy.fillna(value &#x3D; 5)df_f &#x3D; df_copy.fillna(method &#x3D; df_copy.mean())   # 均值填充# 3. 删除空值：删除包含空值的行df_d &#x3D; df_copy.dropna(how &#x3D; &#39;any&#39;)# 均值填充二维数组 nandef fill_nan(array):    for i in range(array.shape[1]):     # arr.shape 返回数组形状元组(idx, col)        col_data &#x3D; array[:,i]           # 取每一列的数据        if np.count_nonzero(col_data !&#x3D; col_data) !&#x3D; 0:            # 获取非nan的值            col_data_value &#x3D; col_data[col_data &#x3D;&#x3D; col_data]            #将 nan 赋值为均值            col_data[np.isnan(col_data)] &#x3D; col_data_value.mean()    return arrayarr_fill &#x3D; fill_nan(arr)print(arr_fill)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-异常值"><a href="#2-3-异常值" class="headerlink" title="2.3 异常值"></a>2.3 异常值</h2><h3 id="2-3-1-取值异常"><a href="#2-3-1-取值异常" class="headerlink" title="2.3.1 取值异常"></a>2.3.1 取值异常</h3><p><strong>属性值超过域范围</strong></p><p>DataFrame.<strong>drop</strong>(labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors=’raise’)</p><ol><li>labels：指定要删除的索引或列标签；axis：删除的方向；index：删除数据的索引；columns：删除数据的列名；level：应用在多级索引 DataFrame 的删除操作中，指定索引级别</li><li>inplace：执行后覆盖原数据；errors：对待错误的方式，有效值：’ignore’, ‘raise’，默认值为’raise’</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport pandas as pddf &#x3D; pd.DataFrame(np.random.randint(1, 20, size &#x3D; (4, 6)))# 按照索引删除整行df.drop(index &#x3D; [1, 2])# 按照列名删除整列df.drop(columns &#x3D; [1, 2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据清洗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析-基础</title>
      <link href="/202208/3032998.html"/>
      <url>/202208/3032998.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据分析 的相关基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>数据分析</strong>：用适当的统计分析方法对收集来的大量数据进行分析，运用高效的分析工具将他们加以分类和汇总，并提取其中最有价值的信息，概况总结形成有效结论，挖掘数据最大价值的过程，发挥数据的作用，支持企业决策</p><p><strong>数据分析流程</strong>：</p><ol><li>明确需求</li><li>确定思路</li><li>采集数据：八爪鱼、火车采集器、HAWK、Python(爬虫)</li><li>处理数据：MySQL、Kettle、Python(Numpy、Pandas)</li><li>分析数据：SPSS、Stata、Eviews、Python(机器学习)、R语言、MATLAB</li><li>展示数据：Tableau、PowerBI、FineBI、Python(matplotlib、Seaborn)、Echarts</li><li>撰写报告：Word、PPT</li><li>效果反馈</li></ol><h1 id="2-数据分析方法"><a href="#2-数据分析方法" class="headerlink" title="2. 数据分析方法"></a>2. 数据分析方法</h1><h2 id="2-1-对比分析"><a href="#2-1-对比分析" class="headerlink" title="2.1 对比分析"></a>2.1 对比分析</h2><p>将两个事物进行比较：横向比较（同一时间与它物进行对比）、纵向比较（不同时间自身对比）</p><p><strong>同比</strong>：间隔时间的比较，如去年的今天和今年的今天进行比较</p><p><strong>环比</strong>：相邻时间的比较，如本月和上个月进行比较</p><h2 id="2-2-逻辑树分析"><a href="#2-2-逻辑树分析" class="headerlink" title="2.2 逻辑树分析"></a>2.2 逻辑树分析</h2><p><strong>逻辑树</strong>：被称为问题树、演绎树或分解树，是麦肯锡公司提出的分析问题、解决问题的重要方法；将繁杂的数据工作细分为多个关系密切的部分，不断地分解问题，从而找出关键点，推动问题的解决</p><h2 id="2-3-多维度拆解分析"><a href="#2-3-多维度拆解分析" class="headerlink" title="2.3 多维度拆解分析"></a>2.3 多维度拆解分析</h2><p>从组成部分拆解</p><p>从指标构成拆解（用户：新老用户）</p><p>从业务流程拆解</p><h2 id="2-4-归因分析（假设检验法）"><a href="#2-4-归因分析（假设检验法）" class="headerlink" title="2.4 归因分析（假设检验法）"></a>2.4 归因分析（假设检验法）</h2><ol><li>提出假设（可以从产品 渠道 运营或4P营销理论进行大胆假设）</li><li>收集证据</li><li>得出结论</li></ol><h2 id="2-5-相关关系分析"><a href="#2-5-相关关系分析" class="headerlink" title="2.5 相关关系分析"></a>2.5 相关关系分析</h2><p><strong>相关关系分析</strong>：研究两种或两种以上的变量的关系</p><p>正相关：一个变量的增长会引起另外一个变量的增长；r = 1 代表完全正相关</p><p>负相关：一个变量的增长反而会引起另外一个变量的下降；r = -1 代表完全负相关</p><p>相关系数r的取值范围[-1,1]；|r|&gt;0.6 代表相关性很强</p><h2 id="2-6-RFM分析模型"><a href="#2-6-RFM分析模型" class="headerlink" title="2.6 RFM分析模型"></a>2.6 RFM分析模型</h2><ul><li>近度：<strong>Recency</strong>，最近一次消费到当前的时间间隔，指用户上一次消费的时间到目前统计时间的间隔</li><li>频度：<strong>Frequency</strong>，最近一段时间内的消费次数，指用户在某段时间内的购物次数；消费频率越高意味着这部分用户对产品的满意度最高，用户粘性最好，忠诚度也最高</li><li>额度：<strong>Monetory</strong>，最近一段时间内的消费金额，指用户在某段时间内的购物金额；消费金额较高的用户是需要重点争取的对象</li></ul><p>通过RFM的取值可以将用户分成八大类</p><table><thead><tr><th>客户类型</th><th>R-客户黏性</th><th>F-忠诚度</th><th>M-消费力</th><th>对应场景</th><th>精细化运营</th></tr></thead><tbody><tr><td>重要价值用户</td><td>高</td><td>高</td><td>高</td><td>优质客户，需要保持</td><td>VIP服务、个性化服务，附加销售</td></tr><tr><td>重要发展用户、重要深耕用户</td><td>高</td><td>低</td><td>高</td><td>优质客户，消费频率低；重点发展</td><td>交叉销售，提供会员忠诚计划，推荐其他产品</td></tr><tr><td>重要保持用户、重要唤回用户</td><td>低</td><td>高</td><td>高</td><td>优质客户，最近无消费；需唤回</td><td>DM营销，提供有用资源，续订产品或更新产品</td></tr><tr><td>重要挽留用户</td><td>低</td><td>低</td><td>高</td><td>优质客户，消费频率低，最近无消费；需挽留</td><td>重点联系，提高留存率</td></tr><tr><td>一般价值客户、潜力客户</td><td>高</td><td>高</td><td>低</td><td>低价值客户，消费频率高，最近有消费；需挖掘</td><td>销售高价值产品</td></tr><tr><td>一般发展客户、新客户</td><td>高</td><td>低</td><td>低</td><td>最近有交易的新客户；可推广留存</td><td>提供免费试用，提升客户兴趣，创建品牌和知名度</td></tr><tr><td>一般维持客户</td><td>低</td><td>高</td><td>低</td><td>价值贡献低，消费频率高</td><td>积分制，打折促销，保持联系</td></tr><tr><td>一般挽留客户、流失客户</td><td>低</td><td>低</td><td>低</td><td>可认为为流失客户</td><td>根据价值判断是否保留</td></tr></tbody></table><h2 id="2-7-漏斗分析模型"><a href="#2-7-漏斗分析模型" class="headerlink" title="2.7 漏斗分析模型"></a>2.7 漏斗分析模型</h2><p><strong>营销漏斗模型</strong>：指的是营销过程中，将非潜在客户逐步变为客户的转化量化模型；量化营销过程各个环节的效率，帮助找到薄弱环节</p><p><strong>AARRR分析模型</strong>：</p><p>第一环节是获取用户（<strong>Acquisition</strong>）：关注渠道曝光量，渠道转换率，日新增用户数，日应用下载量，获客成本</p><ul><li>口碑渠道：适合病毒营销</li><li>有机渠道：适合搜索引擎优化（SEO）、内容营销</li><li>付费渠道：展示位广告、搜索广告、信息流广告</li></ul><p>第二环节是激活用户（<strong>Activation</strong>）：关注日活，活跃率（活跃用户占比），PV，UV</p><p>第三个环节是提高留存（<strong>Retention</strong>）：关注留存率；重点关注留存率，复购率，人均购买次数，召回率等</p><p>第四个环节是增加收入（<strong>Revenue</strong>）：关注客单价、PUR付费用户占比、ARPPU某段时间内付费用户平均收入、生命周期价值（平均一个用户首次和最后登录之间创造的收入）、复购率、销售额（用户数<em>转换率</em>客单价*购买频率）</p><p>第五个环节推荐（<strong>Referral</strong>，病毒式营销）： 关注转发率、转化率、广告转化率、K因子（发出邀请人数*转换率，k&gt;1表现好）</p><h2 id="2-8-杜邦分析法"><a href="#2-8-杜邦分析法" class="headerlink" title="2.8 杜邦分析法"></a>2.8 杜邦分析法</h2><ol><li><p>销售净利润：净利润/销售额</p></li><li><p>总资产周转率：销售额/总资产</p></li><li><p>权益乘数：总资产/净资产（自己出的钱）</p></li></ol><p>业务问题分析：</p><ol><li>明确问题：时间、地点、事件（比较对象、计算方式）</li><li>分析思路：多维度</li></ol><ul><li>主体（人员、产品）</li><li>时间</li><li>空间</li><li>环境（内部、外部：市场、竞争对手、重大事件）</li></ul><p>常见分析指标</p><p><strong>用户数据</strong>：</p><ul><li><strong>日新增用户数</strong>：反映产品拉新的能力</li><li>活跃用户数：衡量网站的运营现状，能够带来一些价值（打开应用、登录、产生特定的行为；分为 <strong>日活DAU</strong>：Daily Active User、月活MAU）；活跃率 = 活跃用户数 / 总用户数</li><li><strong>留存率</strong>：第一天访问的用户数在接下来指定天数的访问用户数的占比情况；反映产品留住用户的能力，行业基本标准（次日留存率：40%；7日留存率：20%；月留存率：10%）</li><li><strong>单位获客成本</strong>：广告活动产生的投放费用与广告活动带来的独立访客数的比值；单位访客成本与访客转化率、访客收入进行关联分析</li><li><strong>客单价</strong>：订单总额与订单数量的比值</li><li><strong>ARPU</strong>：Average Revenue Per User，总收入/总用户数</li><li><strong>ARPPU</strong>：Average Revenue Per Paying User，总收入/付费用户数</li></ul><p><strong>行为数据</strong>：</p><ul><li><strong>PV</strong>：页面访问量，也叫页面点击量，Page View；记录用户访问网页的次数，同一个网页刷新一次就算一次访问、用户对同一页面的多次访问，访问量累计</li><li><strong>UV</strong>：独立访客数；通过cookie来标记用户，对同一cookie在一天内多次访问网站的用户仅记录为一个用户</li><li><strong>IP</strong>：某IP地址的计算机访问网站的次数；如果是局域网使用同一个IP，则只记录一次</li><li><strong>平均访问时长</strong>：打开第一个页面到关闭最后一个页面的时长叫做总访问时长，平均访问时长 = 总访问时长 / 访问次数</li><li><strong>跳出率</strong>：跳出率 = 只访问一个页面就离开网站的访问次数 / 总访问次数；反映网站流量质量</li><li><strong>转化率</strong>：潜在用户在我们的网站上完成一次我们期望的行为叫一次转化；转化率 = 转化次数 / 访问次数；<strong>电商网站的转化率 = 网站下单的次数 / 网站总访问次数</strong></li><li><strong>复购率</strong>：复购率 = 购买两次及以上的客户 / 总购买客户数</li></ul><p><strong>产品数据</strong>：</p><ul><li><strong>GMV</strong>：成交总额，流水；成交总额包括销售额、取消订单金额、拒收订单金额和退货订单金额</li><li><strong>SKU</strong>：Stock Keeping Unit；库存量单位，SKU是商品信息聚合的最小单位</li><li><strong>SPU</strong>：Standard Product Unit：标准化产品单元；SPU是商品信息聚合的最小单位，是一组可复用、易检索的标准化信息的集合，该集合描述了一个产品的特性</li><li><strong>ROI</strong>：Return On Investment：投资回报率；产生的交易金额与活动投放成本金额的比值</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据资产管理-基础</title>
      <link href="/202208/2429729.html"/>
      <url>/202208/2429729.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据资产管理 的相关基础内容</p><span id="more"></span><h1 id="数据资产"><a href="#数据资产" class="headerlink" title="数据资产"></a>数据资产</h1><p><strong>数据资产</strong>：由企业拥有或控制的（包括以合法途径获取的企业外部数据资源），未来能够带来经济利益的，以物理或电子方式记录的数据资源等，如文档资料、电子数据等<br><strong>数据资产管理</strong>：对数据资产进行管理，规划、控制数据及信息资产的业务活动，包括开发、执行和监督有关数据的计划、政策、项目等，确保数据资产保值、升值，贯穿数据整个生命周期</p><h1 id="1-数据资产特性"><a href="#1-数据资产特性" class="headerlink" title="1. 数据资产特性"></a>1. 数据资产特性</h1><p><strong>无消耗性</strong>：数据资产不会因为使用频率的增加而磨损、消耗，与传统无形资产类似<br><strong>增值性</strong>：企业通过稳定发展，数据规模和数据维度会在原有的基础上不断积累，整体价值进一步提升<br><strong>依附性</strong>：数据资产往往依附于相应的软件、硬件发挥作用和效应，不能独立发挥作用<br><strong>价值易变性</strong>：数据资产时刻受到数据容量、数据时效程度、应用场景等因素的影响，其价值更易发生变化<br><strong>战略性</strong>：一切数据业务化，一切业务数据化，具有战略性</p><h1 id="2-数据资产估值"><a href="#2-数据资产估值" class="headerlink" title="2. 数据资产估值"></a>2. 数据资产估值</h1><h2 id="2-1-估值内容"><a href="#2-1-估值内容" class="headerlink" title="2.1 估值内容"></a>2.1 估值内容</h2><ol><li><strong>运营成本</strong>：包括采集、存储、计算和运维的费用</li><li><strong>替换成本</strong>：在灾难性数据破坏事件或数据中断时，数据替换货恢复的成本</li><li><strong>风险成本</strong>：潜在罚款、补救成本和诉讼费用的估价<ul><li>缺少必须数据</li><li>保存不应留存数据</li><li>存储数据不正确</li></ul></li><li><strong>使用价值</strong>：企业日常运行带来的价值，主要通过数据资产分类、使用频次、使用对象、使用效果和共享流通进行计量</li><li><strong>市场价值</strong>：通过交易、售卖、兼并或收购时作为企业资产的价值，通过稀缺性、时效性进行衡量</li><li><strong>洞察价值</strong>：从数据中发现、洞察商机获得的收入价值</li></ol><h2 id="2-2-估值方法"><a href="#2-2-估值方法" class="headerlink" title="2.2 估值方法"></a>2.2 估值方法</h2><ul><li><p><strong>非财务方法</strong></p><blockquote><p>数据的内在价值模型：不考虑业务价值，仅从技术层面进行特征加权统计<br>数据的商业价值模型：结合业务流程进行特征加权统计<br>数据的绩效价值模型：衡量随时间推移对API绩效指标的影响</p></blockquote></li><li><p><strong>财务方法</strong></p><blockquote><p>数据的成本价值模型：衡量获取或替换丢失数据的价值成本<br>数据的经济价值模型：衡量信息资产对企业收入的贡献<br>数据的市场价值模型：衡量企业出售、出租和交换企业数据所产生的收入</p></blockquote></li></ul><h2 id="2-3-价值评估理论"><a href="#2-3-价值评估理论" class="headerlink" title="2.3 价值评估理论"></a>2.3 价值评估理论</h2><ul><li><p><strong>层次分析法</strong></p><blockquote><p>分析各因素关系，建立地接层次结构<br>同一层级进行重要性判断，构建判断矩阵<br>由判断矩阵计算比较元素的相对权重<br>计算合成权重</p></blockquote></li><li><p><strong>专家打分法（德尔菲法）</strong></p><blockquote><p>按照课题组成专家小组<br>收集专家关于相关问题的书面回答<br>分析专家的回答，提出自己的预测<br>将专家判断意见汇总，进行对比，再将所有专家意见返还，专家根据他人意见进行修改<br>回收专家意见，再次汇总分发，直至所有专家不再更改<br>对专家意见进行综合处理</p></blockquote></li></ul><h2 id="2-4-评估指标"><a href="#2-4-评估指标" class="headerlink" title="2.4 评估指标"></a>2.4 评估指标</h2><ul><li><p><strong>数据内在价值——数据质量</strong></p><blockquote><p>完整性：缺失字段或缺失记录（整个数据缺失记录）<br>正确性：数据内容与客观实体特征是否一致<br>一致性：同一实体同一属性值在不同的数据集中是否一致<br>重复性：是否存在重复数据</p></blockquote></li><li><p><strong>数据外在价值</strong></p><blockquote><p>稀缺性：数据供给方数量的多寡及数据的供给丰富程度<br>时效性：数据时间特性对应用的满足程度<br>多维性：描述数据集的多寡程度<br>场景经济性：在具体场景中数据集的经济价值</p></blockquote></li></ul><h1 id="3-数据资产目录"><a href="#3-数据资产目录" class="headerlink" title="3. 数据资产目录"></a>3. 数据资产目录</h1><p><strong>包含内容</strong>：业务术语表、数据元素定义、数据血缘、数据质量标准、数据安全标准等</p><h2 id="3-1-编制方法"><a href="#3-1-编制方法" class="headerlink" title="3.1 编制方法"></a>3.1 编制方法</h2><p><strong>系统视角</strong>：以系统目前的核心系统为主，将系统功能模块分类，按照系统数据主题、实体定义信息、实体分类信息、数据相关方信息、技术信息构建数据资产目录<br><strong>主题域视角</strong>：按照战略发展、业务运营、管理支持构建系统统一的数据域主题或以及主题，按照实体定义信息、实体分类信息、数据相关方信息、技术信息构建数据资产目录</p><h2 id="3-2-能力评估"><a href="#3-2-能力评估" class="headerlink" title="3.2 能力评估"></a>3.2 能力评估</h2><ul><li><p><strong>能力内容</strong></p><p><strong>发现能力</strong>：所有可用数据资产进行清洗全面概述的能力<br><strong>理解能力</strong>：新增、修改数据资产目录和自我丰富的能力<br><strong>信任能力</strong>：支持用户评估数据的可靠性和质量<br><strong>协作能力</strong>：支持用户进行任务共享并鼓励用户创建和修订描述<br><strong>治理能力</strong>：支持满足企业标准的能力</p></li><li><p><strong>能力级别</strong></p><p><strong>初始级</strong>：没有努力集中编制数据资产目录，无法集中获得大部分有价值信息<br><strong>主动管理</strong>：存在数据资产列表和文档，可使用搜索功能，更新缓慢<br><strong>基于工具</strong>：数据资产目录由专业团队管理，能助力自动捕获元数据，使用更轻松<br><strong>优化级</strong>：数据资产目录做了样本数据条目和统计信息，包含自动捕获的血缘信息，使数据资产目录可信度更高<br><strong>自动化级</strong>：可向用户推荐数据资产可自动生成数据质量和数据资产价值评估结果</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
            <tag> 数据质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Excel-常见操作指令</title>
      <link href="/202208/1634439.html"/>
      <url>/202208/1634439.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Office-Excel常见操作指令 的相关基础内容</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><h2 id="1-1-发展历程"><a href="#1-1-发展历程" class="headerlink" title="1.1 发展历程"></a>1.1 发展历程</h2><p>1978年由DanBricklin和BobFrankston创建世界上第一款电子表格——VisiCalc；</p><p>1983年，Lotus公司开发的一款成功的电子表格——Lotus 1-2-3；</p><p>1982年：微软推出第一款电子制表软件-Multiplan，败给了Lotus 1-2-3；</p><p>1985年：微软推出Excel for Mac；1987年：推出 Excel 2 for Windows；绑定系统，打败Lotus 1-2-3；随后收购Lotus公司</p><p>1993年：推出 Excel 5， Excel被捆绑进Microsoft Office中，Excel开始支持VBA；</p><p>1997年：推出 Excel 97，也称 Excel 8，Excel97是Office97中一个重要程序；通用叫法 97-03 版，文件后缀为 xls；03及以后文件后缀为 xlsx；xlsm（带宏的文件），<strong>本文操作以 97-03 版 为准</strong></p><h2 id="1-2-基本构成"><a href="#1-2-基本构成" class="headerlink" title="1.2 基本构成"></a>1.2 基本构成</h2><p><strong>工作簿</strong>：Excel文件又称为工作簿，由多个 sheet 组成；每个 sheet 包含功能区和操作区</p><p><strong>功能区</strong>：由 <strong>文件</strong>、<strong>开始</strong>、<strong>插入</strong>、<strong>页面布局</strong>、<strong>公式</strong>、<strong>数据</strong>、<strong>审阅</strong>、<strong>视图</strong> 和 <strong>开发工具</strong> 等功能选项卡组成</p><p><strong>操作区</strong>：由 1048576(行) * 16384(XFD，列) 的二维表格组成</p><h1 id="2-文件"><a href="#2-文件" class="headerlink" title="2. 文件"></a>2. 文件</h1><h2 id="2-6-选项"><a href="#2-6-选项" class="headerlink" title="2.6 选项"></a>2.6 选项</h2><h3 id="2-6-6-高级"><a href="#2-6-6-高级" class="headerlink" title="2.6.6 高级"></a>2.6.6 高级</h3><p><strong>自定义列表</strong>：点击 文件菜单栏 -&gt; 选择高级 -&gt; 向下滑动找到 编辑自定义列表(位置较下，需要滑动久一点)点击，调出 自定义序列 对话框 -&gt; 对话框左侧选择新序列 -&gt; 右侧输入需要加入的序列列表(序列值通过英文逗号 , 隔开，或者通过换行隔开) -&gt; 点击添加 -&gt; 点击确定，完成新下拉列表的添加；（<strong>修改</strong>：在 自定义序列 对话框左侧选择需要修改的序列 -&gt; 右侧对序列值进行修改 -&gt; 点击添加 -&gt; 点击确定，默认序列不支持修改；<strong>删除</strong>：在 自定义序列 对话框左侧选择需要删除的序列 -&gt; 点击删除 -&gt; 点击确定）</p><h1 id="3-开始"><a href="#3-开始" class="headerlink" title="3. 开始"></a>3. 开始</h1><h2 id="3-1-剪贴板"><a href="#3-1-剪贴板" class="headerlink" title="3.1 剪贴板"></a>3.1 剪贴板</h2><h3 id="3-1-1-粘贴-选择性粘贴"><a href="#3-1-1-粘贴-选择性粘贴" class="headerlink" title="3.1.1 粘贴-选择性粘贴"></a>3.1.1 粘贴-选择性粘贴</h3><p><strong>选择性粘贴打开方式</strong>：</p><ol><li>点击 开始菜单栏 -&gt; 点击 粘贴下拉框(最左侧) -&gt; 选择 选择性粘贴，调出 选择性粘贴 对话框；</li><li>选择需要进行粘贴的单元格，点击鼠标右键，在出现的下拉列表中点击  选择性粘贴，调出 选择性粘贴 对话框</li></ol><p><strong>选择性粘贴-普通粘贴</strong>：点击 开始菜单栏 -&gt; 点击 粘贴下拉框 -&gt; 选择 选择性粘贴，调出 选择性粘贴 对话框 -&gt; 选择 粘贴 中合适的粘贴方式；支持跳过空单元格进行粘贴</p><p><strong>选择性粘贴-运算粘贴</strong>：点击 开始菜单栏 -&gt; 点击 粘贴下拉框 -&gt; 选择 选择性粘贴，调出 选择性粘贴 对话框 -&gt; 选择 运算 中合适的粘贴方式；包括 加、减、乘、除（先复制进行运算的基数，再选择需要进行运算的数据，调出 选择性粘贴 的对话框，选择运算方式，点击确定即可得到结果）</p><h2 id="3-7-编辑"><a href="#3-7-编辑" class="headerlink" title="3.7 编辑"></a>3.7 编辑</h2><h3 id="3-7-2-填充"><a href="#3-7-2-填充" class="headerlink" title="3.7.2 填充"></a>3.7.2 填充</h3><p><strong>注</strong>：填充需要现在填充的开始单元格位置输入填充的起始值</p><ul><li><strong>序列填充</strong>：选中填充的开始单元格位置 -&gt; 点击 开始菜单栏 -&gt; 点击 填充下拉选项卡，选择序列 -&gt; 选择填充方向(行、列)、序列类型(等差、等比等)、填充步长和终止值</li></ul><h3 id="3-7-4-排序与筛选"><a href="#3-7-4-排序与筛选" class="headerlink" title="3.7.4 排序与筛选"></a>3.7.4 排序与筛选</h3><ul><li><strong>单列排序</strong>：选择进行排序的列 -&gt; 点击 开始菜单栏 -&gt; 点击 排序和筛选下拉框 -&gt; 选择排序方式</li><li><strong>多列排序</strong>：点击 开始菜单栏 -&gt; 点击 排序和筛选下拉框 -&gt; 选择自定义排序 -&gt; 在弹出的对话框中选择排序关键字和排序方式，可通过添加条件选择排序的次关键字和排序方式</li></ul><h3 id="3-7-5-查找和选择"><a href="#3-7-5-查找和选择" class="headerlink" title="3.7.5 查找和选择"></a>3.7.5 查找和选择</h3><ul><li><strong>查找</strong>：点击 开始菜单栏 -&gt; 点击 查找和替换(最右侧) -&gt; 在下拉框中选择 查找 -&gt; 在调出的查找对话框中点击选项，进行查找内容限定（内容、单元格格式）、范围限定（工作簿、工作表）、方式限定（按行、按列）等 -&gt; 点击查找全部或查找下一个；<strong>快捷键操作</strong>：Ctrl + F -&gt; 进行查找限定 -&gt; 点击查找全部或查找下一个；默认会保留上一次查找限定</li><li><strong>替换</strong>：点击 开始菜单栏 -&gt; 点击 查找和替换(最右侧) -&gt; 在下拉框中选择 替换 -&gt; 在调出的替换对话框中选项，进行替换内容限定（内容、单元格格式）、范围限定（工作簿、工作表）、方式限定（按行、按列）等 -&gt; 在查找内容 和 替换为 的输入框中输入需要查找替换的内容 -&gt; 点击全部替换或替换，可以提前选择需要替换的范围，则只会在选定范围内进行替换；<strong>快捷键操作</strong>：Ctrl + H -&gt; 进行替换限定 -&gt; 点击全部替换或替换；默认会保留上一次替换限定<br><strong>注</strong>：查找、替换支持通配符：? 代表1个字符，* 代表多个字符（包括 0 个）</li><li><strong>定位</strong>：先选择需要定位的范围，点击 开始菜单栏 -&gt; 点击 查找和替换(最右侧) -&gt; 在下拉框中选择 定位条件 -&gt; 在调出的定位对话框中选择合适的定位条件 -&gt; 点击确定，完成数据定位；此时可对所有选中的单元格进行操作(快捷键正常操作、<strong>完成输入操作后按 Ctrl + Enter 实现将内容填充至所有定位位置</strong>)；<strong>快捷键操作</strong>：Ctrl + G -&gt; 选择定位区域 -&gt; 选择定位条件 -&gt; 点击确认</li></ul><h1 id="4-插入"><a href="#4-插入" class="headerlink" title="4. 插入"></a>4. 插入</h1><h2 id="4-1-数据透视"><a href="#4-1-数据透视" class="headerlink" title="4.1 数据透视"></a>4.1 数据透视</h2><p><strong>数据透视表</strong>：更多操作查看 <a href="https://qizhongyi.gitee.io/202209/0749777.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Excel进阶-数据透视表</strong></font></a></p><h2 id="4-3-图表"><a href="#4-3-图表" class="headerlink" title="4. 3 图表"></a>4. 3 图表</h2><p><strong>图表</strong>：包括图表区、绘图区、图表标题、数据标签、数据系列、坐标轴、网格线、分类名称、图例、图表数据系列名称</p><ul><li><strong>柱状图</strong>：在竖直方向比较不同类型的数据；适用于二维数据集，对于不同类型的数据进行对比，也可用于同一类型的数据在不同的时间维度的数据对比，通过柱子的高度来反应数据的差异</li><li><strong>条形图</strong>：水平方向比较不同类型的数据，更直观；类别名称很长，可以选择条形图</li><li><strong>折线图</strong>：按类别显示一段时间内数据的变化趋势，主要用于时间序列的数据；折线图适合二维的大数据集，还适合多个二维数据集的比较</li><li><strong>散点图</strong>：展示二维数据之间的相关关系；主要是展示两类数据之间的线性关系，前提是二者之间有很强的关联性</li><li><strong>气泡图</strong>：展示三维数据之间的关系；通过横纵坐标展示二维数据的关系，然后通过气泡大小来展示与第三个数据类型的关系</li><li><strong>饼图</strong>：也叫扇形图，主要描述的部分与整体的关系；描述一个整体的各个组成部分之间的占比情况</li><li><strong>雷达图</strong>：用于多维数据，多维度的综合对比；主要用于对比两种类型在多个维度的数据</li><li><strong>面积图</strong>：使用面积大小来展示数据对比情况；通过面积大小来对比不同类型的数据</li><li><strong>组合图</strong>：用多种不同的统计图形进行展示；当两种类型的数据在数值上差异很大的话，一种图表类型无法正常展示，可采用组合图</li></ul><h1 id="7-数据"><a href="#7-数据" class="headerlink" title="7. 数据"></a>7. 数据</h1><h2 id="7-4-数据工具"><a href="#7-4-数据工具" class="headerlink" title="7.4 数据工具"></a>7.4 数据工具</h2><ul><li><p><strong>分列</strong>：选中需要分列的单元格，点击 数据菜单栏 -&gt; 点击 分列(中部) ，调出 分列对话框 -&gt; 在 分列对话框 中选择分列方式（特殊符号：分号、逗号、空格等，支持自定义符号；固定长度），点击 特殊符号 / 设置固定长度，点击下一步，支持在分列对话框下方进行预览 -&gt; 选择数据输出格式（常规、文本、日期等）和输出位置，点击下一步 -&gt; 点击确认，完成 <strong>将一个单元格内的数据拆分成多列</strong><br>  <strong>拼接</strong>：=A1&amp;”-“&amp;B1 , 将A1、B1单元格的内容通过 - 拼接至公式输入的单元格</p></li><li><p><strong>删除重复值</strong>：点击 数据菜单栏 -&gt; 点击 删除重复值(中部) ，调出 删除重复值对话框 -&gt; 选择 重复值判定的列（即选定的列组合后重复，才判断为重复值；默认为全部列） -&gt; 点击 删除重复项 -&gt; 点击确定</p></li></ul><h1 id="9-视图"><a href="#9-视图" class="headerlink" title="9. 视图"></a>9. 视图</h1><h2 id="9-4-窗口"><a href="#9-4-窗口" class="headerlink" title="9.4 窗口"></a>9.4 窗口</h2><p><strong>冻结窗口</strong>：</p><p>冻结多行多列：先拆分，再冻结</p><h1 id="12-快捷键"><a href="#12-快捷键" class="headerlink" title="12. 快捷键"></a>12. 快捷键</h1><h2 id="12-1-菜单栏操作"><a href="#12-1-菜单栏操作" class="headerlink" title="12.1 菜单栏操作"></a>12.1 菜单栏操作</h2><p>收缩 / 展开菜单栏：双击即可实现</p><p>Ctrl + PgUp / PgDn：向右 / 左 切换 Sheet(工作表)</p><p>Ctrl + N：新建工作簿；Ctrl + W：不保存关闭当前工作簿</p><h2 id="12-2-区域选择"><a href="#12-2-区域选择" class="headerlink" title="12.2 区域选择"></a>12.2 区域选择</h2><p>home键：移动至当前行开头；Ctrl + home：回到 A1 单元格；Ctrl + Shift + home：选择当前单元格到 A1 单元格的矩形区域(要求是连续区域)</p><p>Ctrl  + 上 / 下 / 左 / 右 箭头：向上 / 下 / 左 / 右定位至空白单元格；如果没有空白单元格，则连续定位至 当前列的 首行 / 末行 或者当前行的 首列 / 末列</p><p>Ctrl + Shift + 上 / 下 / 左 / 右 箭头：向上 / 下 / 左 / 右选择当前单元格至空白单元格的连续区域；如果没有空白单元格，则连续选择至 首行 / 末行 / 首列 / 末列 区域</p><h2 id="12-3-F键相关"><a href="#12-3-F键相关" class="headerlink" title="12.3 F键相关"></a>12.3 F键相关</h2><p>F2：在选中的单元格末尾进行编辑</p><p>F4：重复上次一次的操作；添加地址引用固定</p><p>F5：定位</p><p>F12：调出 另存为 对话框</p><h2 id="12-4-函数"><a href="#12-4-函数" class="headerlink" title="12.4 函数"></a>12.4 函数</h2><p>Alt + = ：求和</p><h2 id="12-其他"><a href="#12-其他" class="headerlink" title="12. 其他"></a>12. 其他</h2><p>Ctrl + 1 ：调出 设置单元格格式 对话框</p><p>Ctrl + G：调出 定位 对话框</p><p>Ctrl + O：调出 打开 对话框，打开文件</p><p>Ctrl + P：调出 打印 对话框</p><p>Ctrl + R ：类似“复制+粘贴”功能，选择单元格和右方连续的需要填充的单元格，然后 Ctrl + R ，实现将单元格的内容填充至右方选中的所有单元格中（Ctrl + D：向下填充）</p><p>Ctrl + ; ：填充当前日期</p><p>Ctrl + 9 / 0：隐藏当前 行 / 列</p><p>Ctrl + ~ ：显示函数</p><p>Ctrl + M：合并单元格</p><p><del>Ctrl + E</del></p><h1 id="13-案例操作"><a href="#13-案例操作" class="headerlink" title="13. 案例操作"></a>13. 案例操作</h1><p><strong>案例1</strong>：将用科学计数法显示的过长数字显示出全部数字</p><ul><li><strong>解决</strong>：通过分列实现</li><li><strong>操作</strong>：选择需要转换的列 -&gt; 点击 数据菜单栏 -&gt; 点击 分列(中部) ，调出 分列对话框 -&gt; 在 分列对话框 中选择分列方式为 <strong>固定长度</strong> -&gt; 通过鼠标指定分列宽度（<strong>仅分一列</strong>） ，点击下一步-&gt; 选择数据输出格式为 <strong>文本</strong>，点击下一步 -&gt; 点击确认</li></ul><p><strong>案例2</strong>：拆分合并单元格并填充</p><ul><li><strong>解决</strong>：全选拆分，公式填充，选择性粘贴</li><li><strong>操作</strong>：选择需要拆分的单元格 -&gt; 拆分单元格(点击开始菜单栏，点击合并单元格) -&gt; 定位空值(Ctrl + G，定位条件为空值) -&gt; 公式填充(=A1(填充位置正上方的单元格)，Ctrl + Enter) -&gt; 选择性粘贴为数值</li></ul><p><strong>案例3</strong>：标注两列存在差异的数据</p><ul><li><strong>解决</strong>：定位（行内容差异单元格）、条件格式</li><li><strong>操作</strong>：<ol><li><strong>定位</strong>：先选中需要标注的内容 -&gt; Ctrl + G -&gt; 选择 行内容差异单元格，点击确定，完成定位 -&gt; 添加合适的内容格式</li><li><strong>条件格式</strong>：先选中需要标注的内容 -&gt; 选择 开始选项卡 -&gt; 点击 条件格式下拉框 -&gt; 选择 突出显示单元格规则，选择 其他规则 -&gt; 选择 使用公式确定要设置格式的单元格 -&gt; 在单元格内部输入公式：=excat($A1, $B1) = False(判断A1、B1是否相等；仅返回 False-不相等的单元格) -&gt; 点击格式，选择合适的标注格式 -&gt; 点击确认</li></ol></li></ul><p>更多操作查看 <a href="https://qizhongyi.gitee.io/202209/063347.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Excel进阶-公式与函数</strong></font></a></p>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块-math</title>
      <link href="/202208/0441820.html"/>
      <url>/202208/0441820.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python模块-math-的基础知识</p><span id="more"></span><h1 id="math"><a href="#math" class="headerlink" title="math"></a>math</h1><p>对数 log</p>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块-Pandas</title>
      <link href="/202208/0364210.html"/>
      <url>/202208/0364210.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python模块-Pandas-的基础知识</p><span id="more"></span><h1 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h1><p><strong>Pandas</strong>：是一个开放源码、BSD 许可的库，提供高性能、易于使用的数据结构和数据分析工具；可以从各种文件格式比如 CSV、JSON、SQL、Microsoft Excel 导入数据，能够处理多种非数值型的数据，基于 NumPy 提供强大的分析结构化数据的工具集；Pandas 名字衍生自术语 “panel data”（面板数据）和 “Python data analysis”（Python 数据分析）；<a href="https://github.com/pandas-dev/pandas"><font face = "微软雅黑" color = 1E90FF size = 5>Github网址</font></a>， <a href="https://pandas.pydata.org/"><font face = "微软雅黑" color = 1E90FF size = 5>Pandas官网</font></a></p><p><strong>核心功能点</strong>：对各种数据进行运算，包括归并、再成形、选择，还有数据清洗和数据加工特征</p><ul><li><strong>Series</strong>：是一种类似于一维数组的对象，由一组数据（各种Numpy数据类型）以及一组与之相关的数据标签（即索引）组成；内部集成了处理字符串的多种函数</li><li><strong>DataFrame</strong>：是一个表格型的数据结构，含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）；DataFrame 既有行索引也有列索引，可以被看做 <strong>由 Series 组成的字典</strong>（共同用一个索引）</li><li>支持多种数据类型，包括数组、标量、字符串、时间序列（时间偏移：Date offsets、重采样：Resampling）等</li><li>多样的数据分析方法，包括索引：Index objects、分组聚合：GroupBy</li></ul><p><strong>其他功能点</strong>：</p><ul><li>I/O编程：Input/output</li><li>提供众多的通用函数：General functions</li><li>窗口操作：Window</li><li>其他：Style、Plotting、General utility functions、Extensions</li></ul><h2 id="1-Series"><a href="#1-Series" class="headerlink" title="1. Series"></a>1. Series</h2><p><strong>Series</strong> ：是一种类似于一维数组的对象，由一组数据（各种Numpy数据类型）以及一组与之相关的数据标签（即索引）组成；内部集成了处理字符串的多种函数</p><p>pandas.<strong>Series</strong>(data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)</p><ol><li>data：Series 对象的数据；index：设置 Series 对象的数据索引；如果没有为数据指定索引，就会⾃动创建⼀个0到N-1（N为数据的⻓度）的整数型索引；</li><li>dtype：数据类型；name：Series 对象的名称；</li><li>copy：对象是否需要复制，默认为 False</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport pandas as pdser &#x3D; pd.Series(data &#x3D; [1, 2, 3, np.nan, 5, 6], index &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;], name &#x3D; &#39;Series_Test&#39;)    # np.nan:表示空值# 通过字典创建student_dict &#x3D; &#123;&#39;name&#39;:&#39;xiaofang&#39;,&#39;age&#39;:30,&#39;tel&#39;:1000&#125;ser_d &#x3D; pd.Series(student_dict)print(ser, &#39;\n&#39;, ser_d)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-读取"><a href="#1-1-读取" class="headerlink" title="1.1 读取"></a>1.1 读取</h3><p>通过索引进行访问，索引从 0 开始；支持负索引和布尔索引；支持切片；<strong>读取后赋值则实现数组值的修改</strong></p><pre class="line-numbers language-none"><code class="language-none"># 通过标签索引result &#x3D; ser[&#39;a&#39;]# 通过位置索引result_1 &#x3D; ser[1:-1:2]# 查看数据或索引ser_v &#x3D; ser.valuesser_i &#x3D; ser.index# 统计数据出现个数ser_cv &#x3D; ser.value_counts()print(result, &#39;\n&#39;, result_1, &#39;\n&#39;, ser_v, &#39;\n&#39;, ser_i, &#39;\n&#39;, ser_cv)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-字符串处理函数"><a href="#1-2-字符串处理函数" class="headerlink" title="1.2 字符串处理函数"></a>1.2 字符串处理函数</h3><p>Series.str.<strong>contains</strong>(pat, case=True, flags=0, na=None, regex=True)：查看字符串中是否包含指定子串，返回布尔结果</p><h2 id="2-DataFrame"><a href="#2-DataFrame" class="headerlink" title="2. DataFrame"></a>2. DataFrame</h2><p><strong>DataFrame</strong>：是一个表格型的数据结构，含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）；DataFrame 既有行索引也有列索引，可以被看做 <strong>由 Series 组成的字典</strong>（共同用一个索引）</p><p>pandas.<strong>DataFrame</strong>(data=None, index=None, columns=None, dtype=None, copy=None)</p><ol><li>data：DataFrame 对象的数据；index：设置 DataFrame 对象的数据索引；columns：列标签，默认为 RangeIndex (0, 1, 2, …, n)</li><li>dtype：数据类型；copy：对象是否需要复制，默认为 False</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport pandas as pddf &#x3D; pd.DataFrame(np.random.randn(7, 4), index &#x3D; pd.date_range(&#39;20220801&#39;, periods &#x3D; 7), columns &#x3D; list(&#39;ABCD&#39;))print(df)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 查询数组基础属性# 1. 查看数据类型print(df.dtypes)# 2. 查看头尾数据print(df.head(2))        # 默认5行print(df.tail(3))        # 默认5行# 3. 查看索引print(df.index)# 4. 查看列名print(df.columns)# 5. 查看数据统计摘要，包括：数量、平均值、标准差、四分数print(df.describe())# 6. 相关信息概览：行数，列数，列索引，列非空值个数，列类型，内存占用print(df.info())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>DataFrame.<strong>rename</strong>(mapper=None, *, index=None, columns=None, axis=None, copy=True, inplace=False, level=None, errors=’ignore’)</p><ol><li>index、columns：设置重命名的索引名、列名；axis：多值时重命名的方向</li><li>copy：对象是否需要复制，默认为 False；inplace：是否原地替换，如果是，则替换现有的 DataFrame，不创建一个新 DataFrame</li><li>errors：对待错误的方式，有效值：’ignore’, ‘raise’，默认值为’ignore’</li></ol><pre class="line-numbers language-none"><code class="language-none"># 重命名列名df_rn &#x3D; df.rename(columns &#x3D; (&#123;&#39;c&#39;:&#39;cc&#39;&#125;))print(df_rn)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-读取"><a href="#2-1-读取" class="headerlink" title="2.1 读取"></a>2.1 读取</h3><h4 id="2-1-1-切片"><a href="#2-1-1-切片" class="headerlink" title="2.1.1 切片"></a>2.1.1 切片</h4><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport pandas as pddf &#x3D; pd.DataFrame(np.random.randn(7, 4), index &#x3D; pd.date_range(&#39;20220801&#39;, periods &#x3D; 7), columns &#x3D; list(&#39;ABCD&#39;))# 1. 选择单列df_c &#x3D; df[&#39;A&#39;]# 2. 切片（行）df_s &#x3D; df[1:3]# df_s &#x3D; df[:1]      # 读取第一行# df_s &#x3D; df[-2:-1]   # 读取最后一行print(df_c, &#39;\n&#39;, df_s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>查询某个值</strong><pre class="line-numbers language-none"><code class="language-none"># 查询某个值result_l &#x3D; df.loc[&#39;2022-08-01&#39;, &#39;B&#39;]result_a &#x3D; df.at[&#39;2022-08-01&#39;, &#39;B&#39;]    # at:速度更快result_i &#x3D; df.iloc[0, 1]result_ia &#x3D; df.iat[0, 1]               # iat:速度更快print(result_l, result_a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h4 id="2-1-2-索引"><a href="#2-1-2-索引" class="headerlink" title="2.1.2 索引"></a>2.1.2 索引</h4><p>索引值可以重复，可通过 pandas.Index.unique() 进行去重</p><ul><li><strong>标签索引</strong></li></ul><pre class="line-numbers language-none"><code class="language-none"># 按标签查询# 1. 按标签选择某行df_li &#x3D; df.loc[[&#39;2022-08-01&#39;, &#39;2022-08-07&#39;]]# 2. 按标签选择某列df_lc &#x3D; df.loc[:, [&#39;A&#39;, &#39;D&#39;]]          # : 表示检索所有的行# 3. 按标签选择指定行指定列df_l &#x3D; df.loc[&#39;2022-08-01&#39;:&#39;2022-08-07&#39;: 2, [&#39;A&#39;, &#39;B&#39;]]print(df_li, &#39;\n&#39;, df_lc, &#39;\n&#39;, df_l)# 取某个值result_l &#x3D; df.loc[&#39;2022-08-01&#39;, &#39;B&#39;]result_a &#x3D; df.at[&#39;2022-08-01&#39;, &#39;B&#39;]    # at:速度更快print(result_l, result_a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>位置索引</strong></li></ul><pre class="line-numbers language-none"><code class="language-none"># 按位置查询# 1. 按位置选择某行df_ii &#x3D; df.iloc[[1, 3]]# 2. 按位置选择某列df_ic &#x3D; df.iloc[:, [0, 3]]          # : 表示检索所有的行# 3. 按位置选择指定行指定列df_i &#x3D; df.iloc[0:6: 2, [1, 2]]print(df_ii, &#39;\n&#39;, df_ic, &#39;\n&#39;, df_i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>条件索引</strong></li></ul><pre class="line-numbers language-none"><code class="language-none"># 按条件查询df_t &#x3D; df[df &gt; 0]df_isin &#x3D; df[df[&#39;A&#39;].isin([0.111206])]print(df_t, &#39;\n&#39;, df_isin)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>重新设置索引</strong></li></ul><p>DataFrame.<strong>reindex</strong>(labels=None, index=None, columns=None, axis=None, method=None, copy=True, level=None, fill_value=nan, limit=None, tolerance=None) ；默认具有相同的索引值保留，否则数据全部置为 NaN</p><ol><li>index：重新设置的索引值；columns：重新设置的属性/列值；axis：重新设置的方向；method：重新设置的方式，有效值：’backfill’/‘bfill’, ‘pad’/‘ffill’, ‘nearest’</li><li>copy：是否复制，即修改是否作用于原数组</li></ol><p>DataFrame.<strong>set_index</strong>(keys, drop=True, append=False, inplace=False, verify_integrity=False) ；将某一列设为索引</p><ol><li>keys：设置的索引列；drop：是否删除索引列，默认删除；append</li><li>append：将新索引添加到旧索引后面；inplace：是否原地替换，如果是，则替换现有的 DataFrame，不创建一个新 DataFrame</li></ol><pre class="line-numbers language-none"><code class="language-none"># 1. 直接重设，直接在原数组上修改df.index &#x3D; [&#39;1号&#39;, &#39;2号&#39;, &#39;3号&#39;, &#39;4号&#39;, &#39;5号&#39;, &#39;6号&#39;, &#39;7号&#39;]# 2. reindexdf_i &#x3D; df.reindex([&#39;8月1号&#39;, &#39;8月2号&#39;, &#39;8月3号&#39;, &#39;8月4号&#39;, &#39;8月5号&#39;, &#39;8月6号&#39;, &#39;8月7号&#39;], copy &#x3D; True)print(df, &#39;\n&#39;, df_i)# 3. set_index：将 DataFrame 的某一列设为索引df[&#39;E&#39;] &#x3D; (1, 2, 3, 4, 5, 6, 7)df_s &#x3D; df.set_index(&#39;E&#39;, drop &#x3D; False)print(df, &#39;\n&#39;, df_s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>复合索引</strong>：<strong>set_index()</strong> 设置索引时，可以通过设置多列设置复合索引，也可以通过 <strong>groupby()</strong> 进行多列分组形成复合索引</li></ul><pre class="line-numbers language-none"><code class="language-none">df[&#39;F&#39;] &#x3D; [&#39;A&#39;, &#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;, &#39;C&#39;, &#39;C&#39;]df_sm &#x3D; df.set_index([&#39;F&#39;, &#39;E&#39;], drop &#x3D; False)print(df_sm)# 可通过 DataFrame.swaplevel(i&#x3D;- 2, j&#x3D;- 1, axis&#x3D;0) 交换复合索引排序<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-赋值"><a href="#2-2-赋值" class="headerlink" title="2.2 赋值"></a>2.2 赋值</h3><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport pandas as pddf &#x3D; pd.DataFrame(np.random.randn(7, 4), index &#x3D; pd.date_range(&#39;20220801&#39;, periods &#x3D; 7), columns &#x3D; list(&#39;ABCD&#39;))df_copy &#x3D; df.copy()     # 复制数组# 按标签索引赋值# df_copy.loc[&#39;2022-08-01&#39;, &#39;A&#39;] &#x3D; 10df_copy.at[&#39;2022-08-01&#39;, &#39;A&#39;] &#x3D; 10# 按位置索引赋值# df_copy.iloc[6, 3] &#x3D; -10df_copy.iat[6, 3] &#x3D; -10# 按行赋值df_copy.loc[&#39;2022-08-03&#39;] &#x3D; [1, 0, 1, 1]# 按列赋值df_copy.loc[:, &#39;D&#39;] &#x3D; [1, 0, 1, 0, 0, 1, 1]# 按条件赋值df_copy[df_copy &lt; 0] &#x3D; -1# 新增列：直接申明 DataFrame 的新列，并将数据赋值给新列df_copy[&#39;num&#39;] &#x3D; [1, 2, 3, 4, 5, 6, 7]print(df_copy)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-排序"><a href="#2-3-排序" class="headerlink" title="2.3 排序"></a>2.3 排序</h3><p>DataFrame.<strong>sort_index</strong>(axis=0, level=None, ascending=True, inplace=False, kind=’quicksort’, na_position=’last’, sort_remaining=True, ignore_index=False, key=None)</p><ol><li>axis：排序的方向；level：配置排序索引级别；ascending：配置是否升序排列，默认升序；inplace：执行后覆盖原数据</li><li>kind：配置排序算法，有效值：’quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’，默认为 ‘quicksort’；na_position：配置控制显示位置，有效值：’first’, ‘last’，默认为’first’</li><li>ignore_index：配置排序后的索引，默认为 False，显示原索引，否则索引值为0,1,…,n-1</li></ol><p>DataFrame.<strong>sort_values</strong>(by, axis=0, ascending=True, inplace=False, kind=’quicksort’, na_position=’last’, ignore_index=False, key=None)</p><ol><li>by：排序的列名；axis：排序的方向；ascending：配置是否升序排列，默认升序；inplace：执行后覆盖原数据</li><li>kind：配置排序算法，有效值：’quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’，默认为 ‘quicksort’；na_position：配置控制显示位置，有效值：’first’, ‘last’，默认为’first’；ignore_index：配置排序后的索引，默认为 False，显示原索引，否则索引值为0,1,…,n-1</li></ol><pre class="line-numbers language-none"><code class="language-none">df_si &#x3D; df.sort_index(axis &#x3D; 1, ascending &#x3D; False)print(df_si)df_sv &#x3D; df.sort_values(&#39;A&#39;, axis &#x3D; 0, ascending &#x3D; True)print(df_sv)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import pandas as pdfile_path &#x3D; &#39;.&#x2F;Data&#x2F;pd_01_dogNames.csv&#39;df_dog &#x3D; pd.read_csv(file_path)df_dog_sort &#x3D; df_dog.sort_values(by &#x3D; &#39;Count_AnimalName&#39;, ascending &#x3D; False)print(df_dog_sort.head(10))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-运算"><a href="#2-4-运算" class="headerlink" title="2.4 运算"></a>2.4 运算</h3><h4 id="2-4-1-算术运算"><a href="#2-4-1-算术运算" class="headerlink" title="2.4.1 算术运算"></a>2.4.1 算术运算</h4><pre class="line-numbers language-none"><code class="language-none"># 算术运算import numpy as npimport pandas as pddf1 &#x3D; pd.DataFrame(np.random.randn(2, 5))df2 &#x3D; pd.DataFrame(np.random.randn(3, 4))print(&#39;df1 + df2 &#x3D; \n&#39;, df1 + df2)          # 相同位置进行计算，形状不匹配，会在缺省位置填充空值，+、-、*、&#x2F; 都一样<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-4-2-比较运算"><a href="#2-4-2-比较运算" class="headerlink" title="2.4.2 比较运算"></a>2.4.2 比较运算</h4><pre class="line-numbers language-none"><code class="language-none">print(&#39;df1 等于 df2 &#x3D; \n&#39;, df1.eq(df2))  # 相同位置进行计算，形状不匹配，会在缺省位置填充空值，不等于:ne；大于:gt；小于:lt；大于等于:ge；小于等于:le<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="2-4-3-统计"><a href="#2-4-3-统计" class="headerlink" title="2.4.3 统计"></a>2.4.3 统计</h4><pre class="line-numbers language-none"><code class="language-none">print(df1.describe(include &#x3D; &#39;all&#39;))print(df2.describe(include &#x3D; &#39;all&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>统计函数</strong></p><table><thead><tr><th>函数名</th><th>描述</th><th>函数名</th><th>描述</th></tr></thead><tbody><tr><td>min()</td><td>#最小值</td><td>sum()</td><td>#求和</td></tr><tr><td>max()</td><td>#最大值</td><td>mean()</td><td>#均值</td></tr><tr><td>idxmin()</td><td>#最小值的位置，类似于R中的which.min函数</td><td>median()</td><td>#中位数</td></tr><tr><td>idxmax()</td><td>#最大值的位置，类似于R中的which.max函数</td><td>mode()</td><td>#众数</td></tr><tr><td>count()</td><td>#非空元素计算</td><td>var()</td><td>#方差</td></tr><tr><td>abs()</td><td>#求绝对值</td><td>std()</td><td>#标准差</td></tr><tr><td>describe()</td><td>#一次性输出多个描述性统计指标</td><td>quantile(0.1)</td><td>#10%分位数</td></tr><tr><td>prod</td><td>#元素乘积</td><td>mad()</td><td>#平均绝对偏差</td></tr><tr><td>cumsum</td><td>#累计和</td><td>skew()</td><td>#偏度</td></tr><tr><td>cumprod</td><td>#累计乘积</td><td>kurt()</td><td>#峰度</td></tr></tbody></table><h3 id="2-5-操作"><a href="#2-5-操作" class="headerlink" title="2.5 操作"></a>2.5 操作</h3><h4 id="2-5-1-合并"><a href="#2-5-1-合并" class="headerlink" title="2.5.1 合并"></a>2.5.1 合并</h4><p><strong>合并</strong>：pandas.<strong>concat</strong>(objs, axis=0, join=’outer’, ignore_index=False, keys=None, levels=None, names=None, verify_integrity=False, sort=False, copy=True)</p><ol><li>objs：需要合并的数组；axis：合并的方向<ol start="2"><li>join：设置处理另一个数组的索引，有效值：’inner’, ‘outer’，默认值：’outer’；ignore_index：设置合并后的数组的索引，如果为 False，则新增的部分沿用原 DataFrame 的索引；如果为 True，则新增的部分使用合并排在前面的 DataFrame 的索引<ol start="3"><li>names：定义结果的索引名称；sort：设置是否排序；copy：设置是否允许复制</li></ol></li></ol></li></ol><pre class="line-numbers language-none"><code class="language-none">print(pd.concat([df1, df2]))<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>追加</strong>：DataFrame.<strong>append</strong>(other, ignore_index=False, verify_integrity=False, sort=False)；<strong>已弃用(1.4.0)，合并至 concat</strong></p><ol><li>other：需要追加的内容</li><li>ignore_index：设置合并后的数组是否应用原索引</li><li>sort：设置是否排序</li></ol><pre class="line-numbers language-none"><code class="language-none">df1_n1 &#x3D; df1.iloc[1]df1.append(df1_n1, ignore_index &#x3D; True)print(df1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-2-连接"><a href="#2-5-2-连接" class="headerlink" title="2.5.2 连接"></a>2.5.2 连接</h4><p>pandas.<strong>merge</strong>(left, right, how=’inner’, on=None, left_on=None, right_on=None, left_index=False, right_index=False, sort=False, suffixes=(‘_x’, ‘_y’), copy=True, indicator=False, validate=None)</p><ol><li>left、right：左右两边连接的数组；how：连接数组的方式，有效值：’left’, ‘right’, ‘outer’, ‘inner’, ‘cross’，默认值：’inner’；on：连接的字段</li><li>left_on、right_on：连接后左右同名列的新列名；left_index、right_index：设置连接后左右数组的索引是否保留</li><li>sort：设置是否排序；copy：设置是否允许复制</li></ol><p>DataFrame.<strong>join</strong>(other, on=None, how=’left’, lsuffix=’’, rsuffix=’’, sort=False)</p><ol><li>other：连接的 dadaframe 名称；on：连接的字段；how连接的方式，有效值：’left’, ‘right’, ‘outer’, ‘inner’，默认值：’left’</li><li>sort：设置是否排序</li></ol><pre class="line-numbers language-none"><code class="language-none">left  &#x3D; pd.DataFrame(&#123;&#39;key&#39;:[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], &#39;rval&#39;:[1, 2, 2]&#125;)right &#x3D; pd.DataFrame(&#123;&#39;key&#39;:[&#39;a&#39;, &#39;a&#39;, &#39;b&#39;], &#39;rval&#39;:[3, 4, 5]&#125;)df_m &#x3D; pd.merge(left, right, on &#x3D; &#39;key&#39;)print(df_m)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">df_1 &#x3D; pd.DataFrame(np.arange(4, 12).reshape(2,4), index &#x3D; list(&#39;XY&#39;), columns &#x3D; list(&#39;abcd&#39;))df_2 &#x3D; pd.DataFrame(np.arange(9).reshape(3,3), index &#x3D; list(&#39;XYZ&#39;), columns &#x3D; list(&#39;ABC&#39;))# 列名不能相同df_left &#x3D; df_1.join(df_2)df_out &#x3D; df_1.join(df_2, how &#x3D; &#39;outer&#39;)print(df_left, &#39;\n&#39;, df_out)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-3-分组"><a href="#2-5-3-分组" class="headerlink" title="2.5.3 分组"></a>2.5.3 分组</h4><p><strong>拆分</strong>：pandas.<strong>cut</strong>(x, bins, right=True, labels=None, retbins=False, precision=3, include_lowest=False, duplicates=’raise’, ordered=True)</p><ol><li>x：拆分的数据；bins：拆分的条件</li><li>labels：设置新增拆分项的取值</li></ol><pre class="line-numbers language-none"><code class="language-none">import pandas as pddf &#x3D; pd.read_excel(&#39;.&#x2F;Data&#x2F;pd_07_pandas120.xlsx&#39;)# 将salary列数据转换为最大值与最小值的平均值sa_ser &#x3D; df[&quot;salary&quot;].str.split(&quot;-&quot;)def sa_str2nu(sa_str):    if sa_str[-1] &#x3D;&#x3D; &quot;k&quot;:        sa_num &#x3D; int(sa_str[0:-1]) * 1000    elif sa_str[-1] &#x3D;&#x3D; &quot;w&quot;:        sa_num &#x3D; int(sa_str[0:-1]) * 10000    else:        sa_num &#x3D; int(sa_str)        return sa_numsa_avg &#x3D; []for i in sa_ser:    sa_min &#x3D; sa_str2nu(i[0])    sa_max &#x3D; sa_str2nu(i[1])    sa_avg.append(int((sa_max + sa_min) &#x2F; 2))sa_avg_ser &#x3D; pd.Series(sa_avg)df[&quot;salary&quot;] &#x3D; sa_avg_sergroup_names &#x3D; [&#39;低&#39;, &#39;中&#39;, &#39;高&#39;]df[&#39;categories&#39;] &#x3D; pd.cut(df[&#39;salary&#39;], bins, labels &#x3D; group_names)print(df)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分组</strong>：DataFrame.<strong>groupby</strong>(by=None, axis=0, level=None, as_index=True, sort=True, group_keys=True, squeeze=NoDefault.no_default, observed=False, dropna=True)</p><p>返回一个DataFrameGroupBy对象，元素是元组，元组内第一个数据是分组字段的取值，剩余的是分组后的 DataFrame</p><ol><li>by：分组的列；axis：分组的方向；level：分组的等级</li><li>sort：设置是否排序</li></ol><pre class="line-numbers language-none"><code class="language-none">df2[&#39;A&#39;] &#x3D; [&#39;a&#39;, &#39;a&#39;, &#39;A&#39;, &#39;A&#39;]df2[&#39;B&#39;] &#x3D; [&#39;b&#39;, &#39;B&#39;, &#39;b&#39;, &#39;B&#39;]print(df2.groupby(&#39;A&#39;).sum())print(df2.groupby([&#39;A&#39;, &#39;B&#39;]).sum())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import pandas as pdfile_path &#x3D; &#39;.&#x2F;Data&#x2F;pd_03_starbucks_store_worldwide.csv&#39;df_starbucks &#x3D; pd.read_csv(file_path)# print(df_starbucks.info())country_group &#x3D; df_starbucks.groupby(&#39;Country&#39;)    # 返回一个DataFrameGroupBy对象，元素是元组，元组内第一个数据是分组字段的取值country_count &#x3D; country_group[&#39;Brand&#39;].count()  # 得到一个Seriesprint(&#39;美国：&#39;, country_count[&#39;US&#39;], &#39;; 中国：&#39;, country_count[&#39;CN&#39;])# 统计中国每个省份的星巴克数量China_data &#x3D; df_starbucks[df_starbucks[&#39;Country&#39;] &#x3D;&#x3D; &#39;CN&#39;]province_count &#x3D; China_data.groupby(&#39;State&#x2F;Province&#39;).count()[&#39;Brand&#39;]print(province_count)# 统计中国每个省份里面每个市的星巴克数量,按照多个条件进行分组china_groups &#x3D; China_data.groupby(by&#x3D;[China_data[&#39;State&#x2F;Province&#39;],China_data[&#39;City&#39;]]).count()[&#39;Brand&#39;] #返回一个Series，有两个列索引print(china_groups)# 返回 DataFramechina_groups1 &#x3D; df_starbucks[[&#39;Brand&#39;]].groupby(by&#x3D;[df_starbucks[&#39;Country&#39;],df_starbucks[&#39;State&#x2F;Province&#39;]]).count()# china_groups2 &#x3D; df_starbucks.groupby(by&#x3D;[df_starbucks[&#39;Country&#39;],df_starbucks[&#39;State&#x2F;Province&#39;]])[[&#39;Brand&#39;]].count()# china_groups3 &#x3D; df_starbucks.groupby(by&#x3D;[df_starbucks[&#39;Country&#39;],df_starbucks[&#39;State&#x2F;Province&#39;]]).count()[[&#39;Brand&#39;]]print(china_groups1, type(china_groups1))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-5-4-数据清洗"><a href="#2-5-4-数据清洗" class="headerlink" title="2.5.4 数据清洗"></a>2.5.4 数据清洗</h4><p><strong>数据清洗</strong>：是指按照一定的规则对数据进行重新审查和校验的过程，目的在于处理异常值（包括<strong>删除重复信息、纠正错误信息、填充缺失信息</strong>等），并检查数据一致性，更多数据清洗任务查看 <a href="https://qizhongyi.gitee.io/202209/024812.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Python进阶-数据清洗</strong></font></a></p><h4 id="2-5-5-应用函数"><a href="#2-5-5-应用函数" class="headerlink" title="2.5.5 应用函数"></a>2.5.5 应用函数</h4><p>DataFrame.<strong>apply</strong>(func, axis=0, raw=False, result_type=None, args=(), **kwargs)</p><ol><li>func：对 DataFrame 进行操作的函数名称</li></ol><h3 id="2-6-数据透视表"><a href="#2-6-数据透视表" class="headerlink" title="2.6 数据透视表"></a>2.6 数据透视表</h3><p>DataFrame.<strong>pivot_table</strong>(values=None, index=None, columns=None, aggfunc=’mean’, fill_value=None, margins=False, dropna=True, margins_name=’All’, observed=False, sort=True)</p><ol><li>values：数据透视表的有效值，index：数据透视表的行索引；columns：数据透视表的列值</li><li>aggfunc：设置统计算法，有效值为统计算法对应字符串，默认为 ‘mean’；fill_value：设置填充值；margins：增加统计列</li><li>dropna：是否删除空值行；margins_name：统计列名称，默认为’All’；observed：是否翻转；sort：设置是否排序</li></ol><pre class="line-numbers language-none"><code class="language-none">import pandas as pddfp &#x3D; pd.DataFrame(&#123;&quot;A&quot;: [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] * 3,                    &quot;B&quot;: [&quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;] * 4,                    &quot;C&quot;: [&quot;True&quot;, &quot;False&quot;, &quot;True&quot;] * 4,                    &quot;D&quot;: np.random.randn(12),                    &quot;E&quot;: np.random.randn(12),                    &quot;F&quot;: np.random.randn(12)&#125;)df_p &#x3D; pd.pivot_table(dfp, values &#x3D; [&#39;D&#39;, &#39;E&#39;], index &#x3D; [&#39;A&#39;, &#39;C&#39;], columns &#x3D; &#39;B&#39;, aggfunc&#x3D;&#39;sum&#39;, fill_value &#x3D; &#39;zero&#39;, margins &#x3D; True, margins_name &#x3D; &#39;Sum&#39;)print(df_p)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-7-时间序列"><a href="#2-7-时间序列" class="headerlink" title="2.7 时间序列"></a>2.7 时间序列</h3><p>pandas.<strong>date_range</strong>(start=None, end=None, periods=None, freq=None, tz=None, normalize=False, name=None, inclusive=None, **kwargs)</p><ol><li>start、end：时间序列开始、结束时间；periods：生成时间序列的个数；freq：时间序列的时间间隔，有效值：S(秒)、T(分，min)、H(时)、D(天)、W(周)、M(月)、Q(季度)、Y(年)，可以结合数字使用，默认为 D(1天)；tz：时区</li><li>normalize：设置时间是否是午夜时间；name：时间序列的名称；inclusive：设置是否打开边界，有效值：’both’, ‘neither’, ‘left’, ‘right’，默认为：’both’</li></ol><pre class="line-numbers language-none"><code class="language-none">import pandas as pdtime &#x3D; pd.date_range(&#39;2022&#x2F;08&#x2F;08 16:04&#39;, periods &#x3D; 10, freq &#x3D; &#39;-10min&#39;)time &#x3D; time.tz_localize(&#39;UTC&#39;)            # 设置本地时区，tz &#x3D; &#39;Asia&#x2F;Shanghai&#39;time &#x3D; time.tz_convert(&#39;Asia&#x2F;Shanghai&#39;)   # 更改时区print(time)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>时间代码</th><th>英文描述</th><th>时间描述</th></tr></thead><tbody><tr><td><strong>B</strong></td><td>business day frequency</td><td>工作日频率</td></tr><tr><td>C</td><td>custom business day frequency</td><td>自定义工作日频率</td></tr><tr><td><strong>D</strong></td><td>calendar day frequency</td><td>日历日频率（1天）</td></tr><tr><td>W</td><td>weekly frequency</td><td>每周频率</td></tr><tr><td><strong>M</strong></td><td>month end frequency</td><td>月末频率（返回当月月末日期）</td></tr><tr><td>SM</td><td>semi-month end frequency (15th and end of month)</td><td>半月结束频率（15日和月末）</td></tr><tr><td>BM</td><td>business month end frequency</td><td>营业月结束频率</td></tr><tr><td>CBM</td><td>custom business month end frequency</td><td>自定义营业月结束频率</td></tr><tr><td><strong>MS</strong></td><td>month start frequency</td><td>月开始频率（返回当月1号）</td></tr><tr><td>SMS</td><td>semi-month start frequency (1st and 15th)</td><td>半月开始频率（第1天和第15天）</td></tr><tr><td>BMS</td><td>business month start frequency</td><td>营业月开始频率</td></tr><tr><td>CBMS</td><td>custom business month start frequency</td><td>自定义营业月开始频率</td></tr><tr><td><strong>Q</strong></td><td>quarter end frequency</td><td>四分之一结束频率（季度）</td></tr><tr><td>BQ</td><td>business quarter end frequency</td><td>业务季度结束频率</td></tr><tr><td>QS</td><td>quarter start frequency</td><td>季度开始频率</td></tr><tr><td>BQS</td><td>business quarter start frequency</td><td>业务季开始频率</td></tr><tr><td><strong>A, Y</strong></td><td>year end frequency</td><td>年终频率</td></tr><tr><td>BA, BY</td><td>business year end frequency</td><td>业务年度结束频率</td></tr><tr><td>AS, YS</td><td>year start frequency</td><td>年开始频率</td></tr><tr><td>BAS, BYS</td><td>business year start frequency</td><td>营业年度开始频率</td></tr><tr><td>BH</td><td>business hour frequency</td><td>营业时间频率</td></tr><tr><td><strong>H</strong></td><td>hourly frequency</td><td>每小时频率</td></tr><tr><td><strong>T, min</strong></td><td>minutely frequency</td><td>分钟的频率</td></tr><tr><td><strong>S</strong></td><td>secondly frequency</td><td>秒钟的频率</td></tr><tr><td><strong>L, ms</strong></td><td>milliseconds</td><td>毫秒</td></tr><tr><td><strong>U, us</strong></td><td>microseconds</td><td>微秒</td></tr><tr><td><strong>N</strong></td><td>nanoseconds</td><td>纳秒</td></tr></tbody></table><p><strong>注</strong>：时间代码可配合数量申明时间间隔，如：5D(5天)、3Y(3年)</p><h4 id="2-7-1-时间转化"><a href="#2-7-1-时间转化" class="headerlink" title="2.7.1 时间转化"></a>2.7.1 时间转化</h4><p>pandas.<strong>to_datetime</strong>(arg, errors=’raise’, dayfirst=False, yearfirst=False, utc=None, format=None, exact=True, unit=None, infer_datetime_format=False, origin=’unix’, cache=True)，将字符串转化成时间日期类型</p><ol><li>arg：需要转换的时间；errors：对待转换错误的方式，有效值：’ignore’（忽略，返回传入的字符串）, ‘raise’（抛出一个错误）, ‘coerce’（将报错的数据设为 <strong>NaT</strong>），默认值：’raise’；dayfirst、yearfirst：是否日 / 年在前</li><li>utc：转换的时区；format：转化的格式，具体见 <a href="https://qizhongyi.gitee.io/202206/2736392.html"><font face = "微软雅黑" color = 1E90FF size = 5>时间格式化</font></a></li></ol><pre class="line-numbers language-none"><code class="language-none">import pandas as pdfile_path &#x3D; &#39;.&#x2F;Data&#x2F;pd_05_911.csv&#39;df_911 &#x3D; pd.read_csv(file_path, encoding &#x3D; &quot;GBK&quot;)df_911[&#39;timeStamp&#39;] &#x3D; pd.to_datetime(df_911[&#39;timeStamp&#39;], format &#x3D; &quot;%Y-%m-%d %H:%M:%S&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-2-重采样"><a href="#2-7-2-重采样" class="headerlink" title="2.7.2 重采样"></a>2.7.2 重采样</h4><p><strong>重采样</strong>：指的是将时间序列从一个频率转化为另一个频率进行处理的过程，将高频率数据转化为低频率数据为<strong>降采样</strong>，低频率转化为高频率为<strong>升采样</strong></p><p>DataFrame.<strong>resample</strong>(rule, axis=0, closed=None, label=None, convention=’start’, kind=None, loffset=None, base=None, on=None, level=None, origin=’start_day’, offset=None)</p><ol><li>rule：转换的规则；axis：转换的方向；closed：关闭的方向，有效值：’right’, ‘left’</li></ol><pre class="line-numbers language-none"><code class="language-none"># 统计每个月、每个季度的报警次数import matplotlibdf_911.set_index(&#39;timeStamp&#39;, drop &#x3D; False, inplace &#x3D; True)df_month_count &#x3D; df_911.resample(&#39;M&#39;).count()[[&#39;title&#39;]]df_quarter_count &#x3D; df_911.resample(&#39;Q&#39;).count()[[&#39;title&#39;]]plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)plt.subplot(1, 2, 1)plt.plot(df_month_count.index, df_month_count[&#39;title&#39;])plt.xlabel(&#39;Month&#39;)plt.xticks(rotation &#x3D; 45)plt.grid()plt.subplot(1, 2, 2)plt.plot(df_quarter_count.index, df_quarter_count[&#39;title&#39;], marker &#x3D; &#39;^&#39;)plt.xlabel(&#39;Quarter&#39;)plt.xticks(rotation &#x3D; 45)plt.grid()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-7-3-时间索引"><a href="#2-7-3-时间索引" class="headerlink" title="2.7.3 时间索引"></a>2.7.3 时间索引</h4><p>pandas.<strong>PeriodIndex</strong>(data=None, ordinal=None, freq=None, dtype=None, copy=False, name=None, **fields)</p><ol><li>data：转换成时间段的时间字段；freq：时间区间；dtype：数据类型；copy：是否复制</li></ol><h2 id="3-数据I-O"><a href="#3-数据I-O" class="headerlink" title="3. 数据I/O"></a>3. 数据I/O</h2><ul><li><p><strong>CSV</strong>：Comma-Separated Value，逗号分隔值文件</p><p>pandas.<strong>read_csv</strong>(filepath_or_buffer, sep=NoDefault.no_default, delimiter=None, header=’infer’, names=NoDefault.no_default, index_col=None, usecols=None, squeeze=None, prefix=NoDefault.no_default, mangle_dupe_cols=True, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False, skiprows=None, skipfooter=0, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=None, infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, cache_dates=True, iterator=False, chunksize=None, compression=’infer’, thousands=None, decimal=’.’, lineterminator=None, quotechar=’”‘, quoting=0, doublequote=True, escapechar=None, comment=None, encoding=None, encoding_errors=’strict’, dialect=None, error_bad_lines=None, warn_bad_lines=None, on_bad_lines=None, delim_whitespace=False, low_memory=True, memory_map=False, float_precision=None, storage_options=None)</p></li></ul><ol><li>filepath_or_buffer：打开的文件路径和文件名；usecols：选择的数据列，传入列名列表；nrows：选择的记录行数，传入整数行数</li><li>converters：可根据后面的表达式重设数据</li></ol><pre class="line-numbers language-none"><code class="language-none"># CSV：文件较小df.to_csv(&#39;.&#x2F;03-df.csv&#39;)               # 导出df_csv &#x3D; pd.read_csv(&#39;.&#x2F;03-df.csv&#39;, encoding &#x3D; &#39;gbk&#39;, usecols &#x3D; [&#39;A&#39;, &#39;C&#39;], nrows &#x3D; 5)print(df_csv)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>HDF5</strong></li></ul><pre class="line-numbers language-none"><code class="language-none"># HDF5：会自动指定indexdf.to_hdf(&#39;.&#x2F;03-df.h5&#39;, &#39;df&#39;)               # 导出，文件名、table 名df_hdf &#x3D; pd.read_hdf(&#39;.&#x2F;03-df.h5&#39;, &#39;df&#39;)    # 导入print(df_hdf)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>Excel</strong></li></ul><pre class="line-numbers language-none"><code class="language-none"># Exceldf.to_excel(&#39;.&#x2F;03-df.xlsx&#39;, sheet_name &#x3D; &#39;df&#39;)   # 导出df_xlsx &#x3D; pd.read_excel(&#39;.&#x2F;03-df.xlsx&#39;, &#39;df&#39;)    # 导入print(df_xlsx)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>MySQL</strong>：需要先安装 MySQL 支持模块 <strong>pymysql</strong> (cmd 下运行 pip install pymysql) 或者 <strong>sqlalchemy</strong> (cmd 下运行 pip install sqlalchemy ，推荐)</p><p>pandas.<strong>read_sql</strong>(sql, con, index_col = None, coerce_float = True, params = None, parse_dates = None, columns = None, chunksize =  None)</p><ol><li>sql：运行的 SQL语句；con：数据库连接语句</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">import pandas as pdimport pymysqlfrom sqlalchemy import create_engine# 创建数据库连接对象t_user &#x3D; &#39;root&#39;        # 数据库用户名t_password &#x3D; &#39;123456&#39;  # 数据库密码t_host &#x3D; &#39;localhost&#39;   # 数据库ip地址, 127.0.0.1t_port &#x3D; 3306          # 端口号t_database &#x3D; &quot;world&quot;   # 数据库sql &#x3D; &#39;select * from tennis&#39;# pymysqlmysql_conn &#x3D; pymysql.connect(host &#x3D; t_host, port &#x3D; t_port, user &#x3D; t_user, password &#x3D; t_password, database &#x3D; t_database)# sqlalchemyengine &#x3D; create_engine(f&#39;mysql+pymysql:&#x2F;&#x2F;&#123;t_user&#125;:&#123;t_password&#125;@&#123;t_host&#125;:&#123;t_port&#125;&#x2F;&#123;t_database&#125;&#39;, echo&#x3D;True)data &#x3D; pd.read_sql(sql &#x3D; sql, con &#x3D; mysql_conn)    # data &#x3D; pd.read_sql(sql &#x3D; sql, con &#x3D; engine)data<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块-NumPy</title>
      <link href="/202207/2960256.html"/>
      <url>/202207/2960256.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python模块-NumPy-的基础知识</p><span id="more"></span><h1 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h1><p><strong>NumPy</strong>：Numerical Python 的简称，是 Python 科学计算的基础作为在算法和库之间传递数据的容器；对于数值型数据（仅能处理数值型数据），NumPy数组在存储和处理数据时要比内置的Python数据结构高效；支持大量的维度数组与矩阵运算，针对数组运算提供大量的数学函数库，比 Python 本身的列表访问速度快；<a href="https://github.com/numpy/numpy"><font face = "微软雅黑" color = 1E90FF size = 5>Github网址</font></a>， <a href="http://www.numpy.org/"><font face = "微软雅黑" color = 1E90FF size = 5>NumPy官网</font></a></p><p><strong>核心功能点</strong>：提供高性能的矩阵运算</p><ul><li>快速⾼效的多维数组对象ndarray和矩阵(numpy.matlib)；</li><li>⽤于对数组执行元素级计算以及直接对数组执行数学运算的函数，包括：线性代数(numpy.linalg)、离散傅里叶变换(numpy.fft)、随机数生成(numpy.random)等；</li><li>成熟的C-Types外部函数接口(numpy.ctypeslib)， ⽤于Python插件和原⽣C、C++、Fortran代码访问NumPy的数据结构和计算⼯具</li></ul><p><strong>其他功能点</strong></p><ol><li>便捷的数组创建和操作，包括数据类型、字符串操作、浮点错误处理、时间日期支持、二元运算、多项式运算、数组填充、黑箱数组操作(Masked array operations)等；</li><li>多样的数学函数，支持函数式编程，包括自动定义域的数学函数、逻辑函数、窗口函数；</li><li>排序、搜索和计数、统计；</li><li>I/O编程；</li><li>Scipy加速例程(numpy.dual)；</li><li>其他，帮助等</li></ol><p><strong>安装</strong>：pip3/pip install numpy </p><p><strong>导入</strong>：import numpy ； 验证：print(numpy.__version__)</p><h1 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h1><p><strong>ndarray对象</strong>：是用于存放同类型元素的多维数组对象，以 0 下标为开始进行集合中元素的索引；每个元素在内存中都有相同存储大小的区域，存储在内存中的一个连续的位置；通过 <strong>numpy.array()</strong> 函数生成一个ndarray对象，结构如下：</p><ul><li>一个指向数据（内存或内存映射文件中的一块数据）的指针；</li><li>数据类型或 dtype，描述在数组中的固定大小值的格子；</li><li>一个表示数组形状（shape）的元组，表示各维度大小的元组；</li><li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要”跨过”的字节数</li></ul><p><strong>numpy.array()</strong> ：numpy.array(object, dtype=None, *, copy=True, order=’K’, subok=False, ndmin=0, like=None)，返回一个 ndarray对象</p><ol><li>object：可以传入序列型的对象，包括数组或嵌套的数列等</li><li>dtype：data-type，数组元素的数据类型</li><li>copy：对象是否需要复制，默认为 True</li><li>order：创建数组的样式，有效值：’K’, ‘A’, ‘C’(行方向), ‘F’(列方向)，默认为’K’(任意方向)</li><li>subok：是否返回一个与基类类型一致的数组</li><li>ndmin：指定生成数组的维度</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as np# 使用 array()、arange() 生成数组，得到 ndarray 类型的实例化对象arr &#x3D; np.array([1, 2, 3])arr_ar &#x3D; np.arange(10)print(arr, type(arr), arr_ar, type(arr_ar))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h2><p>查看数据类型：print(arr_name.dtype)</p><ol><li>i：表示整数(integer)；u表示无符号整数</li><li>f：表示浮点数(float)；c表示复合浮点数</li><li>complex：表示复数</li><li>S：表示字符串(string)，通过引号包括；U表示unicode字符串</li><li>b：表示布尔值(boolean) True 或者 False</li><li>M：表示时间 datetime；m表示时间区间 timedelta</li></ol><table><thead><tr><th>类型</th><th>类型代码</th><th>说明</th></tr></thead><tbody><tr><td>int8，uint8</td><td>i8，u8</td><td>有（无）符号的8位（1个字节）整型</td></tr><tr><td>int16，uint16</td><td>i2，u2</td><td>有（无）符号的16位（2个字节）整型</td></tr><tr><td>int32，uint32</td><td>i4，u4</td><td>有（无）符号的32位（4个字节）整型</td></tr><tr><td>int64，uint64</td><td>i8，u8</td><td>有（无）符号的64位（8个字节）整型</td></tr><tr><td>float16</td><td>f2</td><td>半精度浮点数</td></tr><tr><td>float32</td><td>f4或f</td><td>标准的单精度浮点数，与C的float兼容</td></tr><tr><td>float64</td><td>f8或d</td><td>标准的双精度浮点数，与C的double和Python的float兼容</td></tr><tr><td>float128</td><td>f16或g</td><td>扩展精度浮点数</td></tr><tr><td>complex64、complex128、complex128</td><td>c8、c16、c32</td><td>用两个32位（64位、128位）表示复数</td></tr><tr><td>bool</td><td>?</td><td>存储True、False的布尔类型</td></tr><tr><td>str</td><td>u2</td><td>存储字符串</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.arange(24).reshape((4,6))print(arr, arr.dtype)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-数据类型转换"><a href="#1-1-数据类型转换" class="headerlink" title="1.1 数据类型转换"></a>1.1 数据类型转换</h3><p>new_arr_name = old_arr_name.astype(d_type) ；d_type：传入上述数据类型或类型代码对应的字符串</p><pre class="line-numbers language-none"><code class="language-none">arr_a &#x3D; arr.astype(&#39;float&#39;)print(arr_a, arr_a.dtype)# 如果将浮点数转换成整数，则⼩数部分将会被截取删除<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-数组形状"><a href="#2-数组形状" class="headerlink" title="2. 数组形状"></a>2. 数组形状</h2><p><strong>数组形状</strong>：表示数组每个维度中元素的数量</p><p><strong>查看数组形状</strong>：print(arr_name.ndim)</p><ol><li>0-D：0维数据，就只有一个数据</li><li>1-D：1维数据，其元素为 0-D数据</li><li>2-D：2维数据，其元素为 1-D数据</li><li>3-D：3维数据，其元素为 2-D数据</li></ol><p><strong>设置数组形状</strong>：通过 ndmin 关键字设置</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([1, 2, 3], ndmin &#x3D; 3)print(arr, arr.ndim, arr.shape)    # shape属性：返回一个元组，每一维具有的元素数量，元组数据个数表示数组维度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-数组重塑"><a href="#2-1-数组重塑" class="headerlink" title="2.1 数组重塑"></a>2.1 数组重塑</h3><p><strong>数组重塑</strong>：改变数组的形状，要求重塑的元素数正好符合设置的形状元组(不可缺少)，只要元素个数符合要求，可以实现 1D、2D、3D 之间的相互转换；返回一个视图</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([1, 2, 3, 4, 5, 6])# 1D -&gt; 2Darr_rs2 &#x3D; arr.reshape(2, 3)# 2D -&gt; 3Darr_rs3 &#x3D; arr.reshape(3, 2, 1)# arr_rs3 &#x3D; arr.reshape(3, 2, -1)       # 可以传入 -1，代表未知的维，由 NumPy 计算print(arr, &#39;\n&#39;, arr_rs2, &#39;\n&#39;, arr_rs3)arr[0] &#x3D; 7print(arr, &#39;\n&#39;, arr_rs2, &#39;\n&#39;, arr_rs3)print(arr.shape, arr_rs2.shape, arr_rs3.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-展平数组"><a href="#2-2-展平数组" class="headerlink" title="2.2 展平数组"></a>2.2 展平数组</h3><p><strong>展平数组</strong>：将多维数组转换成 1D 数组，通过 reshape(-1) 或 flatten() 实现</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([[1, 2], [3, 4], [5, 6]])arr_rs1 &#x3D; arr.reshape(-1)# arr_rs1 &#x3D; arr.reshape(6,)    # 值传入一个数字，(6, 1)、(1, 6) 都会返回二维数组arr_f &#x3D; arr.flatten()print(arr, &#39;\n&#39;, arr_rs1,  &#39;\n&#39;, arr_f)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-转置"><a href="#2-3-转置" class="headerlink" title="2.3 转置"></a>2.3 转置</h3><p><strong>转置</strong>：在对角线方向交换数据位置，通过 transpose() 实现</p><p>ndarray.<strong>transpose</strong>(*axes)</p><p>numpy.<strong>transpose</strong>(a, axes=None)</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([[1, 2], [3, 4], [5, 6]])arr_t &#x3D; arr.transpose()arr_nt &#x3D; np.transpose(arr)arr_T &#x3D; arr.T     # T 为转置属性print(arr.shape, arr_t.shape, arr_nt.shape, arr_T.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>换轴</strong>：</p><p>ndarray.<strong>swapaxes</strong>(axis1, axis2)</p><p>numpy.<strong>swapaxes</strong>(a, axis1, axis2)</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([[1, 2], [3, 4], [5, 6]])arr_s &#x3D; arr.swapaxes(1, 0)arr_ns &#x3D; np.swapaxes(arr, 1, 0)print(arr.shape, arr_s.shape, arr_ns.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-轴-axis"><a href="#2-4-轴-axis" class="headerlink" title="2.4 轴-axis"></a>2.4 轴-axis</h3><p>轴-axis：可以理解为数组的方向，用数字 0, 1, 2, … 表示；对于一位数组，只有一个方向 0-轴；对于二维数组，有两个方向 0-轴（在行上竖向计算，结果数量与列数相同），1-轴（在列上横向运算、结果数量与行数相同）；对于三维数组，有三个方向 0-轴（块运算，结果数量与块数相同），1-轴（在行上竖向计算，结果数量与列数相同），2-轴（在列上横向运算、结果数量与行数相同）</p><p><img src="https://qizhongyi.gitee.io/images/Python/Axis.png" alt="Axis"></p><h2 id="3-数组操作"><a href="#3-数组操作" class="headerlink" title="3. 数组操作"></a>3. 数组操作</h2><h3 id="3-1-读取"><a href="#3-1-读取" class="headerlink" title="3.1 读取"></a>3.1 读取</h3><p>通过数组索引进行访问，索引从 0 开始；支持负索引和布尔索引；支持切片；<strong>读取后赋值则实现数组值的修改</strong></p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.arange(28).reshape((4,7))# 取多行arr_idx &#x3D; arr[0:-1:2]     # [start, stop, step]，[开始，结束)，步长# 取多列arr_col &#x3D; arr[:, 0:-1:2]  # 只取一行，会变成一维数组# 取相邻的多行多列arr_adj &#x3D; arr[1:3, 0:4]# 取不相邻的多行多列arr_uadj_a &#x3D; arr[0:-1:2, 0:-1:2]arr_uadj_b &#x3D; arr[[0, 2, 3], [0, 2, 2]]print(arr, &#39;\n&#39;, arr_idx, &#39;\n&#39;, arr_col, &#39;\n&#39;, arr_adj, &#39;\n&#39;, arr_uadj_a, &#39;\n&#39;, arr_uadj_b)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 布尔索引arr_b &#x3D; arr[ arr &lt; 5]# arr_w &#x3D; arr.where(arr &lt; 5, arr, 5)   # 已取消，1.23.1arr_p &#x3D; arr.clip(8, 18)print(arr, &#39;\n&#39;, arr_b, &#39;\n&#39;, arr_p)# np.where(df.secondType &#x3D;&#x3D; df.thirdType)    # 查找secondType与thirdType值相等的行号：secondType, thirdType 是列名# np.argwhere(df[&#39;salary&#39;] &gt; df[&#39;salary&#39;].mean())[2]  # 查找薪资大于平均薪资的第三个数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-迭代"><a href="#3-2-迭代" class="headerlink" title="3.2 迭代"></a>3.2 迭代</h3><p><strong>迭代</strong>：逐一遍历数组元素</p><ul><li><p>numpy.<strong>nditer</strong>(op, flags=None, op_flags=None, op_dtypes=None, order=’K’, casting=’safe’, op_axes=None, itershape=None, buffersize=0)</p><ol><li>op：需要迭代的数组</li><li>flags、op_flags：迭代的一系列选项</li><li>op_dtypes：设置迭代数据类型，有效值同数组数据类型</li><li>order：设置迭代顺序，有效值：’C’, ‘F’, ‘A’, ‘K’；casting：控制在复制或缓存时可能发生的数据类型转换，有效值：’no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none"># nditerimport numpy as nparr &#x3D; np.array([[[1], [2]], [[3], [4]], [[5], [6]]])# for i in arr:             # 每次只遍历最近的维，可以设置步长#     for j in i:#         for k in j:#             print(j)for i in np.nditer(arr, flags &#x3D; [&#39;buffered&#39;], op_dtypes &#x3D; &#39;S&#39;):   # nditer()可以一次性迭代至 0D 数据    print(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>numpy.<strong>ndenumerate</strong>(arr)：枚举迭代，返回索引和数值</li></ul><pre class="line-numbers language-none"><code class="language-none"># ndenumerateimport numpy as nparr &#x3D; np.array([[[1], [2]], [[3], [4]], [[5], [6]]])for idx, i in np.ndenumerate(arr):    print(idx, i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-副本和视图"><a href="#3-3-副本和视图" class="headerlink" title="3.3 副本和视图"></a>3.3 副本和视图</h3><p><strong>副本</strong>：副本是一个新数组，拥有数据；原始数据更改不会影响副本；通过 arr_name.copy() 实现，参数 order 有效值：’C’, ‘F’, ‘A’, ‘K’</p><p><strong>视图</strong>：指针指向原始数组，不拥有数据；原始数据更改都会影响副本；通过 arr_name.view() 实现，参数 dtype 数据类型，type：有效值：ndarray、matrix</p><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([1, 2, 3])arr_c &#x3D; arr.copy()arr_v &#x3D; arr.view(type &#x3D; np.matrix)arr[0] &#x3D; 4print(arr_c, arr_v)print(arr.base, arr_c.base, arr_v.base)   # base属性：若数组拥有数据，则返回 None；否则返回引用的原始对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-连接"><a href="#3-4-连接" class="headerlink" title="3.4 连接"></a>3.4 连接</h3><p><strong>连接</strong>：将两个或多个数组的内容存放在同一个数组中</p><ul><li><p>numpy.<strong>concatenate</strong>((a1, a2, …), axis=0, out=None, dtype=None, casting=”same_kind”)</p><ol><li>(a1, a2, …)：需要连接的数组名称，需要保留()</li><li>axis：设置连接的轴，默认为0(竖向)</li><li>out：设置输出的数组形状</li><li>dtype：数据类型</li><li>casting：控制可能发生的数据类型转换，有效值：’no’, ‘equiv’, ‘safe’, ‘same_kind’, ‘unsafe’<pre class="line-numbers language-none"><code class="language-none"># concatenateimport numpy as nparr_1 &#x3D; np.array([[1, 2], [3, 4]])arr_2 &#x3D; np.array([[5, 6], [7, 8]])arr_a0 &#x3D; np.concatenate((arr_1, arr_2), axis &#x3D; 0)    # 竖向arr_a1 &#x3D; np.concatenate((arr_1, arr_2), axis &#x3D; 1)    # 横向print(arr_a0, &#39;\n&#39;, arr_a1)print(arr_a0.shape, arr_a1.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p>numpy.<strong>stack</strong>(arrays, axis=0, out=None)，会增加数据的维</p></li><li><p>numpy.<strong>hstack</strong>(tup)、numpy.<strong>vstack</strong>(tup)、numpy.<strong>dstack</strong>(tup)：tup：需要连接的数组名称，组合后再增加维</p><ol><li>arrays：需要连接的数组名称</li><li>axis：设置连接的轴，默认为0</li><li>out：设置输出的数组形状</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none"># stack、hstack（横向）、vstack（竖向）、dstack（深度，相同位置）import numpy as nparr_1 &#x3D; np.array([[1, 2], [3, 4]])arr_2 &#x3D; np.array([[5, 6], [7, 8]])arr_a0 &#x3D; np.stack((arr_1, arr_2), axis &#x3D; 0)    # 竖向arr_a1 &#x3D; np.stack((arr_1, arr_2), axis &#x3D; 1)    # 横向print(arr_a0, &#39;\n&#39;, arr_a1)print(arr_a0.shape, arr_a1.shape)arr_h &#x3D; np.hstack((arr_1, arr_2))arr_v &#x3D; np.vstack((arr_1, arr_2))arr_d &#x3D; np.dstack((arr_1, arr_2))print(arr_h, &#39;\n&#39;, arr_v, &#39;\n&#39;, arr_d)print(arr_h.shape, arr_v.shape, arr_d.shape)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-5-拆分"><a href="#3-5-拆分" class="headerlink" title="3.5 拆分"></a>3.5 拆分</h3><p><strong>拆分</strong>：讲一个数组拆分成多个数组</p><p>numpy.<strong>split</strong>(ary, indices_or_sections, axis=0)</p><p>numpy.<strong>hsplit</strong>(ary, indices_or_sections)、numpy.<strong>vsplit</strong>(ary, indices_or_sections)</p><p>numpy.<strong>array_split</strong>(ary, indices_or_sections, axis=0)</p><ol><li>ary：需要拆分的数组名称</li><li>indices_or_sections：拆分的数量</li><li>axis：拆分的轴</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([1, 2, 3, 4, 5, 6])arr_s &#x3D; np.split(arr, 3)          # 返回一个列表，元素为拆分得到的数组# arr_s &#x3D; np.split(arr, 4)        # 不能正好均分时，会报错:array split does not result in an equal divisionarr_as &#x3D; np.array_split(arr, 4)   # 不能正好均分时，也会拆分成指定数量个数组，返回[array([1, 2]), array([3, 4]), array([5]), array([6])]print(arr_s, arr_as)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 拆分二维数组import numpy as nparr &#x3D; np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])arr_as &#x3D; np.array_split(arr, 3)   # 仅对第一维进行拆分arr_h &#x3D; np.hsplit(arr, 3)arr_v &#x3D; np.vsplit(arr, 2)         # 健在多维数组时可用print(arr_as, arr_h, arr_v)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-6-排序"><a href="#3-6-排序" class="headerlink" title="3.6 排序"></a>3.6 排序</h3><p><strong>排序</strong>：对数组元素按照某一个顺序进行排列</p><p>numpy.<strong>sort</strong>(a, axis=- 1, kind=None, order=None)</p><ol><li>a：需要排序的数组</li><li>axis：排序的方向</li><li>kind：设置排序的算法，有效值：’quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’；order：指定结构化数组排序时使用的字段</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([1, 6, 7, 2, 5, 8, 3, 4, 10])arr_s &#x3D; np.sort(arr, axis &#x3D; 0, kind &#x3D; &#39;quicksort&#39;)print(arr_s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-7-搜索"><a href="#3-7-搜索" class="headerlink" title="3.7 搜索"></a>3.7 搜索</h3><p><strong>搜索</strong>：在数组中搜索某个值，返回匹配的索引值</p><p>numpy.<strong>where</strong>(condition, [x, y, ]/)</p><ol><li>condition：查询条件</li><li>[x, y, ]：设置展示的数据，满足条件展示 x，否则展示 y</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([1, 2, 3, 4, 5, 6])result &#x3D; np.where(arr % 2 &#x3D;&#x3D; 0)     # 多个匹配时，返回元组(满足条件的索引数组, 数据类型)result_x &#x3D; np.where(arr % 2 &#x3D;&#x3D; 0, arr, arr * 2)print(result, &#39;\n&#39;, type(result), &#39;\n&#39;, result_x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>numpy.<strong>searchsorted</strong>(a, v, side=’left’, sorter=None)</p><ol><li>a：搜索的数组；v：搜索的数值</li><li>side：搜索的方向，有效值：’left’, ‘right’，默认为 ‘left’</li></ol><pre class="line-numbers language-none"><code class="language-none"># searchsortedimport numpy as nparr &#x3D; np.array([1, 2, 3, 4, 5, 6])result_l &#x3D; np.searchsorted(arr, 3)result_r &#x3D; np.searchsorted(arr, 3, side &#x3D; &#39;right&#39;)print(result_l, result_r)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-数组运算"><a href="#4-数组运算" class="headerlink" title="4. 数组运算"></a>4. 数组运算</h2><p>数组运算通过 <strong>广播机制</strong> 实现，即数组的每一个数据都进行相同的操作；不⽤编写循环即可对数据执⾏批量运算</p><p><strong>广播机制</strong>：后缘维度（从末尾开始算起的维度）和轴长度相符或其中一方的长度为1，则认为广播兼容；关闭会在缺失和/或长度为1的维度进行（例：shape为(3, 3, 2) 不能和 (3, 3) 进行计算，只能和(3, 2) 进行计算）</p><h3 id="4-1-数组相加减乘除"><a href="#4-1-数组相加减乘除" class="headerlink" title="4.1 数组相加减乘除"></a>4.1 数组相加减乘除</h3><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr_1 &#x3D; np.array([1, 2, 3, 4, 3, 4, 5, 6])arr_2 &#x3D; np.array([4, 5, 6, 7, 8, 9, 10, 11])arr_a &#x3D; arr_1 + 2arr_r &#x3D; arr_1 - 2arr_m &#x3D; arr_1 * 2# 除以 0 不会报错，返回 inf（无限）print(arr_a, &#39;\n&#39;, arr_r, &#39;\n&#39;, arr_m)# 数组相加减时要求具有相同的行数或相同的列数arrs_a &#x3D; arr_1 + arr_2arrs_r &#x3D; arr_1 - arr_2arrs_m &#x3D; arr_1 * arr_2print(arrs_a, &#39;\n&#39;, arrs_r, &#39;\n&#39;, arrs_m)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-2-数组函数加乘"><a href="#4-2-数组函数加乘" class="headerlink" title="4.2 数组函数加乘"></a>4.2 数组函数加乘</h3><p>numpy.<strong>sum</strong>(a, axis=None, dtype=None, out=None, keepdims=&lt; no value&gt;, initial=&lt; no value&gt;, where=&lt; no value&gt;)</p><ol><li>a：需要相加的数组，可传入数组列表；axis：相加的方向，0行上竖向，1列上横向，省略则全部相加；dtype：数组的数据类型</li><li>out：输出的数组</li></ol><p><strong>累加</strong>：numpy.<strong>cumsum</strong>(a, axis=None, dtype=None, out=None)</p><ol><li>a：需要相加的数组，可传入数组列表；axis：相加的方向，0行上竖向，1列上横向，省略则全部相加；dtype：数组的数据类型</li><li>out：输出的数组</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr_1 &#x3D; np.array([1, 2, 3, 4, 5])arr_2 &#x3D; np.array([6, 7, 8, 9, 10])arr_s &#x3D; np.sum([arr_1, arr_2])arr_s0 &#x3D; np.sum([arr_1, arr_2], axis &#x3D; 0)arr_s1 &#x3D; np.sum([arr_1, arr_2], axis &#x3D; 1)print(arr_s, &#39;\n&#39;, arr_s0, &#39;\n&#39;, arr_s1)arr_cs &#x3D; np.cumsum([arr_1, arr_2])arr_cs0 &#x3D; np.cumsum([arr_1, arr_2], axis &#x3D; 0)arr_cs1 &#x3D; np.cumsum([arr_1, arr_2], axis &#x3D; 1)print(arr_cs, &#39;\n&#39;, arr_cs0, &#39;\n&#39;, arr_cs1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>numpy.<strong>prod</strong>(a, axis=None, dtype=None, out=None, keepdims=&lt; no value&gt;, initial=&lt; no value&gt;, where=&lt; no value&gt;)</p><ol><li>a：需要相乘的数组，可传入数组列表；axis：相乘的方向，0行上竖向，1列上横向，省略则全部相乘；dtype：数组的数据类型</li><li>out：输出的数组</li></ol><p><strong>累乘</strong>：numpy.<strong>cumprod</strong>(a, axis=None, dtype=None, out=None)</p><ol><li>a：需要相乘的数组，可传入数组列表；axis：相乘的方向，0行上竖向，1列上横向，省略则全部相乘；dtype：数组的数据类型</li><li>out：输出的数组</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr_1 &#x3D; np.array([1, 2, 3, 4, 5])arr_2 &#x3D; np.array([6, 7, 8, 9, 10])arr_p &#x3D; np.prod([arr_1, arr_2])arr_p0 &#x3D; np.prod([arr_1, arr_2], axis &#x3D; 0)arr_p1 &#x3D; np.prod([arr_1, arr_2], axis &#x3D; 1)print(arr_p, &#39;\n&#39;, arr_p0, &#39;\n&#39;, arr_p1)arr_cp &#x3D; np.cumprod([arr_1, arr_2])arr_cp0 &#x3D; np.cumprod([arr_1, arr_2], axis &#x3D; 0)arr_cp1 &#x3D; np.cumprod([arr_1, arr_2], axis &#x3D; 1)print(arr_cp, &#39;\n&#39;, arr_cp0, &#39;\n&#39;, arr_cp1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3-nan-与-inf"><a href="#4-3-nan-与-inf" class="headerlink" title="4.3 nan 与 inf"></a>4.3 nan 与 inf</h3><p><strong>nan</strong>：not a number，表示不是一个数字，浮点类型数据；读取数据时如果出现缺失，会出现 nan；或者进行不合适的运算</p><ul><li>np.nan != np.nan 两个 nan 不相等</li><li>nan 和任何数值计算都为 nan</li></ul><p><strong>inf</strong>：infinity(无穷)，表示正无穷，-inf 表示负无穷，浮点类型数据；一个数字除以0时，numpy 不会报错，结果返回 inf</p><pre class="line-numbers language-none"><code class="language-none">import numpy as npimport pandas as pddf &#x3D; pd.DataFrame(np.random.randint(1, 20, size &#x3D; (4, 6)))df[df &lt; 10] &#x3D; np.nanarr &#x3D; np.array(df[0])# 判断空值 nan# numpy.isnan(x, &#x2F;, out&#x3D;None, *, where&#x3D;True, casting&#x3D;&#39;same_kind&#39;, order&#x3D;&#39;K&#39;, dtype&#x3D;None, subok&#x3D;True[, signature, extobj]); 是一个ufunc，判断是否为 np.nan，返回与原 ndarray 同形状的布尔数组np.isnan(arr)   # 返回与 arr 相同形状的布尔数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更多内容查看  <a href="https://qizhongyi.gitee.io/202209/024812.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Python进阶-数据清洗</strong></font></a> 中的 <strong>缺失值</strong> 部分</p><h3 id="4-4-统计函数"><a href="#4-4-统计函数" class="headerlink" title="4.4 统计函数"></a>4.4 统计函数</h3><p>求和：ndarray.sum(axis=None) / numpy.sum(a,axis=None)<br>均值：ndarray.mean(axis=None) / numpy.mean(a,axis=None) ；受离群点的影响较大<br>中值：numpy.median(a,axis=None)<br>最大值：ndarray.max(axis=None) / numpy.max(a,axis=None)<br>最小值：ndarray.min(axis=None) / numpy.min(a,axis=None)<br>极值：ndarray.ptp(axis=None) / numpy.ptp(a,axis=None) ；即最大值和最小值之差<br>标准差：ndarray.std(axis=None) / numpy.std(a,axis=None) </p><p><strong>注</strong>：默认返回多维数组的全部的统计结果，如果指定axis，则返回当前轴上的结果</p><h3 id="4-5-差分"><a href="#4-5-差分" class="headerlink" title="4.5 差分"></a>4.5 差分</h3><p><strong>差分</strong>：后面的数据据减去前面的数据</p><p>numpy.<strong>diff</strong>(a, n=1, axis=-1, prepend=&lt; no value&gt;, append=&lt; no value&gt;)</p><ol><li>a：进行差分计算的数组；n：差分的次数，对前一次差分的结果再次进行差分，默认为 1；axis：差分的方向，0行上竖向，1列上横向</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr_1 &#x3D; np.array([1, 2, 3, 5, 5])arr_2 &#x3D; np.array([6, 7, 9, 9, 10])arr_d1 &#x3D; np.diff([arr_1, arr_2], axis &#x3D; 0)arr_d2 &#x3D; np.diff([arr_1, arr_2], n &#x3D; 2, axis &#x3D; 1)print(arr_d1, &#39;\n&#39;, arr_d2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-通用函数-ufuncs"><a href="#5-通用函数-ufuncs" class="headerlink" title="5. 通用函数-ufuncs"></a>5. 通用函数-ufuncs</h2><p><strong>ufuncs</strong>：通用函数的缩写，是⼀种对ndarray中的数据执⾏元素级运算的函数；对 ndarray对象进行操作的 NumPy函数；用于实现 <strong>矢量化</strong>：⽤数组表达式代替循环，提升计算速度；优于迭代速度</p><h3 id="5-1-算术运算"><a href="#5-1-算术运算" class="headerlink" title="5.1 算术运算"></a>5.1 算术运算</h3><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr_1 &#x3D; np.array([6, 7, 8, 9, 10])arr_2 &#x3D; np.array([1, 2, 3, 4, 5])arr_a &#x3D; np.add(arr_1, arr_2)          # 加arr_s &#x3D; np.subtract(arr_1, arr_2)     # 减arr_m &#x3D; np.multiply(arr_1, arr_2)     # 乘arr_d &#x3D; np.divide(arr_1, arr_2)       # 除arr_p &#x3D; np.power(arr_1, arr_2)        # 幂arr_mod &#x3D; np.mod(arr_1, arr_2)        # 取余arr_r &#x3D; np.remainder(arr_1, arr_2)    # 取余arr_di &#x3D; np.divmod(arr_1, arr_2)      # (商、余)元组arr_a &#x3D; np.absolute(arr_1)            # 绝对值，abs()# sqrt：开方print(arr_a, &#39;\n&#39;, arr_s, &#39;\n&#39;, arr_m, &#39;\n&#39;, arr_d, &#39;\n&#39;, arr_p, &#39;\n&#39;, arr_mod, &#39;\n&#39;, arr_r, &#39;\n&#39;, arr_di, &#39;\n&#39;, arr_a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-2-四舍五入"><a href="#5-2-四舍五入" class="headerlink" title="5.2 四舍五入"></a>5.2 四舍五入</h3><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([0.666667, -1.333333])# 截断:trunc, fixarr_t &#x3D; np.trunc(arr)arr_f &#x3D; np.fix(arr)# 四舍五入：around，roundarr_a &#x3D; np.around(arr, 2)# 下限arr_fl &#x3D; np.floor(arr)# 上限arr_c &#x3D; np.ceil(arr)print(arr_t, &#39;\n&#39;, arr_f, &#39;\n&#39;, arr_a, &#39;\n&#39;, arr_fl, &#39;\n&#39;, arr_c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-3-对数"><a href="#5-3-对数" class="headerlink" title="5.3 对数"></a>5.3 对数</h3><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr &#x3D; np.array([1, 10])# 基数为2arr_lg2 &#x3D; np.log2(arr)# 基数为10arr_lg10 &#x3D; np.log10(arr)# 基数为e，自然对数arr_ln &#x3D; np.log(arr)print(arr_lg2, &#39;\n&#39;, arr_lg10, &#39;\n&#39;, arr_ln)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 任意基数import numpy as npfrom math import lognplog &#x3D; np.frompyfunc(log, 2 ,1)&#39;&#39;&#39;numpy.frompyfunc(func, &#x2F;, nin, nout, *[, identity])1. func：函数名2. nin、nout：传入参数个数、输出数据个数&#39;&#39;&#39;print(nplog(100, 4))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-4-公倍公约数"><a href="#5-4-公倍公约数" class="headerlink" title="5.4 公倍公约数"></a>5.4 公倍公约数</h3><p>numpy.<strong>lcm</strong>(x1, x2, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p><ol><li>x1, x2：需要求最小公倍数的数；out：输出的数组</li></ol><p>numpy.<strong>gcd</strong>(x1, x2, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p><ol><li>x1, x2：需要求最小公倍数的数；out：输出的数组</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as npnum_x &#x3D; 3num_y &#x3D; 4arr &#x3D; np.array([1, 2, 3, 4, 5])lcm_n &#x3D; np.lcm(num_x, num_y)      # 求两数的最小公倍数lcm_a &#x3D; np.lcm.reduce(arr)        # 求数组的最小公倍数print(lcm_n, lcm_a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import numpy as npnum_x &#x3D; 12num_y &#x3D; 60arr &#x3D; np.array([12, 30, 45])gcd_n &#x3D; np.gcd(num_x, num_y)      # 求两数的最大公约数gcd_a &#x3D; np.gcd.reduce(arr)        # 求数组的最大公约数print(gcd_n, gcd_a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-5-角度函数"><a href="#5-5-角度函数" class="headerlink" title="5.5 角度函数"></a>5.5 角度函数</h3><p><strong>三角函数</strong>：</p><ul><li><strong>正弦-sin</strong>：numpy.<strong>sin</strong>(x, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj]) ; <strong>sinh</strong></li><li><strong>余弦-cos</strong>：numpy.<strong>cos</strong>(x, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj]) ; <strong>cosh</strong></li><li><strong>正切-tan</strong>：numpy.<strong>tan</strong>(x, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj]) ; <strong>tanh</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">arr &#x3D; np.array([np.pi&#x2F;4, np.pi&#x2F;3, np.pi&#x2F;2, np.pi])arr_sin &#x3D; np.sin(arr)arr_cos &#x3D; np.cos(arr)arr_tan &#x3D; np.tan(arr)print(arr_sin, &#39;\n&#39;, arr_cos, &#39;\n&#39;, arr_tan)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>反三角函数</strong>：</p><ul><li><p><strong>反正弦-arcsin</strong>：numpy.<strong>arcsin</strong>(x, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj]) ; <strong>arcsinh</strong></p></li><li><p><strong>反余弦-arccos</strong>：numpy.<strong>arccos</strong>(x, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj]) ; <strong>arccosh</strong></p></li><li><p><strong>反正切-arctan</strong>：numpy.<strong>arctan</strong>(x, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj]) ; <strong>arctanh</strong></p></li></ul><pre class="line-numbers language-none"><code class="language-none">arr &#x3D; np.array([-1, 0, 1])arr_asin &#x3D; np.arcsin(arr)arr_acos &#x3D; np.arccos(arr)arr_atan &#x3D; np.arctan(arr)print(arr_asin, &#39;\n&#39;, arr_acos, &#39;\n&#39;, arr_atan)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>角度弧度转换</strong>：</p><ul><li><p><strong>角度转弧度</strong>：numpy.<strong>deg2rad</strong>(x, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p></li><li><p><strong>弧度转角度</strong>：numpy.<strong>rad2deg</strong>(x, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p></li></ul><pre class="line-numbers language-none"><code class="language-none">arr &#x3D; np.array([90, 180, 360])arr_radian &#x3D; np.deg2rad(arr)          # 角度转弧度arr_angle  &#x3D; np.rad2deg(arr_radian)   # 弧度转角度print(arr_radian, arr_angle)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>勾股定理</strong>：</p><p>numpy.<strong>hypot</strong>(x1, x2, /, out=None, *, where=True, casting=’same_kind’, order=’K’, dtype=None, subok=True[, signature, extobj])</p><ol><li>x1, x2：两条直角边的值</li></ol><pre class="line-numbers language-none"><code class="language-none">tri_h &#x3D; 3tri_w &#x3D; 4tri_l &#x3D; np.hypot(tri_h, tri_w)print(tri_l)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-6-自定义"><a href="#5-6-自定义" class="headerlink" title="5.6 自定义"></a>5.6 自定义</h3><p>numpy.<strong>frompyfunc</strong>(func, /, nin, nout, *[, identity])</p><ol><li>func：函数名</li><li>nin、nout：传入参数个数、输出数据个数</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as npfrom math import lognplog &#x3D; np.frompyfunc(log, 2 ,1)print(nplog(100, 4))print(type(nplog))        # ufunc函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="6-I-O编程"><a href="#6-I-O编程" class="headerlink" title="6. I/O编程"></a>6. I/O编程</h2><p>numpy.<strong>loadtxt</strong>(fname, dtype=&lt;class ‘float’&gt;, comments=’#’, delimiter=None, converters=None, skiprows=0, usecols=None, unpack=False, ndmin=0, encoding=’bytes’, max_rows=None, *, quotechar=None, like=None)</p><ol><li>fname：文件名称，可以是文件、字符串或者生成器；dtype：数据类型</li><li>delimiter：分隔字符串；skiprows：跳过前面的行数；usecols：读取指定的列，传入列明字符串元组；unpack：为 True，则每个属性写入不同的数组变量（转置），否则为一个数组变量</li><li>ndmin：指定数组维数；encoding：数据编码方式</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as npfile_path_us &#x3D; &#39;.&#x2F;Data&#x2F;np_01_youtube_video_data&#x2F;US_video_data_numbers.csv&#39;&#39;t_us &#x3D; np.loadtxt(file_path_us, delimiter &#x3D; &#39;,&#39;, dtype &#x3D; &#39;int&#39;)print(t_us)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h2><h3 id="7-1集合"><a href="#7-1集合" class="headerlink" title="7.1集合"></a>7.1集合</h3><p>numpy.<strong>unique</strong>(ar, return_index=False, return_inverse=False, return_counts=False, axis=None, *, equal_nan=True)</p><ol><li>ar：创建集合的数组</li></ol><pre class="line-numbers language-none"><code class="language-none">import numpy as nparr_1 &#x3D; np.array([1, 2, 3, 4, 3, 4, 5])arr_2 &#x3D; np.array([4, 5, 6, 7, 8, 9, 10])set_a &#x3D; np.unique(arr_1)            # 查找数组中所有的唯一元素set_u &#x3D; np.union1d(arr_1, arr_2)    # 联合形成数组set_s &#x3D; np.intersect1d(arr_1, arr_2, assume_unique &#x3D; True)   # 相同值集合,assume_unique可加快集合运算速度set_d &#x3D; np.setdiff1d(arr_1, arr_2)  # 差异值集合，仅保留数组1的值set_x &#x3D; np.setxor1d(arr_1, arr_2)   # 异或值集合，两个数组都保留print(set_a, &#39;\n&#39;, set_u, &#39;\n&#39;, set_s, &#39;\n&#39;, set_d, &#39;\n&#39;, set_x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-2-随机数"><a href="#7-2-随机数" class="headerlink" title="7. 2 随机数"></a>7. 2 随机数</h3><pre class="line-numbers language-none"><code class="language-none">from numpy import random# random.seed(10)            # 设置随机种子，保证每次生成的随机数一致ran_i &#x3D; random.randint(100)ran_f &#x3D; random.rand()        # 生成 0-1 之间的随机浮点数，randn# random.randint(low, high&#x3D;None, size&#x3D;None, dtype&#x3D;int)   # 随机生成一个指定范围、指定形状的整数数组ran_a1 &#x3D; random.randint(20, 100, size &#x3D; (5, 3))  # 随机生成一个 大于20，小于100 形状为 (5, 3) 的二维数组# random.randn(d0, d1, ..., dn)  # 随机生成一个指定形状的小数数组ran_ac &#x3D; random.choice([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], size &#x3D; (3, 5))print(ran_i, &#39;\n&#39;, ran_f, &#39;\n&#39;, ran_a1, &#39;\n&#39;, ran_ac)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-3-常用数组"><a href="#7-3-常用数组" class="headerlink" title="7.3 常用数组"></a>7.3 常用数组</h3><p>创建一个全0的数组: np.zeros((3,4))<br>创建一个全1的数组: np.ones((3,4))<br>创建一个对角线为1的正方形数组(方阵): np.eye(3)<br>创建一个空数组：np.empty((3,4)) ，默认会展示一些数字，都是⼀些未初始化的垃圾值</p><p>获取最大值位置：  np.argmax(arr, axis=0)<br>获取最小值位置：  np.argmin(arr, axis=1)</p>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块-matplotlib</title>
      <link href="/202207/2746585.html"/>
      <url>/202207/2746585.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python模块-matplotlib-的基础知识</p><span id="more"></span><h1 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h1><p><strong>matplotlib</strong>：图形绘图库，可以用来绘制各种静态，动态，交互式的图表，包括线图、散点图、等高线图、条形图、柱状图、3D 图形、图形动画等；由 John D. Hunter 编写，大部分使用 python 编写（为平台兼容，少部分使用 C 、 Objective-C 和 JavaScript）；<a href="https://github.com/matplotlib/matplotlib"><font face = "微软雅黑" color = 1E90FF size = 5>Github网址</font></a>， <a href="https://matplotlib.org/"><font face = "微软雅黑" color = 1E90FF size = 5>matplotlib官网</font></a>， <a href="https://matplotlib.org/stable/gallery/lines_bars_and_markers/index.html"><font face = "微软雅黑" color = 1E90FF size = 5>matplotlib官网样例</font></a></p><p><strong>安装</strong>：pip install matploylib，可通过 print(matplotlib.__version__) 验证，正常输出版本号则正常安装<br><strong>导入</strong>：import matplotlib</p><h2 id="1-画布操作"><a href="#1-画布操作" class="headerlink" title="1. 画布操作"></a>1. 画布操作</h2><h3 id="1-1-绘制画布"><a href="#1-1-绘制画布" class="headerlink" title="1.1 绘制画布"></a>1.1 绘制画布</h3><p><strong>绘制画布</strong>：matplotlib.pyplot.figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True, FigureClass=&lt;class ‘matplotlib.figure.Figure’&gt;, clear=False, **kwargs)</p><ol><li>num：设置画布的唯一标识符；figsize：设置画布大小，默认为 (6.4, 4.8)，单位是英寸；dpi：设置画布的分辨率(网络每英寸点数)，默认为100</li><li>facecolor：设置背景颜色(线框外侧)；edgecolor：设置边缘颜色；frameon：设置事后绘制外边框</li></ol><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltfig &#x3D; plt.figure(num &#x3D; 1, figsize &#x3D; (12, 7), dpi &#x3D; 100, facecolor &#x3D; &#39;r&#39;, edgecolor &#x3D; &#39;k&#39;, frameon &#x3D; False)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints &#x3D; [12, 14, 15, 17, 20, 25]plt.plot(xpoints, ypoints)plt.savefig(&quot;.&#x2F;matplotlib_fihure.png&quot;)     # 保存画布，需要在 show() 方法之前plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-绘图"><a href="#2-绘图" class="headerlink" title="2. 绘图"></a>2. 绘图</h2><p><strong>PyPlot</strong>：最常用子模块 import matplotlib.pyplot as plt </p><p><strong>绘图</strong>：matplotlib.pyplot.plot([x], y, [fmt], *, data=None, **kwargs)，绘制折线图</p><ol><li>[x], y：传入两个参数，分别指定x、y轴的坐标，要求坐标数据数量必须一致；如果省略x轴数值，则默认为0,1,2,3… 自动匹配</li><li>fmt：通过字符串指定 <strong>颜色字符</strong>、<strong>线型字符</strong>、<strong>标记字符</strong>；不区分顺序</li><li>**kwargs：通过关键字方式指定 Line2D properties属性，包括 color：颜色字符、linestyle：线型字符、linewidth：线性宽度、marker：标记字符、markersize：标记大小</li></ol><pre class="line-numbers language-none"><code class="language-none"># 1. [x], yimport matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints &#x3D; [12, 14, 15, 17, 20, 25]plt.plot(xpoints, ypoints)# plt.plot(ypoints)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 2. fmtimport matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints_1 &#x3D; [12, 14, 15, 17, 20, 25]ypoints_2 &#x3D; [14, 12, 25, 17, 20, 15]# plt.plot(xpoints, ypoints_1, xpoints, ypoints_2)    # 可以一次性绘制两条线plt.plot(xpoints, ypoints_1, &#39;r--s&#39;)plt.plot(xpoints, ypoints_2, &#39;b--s&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 3. **kwargsimport matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints &#x3D; [12, 14, 15, 17, 20, 25]plt.plot(xpoints, ypoints, linestyle &#x3D; &#39;-.&#39;, color &#x3D; &quot;#008000&quot;, marker &#x3D; &#39;^&#39;, markersize &#x3D; 10)# markeredgewidth：标记边框宽度，简写为 mew# markeredgecolor：标记边框颜色，简写为 mec# markerfacecolor：标记填充颜色，简写为 mfc# markerfacecoloralt：标记备用填充颜色，简写为 mfcalt# fillstyle:标记填充风格，有效值：&#39;full&#39;, &#39;left&#39;, &#39;right&#39;, &#39;bottom&#39;, &#39;top&#39;, &#39;none&#39;，默认full：全填充# antialiased, dash_capstyle, solid_capstyle, dash_joinstyle, solid_joinstyle, pickradius, drawstyle, markeveryplt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">类型</th><th align="center">字符</th><th>图形</th></tr></thead><tbody><tr><td align="center">颜色字符</td><td align="center">‘r’</td><td>红色</td></tr><tr><td align="center">颜色字符</td><td align="center">‘y’</td><td>黄色</td></tr><tr><td align="center">颜色字符</td><td align="center">‘b’</td><td>蓝色</td></tr><tr><td align="center">颜色字符</td><td align="center">‘g’</td><td>绿色</td></tr><tr><td align="center">颜色字符</td><td align="center">‘m’</td><td>洋红色</td></tr><tr><td align="center">颜色字符</td><td align="center">‘c’</td><td>青绿色</td></tr><tr><td align="center">颜色字符</td><td align="center">‘k’</td><td>黑色</td></tr><tr><td align="center">颜色字符</td><td align="center">‘w’</td><td>白色</td></tr><tr><td align="center">颜色字符</td><td align="center">‘#008000’</td><td>RGB 颜色符串，仅能通过关键字方式使用：color = “#008000”</td></tr><tr><td align="center">线型字符</td><td align="center">‘‐’, ‘solid’</td><td>实线，’solid’ 仅能用关键字 linestyle 指定：linestyle = ‘solid’</td></tr><tr><td align="center">线型字符</td><td align="center">‘‐‐’, ‘dashed’</td><td>破折线，’dashed’ 仅能用关键字 linestyle 指定：linestyle = ‘dashed’</td></tr><tr><td align="center">线型字符</td><td align="center">‘‐.’, ‘dotted’</td><td>点划线，’dotted’ 仅能用关键字 linestyle 指定：linestyle = ‘dotted’</td></tr><tr><td align="center">线型字符</td><td align="center">‘:’, ‘dashdot’</td><td>虚线，’dashdot’ 仅能用关键字 linestyle 指定：linestyle = ‘dashdot’</td></tr><tr><td align="center">线型字符</td><td align="center">‘’, ‘ ‘, ‘None’</td><td>不划线，’None’ 仅能用关键字 linestyle 指定：linestyle = ‘None’</td></tr><tr><td align="center">标记字符</td><td align="center">‘o’</td><td>实心圆点</td></tr><tr><td align="center">标记字符</td><td align="center">‘*’</td><td>星号</td></tr><tr><td align="center">标记字符</td><td align="center">‘^’, ‘v’, ‘&lt;’, ‘&gt;’</td><td>正三角、倒三角、左三角、右三角（三角形尖端朝上、下、左、右）</td></tr><tr><td align="center">标记字符</td><td align="center">‘1’, ‘2’, ‘3’, ‘4’</td><td>正Y形、倒Y形、左Y形、右Y形</td></tr><tr><td align="center">标记字符</td><td align="center">‘s’, ‘D’, ‘d’</td><td>正方形、正菱形、瘦菱形</td></tr><tr><td align="center">标记字符</td><td align="center">‘8’</td><td>正八边形</td></tr><tr><td align="center">标记字符</td><td align="center">(numsides, style, angle)</td><td>numsides：边数，angle：旋转角度，style：取0,1,2,3<br />仅能通过关键字方式使用：marker = (9, 0, 30)</td></tr></tbody></table><h3 id="2-1-设置标签"><a href="#2-1-设置标签" class="headerlink" title="2.1 设置标签"></a>2.1 设置标签</h3><p><strong>设置标题标签</strong>：matplotlib.pyplot.title(label, fontdict=None, loc=None, pad=None, *, y=None, **kwargs)<br><strong>设置 x轴 标签</strong>：matplotlib.pyplot.xlabel(xlabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)<br><strong>设置 y轴 标签</strong>：matplotlib.pyplot.ylabel(ylabel, fontdict=None, labelpad=None, *, loc=None, **kwargs)</p><ol><li>label、xlabel、ylabel 设置标题、x轴、y轴 标签名称，如果是中文需要设置中文显示字符</li><li>fontdict：设置标签字体属性字典，可以和 **kwargs 结合使用</li><li>loc：设置标签位置，title、xlabel有效值：’left’, ‘center’, ‘right’，默认为居中；ylabel有效值：’bottom’, ‘center’, ‘top’，默认为居中</li><li>pad、labelpad：设置标签和坐标轴的距离，默认为4</li><li>y：设置标题的纵轴位置，接收float数据，默认为1，在图表顶端，0.5则位于图表中部</li><li>**kwargs：通过关键字方式指定 text properties属性，指定 fontstyle：字体风格，简写为 style，有效值：’normal’, ‘italic’(斜体), ‘oblique’、fontsize：字体大小，或者size、color：字体颜色，简写为 c、rotation：旋转角度，有效值：’vertical’(0), ‘horizontal’(90)，可以输入数值</li></ol><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as plt# 设置显示中文字体：黑体# 设置字体字典# font &#x3D; &#123;&#39;family&#39;: &#39;MicroSoft YaHei&#39;,#        &#39;weight&#39;: &#39;bold&#39;,#        &#39;size&#39;: &#39;larger&#39;&#125;# matplotlib.rc(&#39;font&#39;, font)# 打印所有系统字体# fc-list  ，fc-list :lang&#x3D;zh# print([f.name for f in matplotlib.font_manager.fontManager.ttflist])from pylab import mplmpl.rcParams[&quot;font.sans-serif&quot;] &#x3D; [&quot;SimHei&quot;]# 自定义字体# 实例化字体对象：fname：字体库访问路径，size：设置字体大小myfont &#x3D; matplotlib.font_manager.FontProperties(fname&#x3D;&quot;C:\Windows\Fonts\Candara.ttf&quot;, size &#x3D; 24)fig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints &#x3D; [12, 14, 15, 17, 20, 25]plt.plot(xpoints, ypoints)# 定义标签字体字典font_dict&#x3D;dict(fontsize &#x3D; 16, color &#x3D; &#39;b&#39;, style &#x3D; &#39;oblique&#39;)# 定义图表标题标签plt.title(&quot;matplotlib graph&quot;, fontproperties &#x3D; myfont, y &#x3D; 1.1)# plt.title(&quot;matplotlib graph&quot;, fontdict &#x3D; myfont, y &#x3D; 1.1)      # 有报错，但能显示# 定义坐标轴标签plt.xlabel(&quot;月份&quot;, font_dict, labelpad &#x3D; 10, loc &#x3D; &quot;right&quot;)plt.ylabel(&quot;数量&quot;, font_dict, loc &#x3D; &quot;top&quot;, rotation &#x3D; &#39;horizontal&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-设置坐标轴刻度"><a href="#2-2-设置坐标轴刻度" class="headerlink" title="2.2 设置坐标轴刻度"></a>2.2 设置坐标轴刻度</h3><p><strong>设置坐标轴刻度</strong>：matplotlib 会自动生成对应坐标轴的刻度，也可以自定义</p><p>matplotlib.pyplot.<strong>xticks</strong>(ticks=None, labels=None, **kwargs)</p><p>matplotlib.pyplot.<strong>yticks</strong>(ticks=None, labels=None, **kwargs)</p><ol><li>ticks：设置的坐标轴刻度，其他内容可以用文本属性可用于控制</li><li>labels：设置刻度标签，设置同上文设置标签</li></ol><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltimport randomfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; range(120)ypoints &#x3D; [random.random()*20 + 10 for i in range(120)]plt.plot(xpoints, ypoints)# 自定义标签：range前闭后开list_min &#x3D; [str(i) if i &gt; 9 else &#39;0&#39; + str(i) for i in range(60)]xticks &#x3D; [&#39;10:&#123;&#125;&#39;.format(i) for i in list_min]xticks +&#x3D; [&#39;11:&#123;&#125;&#39;.format(i) for i in list_min]plt.xticks(range(0, 120, 5), xticks[::5], rotation &#x3D; 45)plt.yticks(range(10, 32, 3))plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-3-显示图例"><a href="#2-3-显示图例" class="headerlink" title="2.3 显示图例"></a>2.3 显示图例</h3><p><strong>显示图例</strong>：matplotlib.pyplot.legend(*args, **kwargs)</p><ol><li>handles、labels：设置显示的图例标签</li><li>loc：设置图例位置，有效值：’upper left’, ‘upper right’, ‘lower left’, ‘lower right’, ‘upper center’, ‘lower center’, ‘center left’, ‘center right’ 默认值为 ‘best’，根据内容自行指定</li><li>ncol：设置图例的列数，默认为1(1列)；fontsize：设置图例字体大小；title：设置图例的标题</li></ol><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints_1 &#x3D; [12, 14, 15, 17, 20, 25]ypoints_2 &#x3D; [14, 12, 25, 17, 20, 15]plt.plot(xpoints, ypoints_1, &#39;r--s&#39;)plt.plot(xpoints, ypoints_2, &#39;b--s&#39;)x_labels &#x3D; [&#39;red&#39;, &#39;blue&#39;]# plt.plot(xpoints, ypoints_1, &#39;r--s&#39;, label &#x3D; &#39;red&#39;)# plt.plot(xpoints, ypoints_2, &#39;b--s&#39;, label &#x3D; &#39;blue&#39;)# prop 设置字体plt.legend(labels &#x3D; x_labels, loc &#x3D; &#39;upper right&#39;, ncol &#x3D; 1, fontsize &#x3D; 12, title &#x3D; &quot;Color&quot;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-绘制网格"><a href="#2-4-绘制网格" class="headerlink" title="2.4 绘制网格"></a>2.4 绘制网格</h3><p><strong>绘制网格</strong>：matplotlib.pyplot.grid(visible=None, which=’major’, axis=’both’, **kwargs)</p><ol><li>visible：是否可见，有效值：True、Flase、None(显示网格线)</li><li>which：设置是否应用更改的网格线，有效值：’major’(表示应用更改的网格线), ‘minor’, ‘both’，默认为 ‘major’</li><li>axis：设置展示网格线内容，有效值：’both’, ‘x’(仅显示 x轴), ‘y’(仅显示 y轴)，默认为’both’</li><li>**kwargs：通过关键字方式指定 Line2D properties属性，详细内容见绘图3</li></ol><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints &#x3D; [12, 14, 15, 17, 20, 25]plt.plot(xpoints, ypoints)matplotlib.pyplot.grid(visible &#x3D; True, which &#x3D; &#39;both&#39;, axis &#x3D; &#39;y&#39;, color &#x3D; &#39;r&#39;, linestyle &#x3D; &#39;-&#39;, linewidth &#x3D; 2)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-5-绘制多图"><a href="#2-5-绘制多图" class="headerlink" title="2.5 绘制多图"></a>2.5 绘制多图</h3><p><strong>绘制多图</strong>：</p><ol><li>matplotlib.pyplot.subplot(*args, **kwargs)：在绘图时需要指定位置<ul><li>*args：包含三个参数：nrows(划分行数), ncols(划分列数), index(划分索引数，从 0 开始，按照从左到右，从上到下的顺序增加索引)</li><li>**kwargs：projection：统计图类型None, ‘aitoff’, ‘hammer’, ‘lambert’, ‘mollweide’, ‘polar’, ‘rectilinear’，默认为 rectilinear 折线图</li></ul></li></ol><pre class="line-numbers language-none"><code class="language-none"># subplot()import matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints_1 &#x3D; [12, 14, 15, 17, 20, 25]ypoints_2 &#x3D; [14, 12, 25, 17, 20, 15]plt.subplot(1, 2, 1, projection &#x3D; &#39;rectilinear&#39;)            # 先指定第一行第一列，序号为1的子图，再进行绘图plt.plot(xpoints, ypoints_1)plt.title(&quot;plot_1&quot;)plt.subplot(1, 2, 2)            # 指定第一行第二列，序号为2的子图；plt.subplot(2, 2, 3)绘制第二行第一列，序号为3的子图plt.plot(xpoints, ypoints_2)plt.title(&quot;plot_2&quot;)plt.suptitle(&quot;subplot test&quot;)    # 针对多图进行命名plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>matplotlib.pyplot.subplots(nrows=1, ncols=1, *, sharex=False, sharey=False, squeeze=True, subplot_kw=None, gridspec_kw=None, **fig_kw)：可以一次生成多个，在调用时只需要调用生成对象的 ax<ul><li>nrows、ncols：设置图表的行数、列数，默认为 1</li><li>sharex、sharey：设置 x、y 轴是否共享，有效值：’none’/True, ‘all’/False, ‘row’(共享x轴), ‘col’(共享y轴)</li></ul></li></ol><pre class="line-numbers language-none"><code class="language-none"># subplots()import matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints_1 &#x3D; [1, 2, 3, 4, 5, 6]ypoints_1 &#x3D; [12, 14, 15, 17, 20, 25]xpoints_2 &#x3D; [3, 4, 5, 6, 7, 8]ypoints_2 &#x3D; [14, 12, 25, 17, 20, 15]plt.subplots(1, 1, sharex &#x3D; &quot;col&quot;)            # 先指定第一行第一列，序号为1的子图，再进行绘图plt.plot(xpoints_1, ypoints_1)plt.title(&quot;subplots_1&quot;)plt.subplots(1, 1, sharex &#x3D; &quot;col&quot;)            # 指定第一行第二列，序号为2的子图；plt.subplot(2, 2, 3)绘制第二行第一列，序号为3的子图plt.plot(xpoints_2, ypoints_2)plt.title(&quot;subplots_2&quot;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-其他图形"><a href="#3-其他图形" class="headerlink" title="3. 其他图形"></a>3. 其他图形</h2><p>涉及到标签、刻度、图例等都是通用的；<a href="https://matplotlib.org/stable/gallery/index.html"><font face = "微软雅黑" color = 1E90FF size = 5>绘制图形参考</font></a></p><h3 id="3-1-绘制散点图"><a href="#3-1-绘制散点图" class="headerlink" title="3.1 绘制散点图"></a>3.1 绘制散点图</h3><p><strong>绘制散点图</strong>：</p><p>matplotlib.pyplot.scatter(x, y, s=None, c=None, marker=None, cmap=None, norm=None, vmin=None, vmax=None, alpha=None, linewidths=None, *, edgecolors=None, plotnonfinite=False, data=None, **kwargs)</p><ol><li>x, y：传入两个参数，分别指定x、y轴的坐标，要求坐标数据数量必须一致；不能缺省 x轴 坐标</li><li>s：点的大小，默认20；c：点的颜色，默认蓝色’b’，可以传入数组；marker：点的样式，默认为’o’</li><li>cmap：Colormap，标量或者是一个 colormap 的名字；norm：Normalize，数据亮度在 0-1 之间，只有 c 是一个浮点数的数组的时才使用</li><li>vmin，vmax：亮度设置，在 norm 参数存在时会忽略</li><li>alpha：透明度设置，0-1 之间，默认为1或None(不透明)；linewidths：标记点的长度</li><li>edgecolors：颜色或颜色序列，有效值：’face’, ‘none’, None，默认为 ‘face’</li><li>plotnonfinite：布尔值，设置是否使用非限定的 c ( inf, -inf 或 nan) 绘制点</li></ol><pre class="line-numbers language-none"><code class="language-none"># 1，2，5：x,y,s,c,marker,alpha,linewidthsimport matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints_1 &#x3D; [12, 14, 15, 17, 20, 25]ypoints_2 &#x3D; [14, 12, 25, 17, 20, 15]plt.scatter(xpoints, ypoints_1, s &#x3D; 50, c &#x3D; &#39;r&#39;)plt.scatter(xpoints, ypoints_2, s &#x3D; (20,50,100,500,2000,90), c &#x3D; (&#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;y&#39;, &#39;k&#39;, &#39;g&#39;), marker &#x3D; &#39;^&#39;, alpha &#x3D; 0.3, linewidths &#x3D; 10)plt.title(&quot;scatter&quot;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># cmapimport matplotlib as mplimport matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints &#x3D; [12, 14, 15, 17, 20, 25]# 需要生成 Normalize 实例norm &#x3D; mpl.colors.Normalize(vmin&#x3D;-1, vmax&#x3D;1)plt.scatter(xpoints, ypoints_2, c &#x3D; (20,50,100,500,2000,90), cmap &#x3D; &#39;afmhot&#39;)# cmap：可取 &#39;viridis&#39;(默认), 单色：&#39;YlOrRd&#39;, &#39;Greens&#39;, &#39;Blues&#39;, &#39;Greys&#39;, &#39;Purples&#39;; 拼色：&#39;afmhot&#39;, &#39;cividis&#39;, &#39;inferno&#39;, &#39;magma&#39;, &#39;plasma&#39;plt.colorbar()    # 显示颜色条样例plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-绘制柱状图"><a href="#3-2-绘制柱状图" class="headerlink" title="3.2 绘制柱状图"></a>3.2 绘制柱状图</h3><p><strong>柱状图</strong>：</p><p><strong>绘制竖直型柱状图</strong>：matplotlib.pyplot.bar(x, height, width=0.8, bottom=None, *, align=’center’, data=None, **kwargs)<br><strong>绘制水平型柱状图</strong>：matplotlib.pyplot.barh(y, width, height=0.8, left=None, *, align=’center’, **kwargs)</p><ol><li>x, height（width）：传入两个参数，分别指定x、y轴的坐标</li><li>width（height）：设置柱状图宽度</li><li>bottom：y轴底部坐标，默认为0；left：x轴底部坐标，默认为0</li><li>align：柱形图与 x 坐标的对齐方式，有效值：’center’(默认，中心对齐), ‘edge’(左/下边缘对齐，可传递负宽度值实现右/上边缘对齐)</li><li>**kwargs：包含color、edgecolor、linewidth、tick_label等</li></ol><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints &#x3D; [12, 14, 15, 17, 20, 25]plt.subplot(1, 2, 1)plt.bar(xpoints, ypoints, width &#x3D; -0.5, bottom &#x3D; 10, align &#x3D; &quot;edge&quot;)plt.subplot(1, 2, 2)plt.barh(xpoints, ypoints, height &#x3D; 0.5, left &#x3D; 1, align &#x3D; &quot;edge&quot;, color &#x3D; (&#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;y&#39;, &#39;k&#39;, &#39;g&#39;))plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 绘制多条柱import matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [1, 2, 3, 4, 5, 6]ypoints_1 &#x3D; [12, 14, 15, 17, 20, 25]ypoints_2 &#x3D; [14, 12, 25, 17, 20, 15]plt.bar(xpoints, ypoints_1, label &#x3D; &#39;blue&#39;, width &#x3D; -0.3, bottom &#x3D; 10, align &#x3D; &quot;edge&quot;)plt.bar(xpoints, ypoints_2, label &#x3D; &#39;orange&#39;, width &#x3D; 0.3, bottom &#x3D; 10, align &#x3D; &quot;edge&quot;)plt.legend()plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-绘制饼图"><a href="#3-3-绘制饼图" class="headerlink" title="3.3 绘制饼图"></a>3.3 绘制饼图</h3><p><strong>绘制饼图</strong>：</p><p>matplotlib.pyplot.pie(x, explode=None, labels=None, colors=None, autopct=None, pctdistance=0.6, shadow=False, labeldistance=1.1, startangle=0, radius=1, counterclock=True, wedgeprops=None, textprops=None, center=(0, 0), frame=False, rotatelabels=False, *, normalize=True, data=None)</p><ol><li>x：表示每个扇形的面积</li><li>explode：表示扇形到原点的距离，以半径的倍数计算，默认值为0(紧贴圆心)，传入一个数组；labels：各个扇形的标签，默认值为 None；colors：表示各个扇形的颜色，默认值为 None，会自动指定；autopct：设置饼图内各个扇形百分比显示格式，”%0.2f%%” 两位小数百分比</li><li>pctdistance：设置百分比到圆心的距离，默认为0.6倍半径；labeldistance：绘制标签位置，默认值为1.1倍半径；shadow：设置是否阴影，默认为 False；startangle：其实绘制角度，默认为0(x轴正半轴)；radius：饼图的半径，默认为1；counterclock：设置绘制方向，默认为 True(逆时针)</li><li>wedgeprops：传递给 wedge 对象用来画一个饼图，传递一个字典，如：wedgeprops={‘linewidth’:5}；textprops：用于设置标签和比例文字的格式，传递一个字典</li><li>center：设置图表中心的坐标(需要和 frame 配合使用)；frame：是否绘制带有坐标轴的图；rotatelabels：旋转标签值同一角度</li></ol><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)from pylab import mplmpl.rcParams[&quot;font.sans-serif&quot;] &#x3D; [&quot;SimHei&quot;]xpoints &#x3D; [12, 14, 15, 17, 20, 25]x_labels &#x3D; [&#39;1月&#39;, &#39;2月&#39;, &#39;3月&#39;, &#39;4月&#39;, &#39;5月&#39;, &#39;6月&#39;]plt.pie(xpoints, explode &#x3D; (0.2, 0, 0, 0, 0, 0), labels &#x3D; x_labels, colors &#x3D; (&#39;r&#39;, &#39;b&#39;, &#39;c&#39;, &#39;y&#39;, &#39;k&#39;, &#39;g&#39;), autopct &#x3D; &quot;%0.2f%%&quot;,         pctdistance &#x3D; 0.8, labeldistance &#x3D; 1.2, shadow &#x3D; True, startangle &#x3D; 90, radius &#x3D; 2.2, counterclock &#x3D; False, center &#x3D; (2, 2),         frame &#x3D; True, rotatelabels &#x3D; True)plt.legend(labels &#x3D; x_labels, loc &#x3D; &#39;upper center&#39;, ncol &#x3D; 2, fontsize &#x3D; 12, title &#x3D; &quot;Month&quot;)   # 显示图例，详情见2.4plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-4-绘制直方图"><a href="#3-4-绘制直方图" class="headerlink" title="3.4 绘制直方图"></a>3.4 绘制直方图</h3><p><strong>绘制直方图</strong>：只有为经过统计处理的原始数据才能回执直方图</p><p>matplotlib.pyplot.hist(x, bins=None, range=None, density=False, weights=None, cumulative=False, bottom=None, histtype=’bar’, align=’mid’, orientation=’vertical’, rwidth=None, log=False, color=None, label=None, stacked=False, *, data=None, **kwargs)</p><ol><li>x：直方图绘制的数据；bins：直方图绘制的列数，默认为 10；range：规定 x轴 的最大值最小值元组</li><li>density：设置显示密度；cumulative：进行计算绘制，第n条柱的值为前n条柱的和；bottom：每一条柱的y轴起始位置，可以对每一条柱设置值，默认为0</li><li>histtype：数据展示类型，有效值：’bar’(柱形), ‘barstacked’(), ‘step’(只显示边框，不填充), ‘stepfilled’(填充)，默认值为 ‘bar’；align：设置直方图条的水平对齐方式，有效值：’left’, ‘mid’, ‘right’，默认为 ‘mid’；orientation：设置图条朝向，有效值：’vertical’(竖直), ‘horizontal’(水平)，默认为’vertical’</li><li>rwidth：设置柱形宽度，在 histtype = ‘step’/‘stepfilled’时无法使用；color：设置柱形颜色</li></ol><pre class="line-numbers language-none"><code class="language-none">import matplotlib.pyplot as pltfig &#x3D; plt.figure(figsize &#x3D; (12, 7), dpi &#x3D; 100)xpoints &#x3D; [4,5,14,11,15,20,7,14,19,2,4,5,21,6,3,4,3,13,8,3,12,14,16,7,13,4,14,21,9,1,19,6,3,2,7,1,10,2,1,10,20,5,10,4,6,20,14,9,1,2,1,10,17,21,7,17,11,20,1,13,9,13,13,8,13,14,18,10,14,1,15,11,10,11,21,19,6,12,18,5,15,14,9,8,15,10,3,16,2,9,9,7,19,21,13,1,13,17,21,17,10,2,2,20,20,9,10,13,6,6,8,10,4,13,6,15,9,13,17,8,12,17,18,18,18,9,9,12,16,6,7,4,21,11,19,5,13,2,18,9,3,16,21,17,9,11,18,17,19,21,21,2,6,13,9,10,21,4,2,6,16,11,19,11,10,16,1,20,14,19,5,12,9,21,8,10,11,5,4,12,18,19,6,13,4,13,10,1,13,19,11,10,1,3,19,3,5,4,21,20]plt.hist(xpoints, bins &#x3D; 8, density &#x3D; True, bottom &#x3D; 0.1, cumulative &#x3D; True, histtype &#x3D; &#39;step&#39;, align&#x3D;&#39;right&#39;, orientation&#x3D;&#39;horizontal&#39;,         rwidth &#x3D; 0.9, color &#x3D; &#39;r&#39;)plt.show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h2><h3 id="4-1-问题"><a href="#4-1-问题" class="headerlink" title="4.1 问题"></a>4.1 问题</h3><p><strong>问题1</strong>：Glyph 26376 (\N{CJK UNIFIED IDEOGRAPH-6708}) missing from current font.  中文字符无法显示</p><ul><li>解决：设置显示中文字体<pre class="line-numbers language-none"><code class="language-none">from pylab import mplmpl.rcParams[&quot;font.sans-serif&quot;] &#x3D; [&quot;SimHei&quot;]   # SimHei:黑体,Microsoft YaHei:微软雅黑<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块-二进制数据处理</title>
      <link href="/202207/149327.html"/>
      <url>/202207/149327.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Python模块-二进制数据处理-的基础知识</p><span id="more"></span><h1 id="1-base64"><a href="#1-base64" class="headerlink" title="1. base64"></a>1. base64</h1><p><strong>Base64</strong>：是一种用64个字符来表示任意二进制数据的方法；文本处理软件能处理二进制数据</p><p>正常二进制数据是 8个字节表示一个字符，Base64 定义64个可显示的字符串（’A’, ‘B’, … , ‘Z’, ‘a’, ‘b’,  … ,’z’, ‘0’, ‘1’, … , ‘9’, +’, ‘/‘），用 6个字节进行标识；即原通过二进制编码的数据通过Base64编码后字符长度会增加三分之一（3 * 8 = 4 * 6，原数据每三个字符对应Base64编码后四个字符），对于非三整数倍的字节数据，会用 <strong>\x00字节填充</strong>，再在编码的末尾加上1个或2个 = 号，表示填充的字节数；在解码的时候会自动去掉</p><pre class="line-numbers language-none"><code class="language-none">import base64base64.b64encode(b&#39;binary\x00string&#39;)        # 返回b&#39;YmluYXJ5AHN0cmluZw&#x3D;&#x3D;&#39;base64.b64decode(b&#39;YmluYXJ5AHN0cmluZw&#x3D;&#x3D;&#39;)    # 返回b&#39;binary\x00string&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>url_safe</strong> ：标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数；改进出现 url_safe 的base64编码，其实就是把字符+和/分别变成-和_</p><pre class="line-numbers language-none"><code class="language-none">import base64base64.b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)            # 返回b&#39;abcd++&#x2F;&#x2F;&#39;base64.urlsafe_b64encode(b&#39;i\xb7\x1d\xfb\xef\xff&#39;)    # 返回b&#39;abcd--__&#39;base64.urlsafe_b64decode(&#39;abcd--__&#39;)                  # 返回b&#39;i\xb7\x1d\xfb\xef\xff&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Base64适用于小段内容的编码，常用在数字证书签名、Cookie的内容</strong>；=字符也可能出现在Base64编码中，但在URL、Cookie里面会造成歧义；所以，很多Base64编码后会把=去掉，在解码时需要加上=把Base64字符串的长度变为4的倍数</p><pre class="line-numbers language-none"><code class="language-none"># 去掉&#x3D; base64编码的解码函数import base64def safe_base64_decode(s):    while len(s) % 4 !&#x3D; 0:        s &#x3D; s + &#39;&#x3D;&#39;    return base64.b64decode(s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-struct"><a href="#2-struct" class="headerlink" title="2. struct"></a>2. struct</h1><p><strong>struct</strong>：实现bytes和其他二进制数据类型的转换</p><ul><li><strong>pack</strong>：把任意数据类型变成 bytes，一个参数是处理指令，第二个参数是数据</li></ul><pre class="line-numbers language-none"><code class="language-none">import structstruct.pack(&#39;&gt;I&#39;, 10240099)   # 返回b&#39;\x00\x9c@c&#39;&gt;表示字节顺序是big-endian，也就是网络序；I表示4字节无符号整数；对应最大有效值为 4294967295<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>unpack</strong>：把bytes变成指定的数据类型，第一个参数是处理指令，第二个参数是数据</li></ul><pre class="line-numbers language-none"><code class="language-none">import structstruct.unpack(&#39;&gt;IH&#39;, b&#39;\xf0\xf0\xf0\xf0\x80\x80&#39;)  # 返回(4042322160, 32896)后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># case：解析Windows的位图文件（.bmp）# BMP格式采用小端方式存储数据，文件头的结构按顺序如下：# 两个字节：&#39;BM&#39;表示Windows位图，&#39;BA&#39;表示OS&#x2F;2位图； # 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； # 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数import base64, structbmp_data &#x3D; base64.b64decode(&#39;Qk1oAgAAAAAAADYAAAAoAAAAHAAAAAoAAAABABAAAAAAADICAAASCwAAEgsAAAAAAAAAAAAA&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfAB8AHwAfAB8AHwAfP9&#x2F;&#x2F;3&#x2F;&#x2F;fwB8AHwAfAB8&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfAB8AHz&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;38AfAB8AHwAfAB8AHwAfAB8AHz&#x2F;f&#x2F;9&#x2F;&#x2F;38AfAB8&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;fwB8AHz&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfP9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfP9&#x2F;&#x2F;3&#x2F;&#x2F;fwB8AHz&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfP9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;38AfAB8AHwAfAB8AHwAfP9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfP9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;38AfAB8&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;fwB8AHwAfAB8AHwAfAB8&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;38AfAB8&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;fwB8AHz&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfP9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfP9&#x2F;&#x2F;3&#x2F;&#x2F;fwB8AHz&#x2F;f&#x2F;9&#x2F;AHz&#x2F;f&#x2F;9&#x2F;AHwAfP9&#x2F;&#x2F;38AfP9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfAB8AHwAfAB8AHwAfAB8&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfP9&#x2F;&#x2F;38AfAB8AHwAfAB8AHwAfAB8&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;38AfAB8AHwAfAB8AHwAfAB8&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;AHwAfAB8AHz&#x2F;fwB8AHwAfAB8AHwAfAB8AHz&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;3&#x2F;&#x2F;f&#x2F;9&#x2F;&#x2F;38AAA&#x3D;&#x3D;&#39;)def bmp_info(data):    data_1 &#x3D; struct.unpack(&#39;&lt;ccIIIIIIHH&#39;, data[:30])    if data_1[:2] &#x3D;&#x3D; (b&#39;B&#39;, b&#39;M&#39;):        return &#123;            &#39;width&#39;: data_1[-4],            &#39;height&#39;: data_1[-3],            &#39;color&#39;: data_1[-1]        &#125;    else:        print(&#39;不是位图文件。&#39;)bi &#x3D; bmp_info(bmp_data)print(bi)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-常见服务</title>
      <link href="/202206/3037759.html"/>
      <url>/202206/3037759.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Linux操作系统的常见操作指令</p><span id="more"></span><p>通过端口访服务</p><blockquote><p>22：ssh服务器<br>80：web服务器<br>443：HTTPS<br>21：FTP服务器</p></blockquote><h1 id="1-操作控制"><a href="#1-操作控制" class="headerlink" title="1. 操作控制"></a>1. 操作控制</h1><p>sshd：</p><p><strong>ssh客户端</strong>：使用 Security Shell 协议访问远程计算机的软件程序；传输过程中，进行数据加密（能够防止 DNS欺骗和 IP欺骗）和数据压缩</p><pre class="line-numbers language-none"><code class="language-none"># 免密ssh-keygenssh-copy-id -P port_num user@remote:file_path<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块-colllections</title>
      <link href="/202206/291075.html"/>
      <url>/202206/291075.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python模块-colllections-的基础知识</p><span id="more"></span><h1 id="1-colllections"><a href="#1-colllections" class="headerlink" title="1. colllections"></a>1. colllections</h1><p><strong>colllections</strong>：内建的一个集合模块，提供了许多有用的集合类</p><h2 id="1-1-namedtuple"><a href="#1-1-namedtuple" class="headerlink" title="1.1 namedtuple"></a>1.1 namedtuple</h2><p><strong>namedtuple</strong>：用来创建一个自定义的tuple对象，规定tuple元素的个数，可以用属性来引用tuple的某个元素；具备tuple的不变性，又可以根据属性来引用</p><pre class="line-numbers language-none"><code class="language-none">from collections import namedtuplePoint &#x3D; namedtuple(&#39;Point&#39;, [&#39;x&#39;, &#39;y&#39;])    # namedtuple(&#39;名称&#39;, [属性list]) p &#x3D; Point(1, 2)    # 显示二维坐标print(p.x, p.y)# Circle &#x3D; namedtuple(&#39;Circle&#39;, [&#39;x&#39;, &#39;y&#39;, &#39;r&#39;])     # 定义一个圆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-deque"><a href="#1-2-deque" class="headerlink" title="1.2 deque"></a>1.2 deque</h2><p><strong>deque</strong>：实现高效插入和删除操作的双向列表，适合用于队列和栈，解决线性存储 list 数据量大时插入和删除效率低问题</p><pre class="line-numbers language-none"><code class="language-none">from collections import dequequeue &#x3D; deque([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;])queue.append(&#39;x&#39;)               # 从列表最后（右边）新增queue.appendleft(&#39;y&#39;)           # 从列表左边新增print(queue)pop &#x3D; queue.pop()               # 从列表最后（右边）删除pop_left &#x3D; queue.popleft()      # 从列表左边删除print(pop, pop_left, queue)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-defaultdict"><a href="#1-3-defaultdict" class="headerlink" title="1.3 defaultdict"></a>1.3 defaultdict</h2><p><strong>defaultdict</strong>：key不存在时，返回一个默认值；也可以统计数量</p><pre class="line-numbers language-none"><code class="language-none">from collections import defaultdictdef fun_default():    return &#39;default&#39;default_dict &#x3D; defaultdict(fun_default)         # defaultdict 默认值通过调用函数返回default_dict[&#39;x&#39;] &#x3D; 1                           # 新增字典，其他行为跟dict完全一样print(default_dict[&#39;x&#39;], default_dict[&#39;y&#39;])     # 存在时返回值；不存在时返回默认值# 统计数量from collections import defaultdictblanket &#x3D; [&#39;apple&#39;, &#39;apple&#39;, &#39;orange&#39;, &#39;banana&#39;]default_dict_count &#x3D; defaultdict(int)              # int 默认值为0，也可使用 set、list、str等工厂函数for fruit in blanket:    default_dict_count[fruit] +&#x3D; 1print(default_dict_count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-OrderedDict"><a href="#1-4-OrderedDict" class="headerlink" title="1.4 OrderedDict"></a>1.4 OrderedDict</h2><p><strong>OrderedDict</strong>：保持Key的顺序</p><pre class="line-numbers language-none"><code class="language-none">from collections import OrderedDictnormal_dict &#x3D; dict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5)])order_dict &#x3D; OrderedDict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5)])    # Key按照插入的顺序排列，不是Key本身排序print(normal_dict, order_dict)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># OrderedDict实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的Keyfrom collections import OrderedDictclass LastUpdatedOrderedDict(OrderedDict):    def __init__(self, capacity):        super(LastUpdatedOrderedDict, self).__init__()        self._capacity &#x3D; capacity    def __setitem__(self, key, value):        containsKey &#x3D; 1 if key in self else 0        if len(self) - containsKey &gt;&#x3D; self._capacity:            last &#x3D; self.popitem(last&#x3D;False)            print(&#39;remove:&#39;, last)        if containsKey:            del self[key]            print(&#39;set:&#39;, (key, value))        else:            print(&#39;add:&#39;, (key, value))        OrderedDict.__setitem__(self, key, value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-5-ChainMap"><a href="#1-5-ChainMap" class="headerlink" title="1.5 ChainMap"></a>1.5 ChainMap</h2><p><strong>ChainMap</strong>：可以把一组dict串起来并组成一个逻辑上的dict；ChainMap本身也是一个dict，查找时按照顺序在内部的dict依次查找</p><pre class="line-numbers language-none"><code class="language-none"># 按照指定顺序查找参数from collections import ChainMapimport os, argparse# 构造缺省参数defaults &#x3D; &#123;    &#39;color&#39;: &#39;red&#39;,    &#39;user&#39;: &#39;guest&#39;&#125;# 构造命令行参数parser &#x3D; argparse.ArgumentParser()parser.add_argument(&#39;-u&#39;, &#39;--user&#39;)parser.add_argument(&#39;-c&#39;, &#39;--color&#39;)namespace &#x3D; parser.parse_args()command_line_args &#x3D; &#123; k: v for k, v in vars(namespace).items() if v &#125;# 组合成ChainMapcombined &#x3D; ChainMap(command_line_args, os.environ, defaults)# 打印参数print(&#39;color&#x3D;%s&#39; % combined[&#39;color&#39;])print(&#39;user&#x3D;%s&#39; % combined[&#39;user&#39;])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-6-Counter"><a href="#1-6-Counter" class="headerlink" title="1.6 Counter"></a>1.6 Counter</h2><p><strong>Counter</strong>：计数器，统计字符出现的个数</p><pre class="line-numbers language-none"><code class="language-none">from collections import Counterchar_count &#x3D; Counter()for ch in &#39;programming&#39;:    char_count[ch] &#x3D; char_count[ch] + 1print(char_count)char_count.update(&#39;hello&#39;)print(char_count)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-UDP</title>
      <link href="/202206/284922.html"/>
      <url>/202206/284922.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录计算机网络-UDP-的基础知识</p><span id="more"></span><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-TCP/IP</title>
      <link href="/202206/2818847.html"/>
      <url>/202206/2818847.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录计算机网络-TCP/IP-的基础知识</p><span id="more"></span><h1 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h1>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块-datetime</title>
      <link href="/202206/2736392.html"/>
      <url>/202206/2736392.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python模块-datetime-的基础知识</p><span id="more"></span><h1 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h1><p><strong>datetime</strong>：处理日期和时间的标准库</p><pre class="line-numbers language-none"><code class="language-none">from datetime import datetime   # datetime模块还包含datetime类，通过from datetime import datetime导入datetime这个类；如果仅导入import datetime，则必须引用全名datetime.datetimenow &#x3D; datetime.now()      # 获取当前datetime，具体到秒后六位today &#x3D; datetime.today()  # 返回当前日期print(now, type(now), today, type(now))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 获取指定日期和时间from datetime import datetimedt &#x3D; datetime(2015, 4, 19, 12, 20)   # 用指定日期时间创建 datetimeprint(dt)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>timestamp</strong>：1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数），当前时间就是相对于epoch time的秒数，称为timestamp；用timestamp数字表示时间</p><pre class="line-numbers language-none"><code class="language-none">from datetime import datetimedatetime_now &#x3D; datetime.now()timestamp_now &#x3D; datetime_now.timestamp()                        # 把datetime转换为timestamp，timestamp是一个浮点数，整数位表示秒print(timestamp_now)datetime_now &#x3D; datetime.fromtimestamp(timestamp_now)            # 将timestamp转换成本地时间（北京时区、东8区，比标准时区时间早8小时）datetime_now_UTC &#x3D; datetime.utcfromtimestamp(timestamp_now)     # 将timestamp转换成UTC时间（格林威治标准时区时间）print(datetime_now)print(datetime_now_UTC)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-时间格式化"><a href="#1-时间格式化" class="headerlink" title="1. 时间格式化"></a>1. 时间格式化</h2><p><strong>str转换</strong>：通常用户输入的日期和时间是字符串，需要通过 <strong>datetime.strptime()</strong> 把 str 转换为 datetime，再进行处理</p><pre class="line-numbers language-none"><code class="language-none">from datetime import datetimecday &#x3D; datetime.strptime(&#39;2022-06-27 18:19:59&#39;, &#39;%Y-%m-%d %H:%M:%S&#39;)      # 把str转换为datetimeprint(cday)now &#x3D; datetime.now()print(now.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;))                                  # 把datetime转换为str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>格式化符号</th><th>描述</th></tr></thead><tbody><tr><td>%y</td><td>两位数的年份表示（00-99）</td></tr><tr><td>%Y</td><td>四位数的年份表示（000-9999）</td></tr><tr><td>%m</td><td>月份（01-12）</td></tr><tr><td>%d</td><td>月内中的一天（0-31）</td></tr><tr><td>%H</td><td>24小时制小时数（0-23）</td></tr><tr><td>%I</td><td>12小时制小时数（01-12）</td></tr><tr><td>%M</td><td>分钟数（00-59）</td></tr><tr><td>%S</td><td>秒（00-59）</td></tr><tr><td>%a</td><td>本地简化星期名称</td></tr><tr><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%b</td><td>本地简化的月份名称</td></tr><tr><td>%B</td><td>本地完整的月份名称</td></tr><tr><td>%c</td><td>本地相应的日期表示和时间表示</td></tr><tr><td>%j</td><td>年内的一天（001-366）</td></tr><tr><td>%p</td><td>本地A.M.或P.M.的等价符</td></tr><tr><td>%U</td><td>一年中的星期数（00-53）星期天为星期的开始</td></tr><tr><td>%w</td><td>星期（0-6），星期天为星期的开始</td></tr><tr><td>%W</td><td>一年中的星期数（00-53）星期一为星期的开始</td></tr><tr><td>%x</td><td>本地相应的日期表示</td></tr><tr><td>%X</td><td>本地相应的时间表示</td></tr><tr><td>%Z</td><td>当前时区的名称</td></tr><tr><td>%%</td><td>%号本身</td></tr></tbody></table><p><strong>datetime加减</strong>：导入 timedelta 类，直接用 + 和 - 运算符</p><pre class="line-numbers language-none"><code class="language-none">from datetime import datetime, timedeltanow &#x3D; datetime.now()print(now)print(now + timedelta(hours&#x3D;10))print(now - timedelta(days&#x3D;1))print(now + timedelta(days&#x3D;2, hours&#x3D;12))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>时区转换</strong></p><pre class="line-numbers language-none"><code class="language-none">from datetime import datetime, timedelta, timezonetz_utc_8 &#x3D; timezone(timedelta(hours&#x3D;8))              # 创建时区UTC+8:00now &#x3D; datetime.now()print(now)dt &#x3D; now.replace(tzinfo&#x3D;tz_utc_8)                    # 强制设置为UTC+8:00，在时间后显示时区print(dt)utc_dt &#x3D; datetime.utcnow().replace(tzinfo&#x3D;timezone.utc)        # 拿到UTC时间，并强制设置时区为UTC+0:00print(utc_dt)bj_dt &#x3D; utc_dt.astimezone(timezone(timedelta(hours&#x3D;8)))        # astimezone()将转换时区为北京时间；通过astimezone()方法，可以转换到任意时区print(bj_dt)tokyo_dt &#x3D; utc_dt.astimezone(timezone(timedelta(hours&#x3D;9)))     # astimezone()将转换时区为东京时间print(tokyo_dt)bj_dt2 &#x3D; tokyo_dt.astimezone(timezone(timedelta(hours&#x3D;8)))     # astimezone()将tokyo_dt转换时区为北京时间print(bj_dt2)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 获取用户输入的日期和时间，以及一个时区信息，请编写一个函数将其转换为timestampimport refrom datetime import datetime, timezone, timedeltadef to_timestamp(dt_str, tz_str):    tz_timezone &#x3D; int(re.split(r&#39;[\+\:]+&#39;, tz_str)[1])              # 获取时区值    dt_datetime &#x3D; datetime.strptime(dt_str, &#39;%Y-%m-%d %H:%M:%S&#39;)    # 将字符串转换为datetime类型    dt_datetime_UTC &#x3D; dt_datetime.replace(tzinfo&#x3D;timezone(timedelta(hours&#x3D;tz_timezone)))       # 转换为UTC时间    dt_timestamp &#x3D; dt_datetime_UTC.timestamp()                      # 转换为timestamp    return dt_timestampdt_str, tz_str &#x3D; input(&#39;Please input datetime and timezone: &#39;)# dt_str, tz_str &#x3D; &#39;2022-06-28 09:38:40&#39;, &#39;UTC+8:00&#39;    # 1656380320.0dt_result &#x3D; to_timestamp(dt_str, tz_str)print(dt_result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/202206/2446563.html"/>
      <url>/202206/2446563.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录正则表达式的相关基础知识</p><span id="more"></span><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p><strong>正则表达式</strong>：由一些具有特殊含义的字符组成的字符串，多用于查找、替换符合规则的字符串</p><h2 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1. 元字符"></a>1. 元字符</h2><p><strong>元字符</strong>：有特定含义的字符，多为小写字母</p><table><thead><tr><th align="left">代码</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">.</td><td align="left">匹配除换行符以外的任意字符，如：1，n，+ 等</td></tr><tr><td align="left">\w</td><td align="left">匹配字母或数字或下划线或汉字(word)</td></tr><tr><td align="left">\s</td><td align="left">匹配任意的空白符（包括Tab、空格）</td></tr><tr><td align="left">\d</td><td align="left">匹配数字(digit)</td></tr><tr><td align="left">\b</td><td align="left">匹配单词的开始或结束(begin)</td></tr><tr><td align="left">^</td><td align="left">匹配字符串的开始（在集合字符里[^a]表示非（不匹配）的意思</td></tr><tr><td align="left">$</td><td align="left">匹配字符串的结束</td></tr></tbody></table><ul><li>^\d{5}$：匹配5位数字</li></ul><h2 id="2-反义字符"><a href="#2-反义字符" class="headerlink" title="2. 反义字符"></a>2. 反义字符</h2><p><strong>反义字符</strong>：多用于查找除某个字符以外其他任意字符均可以的情况；多为大写字符</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">\W</td><td align="left">匹配任意不是字母，数字，下划线，汉字的字符</td></tr><tr><td align="left">\S</td><td align="left">匹配任意不是空白符的字符；如：1，*</td></tr><tr><td align="left">\D</td><td align="left">匹配任意非数字的字符</td></tr><tr><td align="left">\B</td><td align="left">匹配不是单词开头或结束的位置</td></tr><tr><td align="left">[^x]</td><td align="left">匹配除了x以外的任意字符</td></tr><tr><td align="left">[^aeiou]</td><td align="left">匹配除了aeiou这几个字母以外的任意字符</td></tr></tbody></table><h2 id="3-限定字符"><a href="#3-限定字符" class="headerlink" title="3. 限定字符"></a>3. 限定字符</h2><p><strong>限定字符</strong>：多用于重复匹配次数</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*</td><td align="left">重复零次或更多次，可能为空 或 任意数字</td></tr><tr><td align="left">+</td><td align="left">重复一次或更多次，可能为1个或多个数字</td></tr><tr><td align="left">?</td><td align="left">重复零次或一次，可能为空或者任意的一个数字</td></tr><tr><td align="left">{n}</td><td align="left">重复n次，\d{8}匹配8位数字</td></tr><tr><td align="left">{n,}</td><td align="left">重复n次或更多次</td></tr><tr><td align="left">{n,m}</td><td align="left">重复n到m次</td></tr></tbody></table><h2 id="4-转义字符"><a href="#4-转义字符" class="headerlink" title="4. 转义字符"></a>4. 转义字符</h2><p><strong>转义字符</strong>：比配元字符需要进行字符转义，如元字符 . 需要转换为\. </p><h2 id="5-字符分枝"><a href="#5-字符分枝" class="headerlink" title="5. 字符分枝"></a>5. 字符分枝</h2><p><strong>字符分枝</strong>：用于满足不同情况的选择，用“|”将不同的条件分割开来，比如有些固定电话区号有三位，有些有四位，这个时候可以采用字符分枝</p><ul><li>\d{3}-\d{8}|\d{4}-\d{8} 可以匹配两种不同长度区号的固定电话</li></ul><h2 id="6-字符分组"><a href="#6-字符分组" class="headerlink" title="6. 字符分组"></a>6. 字符分组</h2><p><strong>字符分组</strong>：多用于将多个字符重复，主要通过使用小括号()来进行分组</p><ul><li>（\d\w){3} 重复匹配3次（\d\w)</li></ul><table><thead><tr><th align="left">分类</th><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">捕获</td><td align="left">(exp)</td><td align="left">匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td align="left">捕获</td><td align="left">(?&lt;name&gt;exp)</td><td align="left">匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td></tr><tr><td align="left">捕获</td><td align="left">(?:exp)</td><td align="left">匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td align="left">零宽断言</td><td align="left">(?=exp)</td><td align="left">匹配exp前面的位置</td></tr><tr><td align="left">零宽断言</td><td align="left">(?&lt;=exp)</td><td align="left">匹配exp后面的位置</td></tr><tr><td align="left">零宽断言</td><td align="left">(?!exp)</td><td align="left">匹配后面跟的不是exp的位置</td></tr><tr><td align="left">零宽断言</td><td align="left">(?&lt;!exp)</td><td align="left">匹配前面不是exp的位置</td></tr><tr><td align="left">注释</td><td align="left">(?#comment)</td><td align="left">这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</td></tr></tbody></table><h2 id="7-懒惰匹配和贪婪匹配"><a href="#7-懒惰匹配和贪婪匹配" class="headerlink" title="7. 懒惰匹配和贪婪匹配"></a>7. 懒惰匹配和贪婪匹配</h2><p><strong>贪婪匹配</strong>：匹配<strong>尽可能多</strong>的字符（默认）</p><p><strong>懒惰匹配</strong>：匹配<strong>尽可能少</strong>的字符，在限定字符后面增加？</p><table><thead><tr><th align="left">代码/语法</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">*?</td><td align="left">重复任意次，但尽可能少重复</td></tr><tr><td align="left">+?</td><td align="left">重复1次或更多次，但尽可能少重复</td></tr><tr><td align="left">??</td><td align="left">重复0次或1次，但尽可能少重复</td></tr><tr><td align="left">{n,m}?</td><td align="left">重复n到m次，但尽可能少重复</td></tr><tr><td align="left">{n,}?</td><td align="left">重复n次以上，但尽可能少重复</td></tr></tbody></table><h2 id="8-后向引用"><a href="#8-后向引用" class="headerlink" title="8. 后向引用"></a>8. 后向引用</h2><p><strong>后向引用</strong>：用于重复搜索前面某个分组匹配的文本</p><h2 id="9-零宽断言"><a href="#9-零宽断言" class="headerlink" title="9. 零宽断言"></a>9. 零宽断言</h2><p><strong>零宽断言</strong>：查找某些匹配之前或之后的东西，要用到们像\b,^,$那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，被称为零宽断言</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础-进程和线程</title>
      <link href="/202206/24891.html"/>
      <url>/202206/24891.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python的IO编程的相关知识</p><span id="more"></span><h1 id="1-进程"><a href="#1-进程" class="headerlink" title="1. 进程"></a>1. 进程</h1><p><strong>进程</strong>：对于操作系统来说，一个任务就是一个进程（Process）；如：打开一个Word就启动了一个Word进程；<strong>multiprocessing</strong> 模块通过 <strong>Process类</strong> 代表一个进程对象</p><pre class="line-numbers language-none"><code class="language-none">from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name):    print(&#39;Run child process %s (%s)...&#39; % (name, os.getpid()))if __name__&#x3D;&#x3D;&#39;__main__&#39;:    print(&#39;Parent process %s.&#39; % os.getpid())    p &#x3D; Process(target&#x3D;run_proc, args&#x3D;(&#39;test&#39;,))    print(&#39;Child process will start.&#39;)    p.start()    p.join()    print(&#39;Child process end.&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>启动大量子进程</strong></p><pre class="line-numbers language-none"><code class="language-none">from multiprocessing import Poolimport os, time, randomdef long_time_task(name):    print(&#39;Run task %s (%s)...&#39; % (name, os.getpid()))    start &#x3D; time.time()    time.sleep(random.random() * 3)    end &#x3D; time.time()    print(&#39;Task %s runs %0.2f seconds.&#39; % (name, (end - start)))if __name__&#x3D;&#x3D;&#39;__main__&#39;:    print(&#39;Parent process %s.&#39; % os.getpid())    p &#x3D; Pool(4)                                         # 设置可以同时运行的进程个数，默认大小是CPU的核数    for i in range(5):        p.apply_async(long_time_task, args&#x3D;(i,))    print(&#39;Waiting for all subprocesses done...&#39;)    p.close()                                           # 调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process    p.join()                                            # 会等待所有子进程执行完毕    print(&#39;All subprocesses done.&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import subprocess             # subprocess模块可以非常方便地启动一个子进程，然后控制其输入和输出print(&#39;$ nslookup www.python.org&#39;)r &#x3D; subprocess.call([&#39;nslookup&#39;, &#39;www.python.org&#39;])print(&#39;Exit code:&#39;, r)import subprocessprint(&#39;$ nslookup&#39;)p &#x3D; subprocess.Popen([&#39;nslookup&#39;], stdin&#x3D;subprocess.PIPE, stdout&#x3D;subprocess.PIPE, stderr&#x3D;subprocess.PIPE)output, err &#x3D; p.communicate(b&#39;set q&#x3D;mx\npython.org\nexit\n&#39;)print(output.decode(&#39;utf-8&#39;))     # 通过communicate()方法输入进程需要的内容print(&#39;Exit code:&#39;, p.returncode)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q):    print(&#39;Process to write: %s&#39; % os.getpid())    for value in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]:        print(&#39;Put %s to queue...&#39; % value)        q.put(value)        time.sleep(random.random())# 读数据进程执行的代码:def read(q):    print(&#39;Process to read: %s&#39; % os.getpid())    while True:        value &#x3D; q.get(True)        print(&#39;Get %s from queue.&#39; % value)if __name__&#x3D;&#x3D;&#39;__main__&#39;:    # 父进程创建Queue，并传给各个子进程：    q &#x3D; Queue()    pw &#x3D; Process(target&#x3D;write, args&#x3D;(q,))    pr &#x3D; Process(target&#x3D;read, args&#x3D;(q,))        pw.start()        # 启动子进程pw，写入    pr.start()        # 启动子进程pr，读取    pw.join()         # 等待pw结束    pr.terminate()    # pr进程里是死循环，无法等待其结束，只能强行终止<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-线程"><a href="#2-线程" class="headerlink" title="2. 线程"></a>2. 线程</h1><p><strong>线程</strong>：进程内的子任务称为线程（Thread），是最小的执行单元；如Word可以同时进行打字、拼写检查、打印等，<strong>一个进程至少有一个线程</strong></p><pre class="line-numbers language-none"><code class="language-none">import time, threading# 新线程执行的代码:def loop():              # 启动一个线程就是把一个函数传入并创建Thread实例    print(&#39;thread %s is running...&#39; % threading.current_thread().name)    # current_thread()，永远返回当前线程的实例    n &#x3D; 0    while n &lt; 5:        n &#x3D; n + 1        print(&#39;thread %s &gt;&gt;&gt; %s&#39; % (threading.current_thread().name, n))        time.sleep(1)    print(&#39;thread %s ended.&#39; % threading.current_thread().name)print(&#39;thread %s is running...&#39; % threading.current_thread().name)        # 何进程默认就会启动一个线程，称为主线程；主线程可以启动新的线程t &#x3D; threading.Thread(target&#x3D;loop, name&#x3D;&#39;LoopThread&#39;)                      # 在创建时可以指定子线程的名字t.start()                # 调用start()开始执行t.join()print(&#39;thread %s ended.&#39; % threading.current_thread().name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocal</strong>：用一个全局 dict 存放所有的Student对象，然后以 thread 自身作为 key 获得线程对应的Student对象；ThreadLocal 帮助自动做查找dict</p><pre class="line-numbers language-none"><code class="language-none">import threading    # 创建全局ThreadLocal对象:local_school &#x3D; threading.local()def process_student():    # 获取当前线程关联的student:    std &#x3D; local_school.student    print(&#39;Hello, %s (in %s)&#39; % (std, threading.current_thread().name))def process_thread(name):    # 绑定ThreadLocal的student:    local_school.student &#x3D; name    process_student()t1 &#x3D; threading.Thread(target&#x3D; process_thread, args&#x3D;(&#39;Alice&#39;,), name&#x3D;&#39;Thread-A&#39;)t2 &#x3D; threading.Thread(target&#x3D; process_thread, args&#x3D;(&#39;Bob&#39;,), name&#x3D;&#39;Thread-B&#39;)t1.start()t2.start()t1.join()t2.join()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>区别</strong></p><ul><li><p>多进程模式最大的优点就是稳定性高，因为一个子进程崩溃，不会影响主进程和其他子进程；（当然主进程崩溃会导致所有进程崩溃，但是Master进程只负责分配任务，崩溃概率低）；多进程模式的缺点是创建进程的代价大，在Unix/Linux系统下，用 fork 调用还行，在Windows下创建进程开销巨大；另外，操作系统能同时运行的进程数也有限；推荐使用多线程</p></li><li><p>多线程模式通常比多进程快（不明显）；由于所有线程共享进程的内存，所以任何一个线程挂掉都可能直接造成整个进程崩溃</p></li></ul><h1 id="3-异步IO"><a href="#3-异步IO" class="headerlink" title="3. 异步IO"></a>3. 异步IO</h1><p>异步IO：可以用单进程单线程模型来执行多任务（事件驱动模型）</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础-IO编程</title>
      <link href="/202206/2351064.html"/>
      <url>/202206/2351064.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python的IO编程的相关知识</p><span id="more"></span><h1 id="1-IO编程"><a href="#1-IO编程" class="headerlink" title="1. IO编程"></a>1. IO编程</h1><p><strong>IO编程</strong>：IO在计算机中指Input/Output，也就是输入和输出；从磁盘读取文件到内存，就只有Input操作；把数据写到磁盘文件里，就只是一个Output操作</p><p><strong>os模块</strong>：操作文件和目录的函数一部分放在 os 模块中，一部分放在 os.path 模块中</p><p>操作文件的流程：1、打开文件；2、读写文件；3、关闭文件</p><h2 id="1-1-打开文件"><a href="#1-1-打开文件" class="headerlink" title="1.1 打开文件"></a>1.1 打开文件</h2><p><strong>打开文件</strong>：使用Python内置的 open() 函数，可以以读文件的模式打开一个文件对象</p><p><strong>open</strong>(file_name, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)</p><ul><li><strong>file_name</strong>：文件名，允许通过绝对路径和相对路径指定文件；区分大小写</li><li><strong>mode</strong>：文件打开方式；打开时，文件指针指向文件开始位置</li></ul><blockquote><table><thead><tr><th align="center">Character</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="center">r</td><td align="left">只读，open for reading (default，默认)</td></tr><tr><td align="center">w</td><td align="left">清空写，open for writing, truncating the file first</td></tr><tr><td align="center">x</td><td align="left">新建写，如果已存在则失败；open for exclusive creation, failing if the file already exists</td></tr><tr><td align="center">a</td><td align="left">追加写，open for writing, appending to the end of the file if it exists</td></tr><tr><td align="center">b</td><td align="left">以二进制方式读写，binary mode；主要用于图片、视频、音频等</td></tr><tr><td align="center">t</td><td align="left">以文本方式读写，默认为t；text mode (default)</td></tr><tr><td align="center">+</td><td align="left">追加功能：r+ 给r增加写功能，w+ 给写增加读功能；open for updating (reading and writing)，会频繁操作文件指针（不建议）</td></tr></tbody></table><p>组合：r+、w+、a+、x+；rb、wb、ab、xb；rt、at、wt、xt</p></blockquote><ul><li><strong>encoding</strong>：字符编码，’utf-8’、’gbk’ 、’ascii’等</li><li><strong>errors</strong>：对待错误的方式</li></ul><blockquote><p><strong>strict</strong>：存在编码错误时抛出ValueError异常；默认值None具有相同的效果<br><strong>ignore</strong>：忽略错误；忽略编码错误可能会导致数据丢失<br><strong>replace</strong>：将错误编码内容替换为指定内容</p></blockquote><ul><li>其他：不常用，buffering：设置缓冲区大小</li></ul><h2 id="1-3-读写文件"><a href="#1-3-读写文件" class="headerlink" title="1.3 读写文件"></a>1.3 读写文件</h2><ul><li>读：f_name.read()：通过文件对象调用 read() 方法实现，文件指针标记读取数据开始位置，一次性将整个文件读取到内存</li><li>按行读：f_name.readline()：每次只读一行，文件指针会移动到下一行；可配合循环读取文件；readlines()读取整个文件，返回一个列表，元素是每一行的内容</li><li>写：f_name.write()：通过文件对象调用 write() 方法实现</li><li>移动指针：f_name.seek() ，将指针移动到文件的指定位置</li><li>返回位置：f_name.tell() ，以整数形式返回当前的文件位置</li></ul><pre class="line-numbers language-none"><code class="language-none">import osf &#x3D; open(&#39;C:&#x2F;Users&#x2F;tanhh&#x2F;Desktop&#x2F;Gitee&#x2F;Resource&#x2F;python_self&#x2F;test.txt&#39;, &#39;r&#39;)     # 如果文件不存在，会抛出一个IOError(FileNotFoundError)的错误# f &#x3D; open(&#39;f_path&#x2F;test.jpg&#39;, &#39;rb&#39;)  # 以二进制形式打开文件，常用于图片、视频、音频等result &#x3D; f.read()                # 调用read()方法可以一次读取文件的全部内容print(result)# result &#x3D; read(size)            # 按照一定大小读取# for line in f.readlines():     # 按行读取#     print(line.strip())        # 把末尾的&#39;\n&#39;删掉f.close()                        # 关闭文件；文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也有限<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用；可以使用try ... finally来实现无论是否出错都能正确地关闭文件try:    f &#x3D; open(&#39;&#x2F;path&#x2F;to&#x2F;file&#39;, &#39;r&#39;)    print(f.read())finally:    if f:        f.close()# method-2：简化写法，可以更容易地清理打开的⽂件with open(&#39;C:&#x2F;Users&#x2F;tanhh&#x2F;Desktop&#x2F;Gitee&#x2F;Resource&#x2F;python_self&#x2F;test.txt&#39;, &#39;r&#39;) as f:    print(f.read())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-4-关闭文件"><a href="#1-4-关闭文件" class="headerlink" title="1.4 关闭文件"></a>1.4 关闭文件</h2><ul><li>关闭：f_name.close()：方法执行后，指针移动到文件末尾；如果忘记关闭文件，会造成系统资源的消耗，还会影响后续对文件的访问</li><li>closed ：判断文件是否关闭，如果是则返回 True</li></ul><h2 id="1-5-StringIO"><a href="#1-5-StringIO" class="headerlink" title="1.5 StringIO"></a>1.5 StringIO</h2><p><strong>StringIO</strong>：在内存中读写str</p><pre class="line-numbers language-none"><code class="language-none">from io import StringIOf &#x3D; StringIO()f.write(&#39;hello&#39;)       # 返回写入的字符数f.write(&#39; world!&#39;)print(f.getvalue())    # getvalue()方法用于获得写入后的str<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读取StringIO</strong>：可以用一个str初始化StringIO，然后像读文件一样读取</p><pre class="line-numbers language-none"><code class="language-none">from io import StringIOf &#x3D; StringIO(&#39;Hello!\nHi!\nGoodbye!&#39;)while True:    s &#x3D; f.readline()    if s &#x3D;&#x3D; &#39;&#39;:        break    print(s.strip())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-6-BytesIO"><a href="#1-6-BytesIO" class="headerlink" title="1.6 BytesIO"></a>1.6 BytesIO</h2><p><strong>BytesIO</strong>：在内存中操作二进制数据</p><pre class="line-numbers language-none"><code class="language-none">from io import BytesIOf &#x3D; BytesIO()f.write(&#39;中文&#39;.encode(&#39;utf-8&#39;))print(f.getvalue())                    # 返回二进制print(f.getvalue().decode(&#39;utf-8&#39;))    # 解码返回中文<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读取BytesIO</strong>：与 StringIO 类似</p><pre class="line-numbers language-none"><code class="language-none">from io import BytesIOf &#x3D; BytesIO(b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;)f.read()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="1-7-操作文件和目录"><a href="#1-7-操作文件和目录" class="headerlink" title="1.7 操作文件和目录"></a>1.7 操作文件和目录</h2><pre class="line-numbers language-none"><code class="language-none">import osprint(os.name)        # 如果是posix，说明系统是Linux、Unix或Mac OS X；如果是nt，就是Windows系统# print(os.uname())   # uname()函数在Windows上不提供；os模块的某些函数与操作系统相关print(os.environ)     # 查看系统环境变量，返回字典print(os.environ.get(&#39;Path&#39;))   # 查看具体环境变量的值print(os.path.abspath(&#39;.&#39;))     # 查看当前目录的绝对路径print(os.path.join(&#39;&#x2F;Users&#x2F;michael&#39;, &#39;testdir&#39;))   # 在某个目录下创建一个新目录，把新目录的完整路径表示出来（把两个路径合成一个，返回字符串）；在Linux&#x2F;Unix&#x2F;Mac下，os.path.join()返回：part-1&#x2F;part-2；而Windows下会返回：part-1\part-2print(os.path.split(&#39;C:&#x2F;Users&#x2F;tanhh&#x2F;Desktop&#x2F;Gitee&#x2F;Resource&#x2F;python_self&#x2F;test.txt&#39;))        # 拆分路径，返回字符串和文件名（包括扩展名）元组print(os.path.splitext(&#39;C:&#x2F;Users&#x2F;tanhh&#x2F;Desktop&#x2F;Gitee&#x2F;Resource&#x2F;python_self&#x2F;test.txt&#39;))     # 拆分文件扩展名，返回文件名（包括路径）和文件扩展名元组os.mkdir(&#39;.&#x2F;testdir&#39;)              # 然后创建一个目录os.listdir(&#39;.&#x2F;testdir&#39;)            # 查看目录内容，返回列表os.chdir(&#39;target_dir_name&#39;)        # 切换工作目录os.rmdir(&#39;.&#x2F;testdir&#39;)              # 删掉一个目录os.rename(&#39;test.txt&#39;, &#39;test.py&#39;)   # 对文件重命名os.remove(&#39;test.py&#39;)               # 删掉文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import osprint([x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)])            # 获取当前文件夹下的所有文件夹名称print([x for x in os.listdir(&#39;.&#39;) if os.path.isfile(x) and os.path.splitext(x)[1]&#x3D;&#x3D;&#39;.py&#39;])            # 获取当前文件夹下的所有 .py文件的文件名称<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径import osdir_list &#x3D; [x for x in os.listdir(&#39;.&#39;) if os.path.isdir(x)]file_list &#x3D; []relative_path_list &#x3D; []for x in dir_list:    for y in os.listdir(x):        if os.path.splitext(y)[1]&#x3D;&#x3D;&#39;.py&#39;:            file_list.append(y)            relative_path_list.append(os.path.join(&#39;.&#39;, x, y))print(file_list)print(relative_path_list)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-8-序列化"><a href="#1-8-序列化" class="headerlink" title="1.8 序列化"></a>1.8 序列化</h2><p><strong>序列化</strong>：把变量从内存中变成可存储或传输的过程，在Python中叫 <strong>pickling</strong> ，在其他语言中被称为serialization，marshalling，flattening等；序列化之后，可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上<br><strong>反序列化</strong>：把变量内容从序列化的对象重新读到内存里</p><pre class="line-numbers language-none"><code class="language-none">import pickle                  # 实现序列化d &#x3D; dict(name&#x3D;&#39;Bob&#39;, age&#x3D;20, score&#x3D;88)print(pickle.dumps(d))         # 把任意对象序列化成一个bytes，然后把这个bytes写入文件f &#x3D; open(&#39;test.txt&#39;, &#39;wb&#39;)pickle.dump(d, f)              # 直接把对象序列化后写入一个file-like Objectf.close()d_result_loads &#x3D; pickle.loads(b&#39;\x80\x04\x95$\x00\x00\x00\x00\x00\x00\x00&#125;\x94(\x8c\x04name\x94\x8c\x03Bob\x94\x8c\x03age\x94K\x14\x8c\x05score\x94KXu.&#39;)     # 反序列化出对象print(d_result_loads)f &#x3D; open(&#39;test.txt&#39;, &#39;rb&#39;)d_result &#x3D; pickle.load(f)      # 从一个file-like Object中直接反序列化出对象f.close()print(d_result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>如果要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，如XML、JSON</strong>，推荐使用 JSON ，JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输；并且比XML更快，可以直接在Web页面中读取</p><pre class="line-numbers language-none"><code class="language-none">import jsond &#x3D; dict(name&#x3D;&#39;Bob&#39;, age&#x3D;20, score&#x3D;88)print(json.dumps(d))             # dumps() 返回一个str，内容是标准的JSON；dump() 直接把JSON写入一个file-like Objectjson_str &#x3D; &#39;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#39;print(json.loads(json_str))      # loads() 把JSON的字符串反序列化，load() 从file-like Object中读取字符串并反序列化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import jsonclass Student(object):    def __init__(self, name, age, score):        self.name &#x3D; name        self.age &#x3D; age        self.score &#x3D; scoredef student2dict(std):              # 为Student专门写一个转换函数，将Student转换成可序列化的JSON对象    return &#123;        &#39;name&#39;: std.name,        &#39;age&#39;: std.age,        &#39;score&#39;: std.score    &#125;s &#x3D; Student(&#39;Bob&#39;, 20, 88)print(json.dumps(s, default&#x3D;student2dict))    # 可选参数default就是把任意一个对象变成一个可序列为JSON的对象# print(json.dumps(s, default&#x3D;lambda obj: obj.__dict__))    # 通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量def dict2student(d):    return Student(d[&#39;name&#39;], d[&#39;age&#39;], d[&#39;score&#39;])json_str &#x3D; &#39;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#39;print(json.loads(json_str, object_hook&#x3D;dict2student))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础-面向对象编程</title>
      <link href="/202206/2024645.html"/>
      <url>/202206/2024645.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python的面向对象编程基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>面向对象编程</strong>：Object Oriented Programming，简称OOP；把计算机程序视为一组对象的集合，一个对象包含数据和操作数据的函数，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递；自定义的对象数据类型就是面向对象中的 <strong>类（Class）</strong>的概念；给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的 <strong>方法（Method）</strong></p><blockquote><p>面向对象最重要的概念就是<strong>类（Class）</strong>和<strong>实例（Instance）</strong>：<br><strong>类</strong> 是抽象的模板，是一类具有相同特征和行为的事务，类拥有的属性（特征）和方法（行为）<br><strong>实例</strong> 是根据类创建出来具体存在，每个对象都拥有相同的属性和方法，但各自的属性值可能不同</p></blockquote><p><strong>面向过程编程</strong>：Procedure Oriented Programming，简称POP；把计算机程序视为一系列的命令集合，即一组函数的顺序执行；为简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度</p><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><h2 id="2-1-自定义"><a href="#2-1-自定义" class="headerlink" title="2.1 自定义"></a>2.1 自定义</h2><pre class="line-numbers language-none"><code class="language-none"># 处理学生的成绩表class Student(object):                  # class关键字申明类，后面紧接着类名 c_name,类名通常是大写开头的单词；紧接着是(object)，表示该类是继承哪个类（如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类），继承object的类成为新式类（旧式类不继承object，python3 解释器默认定义新式类）    def __init__(self, name, score):    # 重写父类的__init__方法把必须绑定的属性强制填写进去，第一个参数永远是self，表示创建的实例本身，把各种属性绑定到self；有了__init__方法，在创建实例的时候，就不能传入空的属性参数        self.name &#x3D; name                # Student类拥有name和score这两个类属性        self.score &#x3D; score    def print_score(self):        # 处理成绩的方法；类定义中的函数第一个参数永远是self：表示实例对象本身；调用时不用传递该参数，可以通过 self. 调用对象的属性和方法        print(&#39;%s: %s&#39; % (self.name, self.score))bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)        # 创建实例：通过类名+()实现，有__init__方法，必须在创建实例对象时同时给类属性赋值# class Student(object):      def print_score(self):          print(&#39;%s: %s&#39; % (self.name, self.score))# bart &#x3D; Student()                        # 先创建实例，无__init__方法，可以随后再给实例对象新增实例属性并进行赋值# bart.name &#x3D; &#39;Bart Simpson&#39;# bart.score &#x3D; 59bart.print_score()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-1-封装"><a href="#2-1-1-封装" class="headerlink" title="2.1.1 封装"></a>2.1.1 封装</h3><p><strong>封装</strong>：将属性和方法封装到一个类中</p><h4 id="2-1-1-1-实例属性与类属性"><a href="#2-1-1-1-实例属性与类属性" class="headerlink" title="2.1.1.1 实例属性与类属性"></a>2.1.1.1 实例属性与类属性</h4><p><strong>类属性</strong>：给类对象定义的属性，记录与类相关的属性，通过 c_name.attr_name 进行调用（建议），也可以通过 instance_name.attr_name 调用（向上查找机制，先找实例属性，在查找类属性）<br><strong>实例属性</strong>：直接在class中通过 __init__ 方法定义的属性，类的所有实例都可以访问到，对具体对象实例申明的属性，仅本实例可以使用</p><pre class="line-numbers language-none"><code class="language-none">class Student(object):    student_count &#x3D; 0               # 类属性，记录实例对象的数量    def __init__(self, name):       # 初始化方法，用来定义实例属性        self.name &#x3D; name            # 实例属性，所有由Student类进行实例化创建的对象都有 name属性        Student.student_count +&#x3D; 1  # 修改类属性的值s &#x3D; Student(&#39;Bob&#39;)s.score &#x3D; 90                     # 实例属性，仅Student类的实例化对象s有 score属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 实例属性优先级比类属性高，针对同一个属性，实例属性会屏蔽掉类属性class Student(object):    name &#x3D; &#39;Student&#39;s &#x3D; Student()print(s.name)             # 输出 Student，可以通过 print(Student.name) 打印类的name属性s.name &#x3D; &#39;Student_s&#39;print(s.name)             # 输出 Student_s，实例属性屏蔽覆盖掉类属性del s.name                # 删除实例的name属性print(s.name)             # 输出Student，再次调用s.name，由于实例的name属性没有找到，就显示类的name属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-1-2-绑定方法"><a href="#2-1-1-2-绑定方法" class="headerlink" title="2.1.1.2 绑定方法"></a>2.1.1.2 绑定方法</h4><p><strong>类方法</strong>：访问使用类属性，需要用 <strong>@classmethod</strong> 来标识，且第一个参数是 cls（习惯，表示类的引用），可以通过 cls. 访问类属性或调用类方法</p><p><strong>实例方法</strong>：访问使用实例属性，第一个参数是 self</p><p><strong>静态方法</strong>：既不需要访问实例属性，也不需要访问类属性的方法；需要使用 <strong>@staticmethod</strong> 来标识，不需要传递第一个参数（参数cls、self）</p><pre class="line-numbers language-none"><code class="language-none">class Game(object):    top_score &#x3D; 0    def __init__(self, player_name):        self.player_name &#x3D; player_name    @classmethod                    # 定义类方法    def show_top_score(cls):        print(&quot;历史最高分: %d&quot; % Game.top_score)    @staticmethod                   # 定义静态方法    def show_help():        print(&#39;Show help.&#39;)    def play_game(self):        print(&#39;%s start play.&#39; % self.player_name)Game.show_help()Game.show_top_score()player_xm &#x3D; Game(&#39;xm&#39;)player_xm.play_game()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>实例绑定</strong></p><pre class="line-numbers language-none"><code class="language-none">class Student(object):    passdef set_age(self, age):              # 定义一个函数作为实例方法    self.age &#x3D; ages &#x3D; Student()from types import MethodTypes.set_age &#x3D; MethodType(set_age, s)    # 前后都相同实例，给s实例绑定方法set_age,仅对当前实例有用s.set_age(25)      # 调用实例方法print(s.age)       # 测试结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>类绑定</strong></p><pre class="line-numbers language-none"><code class="language-none">def set_score(self, score):    self.score &#x3D; scoreStudent.set_score &#x3D; set_score     # 给类绑定方法s.set_score(100)s2 &#x3D; Student()s2.set_score(99)                  # 所有Student类的实例都可以调用print(s.score, s2.score)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**_<em>slots</em><em>**：限制类允许添加的属性；仅对当前类实例起作用，对继承的子类不起作用，如果在子类中也定义 __slots__，则子类实例允许定义的属性就是自身的 __slots_</em> 加上父类的 _<em>slots</em>_</p><pre class="line-numbers language-none"><code class="language-none">class Student(object):    __slots__ &#x3D; (&#39;name&#39;, &#39;age&#39;)  # 用tuple定义允许绑定的属性名称，只允许对Student实例添加name和age属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="2-1-1-3-私有属性和私有方法"><a href="#2-1-1-3-私有属性和私有方法" class="headerlink" title="2.1.1.3 私有属性和私有方法"></a>2.1.1.3 私有属性和私有方法</h4><p><strong>私有属性</strong>：对象不希望公开的属性；<strong>私有方法</strong>：对象不希望公开的方法；通过 __ 表示，如：__name</p><pre class="line-numbers language-none"><code class="language-none">class Women(object):    def __init__(self, name, age):        self.name &#x3D; name        self.__age &#x3D; age    def tell_age(self):         # 在类定义内部，可以使用私有方法        print(&#39;%s的年龄是%d&#39; % (self.name, self.__age))        def __secret(self):        print(&#39;%s的年龄是%d&#39; % (self.name, self.__age))women_xf &#x3D; Women(&#39;xf&#39;, 18)# print(women_xf.__age)         # 私有属性不能在类定义外部使用women_xf.tell_age()women_xf.__secret()             # 私有方法也不能在类定义外部使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 不要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，变成私有变量（private）class Student(object):    def __init__(self, name, score):        self.__name &#x3D; name          # 私有变量，不能在外部进行访问和修改        self.__score &#x3D; score        # 变量名类似__xxx__的，以双下划线开头，以双下划线结尾的变量是特殊变量，可以直接访问，不是private变量        def get_name(self):             # 通过自定义get_name、get_score函数获取私有变量        return self.__name    def get_score(self):        return self.__score    def set_name(self, name):       # 通过自定义set_name、set_score函数修改私有变量        self.__name &#x3D; name    def set_score(self, score):        if 0 &lt;&#x3D; score &lt;&#x3D; 100:            self.__score &#x3D; score        else:            raise ValueError(&#39;error score!&#39;)bart &#x3D; Student(&#39;Bart Simpson&#39;, 59)bart.__name &#x3D; &#39;New Name&#39;            # 并没有修改内部的 __name，而是给 bart对象新增了一个 __name变量；内部__name变量被Python解释器自动改成 _Student__name, 可通过该变量进行修改(不建议、不同解释器会改成不同的变量名)print(bart.__name)       # 返回 New Nameprint(bart.get_name())   # 返回 Bart Simpson<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>python中不存在真正的私有，python解释器针对私有属性和私有方法进行处理：在属性和方法名前增加 _类名，可以通过 <strong>_类名__属性名</strong> 或者 <strong>_类名__方法名</strong> 进行调用，不建议使用</p><pre class="line-numbers language-none"><code class="language-none">print(women_xf._Women__age)women_xf._Women__secret()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><h3 id="2-1-2-继承"><a href="#2-1-2-继承" class="headerlink" title="2.1.2 继承"></a>2.1.2 继承</h3><p><strong>继承</strong>：实现代码的复用，定义一个class时，可以从某个现有的class继承，新的class称为子类（Subclass）、派生类，被继承的class称为基类、父类或超类（Base class、Super class）；子类拥有父类所有的属性和方法，<strong>继承具有传递性</strong>：子类拥有父类所有的属性和方法，还拥有父类拥有父类所有的属性和方法</p><pre class="line-numbers language-none"><code class="language-none">class Animal(object):    def __init__(self, name):        self.name &#x3D; name        # self.__name &#x3D; name      # 无法继承父类的私有属性和私有方法        def run(self):        # print(&#39;%s is running.&#39; % self.__name)        return self.name + &#39; is running.&#39;class Cat(Animal):                # Dog类继承自Animal类，自动拥有 __name 属性和 run()方法    passclass Dog(Animal):    def run(self):                # 重写父类方法，优先查找子类，后查找父类        return &#39;Hello &#39; + self.name + &#39;! Keep running.&#39;dog_ani &#x3D; Animal(&#39;Wangwang&#39;)cat_c &#x3D; Cat(&#39;Mimi&#39;)dog_d &#x3D; Dog(&#39;Wangcai&#39;)print(dog_ani.run())print(cat_c.run())print(dog_d.run())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多重继承</strong>：一个子类就可以同时获得多个父类的所有功能；在设计类的继承关系时，通常主线都通过单一继承下来；如果需要增加额外的功能，可以通过多重继承实现，通常称之为MixIn；MixIn的目的就是给一个类增加多个功能；<strong>优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系</strong>；多重继承时，如果多个父类含有重名的方法，则子类调用最左边父类的方法，可调用 <strong>son_c.__mro__</strong> 内置类属性查看</p><pre class="line-numbers language-none"><code class="language-none">class Land_Animals(object):    def land_breathe(self):        print(&#39;Breathe on land.&#39;)class Aquatic_Animals(object):    def water_breathe(self):        print(&#39;Breathe in water.&#39;)class Frog(Land_Animals, Aquatic_Animals):    passfrog_f &#x3D; Frog()frog_f.land_breathe()frog_f.water_breathe()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-1-继承方法重写"><a href="#2-1-2-1-继承方法重写" class="headerlink" title="2.1.2.1 继承方法重写"></a>2.1.2.1 继承方法重写</h4><p><strong>方法重写</strong>：父类的方法实现不能满足子类的需求，可以在子类中重新编写父类的方法实现，在子类中定义一个和父类同名的方法，并实现</p><p><strong>super</strong>：是一个特殊的类，使用 super() 调用 super类创建的对象，<strong>super().fa_fun()</strong> 用来调用父类的方法；通常在子类重写父类方式时进行调用，实现父类的方法实现，同时在其他位置增加子类的特有的方法实现，也可以通过 <strong>fa_c.fa_fun(self)</strong> 在子类中调用父类的方法，在早期版本不支持 super</p><pre class="line-numbers language-none"><code class="language-none">class Animal(object):    def eat(self):        print(&#39;Animal can eat.&#39;)class Dog(Animal):    def bark(self):        print(&#39;Dog can bark.&#39;)class XiaoTianQuan(Dog):    def fly(self):        print(&#39;XiaoTianQuan can fly&#39;)    def bark(self):             # 对父类的bark进行重写        print(&#39;I can speak.&#39;)    def eat(self):        super().eat()           # 通过super对父类方法进行扩展        print(&#39;XiaoTianQuan can eat monster.&#39;)xiaotian &#x3D; XiaoTianQuan()xiaotian.eat()xiaotian.bark()xiaotian.fly()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过来说，子类不能继承父类的私有属性和私有方法；子类可以调用父类的共有属性和公有方法，父类的公有方法可以调用父类的私有属性和私有方法；通过在子类中调用父类的公有方法实现访问父类的私有属性和私有方法</p><h3 id="2-1-3-多态"><a href="#2-1-3-多态" class="headerlink" title="2.1.3 多态"></a>2.1.3 多态</h3><p><strong>多态</strong>：不同子类对象调用相同的父类方法，产生不同的结果；可以增加代码的灵活度</p><h3 id="2-1-4-获取对象信息"><a href="#2-1-4-获取对象信息" class="headerlink" title="2.1.4 获取对象信息"></a>2.1.4 获取对象信息</h3><p>**dir(value)**：获得一个对象的所有属性和方法，返回一个包含字符串的list；可配合 getattr()、setattr()、hasattr()，直接操作一个对象</p><pre class="line-numbers language-none"><code class="language-none">class MyObject(object):    def __init__(self):        self.x &#x3D; 9        def power(self):        return self.x * self.xobj &#x3D; MyObject()print(hasattr(obj, &#39;x&#39;))  # 判断 obj对象 是否有 x 属性setattr(obj, &#39;y&#39;, 19)     # 新增一个属性&#39;y&#39;，值为 19print(dir(obj))           # 返回 obj对象 的所有属性和方法print(getattr(obj, &#39;y&#39;))  # 获取不存在的属性，会抛出AttributeError的错误; 可以设置默认值:getattr(obj, &#39;z&#39;, 404):获取属性&#39;z&#39;，如果不存在，返回默认值404; fn &#x3D; getattr(obj, &#39;power&#39;):获取属性&#39;power&#39;并赋值到变量fn<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-5-类内置属性和方法"><a href="#2-1-5-类内置属性和方法" class="headerlink" title="2.1.5 类内置属性和方法"></a>2.1.5 类内置属性和方法</h3><ul><li>**__new__**：方法，创建对象时，自动调用；为对象分配内存空间</li><li>**__init__**：方法，对象初始化时，自动调用；用来定义一个类具有的属性</li><li>**__del__**：方法，对象从内存中销毁时，自动调用<blockquote><p>注：更多内容查看下文定制类</p></blockquote></li></ul><h3 id="2-1-6-property"><a href="#2-1-6-property" class="headerlink" title="2.1.6 @property"></a>2.1.6 @property</h3><p><strong>@property</strong>：把一个方法变成属性调用；把一个getter方法变成属性，只需要加上 @property 就可以；此时，@property 又创建了一个装饰器 xxx.setter ，负责把setter方法变成属性赋值</p><pre class="line-numbers language-none"><code class="language-none">class Student(object):    @property    def score(self):        return self._score    @score.setter    def score(self, value):        if not isinstance(value, int):            raise ValueError(&#39;score must be an integer!&#39;)        if value &lt; 0 or value &gt; 100:            raise ValueError(&#39;score must between 0 ~ 100!&#39;)        self._score &#x3D; values &#x3D; Student()s.score &#x3D; 60            # OK，实际转化为s.set_score(60)print(s.score)          # OK，实际转化为s.get_score()# s.score &#x3D; 9999        # 报ValueError<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-定制类"><a href="#2-2-定制类" class="headerlink" title="2.2 定制类"></a>2.2 定制类</h2><p><strong>定制类</strong>：通过有特殊用途的函数，帮助我们完成类的定制，实现某些特定功能</p><ul><li>**__new__()**：为对象分配内存空间；重写 __new__ 方法一定要返回 **super().__new__(cls)**，__new__ 是一个静态方法，在调用时一定要传递 cls 参数</li></ul><pre class="line-numbers language-none"><code class="language-none">class MusicPlayer(object):    def __new__(cls, *args, **kwargs):        instance &#x3D; super().__new__(cls)        return instance    def __init__(self):        print(&#39;Initialization.&#39;)wangyi &#x3D; MusicPlayer()print(wangyi)# 单例类：只生成一个实例，即对同一个类的不同实例对象只返回一个内存地址class MusicPlayer(object):    instance &#x3D; None      # 记录第一个对象的引用    def __new__(cls, *args, **kwargs):        if MusicPlayer.instance is None:            MusicPlayer.instance &#x3D; super().__new__(cls)        return MusicPlayer.instance    def __init__(self):        print(&#39;Initialization.&#39;)wangyi &#x3D; MusicPlayer()qq &#x3D; MusicPlayer()print(wangyi)print(qq)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**__str__()<strong>：定义类实例打印模块，返回对象的描述信息（必须返回字符串），与 print函数配合使用，面向用户；</strong>__repr__()**：面向程序开发者，二者代码都是一样的</li></ul><pre class="line-numbers language-none"><code class="language-none">class Student(object):    def __init__(self, name):        self.name &#x3D; name        def __str__(self):        return &#39;Student object (name: %s)&#39; % self.name     # 必须返回字符串        __repr__ &#x3D; __str__        # 简单写法，也可重新定义一个 __repr__print(Student(&#39;Michael&#39;))     # 输出 Student object (name: Michael)；如果不定义__str__()，则print会输出 &lt;__main__.Student object at 0x000001F6EC352370&gt;：表示有一个Student类，且Student类的内存地址为0x000001F6EC352370<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>**__iter__()**：返回一个可迭代对象类，被用于 for … in 循环；调用 <strong>__next__()</strong> 方法拿到循环的下一个值</p><pre class="line-numbers language-none"><code class="language-none">class Fib(object):    def __init__(self):        self.a, self.b &#x3D; 0, 1                       # 初始化两个计数器a，b    def __iter__(self):        return self                                 # 实例本身就是迭代对象，故返回自己    def __next__(self):        self.a, self.b &#x3D; self.b, self.a + self.b    # 计算下一个值        if self.a &gt; 100000:                         # 退出循环的条件            raise StopIteration()        return self.a                               # 返回下一个值for n in Fib():    print(n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>**__getitem__()**：Fib实例虽然能作用于for循环，但还是不能把它当成list来使用，无法直接获取某个元素，也无法进行切片操作</p></li></ul><pre class="line-numbers language-none"><code class="language-none">class Fib(object):    def __getitem__(self, n):        if isinstance(n, int):      # n是索引，获取指定值            a, b &#x3D; 1, 1            for x in range(n):                a, b &#x3D; b, a + b            return a        if isinstance(n, slice):    # n是切片，进行切片            start &#x3D; n.start            stop &#x3D; n.stop            if start is None:                start &#x3D; 0            a, b &#x3D; 1, 1            L &#x3D; []            for x in range(stop):                if x &gt;&#x3D; start:                    L.append(a)                a, b &#x3D; b, a + b            return Lf &#x3D; Fib()print(f[2])print(f[0:5])# 仍然存在缺陷，没有对step参数和负数作处理；对应的还有__setitem__()方法：把对象视作list或dict来对集合赋值；__delitem__()方法：删除某个元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**__getattr__()**：返回动态类的一个属性，属性不存在于 <strong>__init__()</strong> 时调用</li></ul><pre class="line-numbers language-none"><code class="language-none">class Student(object):    def __init__(self):        self.name &#x3D; &#39;Michael&#39;    def __getattr__(self, attr):        if attr&#x3D;&#x3D;&#39;score&#39;:            return 99        if attr&#x3D;&#x3D;&#39;age&#39;:               # 也可以返回函数，调用方式要变为函数调用            return lambda: 25        raise AttributeError(&#39;\&#39;Student\&#39; object has no attribute \&#39;%s\&#39;&#39; % attr)    # 只对定义的属性响应，定义外的属性仍然抛出 AttributeError；未定义就返回 __getattr__() 的默认返回值 Nones &#x3D; Student()print(s.name)print(s.score)print(s.age())print(s.abc)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**__call__()**：通常调用实例方法时，通过 <strong>instance.method()</strong> 来调用；可以通过定义一个 __call__()方法，直接对实例进行调用</li></ul><pre class="line-numbers language-none"><code class="language-none">class Student(object):    def __init__(self, name):        self.name &#x3D; name    def __call__(self):      # 还可以定义参数。直接调用实例进行与函数调用一样，传入参数        print(&#39;My name is %s.&#39; % self.name)s &#x3D; Student(&#39;Michael&#39;)s()            # self参数不需要传入<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.python.org/3/reference/datamodel.html#special-method-names"><font face = "微软雅黑" color = 1E90FF size = 5>定制类官方文档</font></a></p><h2 id="2-3-枚举类"><a href="#2-3-枚举类" class="headerlink" title="2.3 枚举类"></a>2.3 枚举类</h2><p><strong>枚举类</strong>：存储枚举的常量的类，有特殊用途的函数，可以帮助我们定制类</p><pre class="line-numbers language-none"><code class="language-none">from enum import EnumMonth &#x3D; Enum(&#39;Month&#39;, (&#39;Jan&#39;, &#39;Feb&#39;, &#39;Mar&#39;, &#39;Apr&#39;, &#39;May&#39;, &#39;Jun&#39;, &#39;Jul&#39;, &#39;Aug&#39;, &#39;Sep&#39;, &#39;Oct&#39;, &#39;Nov&#39;, &#39;Dec&#39;))    # 创建Month类型的枚举类print(Month)                           # 打印实例print(Month.__members__)               # 打印元素print(Month.__members__.items())       # 打印元素，字典形式print(Month.__members__.keys())        # 打印属性，字典形式print(Month.__members__.values())      # 打印属性值，字典形式；value属性则是自动赋给成员的int常量，默认从1开始计数for name, member in Month.__members__.items():    print(name, &#39;&#x3D;&gt;&#39;, member, &#39;,&#39;, member.value)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">from enum import Enum, unique@unique                 # @unique装饰器可以保证没有重复值class Weekday(Enum):    Sun &#x3D; 0             # Sun的value被设定为0    Mon &#x3D; 1    Tue &#x3D; 2    Wed &#x3D; 3    Thu &#x3D; 4    Fri &#x3D; 5    Sat &#x3D; 6print(Weekday.Tue)            # 根据属性取值，返回 Weekday.Tueprint(Weekday[&#39;Tue&#39;])         # 根据key取值，返回 Weekday.Tueprint(Weekday.Tue.value)      # 获取属性对应值，返回 2print(Weekday(1))             # 根据值获取属性，返回 Weekday.Mon；Weekday(7)，值不在定义内，会报 ValueErrorday1 &#x3D; Weekday.Monprint(day1)                   # 可以给其他变量赋值，返回 Weekday.Monprint(day1 &#x3D;&#x3D; Weekday(1))     # 可以进行比较，返回 True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python模块-re</title>
      <link href="/202204/2424494.html"/>
      <url>/202204/2424494.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python模块-re-的基础知识</p><span id="more"></span><h1 id="re"><a href="#re" class="headerlink" title="re"></a>re</h1><p><strong>re</strong>：包含所有正则表达式的所有功能</p><pre class="line-numbers language-none"><code class="language-none">import reprint(re.match(r&#39;^\d&#123;3&#125;\-\d&#123;3,8&#125;$&#39;, &#39;010-12345&#39;))     # 判断是否匹配，如果匹配成功，返回一个Match对象，否则返回None# case-mathimport rechar_input &#x3D; input(&#39;Please input few chars: &#39;)print(char_input)if re.match(r&#39;[0-9a-zA-Z\_]+&#39;, char_input):    print(&#39;ok&#39;)else:    print(&#39;failed&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import reprint(re.split(r&#39;[\s\,\;]+&#39;, &#39;a,b;; c  d&#39;))   # 切分字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>分组</strong>：用()表示的就是要提取的分组（Group），用于提取子串</p><pre class="line-numbers language-none"><code class="language-none">import rem &#x3D; re.match(r&#39;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#39;, &#39;010-12345&#39;)print(m.group(0))           # group(0)是与整个正则表达式相匹配的字符串print(m.group(1))           # group(1)、group(2)……表示第1、2、……个子串print(m.group(2))t &#x3D; &#39;19:05:30&#39;m &#x3D; re.match(r&#39;^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$&#39;, t)print(m.groups())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>贪婪匹配</strong>：默认贪婪匹配，匹配尽可能多的字符</p><pre class="line-numbers language-none"><code class="language-none">re.match(r&#39;^(\d+)(0*)$&#39;, &#39;102300&#39;).groups()     # 贪婪匹配re.match(r&#39;^(\d+?)(0*)$&#39;, &#39;102300&#39;).groups()    # 非贪婪匹配<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>编译</strong>：编译正则表达式，如果正则表达式的字符串本身不合法，会报错；用编译后的正则表达式去匹配字符串</p><pre class="line-numbers language-none"><code class="language-none">import rere_telephone &#x3D; re.compile(r&#39;^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$&#39;)       # 编译，编译后生成Regular Expression对象print(re_telephone.match(&#39;010-12345&#39;).groups())         # 使用print(re_telephone.match(&#39;010-8086&#39;).groups())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import redef clean_strings(strings):    result &#x3D; []    for value in strings:        # 去除前后两段的空格        value &#x3D; value.strip()        # 去除特殊字符        value &#x3D; re.sub(&quot;[!#?]&quot;, &quot;&quot;, value)        # 转换成标题格式        value &#x3D; value.title()        result.append(value)    return resultstates &#x3D; [&quot;   Alabama &quot;, &quot;Georgia!&quot;, &quot;Georgia&quot;, &quot;georgia&quot;, &quot;FlOrIda&quot;,          &quot;south   carolina##&quot;, &quot;West virginia?&quot;]states_c &#x3D; clean_strings(states)print(states_c)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 模块 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全管理实践-Ranger</title>
      <link href="/202203/1636719.html"/>
      <url>/202203/1636719.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍 数据安全管理实践-Ranger 的相关内容</p><span id="more"></span><h1 id="Ranger"><a href="#Ranger" class="headerlink" title="Ranger"></a>Ranger</h1><p><strong>Ranger</strong>：是 Hadoop 平台之上操作、监控、管理数据安全的集中式安全管理框架，可以细化到字段，通过访问控制策略提供一套标准的授权方法，提供集中式组件，用于审计用户的访问行为和管理组件之间的安全交互<br><a href="http://ranger.apache.org/"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></p><p>RBAC授权原则</p><h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h2><h3 id="1-1-核心组件"><a href="#1-1-核心组件" class="headerlink" title="1.1 核心组件"></a>1.1 核心组件</h3><ul><li><strong>UserSync</strong>：定期将 Unix 系统或者 LDAP 、Active Directory 中的用户/组同步到 RangerAdmin 中，可用作 RangerAdmin 的身份验证服务器，以使用 Linux 用户/密码登录到 RangerAdmin<blockquote><p>LDAP：全称 Light Directory Access Protocol，基于 x500标准 的轻量级目录访问协议<br>Active Directory：是微软 Windows Server 中负责架构中大型网路环境的集中式目录管理服务，处理在组织中的网路物件，包括计算机、用户、群组、组织单元(OU)等</p></blockquote></li><li><strong>RangerAdmin Server</strong>：简称 RangerAdmin，用于管理安全策略、用户/组的门户，并提供 Rest Server</li><li><strong>Agent Plugin</strong>：插件是嵌入到 Hadoop 各个组件的轻量级 Java 程序，定期从 AdminServer 拉取策略，存储在本地文件中；当用户访问 Hadoop 组件时，插件会拦截请求根据策略进行安全评估，并且定期发送数据到审计服务器做记录</li></ul><h3 id="1-2-核心特性"><a href="#1-2-核心特性" class="headerlink" title="1.2 核心特性"></a>1.2 核心特性</h3><ul><li>集中管理：在 中央UI 或使用 REST API 管理所有与安全相关的业务</li><li>精细授权：使用 Hadoop 组件/工具执行特定动作或操作，细化到字段，并通过集中管理工具进行管理</li><li>标准化支持 Hadoop 组件的授权方法</li><li>支持不同授权方法：包括基于角色的访问控制，基于属性的访问控制，基于 Tag 的访问控制（需结合 Atlas）</li><li>集中审计用户访问和管理操作</li><li>支持和 Kerberos 的集成</li></ul><h2 id="2-安全方案"><a href="#2-安全方案" class="headerlink" title="2. 安全方案"></a>2. 安全方案</h2><h3 id="2-1-Kerberos"><a href="#2-1-Kerberos" class="headerlink" title="2.1 Kerberos"></a>2.1 Kerberos</h3><p><strong>Kerberos</strong>：开源常用方案，业界常用，非侵入式</p><ul><li><p><strong>组件</strong></p><blockquote><p>KDC：Kerberos 的服务器程序，用于验证各个模块<br>Client：需要访问服务的用户，kDC 和 Service 会对用户身份进行认证<br>Service：集成了 Kerberos 的服务，如 Hive、YARN、HBase</p></blockquote></li><li><p><strong>验证过程</strong></p><blockquote><ol><li>Client 向 KDC 申请 TGT( Ticket Granting Ticket，认购权，判断是否有资格进行权限操作的权限)</li><li>Client 通过获得的 TGT 向 KDC 申请用于访问 Service 的 Ticket</li><li>Client 用返回的 Ticket 访问 Service</li></ol></blockquote></li><li><p>优点</p><blockquote><ol><li>服务认证，方式 broker、datanode、regionserver 等组件冒充加入集群</li><li>解决了服务端到服务端、客户端到服务端的认证</li></ol></blockquote></li><li><p>缺点</p><blockquote><ol><li>使用临时的 Ticket，认证信息会失效，重新认证频繁</li><li>智能控制服务级别的访问，粒度较组</li></ol></blockquote></li></ul><h3 id="2-2-Apache-Sentry"><a href="#2-2-Apache-Sentry" class="headerlink" title="2.2 Apache Sentry"></a>2.2 Apache Sentry</h3><p><strong>Apache Sentry</strong>：是 Hadoop 之上基于角色的细粒度授权模块，为经过验证的用户和应用程序提供数据访问进行授权，Cloudera 选用的方案，CDH 版本中集成，CDP 中换成 Ranger，支持 Hive、HDFS、Impala 等</p><ul><li><p>优点</p><blockquote><ol><li>支持细粒度的 HDFS元数据访问控制，支持 Hive 列级别的访问控制</li><li>通过基于角色的授权简化了管理，将访问统一数据及的不同特权分别授予多个角色</li><li>提供了一个平台方便管理</li><li>支持集成 Kerberos</li></ol></blockquote></li><li><p>缺点</p><blockquote><p>只支持 Hive、HDFS、Impala；不支持 Kafka、HBase、YARN、Storm </p></blockquote></li></ul><h3 id="2-3-Apache-Ranger"><a href="#2-3-Apache-Ranger" class="headerlink" title="2.3 Apache Ranger"></a>2.3 Apache Ranger</h3><p><strong>Apache Ranger</strong>：Hortonworks 选用的方案，HDP 版本中集成</p>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
            <tag> 数据安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元数据管理实践-Atlas</title>
      <link href="/202203/1519375.html"/>
      <url>/202203/1519375.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录元数据管理实践-Atlas的相关内容</p><span id="more"></span><h1 id="Atlas"><a href="#Atlas" class="headerlink" title="Atlas"></a>Atlas</h1><p><strong>Atlas</strong>：是 hadoop 的数据治理和元数据框架，提供包括数据分类、集中策略引擎、数据血缘、安全和生命周期管理的元数据治理核心能力，<a href="http://atlas.apache.org/"><font face = "微软雅黑" color = 1E90FF size = 5>Atlas官网</font></a></p><h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1. 架构"></a>1. 架构</h2><h3 id="1-1-核心组件-Core"><a href="#1-1-核心组件-Core" class="headerlink" title="1.1 核心组件-Core"></a>1.1 核心组件-Core</h3><ul><li><strong>Type System</strong>：允许用户定义和管理类型和实体，对所有的元数据对象（Hive表）进行建模，并表示为实体</li><li><strong>Ingest/Export</strong>：Ingest 组件允许将元数据添加到 Atlas 中，Export 暴露由 Atlas 检测到的元数据更改，作为事件引发，消费者通过事件响应</li><li><strong>Graph Engine</strong>：Atlas 通过图形模型管理元数据对象，图形引擎负责类型系统的类型和实体之间的转换</li><li><strong>Titan</strong>：Atlas 使用 Titan 图数据库（Neo4j）存储元数据对象，默认元数据存储配置为 HBase，索引存储配置为 Solr；也支持 BerkeleyDB 存储元数据，ElasticSearch 存储索引</li></ul><h3 id="1-2-核心组件-Intergration"><a href="#1-2-核心组件-Intergration" class="headerlink" title="1.2 核心组件-Intergration"></a>1.2 核心组件-Intergration</h3><ul><li><strong>API</strong>：通过 REST API 提供给最终用户，允许创建、更新和删除类型和实体</li><li><strong>Messaging</strong>：可以选择基于 Kafka 的消息接口与 Atlas 集成，通过<strong>钩子</strong>（hook，一段程序）感知元数据的更改，这有利于提高 <strong>Ingest/Export</strong> 的能力，还能提供更松耦合的集成<blockquote><p>ALTAS_HOOK：钩子获取到来自各个组件的元数据更改事件通知写入到名为 ATLAS_HOOk 的 Kafka topic 发送到 Atlas<br>ATLAS_ENTITIES：从 Atlas 到其他组件的写入到名为 ATLAS_ENTITIES 的 Kafka topic</p></blockquote></li></ul><h3 id="1-3-核心组件-Metadata-source"><a href="#1-3-核心组件-Metadata-source" class="headerlink" title="1.3 核心组件-Metadata source"></a>1.3 核心组件-Metadata source</h3><ul><li><p><strong>数据来源</strong></p><blockquote><ol><li>Hive：通过 hive bridge 接入 hive 的元数据，包括 hive_db、hive_table、hive_column、hive_process、hive_db_ddl、hive_table_ddl 等</li><li>Sqoop：通过 sqoop bridge 接入关系型数据库的元数据，包括 sqoop_operation_type、sqoop_dbstore_usage、sqoop_process、sqoop_dbdatastore 等</li><li>Falcon：通过 falcon bridge 接入 falcon 的元数据，包括 falcon_cluster、falcon_feed、falcon_feed_creation、falcon_feed_replication、falcon_process 等</li><li>Storm：通过 storm bridge 接入流式处理的元数据，包括 storm_topology、storm_sqout、storm_bolt、storm_node 等</li></ol></blockquote></li><li><p><strong>自主集成</strong></p><blockquote><ol><li>需要基于 Atlas 类型定义的能够表达大数据组件元数据对象的元数据模型，如 hive 的元数据模型实现在 org.apache.atlas.hive.model.HiveDataModelGenerator</li><li>需要提供钩子组件从大数据组件的元数据源中提取元数据对象，实时侦听元数据变更事件并反馈给 atlas</li></ol></blockquote></li></ul><h3 id="1-4-核心组件-Application"><a href="#1-4-核心组件-Application" class="headerlink" title="1.4 核心组件-Application"></a>1.4 核心组件-Application</h3><ul><li>Admin UI：基于 web 的应用程序，允许数据管理员和科学家发现和注释元数据，提供了搜索界面和类SQL查询语言</li></ul><h2 id="2-核心特性"><a href="#2-核心特性" class="headerlink" title="2. 核心特性"></a>2. 核心特性</h2><h3 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h3><ul><li>为元数据导入或定义业务导向的分类注释</li><li>定义、注释以及自动捕获数据集和底层元素之间的关系</li><li>导出元数据到第三方系统</li></ul><h3 id="2-2-血缘"><a href="#2-2-血缘" class="headerlink" title="2.2 血缘"></a>2.2 血缘</h3><ul><li>预定义的导航路径用来搜索数据分类以及审计信息</li><li>基于文本的搜索特性来快速准确的定位相关的数据和审计事件</li><li>对数据血缘关系的可视化浏览使用用户可以下钻到操作，安全以及数据起源信息</li></ul><h3 id="2-3-搜索"><a href="#2-3-搜索" class="headerlink" title="2.3 搜索"></a>2.3 搜索</h3><h3 id="2-4-安全审计"><a href="#2-4-安全审计" class="headerlink" title="2.4 安全审计"></a>2.4 安全审计</h3><ul><li>捕获与所有应用、过程以及与数据交互的安全访问信息</li><li>捕获执行、步骤、活动等操作信息</li><li>基于数据分类模式、属性以及角色的运行时合理合规策略</li><li>基于分类-预测的高级策略定义以防止数据推导</li><li>基于 cell 的属性和值的行列级别的 masking</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
            <tag> 元数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础-模块</title>
      <link href="/202112/2117947.html"/>
      <url>/202112/2117947.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Python模块 的相关基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>模块</strong>：在Python中，一个.py文件就称之为一个模块（Module）<br><strong>优点</strong>：提高代码的可维护性；编写代码不必从零开始</p><pre class="line-numbers language-none"><code class="language-none">#!&#x2F;usr&#x2F;bin&#x2F;env python3       # 让本文件直接在Unix&#x2F;Linux&#x2F;Mac上运行# -*- coding: utf-8 -*-      # 本文件本身使用标准UTF-8编码&#39; a test module &#39;            # 表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释__author__ &#x3D; &#39;Qizhongyi&#39;     # 使用 __author__ 变量申明作者# 以上为标准模块模板，可以全部删除；以下为模块的真正代码部分import sys                   # 导入 sys 模块def test():    args &#x3D; sys.argv          # 用list存储命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称；运行python3 hello.py获得的sys.argv就是[&#39;hello.py&#39;]；运行python3 hello.py Michael获得的sys.argv就是[&#39;hello.py&#39;, &#39;Michael&#39;]    if len(args)&#x3D;&#x3D;1:        print(&#39;Hello, world!&#39;)    elif len(args)&#x3D;&#x3D;2:        print(&#39;Hello, %s!&#39; % args[1])    else:        print(&#39;Too many arguments!&#39;)if __name__&#x3D;&#x3D;&#39;__main__&#39;:     # 在命令行运行hello模块文件时，Python解释器把一个特殊变量 __name__ 置为 __main__ ；如果在其他地方导入该模块时，if判断将失败    test()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>包</strong>：Python按目录来组织模块的方法避免模块名冲突，称为包（Package），包含多个模块的特殊目录；每一个包目录下面都会有一个 <strong>_<em>init</em>_.py</strong> 的文件；<strong>_<em>init</em>_.py</strong>本身是一个模块</p><p><strong>优点</strong>：避免模块名冲突；通过导入包的方式（import pac_name）一次性导入多个模块</p><pre class="line-numbers language-none"><code class="language-none">import pac_name    # 导入包# 要是用包里面的模块，需要在 __init__.py 文件里面添加对外界提供访问的模块列表from . inport mod_name   # 从当前目录下导入 mod_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><ul><li>模块名要遵循Python变量命名规范，不要使用中文、特殊字符</li><li>模块名不要和系统模块名冲突，最好先查看系统是否已存在该模块，检查方法是在Python交互环境执行 <strong>import module_name</strong>，若成功则说明系统存在此模块</li></ul><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><p><strong>导入</strong>：</p><ul><li>import mod_name ；导入名为 mod_name 的模块，可以一次性导入多个模块：import mod_name_1, mod_name_2… ，不建议，需要一个模块独占一行；通过 <strong>mod_name.fun_name</strong> 使用模块内的工具，包括全局变量、函数、类等；可以通过 import mod_name as nick_name 给模块名较长的模块起一个别名，方便使用</li><li>from mod_name import fun_name ；从名为 mod_name 的模块中导入fun_name函数；可直接通过 <strong>fun_name</strong> 使用模块内的工具，包括全局变量、函数、类等；from mod_name import fun_name as nick_name ：同样可以起别名使用</li><li>from mod_name import *：不建议，如果存在同名模块，较难排查问题</li></ul><p><strong>导入自定义模块</strong>：通过 <strong>__name__</strong> 屏蔽掉导入模块的测试代码和顶格输出代码；<strong>__name__</strong> 在运行当前模块是，仅保存 <strong>__name__</strong> ，当被导入时，保存模块的文件名</p><pre class="line-numbers language-none"><code class="language-none"># 文件名 test_import.pydef say_hello():    print(&#39;Hello!&#39;)if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    print(__name__)           # 输出 __main__；在本文件内调用，存储 __main__    say_hello()# 文件名 test.py(无所谓)import test_import            # 要与导入文件名保持一致print(test_import.__name__)   # 输出 test_import；在导入文件调用，存储文件名test_import.say_hello()       # 调用函数才会打印 Hello!，test_import.py 不加 if判断，会输出两次 Hello!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-1-模块搜索路径"><a href="#2-1-模块搜索路径" class="headerlink" title="2.1 模块搜索路径"></a>2.1 模块搜索路径</h2><p><strong>模块搜索路径</strong>：导入一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错；默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在 sys 模块的 path变量中，可通过 __file__ 内置属性查看模块的完整导入路径</p><pre class="line-numbers language-none"><code class="language-none">import randomprint(random.__file__)    # 输出random.py在本机的存储位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>新增搜索目录</strong></p><blockquote><ul><li>直接修改 sys.path<pre class="line-numbers language-none"><code class="language-none">import syssys.path.append(&#39;&#x2F;xxx&#x2F;xxx&#x2F;...&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>设置环境变量 PYTHONPATH</li></ul></blockquote><h2 id="2-2-发布"><a href="#2-2-发布" class="headerlink" title="2.2 发布"></a>2.2 发布</h2><ol><li>在于包目录的同级目录建立名为 setup.py 的文件</li></ol><pre class="line-numbers language-none"><code class="language-none">from distutils.core import setupsetup(name &#x3D; &#39;pac_name&#39;,                           # 包名      version &#x3D; &#39;version_num&#39;,                     # 版本号      description &#x3D; &#39;description&#39;,                 # 包描述信息      author &#x3D; &#39;author_name&#39;,                      # 作者名称      author_email &#x3D; &#39;author_email&#39;,               # 作者邮箱      url &#x3D; &#39;author_url&#39;,                          # 作者个人主页      py_module &#x3D; [&#39;mod_name_1&#39;, &#39;mod_name_2&#39;)     # 发布的模块名称列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>终端执行 setup.py 文件（在对应目录下执行）： python3 setup.py build ：针对 python3的解释器执行，会生成在同级目录自动生成 build -&gt; lib -&gt; pac_name 的目录，即打包压缩的文件夹</li><li>生成发布压缩包：python3 setup.py sdist ：会生成 dist -&gt; 发布包</li></ol><h2 id="2-3-安装发布包"><a href="#2-3-安装发布包" class="headerlink" title="2.3 安装发布包"></a>2.3 安装发布包</h2><ol><li>解压发布包：自动生成 pac_name_version_num 的文件夹，里面包含 pac_name 的文件夹（保存包代码）、PAC_INFO（setup() 里面定义的模块描述信息）、setup.py 文件</li><li>执行 setup.py 文件：python3 setup.py install</li></ol><h1 id="3-常用模块"><a href="#3-常用模块" class="headerlink" title="3. 常用模块"></a>3. 常用模块</h1><h2 id="3-1-数据处理类"><a href="#3-1-数据处理类" class="headerlink" title="3.1 数据处理类"></a>3.1 数据处理类</h2><h3 id="3-1-1-re"><a href="#3-1-1-re" class="headerlink" title="3.1.1 re"></a>3.1.1 re</h3><p><a href="https://qizhongyi.gitee.io/202204/2424494.html"><font face = "微软雅黑" color = 1E90FF size = 5> <strong>re</strong></font></a>：通过正则表达式来匹配处理字符串</p><h3 id="3-1-2-datetime"><a href="#3-1-2-datetime" class="headerlink" title="3.1.2 datetime"></a>3.1.2 datetime</h3><p><a href="https://qizhongyi.gitee.io/202206/2736392.html"><font face = "微软雅黑" color = 1E90FF size = 5> <strong>datetime</strong></font></a>：处理日期和时间的标准库</p><h3 id="3-1-3-math"><a href="#3-1-3-math" class="headerlink" title="3.1.3 math"></a>3.1.3 math</h3><p><a href="https://qizhongyi.gitee.io/202208/0441820.html"><font face = "微软雅黑" color = 1E90FF size = 5> <strong>math</strong></font></a>：提供对浮点数的数学运算函数，返回值均为浮点数，除非另有明确说明</p><h3 id="3-1-4-二进制数据处理"><a href="#3-1-4-二进制数据处理" class="headerlink" title="3.1.4 二进制数据处理"></a>3.1.4 二进制数据处理</h3><p><a href="https://qizhongyi.gitee.io/202207/149327.html"><font face = "微软雅黑" color = 1E90FF size = 5> <strong>二进制数据处理</strong></font></a>：对二进制数据进行编解码，bytes和其他二进制数据类型的转换</p><h2 id="3-2-GUI类"><a href="#3-2-GUI类" class="headerlink" title="3.2 GUI类"></a>3.2 GUI类</h2><h3 id="3-2-1-Tkinter"><a href="#3-2-1-Tkinter" class="headerlink" title="3.2.1 Tkinter"></a>3.2.1 Tkinter</h3><p><strong>Tkinter</strong>：Python自带的库是支持Tk的Tkinter，进行GUI编程；Python代码会调用内置的Tkinter，Tkinter封装了访问Tk的接口；Tk会调用操作系统提供的本地GUI接口，完成最终的GUI（Tk是一个图形库，支持多个操作系统，使用Tcl语言开发）</p><pre class="line-numbers language-none"><code class="language-none">from tkinter import *import tkinter.messagebox as messageboxclass Application(Frame):    def __init__(self, master&#x3D;None):        Frame.__init__(self, master)        self.pack()        self.createWidgets()    def createWidgets(self):        self.nameInput &#x3D; Entry(self)        self.nameInput.pack()        self.alertButton &#x3D; Button(self, text&#x3D;&#39;Hello&#39;, command&#x3D;self.hello)        self.alertButton.pack()    def hello(self):        name &#x3D; self.nameInput.get() or &#39;world&#39;                  # 获得用户输入的文本        messagebox.showinfo(&#39;Message&#39;, &#39;Hello, %s&#39; % name)      # 弹出消息对话框app &#x3D; Application()app.master.title(&#39;Hello World&#39;)app.mainloop()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-2-turtle"><a href="#3-2-2-turtle" class="headerlink" title="3.2.2 turtle"></a>3.2.2 turtle</h3><p><strong>turtle</strong>：通过编程指挥一个小海龟（turtle）在屏幕上绘图；1966年发明的一种专门给儿童学习编程的语言</p><pre class="line-numbers language-none"><code class="language-none">from turtle import *def drawStar(x, y):    pu()    goto(x, y)           # 设置起始位置    pd()        seth(0)              # set heading: 0    for i in range(5):        fd(200)        rt(144)drawStar(-100, 0)done()             # 调用done()使得窗口等待被关闭，否则将立刻关闭窗口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-第三方模块"><a href="#4-第三方模块" class="headerlink" title="4. 第三方模块"></a>4. 第三方模块</h1><p>通过 <strong>pip</strong> 进行安装</p><h2 id="4-1-科学计算类"><a href="#4-1-科学计算类" class="headerlink" title="4.1 科学计算类"></a>4.1 科学计算类</h2><h3 id="4-1-1-NumPy"><a href="#4-1-1-NumPy" class="headerlink" title="4.1.1 NumPy"></a>4.1.1 NumPy</h3><p><a href="https://qizhongyi.gitee.io/202207/2960256.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>NumPy</strong></font></a>：Numerical Python 的简称，是 Python 科学计算的基础作为在算法和库之间传递数据的容器；对于数值型数据（仅能处理数值型数据），NumPy数组在存储和处理数据时要比内置的Python数据结构高效；支持大量的维度数组与矩阵运算，针对数组运算提供大量的数学函数库，比 Python 本身的列表访问速度快；<a href="https://github.com/numpy/numpy"><font face = "微软雅黑" color = 1E90FF size = 5>Github网址</font></a>， <a href="http://www.numpy.org/"><font face = "微软雅黑" color = 1E90FF size = 5>NumPy官网</font></a></p><p><strong>核心功能点</strong></p><ul><li>快速⾼效的多维数组对象ndarray和矩阵(numpy.matlib)；</li><li>⽤于对数组执行元素级计算以及直接对数组执行数学运算的函数，包括：线性代数(numpy.linalg)、离散傅里叶变换(numpy.fft)、随机数生成(<strong>numpy.random</strong>)等；</li><li>成熟的C-Types外部函数接口(numpy.ctypeslib)， ⽤于Python插件和原⽣C、C++、Fortran代码访问NumPy的数据结构和计算⼯具</li></ul><h3 id="4-1-2-Pandas"><a href="#4-1-2-Pandas" class="headerlink" title="4.1.2 Pandas"></a>4.1.2 Pandas</h3><p><a href="https://qizhongyi.gitee.io/202208/0364210.html"><font face = "微软雅黑" color = 1E90FF size = 5> <strong>Pandas</strong></font></a>：是一个开放源码、BSD 许可的库，提供高性能、易于使用的数据结构和数据分析工具；可以从各种文件格式比如 CSV、JSON、SQL、Microsoft Excel 导入数据，能够处理多种非数值型的数据，基于 NumPy 提供强大的分析结构化数据的工具集；Pandas 名字衍生自术语 “panel data”（面板数据）和 “Python data analysis”（Python 数据分析）；<a href="https://github.com/pandas-dev/pandas"><font face = "微软雅黑" color = 1E90FF size = 5>Github网址</font></a>， <a href="https://pandas.pydata.org/"><font face = "微软雅黑" color = 1E90FF size = 5>Pandas官网</font></a></p><p><strong>核心功能点</strong>：对各种数据进行运算，包括归并、再成形、选择，还有数据清洗和数据加工特征</p><ul><li><strong>Series</strong>：是一种类似于一维数组的对象，由一组数据（各种Numpy数据类型）以及一组与之相关的数据标签（即索引）组成；内部集成了处理字符串的多种函数</li><li><strong>DataFrame</strong>：是一个表格型的数据结构，含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔型值）；DataFrame 既有行索引也有列索引，可以被看做 <strong>由 Series 组成的字典</strong>（共同用一个索引）</li><li>支持多种数据类型，包括数组、标量、字符串、时间序列（时间偏移：Date offsets、重采样：Resampling）等</li><li>多样的数据分析方法，包括索引：Index objects、分组聚合：GroupBy</li></ul><h2 id="4-2-工具类"><a href="#4-2-工具类" class="headerlink" title="4.2 工具类"></a>4.2 工具类</h2><h3 id="4-2-1-matplotlib"><a href="#4-2-1-matplotlib" class="headerlink" title="4.2.1 matplotlib"></a>4.2.1 matplotlib</h3><p><a href="https://qizhongyi.gitee.io/202207/2746585.html"><font face = "微软雅黑" color = 1E90FF size = 5> <strong>matplotlib</strong></font></a>：图形绘图库，可以用来绘制各种静态，动态，交互式的图表，包括线图、散点图、等高线图、条形图、柱状图、3D 图形、图形动画等；由 John D. Hunter 编写，大部分使用 python 编写（为平台兼容，少部分使用 C 、 Objective-C 和 JavaScript）；<a href="https://github.com/matplotlib/matplotlib"><font face = "微软雅黑" color = 1E90FF size = 5>Github网址</font></a>， <a href="https://matplotlib.org/"><font face = "微软雅黑" color = 1E90FF size = 5>matplotlib官网</font></a>， <a href="https://matplotlib.org/stable/gallery/lines_bars_and_markers/index.html"><font face = "微软雅黑" color = 1E90FF size = 5>matplotlib官网样例</font></a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础-控制语句</title>
      <link href="/202111/1825209.html"/>
      <url>/202111/1825209.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Python控制语句 的相关基础知识</p><span id="more"></span><h1 id="1-引用语句"><a href="#1-引用语句" class="headerlink" title="1. 引用语句"></a>1. 引用语句</h1><ul><li>import mod_name ；导入名为 mod_name 的模块，可以一次性导入多个模块：import mod_name_1, mod_name_2… ，不建议，需要一个模块独占一行；通过 <strong>mod_name.fun_name</strong> 使用模块内的工具，包括全局变量、函数、类等；可以通过 import mod_name as nick_name 给模块名较长的模块起一个别名，方便使用</li><li>from mod_name import fun_name ；从名为 mod_name 的模块中导入fun_name函数；可直接通过 <strong>fun_name</strong> 使用模块内的工具，包括全局变量、函数、类等；from mod_name import fun_name as nick_name ：同样可以起别名使用</li></ul><h1 id="2-分支语句"><a href="#2-分支语句" class="headerlink" title="2. 分支语句"></a>2. 分支语句</h1><p>if 语句 从上往下执行判断，如果在某个判断上是 True ，把该判断对应的语句执行后，就忽略掉剩下的 elif 和 else；可进行嵌套，进行多层判断</p><p><strong>单分支</strong>：if condition : …</p><pre class="line-numbers language-none"><code class="language-none">age &#x3D; 20if age &gt;&#x3D; 18:    print(&#39;adult&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>双分支</strong>：if condition: …else condition: …</p><pre class="line-numbers language-none"><code class="language-none">age &#x3D; 3if age &gt;&#x3D; 18:    print(&#39;adult&#39;)else:    print(&#39;teenager&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多分支</strong>：if condition: …elif condition: … else condition: …<br>如果在某个判断上是 True ，只执行该判断对应的语句，忽略掉剩下的 elif 和 else</p><pre class="line-numbers language-none"><code class="language-none">age &#x3D; 3if age &gt;&#x3D; 18:    print(&#39;adult&#39;)elif age &gt;&#x3D; 6:          # 可以写多个 elif    print(&#39;teenager&#39;)else:    print(&#39;kid&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. 循环语句</h1><p><strong>for遍历循环</strong>：for 循环变量 in 遍历数据: …</p><pre class="line-numbers language-none"><code class="language-none">sum &#x3D; 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:   # 计算 1~10 累加的和    sum &#x3D; sum + xprint(sum)sum &#x3D; 0for x in range(11):    sum &#x3D; sum + xprint(sum)range(11) 会生成一个(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)整数序列，可以在通过list()函数转换成 list数据，如：list(range(11)) 会得到一个元素为 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 的列表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>增强for循环</strong>：for … else … ，正常循环结束时执行else的语句内容，for 循环使用了 break 推出循环，则不会执行 else语句</p><pre class="line-numbers language-none"><code class="language-none"># 定义学生信息列表list_stu &#x3D; [    &#123;&#39;name&#39;: &#39;zhangsan&#39;, &#39;age&#39;: 18, &#39;gender&#39;: True&#125;,    &#123;&#39;name&#39;: &#39;lisi&#39;, &#39;age&#39;: 18, &#39;gender&#39;: False&#125;,    &#123;&#39;name&#39;: &#39;wangwu&#39;, &#39;age&#39;: 19, &#39;gender&#39;: True&#125;]stu_name &#x3D; input(&#39;Please a name: &#39;)# 查找指定的学生信息for stu_info in list_stu:    if stu_info[&#39;name&#39;] &#x3D;&#x3D; stu_name:        print(&#39;Find %s : &#39; % stu_name, stu_info)        breakelse:    print(&#39;Not find %s &#39; % stu_name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注</strong>：for 循环不会默认编程一个函数体 (与Java不同)，在for循环中的循环变量和 “局部变量” 的作用域其实和for循环同级</p><pre class="line-numbers language-none"><code class="language-none">for i in range(10):    sum &#x3D; i * iprint(i, sum)  # 输出返回最后一次循环的值 i &#x3D; 9, sum &#x3D; 81<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>while循环</strong>：while condition: …</p><pre class="line-numbers language-none"><code class="language-none">sum &#x3D; 0n &#x3D; 99while n &gt; 0:        # 计算 100 以内的所有奇数和    sum &#x3D; sum + n    n &#x3D; n - 2print(sum)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>循环控制</strong>：</p><ul><li><strong>break</strong>：直接跳出循环循环，执行循环后的语句 <pre class="line-numbers language-none"><code class="language-none">sum &#x3D; 0n &#x3D; 1while n &lt; 101:    if n % 2 &#x3D; 0:     # 判断n除以2的余数        break    sum &#x3D; sum + n    n &#x3D; n + 1print(sum)            # sum &#x3D; 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>continue</strong>：退出本次循环过程，继续下一次循环<pre class="line-numbers language-none"><code class="language-none">sum &#x3D; 0n &#x3D; 1while n &lt; 101:        # 计算 100 以内的所有奇数和    if n % 2 &#x3D; 0:        continue    sum &#x3D; sum + n    n &#x3D; n + 1print(sum)           # sum &#x3D; 2500<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h1 id="4-赋值语句"><a href="#4-赋值语句" class="headerlink" title="4. 赋值语句"></a>4. 赋值语句</h1><p>通过<strong>赋值运算符</strong>进行赋值，将右边的内容赋值给左边；多个变量同时赋值时，按照顺序赋值</p><pre class="line-numbers language-none"><code class="language-none">c &#x3D; a + bc +&#x3D; a；c &#x3D; c + aa, b &#x3D; 1, 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">运算符</th><th align="center">实例</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">赋值</td><td align="center">c = a + b</td></tr><tr><td align="center">+=</td><td align="center">加赋值</td><td align="center">c += a；c = c + a；对于列表则是调用 extend 方法</td></tr><tr><td align="center">-=</td><td align="center">减赋值</td><td align="center">c -= a；c = c - a</td></tr><tr><td align="center">*=</td><td align="center">乘赋值</td><td align="center">c *= a；c = c * a</td></tr><tr><td align="center">/=</td><td align="center">除赋值</td><td align="center">c /= a；c = c / a</td></tr><tr><td align="center">//=</td><td align="center">求模赋值</td><td align="center">c //= a；c = c // a</td></tr><tr><td align="center">%=</td><td align="center">取余赋值</td><td align="center">c %= a；c = c % a</td></tr><tr><td align="center">**=</td><td align="center">幂赋值</td><td align="center">c **= a；c = c ** a</td></tr></tbody></table><h1 id="5-异常控制语句"><a href="#5-异常控制语句" class="headerlink" title="5. 异常控制语句"></a>5. 异常控制语句</h1><ul><li>**try: … except: … else:… finally: …**：try 需要捕获异常的的代码块；except 捕获到异常后的处理模块；else 当没有错误发生时，会自动执行else语句块（有错误不执行）；finally 执行完 try代码块和 except代码块的最终执行模块</li></ul><pre class="line-numbers language-none"><code class="language-none">try:                                    # 运行 try代码块，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码    number &#x3D; input(&#39;Please input a number: &#39;)    print(&#39;try...&#39;)    r &#x3D; 10 &#x2F; int(number)                # 代码错误，后续语句print(&#39;result:&#39;, r)不会被执行    print(&#39;result:&#39;, r)except ValueError as e:                 # try代码块有错误时执行；没有错误发生，则except语句块不会被执行；e 是对 ValueError 重定义的一个变量名，用于后面代码的输出    print(&#39;ValueError:&#39;, e)except ZeroDivisionError as e:          # 可以通过多个except语句块获取多种不同的错误    print(&#39;except:&#39;, e)except UnicodeError as e:               # 永远也捕获不到UnicodeError，因为UnicodeError是ValueError的子类，如果有，也会被第一个except捕获；所有的错误类型都继承自 BaseException    print(&#39;UnicodeError:&#39;, e)except Exception as e:                  # Exception是一个异常类    print(&#39;未知错误: %s&#39; %s e)else:                                   # 如果没有错误发生，可以在except语句块后面加一个else语句块；当没有错误发生时，会自动执行else语句块    print(&#39;no error!&#39;)finally:                                # 如果有错误，执行完except代码块后执行；如果没有错误，执行完try语句块后执行；finally语句块可以没有，如果有就一定会执行    print(&#39;finally...&#39;)print(&#39;END&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>跨层级调用捕获</strong>：不需要在每个可能出错的地方去捕获错误，只需要在合适的层次去捕获错误，可以大大减少写try…except…finally的麻烦</p><pre class="line-numbers language-none"><code class="language-none">def foo(s):    return 10 &#x2F; int(s)def bar(s):    return foo(s) * 2def main():              # main()调用bar()，bar()调用foo()，foo()出错，只要main()捕获到就可以处理    try:        bar(&#39;0&#39;)    except Exception as e:        print(&#39;Error:&#39;, e)    finally:        print(&#39;finally...&#39;)main()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>调用栈</strong>：如果错误没有被捕获，它就会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出</p><pre class="line-numbers language-none"><code class="language-none">def foo(s):    return 10 &#x2F; int(s)def bar(s):    return foo(s) * 2def main():    bar(&#39;0&#39;)main()发生异常: ZeroDivisionErrordivision by zero  File &quot;C:\Users\tanhh\Desktop\Gitee\Resource\python_self\test.py&quot;, line 2, in foo    return 10 &#x2F; int(s)  File &quot;C:\Users\tanhh\Desktop\Gitee\Resource\python_self\test.py&quot;, line 5, in bar    return foo(s) * 2  File &quot;C:\Users\tanhh\Desktop\Gitee\Resource\python_self\test.py&quot;, line 8, in main    bar(&#39;0&#39;)  File &quot;C:\Users\tanhh\Desktop\Gitee\Resource\python_self\test.py&quot;, line 10, in &lt;module&gt;    main()# 可以根据调用栈定位具体出错的位置，进行修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>抛出错误</strong>：可以抛出自定义的错误，只有在必要的时候才定义我们自己的错误类型，尽量使用Python内置的错误类型</p><pre class="line-numbers language-none"><code class="language-none">class FooError(ValueError):   # 定义一个异常类    passdef foo(s):    n &#x3D; int(s)    if n&#x3D;&#x3D;0:        raise FooError(&#39;invalid value: %s&#39; % s)    # 实例化一个 FooError ，并抛出异常    return 10 &#x2F; n# 捕获抛出的异常try:    foo(&#39;0&#39;)except Exception as e:    print(e)             # 输出异常信息# casedef verify_password():    pwd_str &#x3D; input(&#39;Please input your password: &#39;)    if len(pwd_str) &gt; 7:        return pwd_str    ex &#x3D; Exception(&#39;Not long enough.&#39;)    # 创建异常对象可用错误信息字符串作为参数    raise extry:    print(verify_password())except Exception as e:    print(e)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-1-调试"><a href="#5-1-调试" class="headerlink" title="5.1 调试"></a>5.1 调试</h2><ul><li><p><strong>直接打印</strong>：可以通过 print 直接打印参数，简单直接，但是将来还得删掉</p></li><li><p><strong>断言</strong>：assert ，设置断言，用来辅助查看，用于调试；启动Python解释器时可以用 <strong>-O参数</strong>（英文大写字母O）来关闭 assert ： python -O py_file_name.py；关闭后，所有的 assert语句 可以当成 pass 来看</p><pre class="line-numbers language-none"><code class="language-none">def foo(s):    n &#x3D; int(s)    assert n !&#x3D; 0, &#39;n is zero!&#39;     # assert后的表达式为True，则执行后续代码；为False，执行表达式之后的代码，并抛出 AssertionError    return 10 &#x2F; ndef main(number):    return foo(number)number_in &#x3D; input(&#39;Please input a number: &#39;)result &#x3D; main(number_in)print(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>打印错误日志</strong>：通过 <strong>logging</strong> 打印错误日志</p><pre class="line-numbers language-none"><code class="language-none">import logginglogging.basicConfig(level&#x3D;logging.INFO)   # 允许指定记录信息的级别，包括debug，info，warning，error等几个级别def foo(s):    return 10 &#x2F; int(s)def bar(s):    return foo(s) * 2def main():    try:        bar(&#39;0&#39;)    except Exception as e:        logging.exception(e)      # 引入logging后，程序打印完错误信息后会继续执行后续代码，并正常退出main()print(&#39;END&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>调试</strong>：启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态</p></li></ul><pre class="line-numbers language-none"><code class="language-none"># 调试：pdb，使用麻烦s &#x3D; &#39;0&#39;n &#x3D; int(s)print(10 &#x2F; n)# 保存文件，在cmd(命令行)下执行python -m pdb xxx&#x2F;f_name.py   # 文件路径；进入 pdb 调试器l(英文l)：查看所有代码n：逐步运行代码p var_name：查看变量值q：退出 pdb 调试器<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**pdb.set_trace()**：不需要单步执行， 先 import pdb ，在可能出错的地方放一个 pdb.set_trace() 设置一个断点</p><pre class="line-numbers language-none"><code class="language-none">import pdbs &#x3D; &#39;0&#39;n &#x3D; int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 &#x2F; n)# 保存文件，在cmd(命令行)下执行python xxx&#x2F;f_name.py   # 自动进入 pdb 调试器p var_name：查看变量值c：继续执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-1-1-单元测试"><a href="#5-1-1-单元测试" class="headerlink" title="5.1.1 单元测试"></a>5.1.1 单元测试</h3><p><strong>单元测试</strong>：用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作</p><pre class="line-numbers language-none"><code class="language-none"># 测试代码：mydict.py，另存一个文件，取名 mydict.pyclass Dict(dict):    def __init__(self, **kw):        super().__init__(**kw)    def __getattr__(self, key):        try:            return self[key]        except KeyError:            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)    def __setattr__(self, key, value):        self[key] &#x3D; value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>编写</strong>：编写测试类，需要从 unittest.TestCase 继承；对每一类测试都需要编写一个test_xxx()方法；以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行</p><pre class="line-numbers language-none"><code class="language-none"># 一个新文件，文件路径与 mydict.py 一致import unittest                                    # 需要引入Python自带的 unittest 模块from mydict import Dictclass TestDict(unittest.TestCase):                 # 编写测试类，需要从 unittest.TestCase 继承；对每一类测试都需要编写一个test_xxx()方法    def test_init(self):                           # 以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行        d &#x3D; Dict(a&#x3D;1, b&#x3D;&#39;test&#39;)        self.assertEqual(d.a, 1)                   # 可通过 assertEqual() 断言判断程序的正确性（常用）        self.assertEqual(d.b, &#39;test&#39;)        self.assertTrue(isinstance(d, dict))    def test_key(self):        d &#x3D; Dict()        d[&#39;key&#39;] &#x3D; &#39;value&#39;        self.assertEqual(d.key, &#39;value&#39;)    def test_attr(self):        d &#x3D; Dict()        d.key &#x3D; &#39;value&#39;        self.assertTrue(&#39;key&#39; in d)        self.assertEqual(d[&#39;key&#39;], &#39;value&#39;)    def test_keyerror(self):        d &#x3D; Dict()        with self.assertRaises(KeyError):        # 可通过 assertRaises 断言抛出指定类型的Error（常用）            value &#x3D; d[&#39;empty&#39;]    def test_attrerror(self):        d &#x3D; Dict()        with self.assertRaises(AttributeError):            value &#x3D; d.empty# 可以在单元测试中编写两个特殊的setUp()和tearDown()方法，会分别在调用每一个测试方法的前后分别被执行；可以减少重复代码的编写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>运行</strong></p><ul><li>在写好的单元测试文件上加入如下代码；可以把单元测试文件当做正常的python脚本运行</li></ul><pre class="line-numbers language-none"><code class="language-none">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:    unittest.main()# 命令行下运行python unit_test_f_name.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>在命令行通过参数 <strong>-m unittest</strong> 直接运行单元测试</li></ul><pre class="line-numbers language-none"><code class="language-none">python -m unittest mydict_test<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="5-1-2-文档测试"><a href="#5-1-2-文档测试" class="headerlink" title="5.1.2 文档测试"></a>5.1.2 文档测试</h3><p><strong>文档测试</strong>：通过Python内置的 <strong>doctest</strong> 文档测试模块可以直接提取注释中的代码并执行测试；doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确</p><pre class="line-numbers language-none"><code class="language-none"># mydict2.pyclass Dict(dict):    &#39;&#39;&#39;    Simple dict but also support access as x.y style.    &gt;&gt;&gt; d1 &#x3D; Dict()    &gt;&gt;&gt; d1[&#39;x&#39;] &#x3D; 100    &gt;&gt;&gt; d1.x    100    &gt;&gt;&gt; d1.y &#x3D; 200    &gt;&gt;&gt; d1[&#39;y&#39;]    200    &gt;&gt;&gt; d2 &#x3D; Dict(a&#x3D;1, b&#x3D;2, c&#x3D;&#39;3&#39;)    &gt;&gt;&gt; d2.c    &#39;3&#39;    &gt;&gt;&gt; d2[&#39;empty&#39;]    Traceback (most recent call last):        ...    KeyError: &#39;empty&#39;    &gt;&gt;&gt; d2.empty    Traceback (most recent call last):        ...    AttributeError: &#39;Dict&#39; object has no attribute &#39;empty&#39;    &#39;&#39;&#39;    def __init__(self, **kw):        super(Dict, self).__init__(**kw)    def __getattr__(self, key):        try:            return self[key]        except KeyError:            raise AttributeError(r&quot;&#39;Dict&#39; object has no attribute &#39;%s&#39;&quot; % key)    def __setattr__(self, key, value):        self[key] &#x3D; valueif __name__&#x3D;&#x3D;&#39;__main__&#39;:     # 当模块正常导入时，doctest不会被执行；只有在命令行直接运行时，才执行doctest    import doctest    doctest.testmod()# 命令行运行python mydict2.py    # 如果什么输出也没有，说明编写的doctest运行都正确<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy"><font face = "微软雅黑" color = 1E90FF size = 5>常见的错误类型和继承关系</font></a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础-数据类型</title>
      <link href="/202111/1865236.html"/>
      <url>/202111/1865236.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Python数据类型 的相关基础知识</p><span id="more"></span><h1 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1. 数据类型"></a>1. 数据类型</h1><p>Pyhton 没有数据类型关键字，能够直接处理的数据类型有：整数、浮点数、字符串、布尔值、列表、元组、集合、字典</p><ol><li><strong>静态语言</strong>：是编译时变量的数据类型就可以确定的语言，在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错；如：Java</li><li><strong>动态语言</strong>：是运行时才确定数据类型的语言，变量在使用之前无需申明类型，变量本身数据类型不固定的语言，在赋值时确定对应变量的数据类型；如：Python，动态语言更灵活；Python 变量不仅包括值，还包括关于值的类型的额外信息</li></ol><h2 id="1-1-基本数据类型"><a href="#1-1-基本数据类型" class="headerlink" title="1.1 基本数据类型"></a>1.1 基本数据类型</h2><h3 id="1-1-1-整数"><a href="#1-1-1-整数" class="headerlink" title="1.1.1 整数"></a>1.1.1 整数</h3><p><strong>整数</strong>：可以处理任意大小的整数，包括负整数；表示方法和数学上的写法一模一样，Python 允许在数字中间以 _ 分隔数值较大的数，方便阅读，如：10_000_000_000，和 10000000000 完全一样，不可变对象</p><pre class="line-numbers language-none"><code class="language-none">int &#x3D; 2     # 十进制整数2int &#x3D; 0x11  # 十六进制整数17，二进制为 int &#x3D; 0b11 &#x3D; 3，八进制为 int &#x3D; 0o11 &#x3D; 9hex(num)：返回十进制整数对应的十六进制数oct(num)：返回十进制整数对应的八进制数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-2-浮点数"><a href="#1-1-2-浮点数" class="headerlink" title="1.1.2 浮点数"></a>1.1.2 浮点数</h3><p><strong>浮点数</strong>：指按照科学记数法表示时，浮点数的小数点位置可变，如：1.23x10^9 = 12.3x10^8 ，在 Python 里面写作 1.23e9，不可变对象</p><pre class="line-numbers language-none"><code class="language-none">float &#x3D; 2.0  # 浮点数类型<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>整数和浮点数在计算机内部存储的方式不同：整数运算永远是精确的，普通除法结果是浮点数，浮点数运算则可能会有四舍五入的误差<br>除法 / 计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数<br>地板除 // （求商）：两个整数的除法仍然是整数，整数的地板除 // 永远是整数<br>取余 %：两个整数的除法仍然是整数</p></blockquote><h4 id="1-1-2-1-数值处理函数"><a href="#1-1-2-1-数值处理函数" class="headerlink" title="1.1.2.1 数值处理函数"></a>1.1.2.1 数值处理函数</h4><ul><li>一元操作符：+、-、*、/、//（整数商）、%（求模或取余）、**（幂运算）</li><li>二元操作符：+=、-=、*=、/=、//=、%=、**=</li><li>返回绝对值：abs()</li><li>divmod(x，y) = (x//y，x%y)，返回商和余数的元组</li><li>pow(x，y) = x**y，返回 x 的 y 次幂、pow(x，y，z) = x**y%z，返回 x 的 y 次幂 除以 z 的余数</li><li>round(x，d)：x四舍五入保留d位小数，省略d则保留整数</li><li>max()、min()，求最大最小值</li></ul><h3 id="1-1-3-复数"><a href="#1-1-3-复数" class="headerlink" title="1.1.3 复数"></a>1.1.3 复数</h3><p><strong>复数</strong>：主要用于科学计算，不可变对象</p><h3 id="1-1-4-字符串"><a href="#1-1-4-字符串" class="headerlink" title="1.1.4 字符串"></a>1.1.4 字符串</h3><p><strong>字符串</strong>：是以单引号 ‘ 或双引号 “ 括起来的任意文本，推荐使用双引号，如果文本内包含 ‘ 或 “ ，可以通过 \ 进行转义，也可以 ‘ 和 “ 混用，不可变对象，以 Unicode 编码</p><pre class="line-numbers language-none"><code class="language-none">string &#x3D; &#39;2&#39;&#x2F;&quot;2&quot;     # 字符串 2string &#x3D; &#39;I\&#39;m OK!&#39;  # 字符串 I&#39;m OK!string &#x3D; &quot;I&#39;m OK!&quot;   # 字符串 I&#39;m OK!特殊含义转义\\, \&#39;, \&quot; ：转义，输出 \, &#39;, &quot;\n：换行，显示 \n 需要写成 \\n，即进行转义\t：制表位\r：回车r&#39;&#39; 中包裹的字符不进行转义，print(r&#39;\\\t\\&#39;)，输出：\\\t\\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多行字符串</strong>：打印多行字符串时，可以通过 ‘’’ 或 “”” 括起来</p><pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; print(&#39;&#39;&#39;line1... line2... line3&#39;&#39;&#39;)在交互式命令行内输入多行内容时，提示符由 &gt;&gt;&gt; 变为 ... ，提示可以接着上一行输入；结束输入需要按两次回车重新回到 &gt;&gt;&gt; 提示符下<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-1-4-1-字符串处理函数"><a href="#1-1-4-1-字符串处理函数" class="headerlink" title="1.1.4.1 字符串处理函数"></a>1.1.4.1 字符串处理函数</h4><p><strong>统计</strong></p><pre class="line-numbers language-none"><code class="language-none">len(str)：返回 str字符串的字符数，len(str.encode(&#39;utf-8&#39;))：返回 str字符串的字节数str.count(x)：返回 x子串 在 str字符串 中出现的次数str.index(x)：返回从左往右数在 str字符串 中第一次出现 x子串的索引值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>字符编码</strong></p><pre class="line-numbers language-none"><code class="language-none">ord(str)：返回 str字符 对应的十进制整数编码值chr(num)：返回十进制整数编码值对应的 ASCII 字符，也可用&#39;\十进制整数编码&#39;直接输出对应字符string &#x3D; &#39;\u4e2d\u6587&#39;  等价于 string &#x3D; &#39;中文&#39;str.encode()：指定编码方式，&#39;ABC&#39;.encode(&#39;ascii&#39;)，&#39;ABC&#39;.encode(&#39;utf-8&#39;)；显示为编码字符 b&#39;ABC&#39; ，与字符串 &#39;ABC&#39; 不同str.decode()：指定解码方式，b&#39;ABC&#39;.decode(&#39;utf-8&#39;)：将 b&#39;ABC&#39; 编码字符按照 &#39;utf-8&#39; 编码方式解码成字符串&#39;中文&#39;.encode(&#39;utf-8&#39;)，输出：b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;b&#39;\xe4\xb8\xad\xe6\x96\x87&#39;.decode(&#39;utf-8&#39;)，输出：&#39;中文&#39;，如果其中有无法解码的内容会报错，可以忽略，b&#39;\xe4\xb8\xad\xff&#39;.decode(&#39;utf-8&#39;, errors&#x3D;&#39;ignore&#39;)，输出：&#39;中&#39;为了避免乱码问题，应当始终坚持使用 UTF-8编码方式对字符串进行编码解码通常在文件开头写上下面两行注释#!&#x2F;usr&#x2F;bin&#x2F;env python3   # 表明这是一个Python3可执行程序# -*- coding: utf-8 -*-  # 告诉Python解释器，按照UTF-8编码读取源代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查找替换</strong></p><pre class="line-numbers language-none"><code class="language-none">str(x)：将x转换为字符串格式操作符：连接（a+b）、复制（a * n：将a复制n次）、判断存在（b in&#x2F;(not in) a：判断b是否在a中存在）str.startswith(x)：str字符串是否以 x 开头str.endswith(x)：str字符串是否以 x 结尾str.find(x, start &#x3D; 0, end &#x3D; len(str))：str字符串在[start, end) 中是否存在 x；返回第一次出现的索引值，不存在返回 -1str.rfind(x, start &#x3D; 0, end &#x3D; len(str))：str字符串在[start, end) 中是否存在 x；返回第一次出现的索引值（从右往左查），不存在返回 -1str.index(x, start &#x3D; 0, end &#x3D; len(str))：str字符串在[start, end) 中是否存在 x；返回第一次出现的索引值，不存在会报错str.rindex(x, start &#x3D; 0, end &#x3D; len(str))：str字符串在[start, end) 中是否存在 x；返回第一次出现的索引值（从右往左查），不存在会报错str.replace(old, new, num)：返回 old 被 new 替代 num次的新字符串，旧字符串未改变str.capitalize()：返回首字母大写的副本str.title()：返回 str 的标题形式（每个单词首字母大写）str.lower()：返回 str 小写形式的副本str.upper()：返回 str 大写形式的副本str.swapcase()：返回翻转 str 大小写的副本str.strip(x)：去掉字符串两边的指定x字符，默认为空格str.lstrip(x)：去掉字符串左边的指定x字符，默认为空格str.rstrip(x)：去掉字符串右边的指定x字符，默认为空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>拆分和连接</strong></p><pre class="line-numbers language-none"><code class="language-none">str.split(&#39;x&#39;, num)：返回str根据x字符分隔num次的字符串列表，缺省包含 \r, \t, \nstr.splitelines()：返回str按照\r, \t, \n分隔的字符串列表str.join(sep)：返回 sep 所有元素以 str 拼接的字符串，要求 sep 是一个可迭代对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>对齐</strong></p><pre class="line-numbers language-none"><code class="language-none">str.center(width,fillchar)：字符串根据给定宽度居中显示，多余位置按 fillchar 填充str.ljust(width,fillchar)：字符串根据给定宽度左对齐显示，多余位置按 fillchar 填充str.rjust(width,fillchar)：字符串根据给定宽度右对齐显示，多余位置按 fillchar 填充<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>类型判断</strong>：以 is 开头</p><pre class="line-numbers language-none"><code class="language-none">str.isspace()：是否只包含空白字符，包括空格、\r, \t, \nstr.isalnum()：是否只包含字母和数字str.isalpha()：是否只包含字母str.isacsii)：是否只包含ASCII码str.isdecimal()：是否只包含数字，不能判断小数，最常用str.isdigit()：是否只包含数字，可以识别非十进制数字，不能判断小数str.isnumberic()：是否只包含数字，可以识别非十进制数字，可以识别中文数字(包括繁体)，不能判断小数str.istitle()：是否是标题（每个单词首字母大写）str.islower()：是否只包含小写字母str.isupper()：是否只包含大写字母<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-5-布尔值"><a href="#1-1-5-布尔值" class="headerlink" title="1.1.5 布尔值"></a>1.1.5 布尔值</h3><p><strong>布尔值</strong>：仅代表是和否，用 True 、False 代替，注意首字母大写，可结合逻辑运算符 and、or、not 进行运算</p><pre class="line-numbers language-none"><code class="language-none">bool &#x3D; True&#x2F;False   # bool类型True  and True    TrueTrue  and False   FalseFalse and False   FalseTrue  or  True    TrueTrue  or  False   TrueFalse or  False   Falsenot True          Falsenot False         True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-6-空值"><a href="#1-1-6-空值" class="headerlink" title="1.1.6 空值"></a>1.1.6 空值</h3><p>空值是Python里一个特殊的空值，用 None 表示，不能理解为 0</p><h3 id="1-1-7-基本数据类型操作"><a href="#1-1-7-基本数据类型操作" class="headerlink" title="1.1.7 基本数据类型操作"></a>1.1.7 基本数据类型操作</h3><pre class="line-numbers language-none"><code class="language-none">type(value)      # 查看 value 的数据类型# 数据类型转换string &#x3D; str(value)   # 将 value 转为字符串，int(value)、float(value)、bool(value)# int(value)：只能传入字符串，不能讲一个元素的元组作为传入参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-复杂数据类型"><a href="#1-2-复杂数据类型" class="headerlink" title="1.2 复杂数据类型"></a>1.2 复杂数据类型</h2><h3 id="1-2-1-列表"><a href="#1-2-1-列表" class="headerlink" title="1.2.1 列表"></a>1.2.1 列表</h3><p><strong>列表类型</strong>：申明：l_name = [] 或者 l_name = list(values)，通过 list() 函数进行转换；列表里面元素的数据类型可以不同，可以嵌套列表，如：l_name = [‘python’, ‘java’, [‘asp’, ‘php’], ‘scheme’]；查找插入时间随着元素的增加而增加，但占用空间小，可变对象，有序表</p><p><strong>列表生成式创建</strong>：</p><pre class="line-numbers language-none"><code class="language-none">[x * x for x in range(1, 11)]   # 生成 [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]，for 前面是一个表达式，用于生成结果[x * x for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0]  # 生成 [4, 16, 36, 64, 100]，后面加 if 筛选条件筛选数据，不能带 else[x if x % 2 &#x3D;&#x3D; 0 else -x for x in range(1, 11)]   # 生成 [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10]，if在前，必须加else两层循环[m + n for m in &#39;ABC&#39; for n in &#39;XYZ&#39;]  # 生成 [&#39;AX&#39;, &#39;AY&#39;, &#39;AZ&#39;, &#39;BX&#39;, &#39;BY&#39;, &#39;BZ&#39;, &#39;CX&#39;, &#39;CY&#39;, &#39;CZ&#39;][name for names in all_data for name in names if name.count(&quot;a&quot;) &gt;&#x3D; 2]   # 外层循环在前，内层循环在后[x * y for x in range(1, 11) if x % 2 &#x3D;&#x3D; 0 for y in range(1, 11) if y % 2 !&#x3D; 0]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>生成器</strong>：按照某种算法推算出来列表元素，边循环边计算</p><pre class="line-numbers language-none"><code class="language-none">g_name &#x3D; (x * x for x in range(10))  # 可以简单的将列表生成式的的 [] 改成 () ，就可以生成一个生成器next(g_name)  # 通过 next() 函数进行获取生成器里面的数据，每一次调用，就计算出下一个 g_name 的值，直到计算到最后一个元素，没有更多的元素时，抛出 StopIteration 错误一般通过 for 循环访问数据for n in g_name：    print(n)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过 yield 关键字进行将不同函数定义成生成器函数，在每次调用 next() 时执行，遇到 yield 语句返回，再次执行时从上次返回的 yield 语句处继续执行</p><pre class="line-numbers language-none"><code class="language-none">def fun_fib(fib_num):    n, a, b &#x3D; 0, 0, 1    while n &lt; fib_num:        yield b            # 一个普通函数定义中包含 yield 关键字，就变成一个 generator 函数,调用next()时，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行        a, b &#x3D; b, a + b        n &#x3D; n + 1number &#x3D; eval(input(&#39;please entry a number: &#39;))generator_fun &#x3D; fun_fib(number)   # 调用一个generator函数将返回一个generator对象generator_list &#x3D; []for n in generator_fun:            # 通过 for 循环便利 generator对象(可迭代对象)    generator_list.append(n)print(generator_list)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="1-2-1-1-列表处理函数"><a href="#1-2-1-1-列表处理函数" class="headerlink" title="1.2.1.1 列表处理函数"></a>1.2.1.1 列表处理函数</h4><p><strong>统计</strong></p><pre class="line-numbers language-none"><code class="language-none">len(l_name)：返回列表长度，即列表里面的数据个数l_name.count(value) ：统计 value 在 l_name 中出现的次数max(l_name)、min(l_name)：返回列表最大最小值，需要列表的元素数据类型一致，即都为数值型或都为字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>读取</strong></p><ul><li><strong>切片</strong><pre class="line-numbers language-none"><code class="language-none">list_a &#x3D; [1, 2, 3, 4]，list_a &#x3D; [] 创建空列表l_name[start_idx: end_idx: step]：从 start_idx 开始以 sept 的步长切片到 end_idx ，不包括 end_idx 位置的数据list_a[1] 和 list_a[-3] 取出来的数据都是 2，idx：从左往右，从 0 开始；从右往左，从 -1 开始；当索引超出范围时，会报 IndexError 的错误切片操作也可以运用到字符串、元组等序列元素集<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>迭代</strong>：通过 for 循环进行遍历<pre class="line-numbers language-none"><code class="language-none">for p_name in l_name:    xxxxlist_a &#x3D; [1, 2, 3, 4]for num in list_a:    print(num)只要是可迭代对象，无论有无下标，都可以迭代，迭代可以使用在字符串、列表、元组、字典；默认字典迭代 key值，可通过 d_name.value() 迭代 value，可以通过 d_name.items() 迭代 key-valued &#x3D; &#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;for key,value in d.items():     print(key)      # 仅会输出 key (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;)for a in d.items():     print(a)        # 会输出所有键值对：(&#39;a&#39;, 1)(&#39;b&#39;, 2)(&#39;c&#39;, 3)判断是否是可迭代对象：需要导入包：from collections.abc import Iterableisinstance(value&#x2F;v_name, Iterable)；内置的 enumerate函数 可以把 list 变成索引-元素对，可以在 for循环 中同时迭代索引和元素本身for i, value in enumerate([&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]):    print(i, value)  # 会输出迭代索引和元素 0 A \n 1 B \n 2 C<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>操作</strong></p><pre class="line-numbers language-none"><code class="language-none">l_name.append(value)：在列表末尾加入 value元素l_name.insert(idx_num, value)：在列表第 idx_num 位插入 value 元素，append 的效率会优于 insert，插入点后续元素的引⽤必须在内部迁移l_name.extend(l_name_o)：将 l_name_o 里面的数据追加入到 l_name 末尾l_name_a + l_name_b ：得到一个新列表，元素是a、b两个列表的所有元素，a 在前，b 在后l_name * num ：列表 l_name 以相同的顺序重复 num 次l_name.index(value)：返回对应值的索引值，没有对应数据会报错l_name.pop()：取出列表末尾的元素并删除l_name.pop(idx_num)：从列表中取出第 idx_num 位元素并删除l_name.remove(value)：删除列表中第一次出现的 value 元素l_name.clear()：清空列表del l_name[idx_num_strat : idx_num_end]：不包含结束位置，不返回删除元素l_name[idx_num] &#x3D; value ：将 idx_num 位的元素改成 valuelist(values) ：将 values 序列变成一个列表，元素是 valuesl_name.reverse()：将列表倒序排列（插入顺序，不是大小顺序）l_name.sort(reverse &#x3D; True)：将 l_name 以逆序（由大到小）排列，默认为 Falsel_name.copy()：返回列表的副本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-2-字典"><a href="#1-2-2-字典" class="headerlink" title="1.2.2 字典"></a>1.2.2 字典</h3><p><strong>字典类型</strong>：由键值对 (key-value) 表示，键必须唯一且不允许为空，申明：d_name = {key : value}，保存数据时根据 key 算出 value 的存放位置，具有极快的查询速度，查找和插入不会随着 key 值的增加而变慢，但占用大量内存，key 值必须是不可变对象；本身是可变对象</p><h4 id="1-2-2-1-字典处理函数"><a href="#1-2-2-1-字典处理函数" class="headerlink" title="1.2.2.1 字典处理函数"></a>1.2.2.1 字典处理函数</h4><p><strong>统计</strong></p><pre class="line-numbers language-none"><code class="language-none">len(d_name)：返回字典键值对数量max(d_name)、min(d_name)：返回 key 的最大最小值，不比较 value，需要字典 key值数据类型一致，即都为数值型或都为字符串<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>读取</strong></p><pre class="line-numbers language-none"><code class="language-none">dict_a &#x3D; &#123;&#39;a&#39;: 1, &#39;B&#39;: 2&#125;；dict_a &#x3D; &#123;&#125; 创建空字典dict_a[key]， 通过 key值获取相应的 value；如果 key值不存在，会报 KeyError 的错误；可以提前进行判断：key in dict_a，返回 True 或 Falsed_name.get(key[,default])：若 key值存在，则返回对应值；不存在且规定默认值，返回默认值；不存在未规定默认值，返回 Noned_name.keys()：返回字典的所有键d_name.values()：返回字典所有的值d_name.items()：返回字典所有的键值对索引：&lt;接受变量&gt; &#x3D; &lt;字典名称&gt;[&lt;键&gt;]遍历：for &lt;变量名&gt; in &lt;值域 &gt;:&lt;语句块&gt;&lt;值域&gt; 可以有 d_name.keys()、d_name.values()、d_name.items()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>操作</strong></p><pre class="line-numbers language-none"><code class="language-none"># 创建字典dict_a &#x3D; &#123;&#39;a&#39;: 1, &#39;B&#39;: 2&#125;dict_a &#x3D; dict(zip(key_list,value_list))   # zip 可以将多个序列组合成一个元组列表dict_a[key] &#x3D; value，如果 key 存在，就会修改 value 的内容；如果 key不存在，就会新增对应的 key:valued_name.update(d_name_o)，将 d_name_o 的数据加入到 d_name 中，如果 key 重复，则会更新为 d_name_o 对应 key 的 valued_name.pop(key[,default])：若 key值存在，返回对应 value值并删除该键值对；不存在且规定默认值，返回默认值；不存在未规定默认值，返回 Noned_name.popitem()：将字典中末尾的键值对以元组形式输出，并删除该键值对d_name.clear()：清空字典删除：del d_nam3[key]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-元组"><a href="#1-2-3-元组" class="headerlink" title="1.2.3 元组"></a>1.2.3 元组</h3><p><strong>元组类型</strong>：申明 t_name = ()，元组与列表类似，读取方式与列表一致，元组数据不可被修改，不可变对象（指向不可变对象，代码更安全，尽量使用元组代替列表）</p><pre class="line-numbers language-none"><code class="language-none">t_name &#x3D; (1, 2, 3)， 当只有一个元素的元组时，需要定义成 t_name &#x3D; (1，)；因为括号()既可以表示tuple，又可以表示数学公式中的小括号，为避免歧义，统一按小括号进行计算t_name&#x3D;4,5,6t_name &#x3D; () ，定义空元组t_name.count(); len(t_name)t_name.index()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可变元组</strong></p><pre class="line-numbers language-none"><code class="language-none">tuple_a &#x3D; (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])tuple_a[2][0] &#x3D; 1tuple_a[2][2] &#x3D; 2这时的 tuple_a 就变成了 (&#39;a&#39;, &#39;b&#39;, [1, 2])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-4-集合"><a href="#1-2-4-集合" class="headerlink" title="1.2.4 集合"></a>1.2.4 集合</h3><p><strong>集合</strong>：无顺序问题，输入不限，输出自动去重；申明：s_name = set() 或 s_name = {}，可变对象</p><h4 id="1-2-4-1-集合处理函数"><a href="#1-2-4-1-集合处理函数" class="headerlink" title="1.2.4.1 集合处理函数"></a>1.2.4.1 集合处理函数</h4><p><strong>创建</strong></p><pre class="line-numbers language-none"><code class="language-none">set_a &#x3D; set(&#39;apple&#39;, &#39;orange&#39;, &#39;pear&#39;, &#39;banana&#39;) set_a &#x3D; &#123;&#39;apple&#39;, &#39;orange&#39;, &#39;pear&#39;, &#39;banana&#39;&#125;创建空集合只能用 set_a &#x3D; set()，空大括号 &#123;&#125; 用来创建空字典<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>统计</strong></p><pre class="line-numbers language-none"><code class="language-none">len(s_name)：返回集合元素个数s_name.count()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>操作</strong></p><pre class="line-numbers language-none"><code class="language-none">s_name.add(key)：添加 key元素s_name.remove(key)：移除 key元素s_name.clear()：清空集合key in&#x2F;(not in) s_name：判断 key元素 是否在集合内<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>集合计算</strong></p><pre class="line-numbers language-none"><code class="language-none">a-b：在集合a却不在集合b中的元素a&amp;b：同时在集合a、b中的元素a^b：集合a、b各自独有的元素a|b：集合a、b共有的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可迭代对象</strong>（Iterable）：可以直接作用于 for 循环的对象，如：列表（list）、字典（dict）、元组（tuple）、集合（set）、字符串（str）、生成器（generator）、列表生成式</p><pre class="line-numbers language-none"><code class="language-none">isinstance([], Iterable)   # 可使用 isinstance() 判断一个对象的类型，返回 True 或 Falseisinstance((x for x in range(10)), Iterable)  # 返回 True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>迭代器</strong>（Iterator）：可以被 next() 函数调用并不断返回下一个值的对象，表示一个<strong>惰性计算</strong>（只有在需要返回下一个数据时才计算）的序列，如：生成器（generator）、列表生成式</p><pre class="line-numbers language-none"><code class="language-none">isinstance([], Iterator)   # 返回 Falseisinstance((x for x in range(10)), Iterable)  # 返回 True可以使用 iter() 函数将 可迭代对象（Iterable）变成 迭代器（Iterator）isinstance(iter([]), Iterator)  # 返回 True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-运算符"><a href="#1-3-运算符" class="headerlink" title="1.3 运算符"></a>1.3 运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">描述</th><th align="center">示例</th><th>数据类型</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">合并</td><td align="center">[1, 2] + [1, 3]，结果为[1, 2, 1, 3]</td><td>字符串、列表、元组</td></tr><tr><td align="center">*</td><td align="center">重复</td><td align="center">[1, 2] * 2，结果为[1, 2, 1, 2]</td><td>字符串、列表、元组</td></tr><tr><td align="center">[not] in</td><td align="center">判断存在</td><td align="center">1 [not] in [1, 2]，返回 False / True</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">&gt;  &gt;=  ==  &lt;  &lt;=</td><td align="center">元素比较</td><td align="center">[1, 2] &lt; [1, 3]，返回 True</td><td>字符串、列表、元组</td></tr></tbody></table><h1 id="2-变量"><a href="#2-变量" class="headerlink" title="2. 变量"></a>2. 变量</h1><p>数量可变化的内容，大小写英文、数字和 _ 的组合，且不能用数字开头<br>等号 = 是赋值语句：可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量</p><pre class="line-numbers language-none"><code class="language-none">a &#x3D; 123 # a是整数，Python 解释器在内存中创建了一个&#39;123&#39;的整数；同时创建了一个名为a的变量，并把它指向&#39;123&#39;print(a)a &#x3D; &#39;ABC&#39; # a变为字符串b&#x3D; a  # 把变量a的值赋值给变量b，实际上是把变量b指向变量a所指向的数据print(a,b)变量本身类型不固定的语言称为动态语言，如 Python；在定义变量时必须指定变量类型的语言称为静态语言，如果赋值的时候类型不匹配会报错，如 C、Java<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>局部变量</strong>：在函数内部定义的变量，只能在定义函数内部使用；在函数调用时创建，函数执行结束时回收</p><p><strong>全局变量</strong>：在函数外部定义的变量，所有函数内部都可以使用；不允许在函数内部修改全局变量的值，可用 global 申明改变</p><h2 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h2><p>常量就是不能变的变量，如常用的数学常数 π，通常用全部大写的变量名表示常量</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶-安全</title>
      <link href="/202110/188693.html"/>
      <url>/202110/188693.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 MySQL安全 的相关问题</p><span id="more"></span><h1 id="1-SQL注入"><a href="#1-SQL注入" class="headerlink" title="1. SQL注入"></a>1. SQL注入</h1><p><strong>原因</strong>：程序开发过程中不注意规范书写 SQL语句 和对特殊字符未进行过滤，到时客户端可以通过 post 和 get 提交 SQL语句 正常执行</p><p><strong>防止</strong>：</p><ol><li>开启配置文件中的 magic_quotes_gpc 和 magic_quotes_runtime 设置执行 SQL语句时使用 addslasges 进行 SQL语句 转换；</li><li>SQL语句 书写不省略双引号和单引号；</li><li>过滤掉 SQL语句 中的关键字，如：update、insert、delete</li><li>提高数据库表和字段的命名技巧，保证不易猜到</li></ol>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶-事务</title>
      <link href="/202109/1848384.html"/>
      <url>/202109/1848384.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 MySQL事务 的相关基础知识</p><span id="more"></span><h1 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h1><p><strong>事务</strong>：是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败；维护数据库的完整性</p><h2 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h2><h3 id="1-1-1-事务特性"><a href="#1-1-1-事务特性" class="headerlink" title="1.1.1 事务特性"></a>1.1.1 事务特性</h3><p><strong>原子性</strong>—A（atomicity）：事务是一个不可分割的工作单位，要么不做，要么全做<br><strong>一致性</strong>—C（consistency）：事务执行结果正确，事务前后数据的状态必须保持一致<br><strong>隔离性</strong>—I （isolation）：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离<br><strong>持久性</strong>—D（durability）：事务完成后，结果直到下一次修改前，永久保存</p><blockquote><p>开启事务环境：begin/start transaction;<br>提交事务：commit; 将数据更新修改操作本地持久化，在物理层面执行更新修改；一般采取隐含提交，即提交（写或保存）操作是自动进行，开启事务后需要手动提交<br>回滚事务：rollback; 撤销数据的更新修改操作，可以回退整个事务，也可以回退到某个保留点；只能在一个事务处理内使用，不能回退CREATE或DROP操作<br>保留点：savepoint； 指事务处理中设置的临时占位符，可以进行回退；保留点在事务处理完成后自动释放</p></blockquote><pre class="line-numbers language-none"><code class="language-none">savepoint savepoint_name;  -- 申明保留点RELEASE SAVEPOINT;  -- 释放保留点set autocommit &#x3D; 0&#x2F;1;  -- 设置是否自动提交，1 为是，0 为否commit;  -- 提交事务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-1-2-引发问题"><a href="#1-1-2-引发问题" class="headerlink" title="1.1.2 引发问题"></a>1.1.2 引发问题</h3><p><strong>丢失更新</strong>：Lose Update，两个及以上事务选择同一行，然后基于最初选定的值进行修改，会导致最后的更新覆盖了其他事务的更新，出现丢失更新问题<br><strong>脏读</strong>：Dirty Reades，事务A读取到事务B已修改但尚未提交的数据，并在这个数据的基础上进行操作；破坏了事务的一致性<br><strong>幻读</strong>：Phanton Reades，事务A读取到事务B在事务A未执行结束时的新增数据；破坏了事务的隔离性<br><strong>不可重复读</strong>：Non-Repeatable Reades，事务A未结束，两次读取的数据结果不一致（数据被更新或删除）；破坏了事务的隔离性</p><h2 id="1-2-锁机制"><a href="#1-2-锁机制" class="headerlink" title="1.2 锁机制"></a>1.2 锁机制</h2><p><strong>锁</strong>：是计算机协调多个进程或线程并发访问某一资源的机制；在数据库中，数据是一个所用户使用的共享资源，会存在多个事务同时存取同一数据的情况，需要进行并发控制，保证获取数据的一致性；加锁是当事务对某个数据进行操作前，先向系统请求加锁，进而限制其他事务对当前数据的操作，在当前事务完成前其他事务只能对锁定的数据执行规定内的操作，直到当前事务完成释放锁</p><h3 id="1-2-1-锁的分类"><a href="#1-2-1-锁的分类" class="headerlink" title="1.2.1 锁的分类"></a>1.2.1 锁的分类</h3><p><strong>数据操作类型</strong>：</p><ul><li><p><strong>共享锁</strong>：读锁，针对同一份数据，允许多个事务同时进行读操作，不会相互影响；<strong>添加读锁后，本身会话可以对表进行读操作，不能对锁定表进行写操作，也不能对其他表进行读操作；其他会话可以进行读操作，进行写操作会堵塞，等待读锁释放后进行写操作</strong></p></li><li><p><strong>排它锁</strong>：写锁，当前事务为写操作时，会对当前写操作涉及到的数据添加排它锁；<strong>添加写锁后，本身会话可以对表进行读操作，也可以对表进行写操作，不能对其他表进行读操作；其他会话进行读写操作会堵塞，等待写锁释放后进行读写操作</strong></p><blockquote><p>MyISAM读写锁调度以写优先，不适合写为主表的业务场景</p></blockquote></li></ul><p><strong>数据操作粒度</strong>：</p><ul><li><strong>表级锁</strong>：偏向于MyISAM存储引擎；开销小，加锁快，不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发量最低；通常用于读操作</li><li><strong>行级锁</strong>：偏向于InnoDB存储引擎；开销大，加锁慢，会出现死锁；锁力度小，发生锁冲突的概率小，并发度最高；通常用于写操作</li><li><strong>页面锁</strong>：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<blockquote><p>MyISAM 支持表锁；InnoDB 支持表锁和行锁，默认为行锁 </p></blockquote></li></ul><p><strong>其他</strong>：</p><ul><li><strong>间隙</strong>：使用范围条件检索数据时，对于键值在条件范围内但不存在的记录叫做 Gap间隙</li><li><strong>间隙锁</strong>：在操作数据并请求共享锁或排它锁时，InnoDB会对符合条件的已有数据记录的索引加锁，包括间隙，对间隙加的锁称为 间隙锁（Next-Key）</li></ul><h3 id="1-2-2-锁操作"><a href="#1-2-2-锁操作" class="headerlink" title="1.2.2 锁操作"></a>1.2.2 锁操作</h3><p><strong>表锁</strong>：</p><pre class="line-numbers language-none"><code class="language-none">show open tables;  -- 查看表添加锁的情况，In_use不为0，则已经加锁lock table tb_name_a read, tb_name_b write;  -- tb_name_a表上读锁，tb_name_b表上写锁unlock tables;  -- 解除所有表的锁定show status like &#39;table%&#39;;  -- 查看状态变量-- table_locks_immediate：产生标记锁定的次数，表示可以立即获取锁的查询次数，每立即获取锁值加1-- table_locks_waited：出现表级锁定争用而发生等待的次数（不能立即获取锁的次数，每等待一次值加1）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>行锁</strong>：<strong>索引失效后，会从行锁变成表锁</strong></p><pre class="line-numbers language-none"><code class="language-none">selct select_expr from tb_name where condition for update;  -- 手动对某一行进行上锁select name, age from user where id &#x3D; 1 for update;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">show status like &#39;innodb_row_lock%&#39;;  -- 查看行锁情况-- innodb_row_lock_current_waits：当前正在等待锁定的数量-- innodb_row_lock_time：系统锁定的总时长-- innodb_row_lock_time_avg：系统锁定的平均时长-- innodb_row_lock_time_max：系统锁定的最大时长-- innodb_row_lock_waites：系统锁定的总次数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-3-锁的优化"><a href="#1-2-3-锁的优化" class="headerlink" title="1.2.3 锁的优化"></a>1.2.3 锁的优化</h3><ol><li><p>尽可能所有的数据检索都通过索引完成，避免无索引行而升级为表锁</p></li><li><p>合理设计索引，尽量减少锁的范围</p></li><li><p>尽可能减少范围检索，避免间隙锁</p></li><li><p>尽量控制事务大小，减少锁定的资源量和锁持有时间</p></li><li><p>尽可能降低事务隔离级别</p></li><li><p>读写分离</p></li><li><p>分段加锁</p></li><li><p>多线程尽量以相同的顺序获取资源</p><blockquote><p>不能将锁的粒度过于细化，多次加锁和释放会影响事务执行效率</p></blockquote></li></ol><h2 id="1-3-事务隔离级别"><a href="#1-3-事务隔离级别" class="headerlink" title="1.3 事务隔离级别"></a>1.3 事务隔离级别</h2><p><strong>RU</strong>：read uncommited；读未提交，产生脏读<br><strong>RC</strong>：read committed；读已提交，产生不可重复读<br><strong>RR</strong>：repeatable read；可重复读，产生脏读（MySQL 在 RR 级别，脏读不存在）<br><strong>Serializable</strong>：序列化，不存在事务并发问题，为读写都加锁，效率不高</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;tx_isolation&#39;;  -- 查看当前数据库的事务隔离级别，MySQL默认是 RR<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>事务隔离级别</th><th>读数据一致性</th><th>是否脏读</th><th>是否不可重复读</th><th>是否幻读</th></tr></thead><tbody><tr><td>RU</td><td>最低级别，只能保证不读取物理上损坏的数据</td><td>是</td><td>是</td><td>是</td></tr><tr><td>RC</td><td>语句级</td><td>否</td><td>是</td><td>是</td></tr><tr><td>RR</td><td>事务级</td><td>否</td><td>否</td><td>是</td></tr><tr><td>Serializable</td><td>事务级，最高级别</td><td>否</td><td>否</td><td>否</td></tr></tbody></table><p>MySQL的 RC 和 RR 是通过 MVCC (多版本并发控制)机制实现：读不加锁，写加锁，读写不冲突</p><h3 id="1-3-1-MVCC"><a href="#1-3-1-MVCC" class="headerlink" title="1.3.1 MVCC"></a>1.3.1 MVCC</h3><p>通过回滚段undo log 和 ReadView 实现<br><strong>undo log</strong><br>分为 insert undo log 和 update undo log 两种</p><ul><li><p>insert undo log</p><blockquote><p>在 insert 过程中产生的 undo log<br>insert 操作的记录仅当前事务可见，其他事务不可见，insert undo log 可以在事务提交后直接删除，不需要进行 purge 操作</p></blockquote></li><li><p>update undo log</p><blockquote><p>在 update 或 delete 过程中产生的 undo log<br>会对已经存在的记录产生影响，update undo log 是在事务提交后加入到 history list 上，等待 purge 进程进行删除操作</p></blockquote></li></ul><p><strong>ReadView</strong><br>select 语句读取的版本取决于 ReadView，ReadView里面用一个列表 m_ids 存储的当前所有的活跃事务ID</p><blockquote><p>RC：在事务的每一个 select 语句都会实时产生一个 ReadView<br>RR：在事务的第一个 select 语句产生一个 ReadView</p></blockquote><ul><li>比较<blockquote><p>如果被访问版本的 trx_id 小于 m_ids 列表中最小的事务ID，表明生成该版本的事务在生成 ReadView 之前就已经提交，可以被访问<br>如果被访问版本的 trx_id 大于 m_ids 列表中最大的事务ID，表明生成该版本的事务在生成 ReadView 之后就已经提交，不可以访问<br>如果被访问版本的 trx_id 介于 m_ids 列表中最小的事务ID和最大的事务ID之间，需要对 trx_id 的值进行判断，如果在 m_ids 里，说明在生成 ReadView 时生成该版本的事务还是活跃的，不可以被访问；如果不在 m_ids 里，说明在生成 ReadView 时生成该版本的事务已经提交，可以被访问</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶-维护操作</title>
      <link href="/202109/1742389.html"/>
      <url>/202109/1742389.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录MySQL进阶-数据维护操作的相关知识，包括存储过程、游标和触发器</p><span id="more"></span><h1 id="1-存储过程"><a href="#1-存储过程" class="headerlink" title="1. 存储过程"></a>1. 存储过程</h1><p><strong>存储过程-procedure</strong>：预编译的SQL语句，为以后的使用而保存，类似于批文件，允许模块化设计，可用命令对象进行调用<br><strong>目的</strong>：简单、安全、高性能</p><blockquote><p>把处理封装在容易使用的单元中，简化复杂的操作<br>避免反复建立一系列处理步骤，保证数据的完整性和一致性<br>处理过程对使用者透明，简化对变动的管理；表名、列名或业务逻辑变化，只需要更改存储过程的代码<br>提高性能；使用存储过程比使用单独的SQL语句要快<br>编写功能更强更灵活的代码</p></blockquote><h2 id="1-1-操作"><a href="#1-1-操作" class="headerlink" title="1.1 操作"></a>1.1 操作</h2><ul><li><strong>创建存储过程</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">delimiter $$    -- delimiter $$：将语句分隔符修改为$$，delimiter用于修改语句分隔符create procedure pro_name([pramer_name data_type, out pramer_name data_type])[(Comment)]beginSQL_Listend $$delimiter ;   -- 重新定义，恢复成默认以英文分号 ; 结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>删除存储过程</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">drop procedure [IF EXISTS] pro_name;只给出存储过程名，后面没有小括号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>使用存储过程</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">1. 启用：call pro_name([pramer_value_list]);2. 使用查询 select pramer_value_list;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>检查存储过程</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">show create procedure pro_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="1-2-案例"><a href="#1-2-案例" class="headerlink" title="1.2 案例"></a>1.2 案例</h2><h3 id="1-2-1-输出参数"><a href="#1-2-1-输出参数" class="headerlink" title="1.2.1 输出参数"></a>1.2.1 输出参数</h3><ol><li><strong>创建</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">delimiter $$create procedure productpricing(out pl decimal(8,2),    -- out 申明输出变量，接收价格最低值；默认为in，输入参数out pm decimal(8,2),    -- out 申明输出变量，接收价格最高值out pa decimal(8,2)     -- out 申明输出变量，接收价格平均值)beginselect min(prod_price) into pl from products;    -- 使用 into 关键字将数据保存到相应的变量select max(prod_price) into pm from products;select avg(prod_price) into pa from products;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>使用</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">call procedure pro_name(@price_low,@price_max,@price_avg);  -- 所有MySQL变量都必须以@开始select @price_low, @price_max, @price_avg;  -- 在调用时，并不显示任何数据；完成调用后，申明的输出变量可在其他处理中使用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-2-2-输入输出参数"><a href="#1-2-2-输入输出参数" class="headerlink" title="1.2.2 输入输出参数"></a>1.2.2 输入输出参数</h3><ol><li><strong>创建</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">delimiter $$create procedure ordertotal(in onumber int,    -- in 申明输入变量，接收订单编号；in 可省略out ototal decimal(8,2)     -- 申明输出变量，接收订单金额)beginselect sum(item_price * quantity) from orderitems where order_num &#x3D; onumber into ototal;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>使用</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">call ordertotal(2005, @total);select @total;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="1-2-3-复杂案例"><a href="#1-2-3-复杂案例" class="headerlink" title="1.2.3 复杂案例"></a>1.2.3 复杂案例</h3><ol><li><strong>创建</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">delimiter $$create procedure ordertotal(in onumber int,    -- 申明输入变量，接收订单编号in taxable boolean,    -- 申明输入变量，接收是否收税out ototal decimal(8,2)     -- 申明输出变量，接收订单金额)(Comment &#39;add tax&#39;)begindeclare total decimal(8,2);       -- 申明局部变量，存储订单金额declare taxrate int default 6;    -- 申明局部变量，存储税率；默认为6%select sum(item_price * quantity) from orderitems where order_num &#x3D; onumber into total;if taxable thenselect total + (total&#x2F;100 * taxrate) into totalend if;select total into ototal;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><strong>使用</strong></li></ol><pre class="line-numbers language-none"><code class="language-none">call procedure ordertotal(2005, 0, @total);select @total;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-- 例：批量插入数据脚本delimiter $$ create procedure insert_emp(in start int(10),in max_num int(10))begindeclare i int default 0;set autocommit &#x3D; 0;repeatset i &#x3D; i+1;insert into emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) values((start+i),ran_string(6),&#39;salesman&#39;,0001,curdate(),2000,400,rand_num());until i&#x3D;max_numend repeat;commit;end $$delimiter ;delimiter $$ create procedure insert_dept(in start int(10),in max_num int(10))begindeclare i int default 0;set autocommit &#x3D; 0;repeatset i &#x3D; i+1;insert into dept(deptno,dname,loc) values((start+i),ran_string(10),ran_string(8));until i&#x3D;max_numend repeat;commit;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-游标"><a href="#2-游标" class="headerlink" title="2. 游标"></a>2. 游标</h1><p><strong>游标-cursor</strong>：一个存储在 MySQL 服务器上的数据库查询，是 SQL 语句检索出来的结果集；存储游标后，应用程序可以根据需要滚动或浏览其中的数据；MySQL游标只能用于存储过程（和函数）</p><h2 id="2-1-使用"><a href="#2-1-使用" class="headerlink" title="2.1 使用"></a>2.1 使用</h2><p><strong>过程</strong></p><ol><li>使用游标前，必须声明（定义）</li><li>声明后，打开游标以供使用；这个过程用前面定义的 SELECT 语句把数据实际检索出来</li><li>对于填有数据的游标，根据需要取出（检索）各行</li><li>在结束游标使用时，必须关闭游标</li></ol><h3 id="2-1-1-创建"><a href="#2-1-1-创建" class="headerlink" title="2.1.1 创建"></a>2.1.1 创建</h3><pre class="line-numbers language-none"><code class="language-none">create procrdure processorders()begindeclare ordernumbers cursorforselect order_num from orders;end;创建了名为 processorders 的存储过程和名为 ordernumbers 的游标，游标可以检索所有订单的 SELECT 语句；存储过程处理完成后，游标消失（局限于存储过程）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-2-开关"><a href="#2-1-2-开关" class="headerlink" title="2.1.2 开关"></a>2.1.2 开关</h3><pre class="line-numbers language-none"><code class="language-none">open ordernumbers;    -- 开启游标；在处理OPEN语句时执行查询，存储检索出的数据以供浏览和滚动close ordernumbers;   -- 关闭游标；CLOSE释放游标使用的所有内部内存和资源，应该及时关闭游标；不明确申明关闭游标，MySQL将会在到达END语句时自动关闭<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="2-1-3-实例"><a href="#2-1-3-实例" class="headerlink" title="2.1.3 实例"></a>2.1.3 实例</h3><p><strong>检索单行</strong></p><pre class="line-numbers language-none"><code class="language-none">create procrdure processorders()begindeclare o int;declare ordernumbers cursorforselect order_num from orders;open ordernumbers;fetch ordernumbers into o;  -- 游标被打开后，FETCH 用来检索指定列 order_num 当前行的数据，并将数据加载到一个名为 o 的局部声明的变量中，对检索出的数据不做任何处理；自动从第一行开始检索close ordernumbers;end;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>循环检索</strong></p><pre class="line-numbers language-none"><code class="language-none">create procrdure processorders()begindeclare done boolean default 0;declare o int;declare ordernumbers cursor for select order_num from orders;declare continue handler for SQLSTATE &#39;02000&#39; set done &#x3D; 1;   -- 指出当SQLSTATE &#39;02000&#39;出现时，SET done&#x3D;1；SQLSTATE &#39;02000&#39; 出现在REPEAT 没有更多的行供循环而不能继续时open ordernumbers;repeatfetch ordernumbers into o;until done end repeat;    -- 直到临时变量 done 为真时结束 repeatclose ordernumbers;end;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>上例修改</strong></p><pre class="line-numbers language-none"><code class="language-none">create procrdure processorders()begindeclare done boolean default 0;declare o int;declare t decimal(8,2);declare ordernumbers cursor for select order_num from orders;declare continue handler for SQLSTATE &#39;02000&#39; set done &#x3D; 1;create table if not exists ordertotals(order_num int, total decimal(8,2));open ordernumbers;repeatfetch ordernumbers into o;call ordertotal(o, 1, t);  -- 调用存储过程，计算带税合计insert into ordertotals(order_num, total) values(o, t);until done end repeat;close ordernumbers;end;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-触发器"><a href="#3-触发器" class="headerlink" title="3. 触发器"></a>3. 触发器</h1><p><strong>触发器</strong>：是与表有关的命名数据库对象，当表上特定事件发生时触发执行特定 SQL；触发器在每个表中不能重名，同一数据库中的两个表可具有相同名字的触发器，尽量在数据库范围内使用唯一的触发器名；一个事件只支持创建一个触发器，每个表最多支持6个触发器，可能出现锁表的现象；只有表才支持触发器，视图不支持</p><blockquote><p>唯一的触发器名<br>触发器关联的表<br>触发器应该响应的活动（DELETE、INSERT或UPDATE）<br>触发器何时执行（处理之前或之后）</p></blockquote><h2 id="3-1-使用"><a href="#3-1-使用" class="headerlink" title="3.1 使用"></a>3.1 使用</h2><ul><li><p><strong>创建触发器</strong></p><pre class="line-numbers language-none"><code class="language-none">CREATE TRIGGER trigger_name trigger_time(before&#x2F;after) trigger_event(INSERT&#x2F;delete&#x2F;update) ON tb_name FOR EACH ROW 执行性SQL_List;trigger_event：指明激活触发器的语句的类型，包括 INSERT、UPDATE、DELETE，即插入、修改、删除数据时激活触发器，执行预定义的代码trigger_time：指明激活触发器的动作时间，包括 BEFORE 和 AFTER，如在删除前执行操作或删除后执行操作FOR EACH ROW：针对每一行更新都触发CREATE TRIGGER audit_log after insert on employees_test FOR EACH ROW insert into audit values(new.id, new.name);创建触发器audit_log：当 employees_test 表插入数据后，将新ID和新名称添加到 into 表里<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>删除触发器</strong></p><pre class="line-numbers language-none"><code class="language-none">DROP TRIGGER trigger_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>查看触发器</strong></p><pre class="line-numbers language-none"><code class="language-none">show create trigger_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><strong>特殊执行</strong></p><pre class="line-numbers language-none"><code class="language-none">INSERT INTO on duplicate key update 语法触发：如果没有重复记录，触发：before INSERT, after INSERT如果有重复记录并更新，触发：before INSERT, before update, after update如果有重复记录无更新，触发：before INSERT,befor updateReplace语法如果有记录，触发：before INSERT, before delete, after delete, after INSERT<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h3 id="3-1-1-INSERT触发器"><a href="#3-1-1-INSERT触发器" class="headerlink" title="3.1.1 INSERT触发器"></a>3.1.1 INSERT触发器</h3><p><strong>INSERT触发器</strong>：INSERT 触发器在 INSERT 语句执行之前或之后执行</p><blockquote><p>在 INSERT 触发器代码内，可引用一个名为 NEW 的虚拟表，访问被插入的行；INSERT 没有 old 记录<br>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新（允许更改被插入的值）<br>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含0，执行后包含新的自动生成值</p></blockquote><pre class="line-numbers language-none"><code class="language-none">CREATE TRIGGER neworder after insert on orders FOR EACH ROW select new.order_num;创建 neworder 触发器： order 表插入一行之后，返回新纪录自动生成的 order_num；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-1-2-DELETE触发器"><a href="#3-1-2-DELETE触发器" class="headerlink" title="3.1.2 DELETE触发器"></a>3.1.2 DELETE触发器</h3><p><strong>DELETE触发器</strong>：DELETE 触发器在 DELETE 语句执行之前或之后执行</p><blockquote><p>在 BEFORE UPDATE 触发器中，NEW 中的值可以被更新，即允许更改将要用于UPDATE语句中的值<br>OLD 中的值全都是只读的，不能更新；delete 没有 new 记录</p></blockquote><pre class="line-numbers language-none"><code class="language-none">CREATE TRIGGER updateorder before update on orders FOR EACH ROW set new.vend_state &#x3D; upper(new.vend_state);创建 neworder 触发器： order 表更新一行之前，将删除记录的 order_num, order_date, cust_id 插入到 archive_orders 表中；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-1-3-UPDATE触发器"><a href="#3-1-3-UPDATE触发器" class="headerlink" title="3.1.3 UPDATE触发器"></a>3.1.3 UPDATE触发器</h3><p><strong>UPDATE触发器</strong>：UPDATE 触发器在 UPDATE 语句执行之前或之后执行</p><blockquote><p>在 DELETE 触发器代码内，你可以引用一个名为 OLD 的虚拟表，访问被删除的行<br>OLD 中的值全都是只读的，不能更新；UPDATE 拥有 new 和 old 记录</p></blockquote><pre class="line-numbers language-none"><code class="language-none">CREATE TRIGGER deleteorder before delete on orders FOR EACH ROW begininsert into archive_orders(order_num, order_date, cust_id) values(old.order_num, old.order_date, old.cust_id)end;创建 neworder 触发器：当 order 表更新一行之前，将更新记录的 order_num 全部变为大写后, 再更新到指定的记录中；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-1-4-注意"><a href="#3-1-4-注意" class="headerlink" title="3.1.4 注意"></a>3.1.4 注意</h2><blockquote><p>创建触发器可能需要特殊的安全访问权限，与对应的 INSERT、UPDATE 或 DELETE 语句 权限需求相同<br>应该用触发器来保证数据的一致性（大小写、格式等）；自动规范化进行，对客户机透明<br>可以创建审计跟踪，把更改记录到另一个表<br>触发器中不支持CALL语句，不能从触发器内调用存储过程</p></blockquote><h1 id="4-事务"><a href="#4-事务" class="headerlink" title="4. 事务"></a>4. 事务</h1><p><strong>事务</strong>：是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败；维护数据库的完整性</p><h2 id="4-1-事务特性"><a href="#4-1-事务特性" class="headerlink" title="4.1 事务特性"></a>4.1 事务特性</h2><p><strong>原子性</strong>—A（atomicity）：事务是一个不可分割的工作单位，要么不做，要么全做<br><strong>一致性</strong>—C（consistency）：事务执行结果正确，事务前后数据的状态必须保持一致<br><strong>隔离性</strong>—I （isolation）：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离<br><strong>持久性</strong>—D（durability）：事务完成后，结果直到下一次修改前，永久保存</p><blockquote><p>开启事务环境：begin/start transaction;<br>提交事务：commit; 将数据更新修改操作本地持久化，在物理层面执行更新修改；一般采取隐含提交，即提交（写或保存）操作是自动进行，开启事务后需要手动提交<br>回滚事务：rollback; 撤销数据的更新修改操作，可以回退整个事务，也可以回退到某个保留点；只能在一个事务处理内使用，不能回退CREATE或DROP操作<br>保留点：savepoint； 指事务处理中设置的临时占位符，可以进行回退；保留点在事务处理完成后自动释放</p></blockquote><pre class="line-numbers language-none"><code class="language-none">savepoint savepoint_name;  -- 申明保留点RELEASE SAVEPOINT;  -- 释放保留点<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">set autocommit &#x3D; 0&#x2F;1;  -- 设置是否自动提交，1 为是，0 为否<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="4-2-隔离级别"><a href="#4-2-隔离级别" class="headerlink" title="4.2 隔离级别"></a>4.2 隔离级别</h2><p>RU：read uncommited；读未提交，产生脏读<br>RC：read committed；读已提交，产生不可重复读<br>RR：repeatable read；可重复读，产生脏读（MySQL 在 RR 级别，脏读不存在）<br>Serializable：不存在事务并发问题，为读写都加锁，效率不高</p><p>MySQL 的 RC 和 RR 是通过 MVCC (多版本并发控制)机制实现：读不加锁，写加锁，读写不冲突</p><h1 id="5-用户"><a href="#5-用户" class="headerlink" title="5. 用户"></a>5. 用户</h1><h2 id="5-1-操作"><a href="#5-1-操作" class="headerlink" title="5.1 操作"></a>5.1 操作</h2><ul><li><strong>创建用户</strong><pre class="line-numbers language-none"><code class="language-none">create user &#39;user_name&#39;[@&#39;ip&#39;] identified by &#39;password&#39;;ip：表示允许用户登录的主机ip，%表示所有机器，localhost表示只允许本机登录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><strong>修改</strong><pre class="line-numbers language-none"><code class="language-none">rename old_user_name to new_user_name;  -- 重命名set password for user_name &#x3D; password(&#39;xxx&#39;);  -- 修改密码；在不指定用户名时，默认更新当前登录用户的口令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><strong>删除用户</strong><pre class="line-numbers language-none"><code class="language-none">drop user user_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h2 id="5-2-权限管理"><a href="#5-2-权限管理" class="headerlink" title="5.2 权限管理"></a>5.2 权限管理</h2><ul><li><strong>权限表</strong>：MySQL服务器通过权限表来控制用户对数据库的访问，权限表存储在数据库里，由MySQL_install_db脚本初始化，权限表</li></ul><blockquote><p><strong>user</strong>：记录允许连接到服务器的用户账号信息，里面的权限是全局级的<br><strong>db</strong>：记录各个账号在各个数据库上的操作权限<br><strong>table_priv</strong>：记录数据表级的操作权限<br><strong>columns_priv</strong>：记录数据列级的操作权限<br><strong>host</strong>：配合db权限表对给定主机上数据库级操作权限做更细致的控制，不受grant、revoke的影响</p></blockquote><ul><li><strong>赋予权限</strong>：包括要授予的权限、被授予访问权限的数据库或表和用户名<pre class="line-numbers language-none"><code class="language-none">grant privileges on db_name&#x2F;tb_name to user_name;grant select, insert on user_info to user_name;  -- 支持一次授予多个权限权限对象包括：服务器、数据库、数据表、数据列、存储过程、触发器、函数服务器：GRANT ALL数据库：ON database.*数据表：ON db_name.tb_name数据列：ON db_name.tb_name.col_name存储过程、触发器、函数的权限对应到具体的表或者字段<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/privileges.jpg" alt="privileges"></li></ul><ul><li><strong>查看权限</strong><pre class="line-numbers language-none"><code class="language-none">show grants for user_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><strong>回收权限</strong>：撤销的访问权限必须存在，否则会出错<pre class="line-numbers language-none"><code class="language-none">revoke privileges on db_name&#x2F;tb_name from user_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><h1 id="6-日常维护"><a href="#6-日常维护" class="headerlink" title="6. 日常维护"></a>6. 日常维护</h1><h2 id="6-1-分析数据表"><a href="#6-1-分析数据表" class="headerlink" title="6.1 分析数据表"></a>6.1 分析数据表</h2><p><strong>分析数据表</strong>：ANALYZE TABLE，用来检查表键是否正确</p><pre class="line-numbers language-none"><code class="language-none">ANALYZE TABLE tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶-索引</title>
      <link href="/202109/1525719.html"/>
      <url>/202109/1525719.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 MySQL索引 的相关基础知识</p><span id="more"></span><h1 id="1-索引介绍"><a href="#1-索引介绍" class="headerlink" title="1. 索引介绍"></a>1. 索引介绍</h1><p><strong>索引</strong>：是帮助数据库高效获取数据的 <strong>数据结构</strong>（排好序的快速查找数据结构），会影响到 where 条件后的条件过滤和 order by 排序；常用于数据库优化，提高检索速度；MyISM存储引擎下索引和数据分离，InnoDB存储引擎下索引和数据不分离</p><h2 id="1-1-优缺点"><a href="#1-1-优缺点" class="headerlink" title="1.1 优缺点"></a>1.1 优缺点</h2><p><strong>优点</strong>：</p><ul><li>提高数据检索的效率，降低数据库的 I/O成本</li><li>提高数据排序的效率，降低CPU的消耗</li></ul><p><strong>缺点</strong>：</p><ul><li>索引也是一张表，里面存储主键和索引字段，并指向实体记录；会占用额外的存储空间</li><li>对表进行增删改时，索引也会动态维护数据更新后的索引信息，包括主键、索引字段和指向信息等，降低了数据的维护速度</li><li>需要根据实际业务情况，不断更新重建最合适的索引</li><li>在最频繁使用以缩小查询范围、频繁使用需要排序的字段上建立索引；不宜在很少在查询中涉及或者重复值比较多的列或者数据类型是文本的字段上建立索引</li></ul><h2 id="1-2-创建字段"><a href="#1-2-创建字段" class="headerlink" title="1.2 创建字段"></a>1.2 创建字段</h2><p><strong>适合创建索引的字段</strong>：高并发下倾向创建复合索引</p><ul><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该建立索引，如 身份证号、联系电话、银行账号、用户账号等</li><li>查询中与其他表关联的字段，如 外键字段</li><li>查询中用于排序的字段，排序字段通过索引访问会提高排序速度</li><li>查询中统计或分组的字段，分组前要进行排序</li></ul><p><strong>禁止创建索引字段</strong>：</p><ul><li>频繁更新的字段，每次更新操作，不仅会更新数据，还会更新索引</li><li>where条件 中用不到的字段</li><li>数据重复且分布平均的表字段</li></ul><h2 id="1-3-分类"><a href="#1-3-分类" class="headerlink" title="1.3 分类"></a>1.3 分类</h2><p><strong>按应用层次分类</strong></p><ul><li><strong>主索引</strong>：所有索引依赖的索引，辅助索引都是依赖主索引建立的，辅助索引叶子结点存储的不是数据的地址，而是主索引的值，先查到主索引的值，再根据主索引的值查找到具体的数据</li><li><strong>唯一索引</strong>：索引列的值必须唯一，但允许空值</li><li><strong>单值索引</strong>：也称普通索引，一个索引只包含一列，一个表可以有多个单值索引，允许数据列包含重复值；可针对频繁查找的列创建单值索引</li><li><strong>复合索引</strong>：多列值组成一个索引，专门用于组合搜索；效率高于索引合并，即创建复合索引优于单值索引</li></ul><p><strong>按物理顺序与键值的逻辑(索引)顺序分类</strong></p><ul><li><strong>聚集索引/聚簇索引</strong>：指的是一种数据存储方式，InnoDB的聚集索引是在同一个结构中保存了BTree索引和数据行</li><li><strong>非聚集索引/非聚簇索引</strong>：不是聚集索引，就是非聚集索引</li></ul><p><strong>按存储结构分类</strong></p><ul><li><p><strong>B-Tree索引</strong>：利用B树，将数据均匀分布在各个环节点中，可以加快数据访问速度 </p></li><li><p><strong>B+Tree索引</strong>：是B-Tree索引的改进版本，同时也是数据库索引索引采用的存储结构，数据都在叶子节点上，增加了顺序访问指针，每个叶子节点都指向相邻叶子节点的地址，进行范围查找时 B+Tree 只需要查找两个节点进行便利，B-Tree 需要获取所有节点，查询效率优于 B-Tree 索引，B+Tree 在新增数据时，会根据索引指定列的值，对旧的的 B+Tree 进行调整</p><blockquote><p>B-Tree、B+Tree都是用页(4k)来划分节点大小，B+Tree中间节点不存储数据，在同样大小的节点中，B+Tree可以存储更多的key，提升查找效率</p></blockquote></li><li><p><strong>Hash索引</strong>：基于 hash 表实现，只有精确匹配索引所有列的查询才有效，对每一条记录的所有索引列计算出一个哈希码(hash code)，并将哈希码存储在索引中，同时在索引表中保存每个数据行的指针</p></li><li><p><strong>full-index索引</strong>：(只有 MyISAM 存储引擎支持)  sphinx  + 中文分词  coreseek ，目前 innodb 也支持</p></li><li><p><strong>R-Tree索引</strong></p><ul><li>在 MyISAM 引擎中，B+Tree 索引采用非聚集索引实现，InnoDB 采用聚集索引实现，InnoDB 中，所有的辅助索引(叶子节点中存储的是主索引的值，在定位到记录的地址)都依赖于主索引建立</li><li>InnoDB 显式支持 B-Tree 索引(技术上是 B+Tree 索引)，对于频繁访问的表，InnoDB 会透明建立hash索引(在B树索引基础上建立 hash 索引，可以显著提高效率，客户端不可控制)</li></ul></li><li><p><strong>索引结构采用B+Tree的原因</strong></p><ul><li>B树的叶子节点和非叶子节点都会保存数据，导致非叶子节点保存的指针数量变少(扇出)，指针少的情况下要保存大量数据只能增加树的高度，导致IO操作增加，查询效率降低</li><li>二叉树：树的高度不均匀，不能自平衡，导致查询效率低，并且IO代价高</li><li>红黑树：树的高度随着数据量的增加而增加，IO代价高</li><li>Hash：虽然可以快速定位，但是没有顺序，IO复杂度高</li></ul></li></ul><h2 id="1-4-使用注意"><a href="#1-4-使用注意" class="headerlink" title="1.4 使用注意"></a>1.4 使用注意</h2><p><strong>启用条件</strong>：</p><ul><li>使用复合索引时，遵循 <strong>最佳左前缀法则</strong>（查询从索引的最左前列开始，并且不跳过索引中的列；条件顺序不一致时，仍可以使用索引，但不能缺少），即查询条件使用了最左边的列，会使用索引</li><li>查询列类型是字符串 varchar类型时，在条件中使用单引号引用</li><li>使用 <strong>覆盖索引</strong>（查询的字段与复合索引的字段一致，减少使用 select *），会使用索引</li><li>使用 <strong>like查询</strong>，在 %或 _不在第一个字符的模糊匹配时，会使用索引</li></ul><p><strong>失效条件</strong>：</p><ul><li>使用复合索引时，未遵循 最佳左前缀法则</li><li>在索引列上进行操作（计算、函数、自动手动隐式类型转换：如，varchar类型 不加单引号可能会自动转换成 int型），会导致索引失效</li><li>存储引擎不能使用索引中范围条件右边的列，即某一个索引列上进行范围查找，则创建索引位于该列右边的索引列不会被使用</li><li>mysql 使用不等于（!=、&lt;&gt;）时无法使用索引</li><li>使用 col_name is [not] null 将使用无法索引</li><li>使用 like查询，使用以 %或 _ 开头的模糊匹配语句，如果业务需求一定实现，可使用覆盖索引进行优化</li><li>使用 or查询，索引会失效，<del>条件前后没有同时使用索引</del></li><li>如果mysql估计使用全表扫描要比使用索引快，则不使用索引</li></ul><table><thead><tr><th>Where语句（假设index(a,b,c)）</th><th>索引是否被使用</th></tr></thead><tbody><tr><td>where a = 3</td><td>Y，使用到a</td></tr><tr><td>where a = 3 and b = 5</td><td>Y，使用到a，b</td></tr><tr><td>where a = 3 and b = 5</td><td>Y，使用到a，b，c</td></tr><tr><td>where b = 3 或者 where b = 3 and c = 4 或者 where c = 4</td><td>N，没有用到a字段</td></tr><tr><td>where a = 3 and c = 5</td><td>使用到a，但是没有用到c，因为b断了</td></tr><tr><td>where a = 3 and b &gt; 4 and c = 5</td><td>使用到a，b，但是没有用到c，因为c在范围之后</td></tr><tr><td>where a = 3 and b like ‘kk%’ and c = 4</td><td>Y，a，b，c都用到</td></tr><tr><td>where a = 3 and b like ‘%kk’ and c = 4</td><td>只用到a</td></tr><tr><td>where a = 3 and b like ‘%kk%’ and c = 4</td><td>只用到a</td></tr><tr><td>where a = 3 and b like ‘k%kk%’ and c = 4</td><td>Y，a，b，c都用到</td></tr></tbody></table><p><strong>注意</strong>：</p><ul><li>数据量太少的表不建议创建索引（数据量少于百万级）</li><li>一张表创建索引尽量不要超过5个</li><li>尽量采用自增主键作为主索引：自增主键是连续的，具有较少的页分裂，并且能减少数据移动（减少分裂和减少数据移动）</li><li>两张表关联时，在相反表上创建索引，即左连接则在右表上创建索引，右连接则在左表上创建索引；<strong>在连接的副表上创建索引</strong></li><li>创建单值索引时，应选择过滤性更好的字段；创建复合索引时，尽量选择可以包含更多 where条件字段的索引，并且过滤性更好的字段位置越靠左越好</li></ul><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><ul><li><strong>建立索引</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">CREATE [UNIQUE|FULLTEXT] INDEX index_name on tb_name (col_name [(length)]  [ASC|DESC], ...);ALTER TABLE tb_name ADD INDEX [index_name]  (index_col_name,...)alter table actor add unique index uniq_idx_firstname(first_name);  -- 在 actor 表的first_name 字段上添加唯一性索引 uniq_idx_firstnamealter table tb_name add primary key (col_name_list);  -- 创建主键索引，且不能为nullalter table tb_name add unique index index_name (col_name_list);  -- 创建唯一索引，可以为nullalter table tb_name add index_name (col_name_list);  -- 创建普通索引alter table tb_name add fulltext index_name (col_name_list);  -- 指定索引为 FULLTEXT，用于全文索引<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>删除索引</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">DROP INDEX index_name ON tb_name;ALTER TABLE tb_name drop index index_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>查询索引</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">SHOW INDEX FROM tb_name;SHOW KEYS FROM tb_name;DESC tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>查看索引使用情况</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">show status like &#39;handler_read%&#39;;handler_read_key：这个值越高越好，越高表示使用索引查询到的次数越多handler_read_rnd_next：这个值越低越好，越高表示查询越低效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>使用索引</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">select * from salaries FORCE INDEX (idx_emp_no) where emp_no &#x3D; 10005;  -- 强制按照 idx_emp_no 索引查询 salaries 表里 emp_no &#x3D; 10005 的所有信息<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-全文本搜索"><a href="#3-全文本搜索" class="headerlink" title="3. 全文本搜索"></a>3. 全文本搜索</h1><p><strong>全文本搜索</strong>：创建时使用 FULLTEXT 关键字进行申明，其他操作与普通索引相同；定义之后在增加、更新或删除行时，索引自动更新，使用 Match() 和 Against() 两个函数执行全文本搜索；全文本搜索的性能优于 like 和正则，可以明确配置匹配的关键字，可以智能化选择结果</p><pre class="line-numbers language-none"><code class="language-none">MATCH (col_name_list) AGAINST (expr)：Match()指定被搜索的列，Against()指定要使用的搜索表达式，传递给 Match() 的值必须与 FULLTEXT()定义中的相同；默认不区分大小写，可使用 BINARY 方式FULLTEXT(col_name)：可在建表字段定义之后申明，也可通过创建索引方式申明select note_textfrom productnoteswhere MATCH (note_text) AGAINST (&#39;rabbit&#39;); 等价于 where  note_text like &#39;%rabbit%&#39;;使用全文本搜索返回以文本匹配良好程度排序的数据，可使用 select 查询文本匹配良好程度值，文本中词靠前行的等级值高<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-1-查询扩展"><a href="#3-1-查询扩展" class="headerlink" title="3.1 查询扩展"></a>3.1 查询扩展</h2><p><strong>查询扩展</strong>：查询与指定关键词可能相关的数据，即使不包含给定关键字</p><pre class="line-numbers language-none"><code class="language-none">MATCH (col_name_list) AGAINST (&#39;xxx&#39; with query expansion) <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>首先，进行一个基本的全文本搜索，找出与搜索条件匹配的所有行</li><li>之后，MySQL检查这些匹配行并选择所有有用的词</li><li>最后，MySQL再次进行全文本搜索，这次不包括原来的条件和所有有用的词</li></ol><p><strong>使用说明</strong>：</p><ol><li>短词定义为具有3个或3个以下字符的词，数目可以更改</li><li>MySQL带有一个内建的非用词（stopword）列表，在索引全文本数据时总是被忽略，可以根据需要覆盖修改这个列表</li><li>MySQL规定了一条50%规则：如果一个词出现在50%以上的行中，则将它作为一个非用词忽略；50%规则不用于IN BOOLEAN MODE</li><li>表中的行数少于3行，则全文本搜索不返回结果；每个词或者不出现，或者至少出现在50%的行中</li><li>忽略词中的单引号；如，don’t索引为dont</li><li>不具有词分隔符（包括日语和汉语）的语言不能恰当地返回全文本搜索结果</li></ol><h2 id="3-2-布尔文本搜索"><a href="#3-2-布尔文本搜索" class="headerlink" title="3.2 布尔文本搜索"></a>3.2 布尔文本搜索</h2><p><strong>布尔文本搜索</strong>：全文本搜索的另外一种形式，即使没有定义 FULLTEXT 索引，也可以使用</p><pre class="line-numbers language-none"><code class="language-none">MATCH (col_name_list) AGAINST (&#39;xxx&#39; in boolean mode)；支持布尔操作符限定词语<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th align="center">布尔操作符</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">+</td><td align="left">包含，词必须存在</td></tr><tr><td align="center">-</td><td align="left">排除，词必须不出现</td></tr><tr><td align="center">&gt;</td><td align="left">包含，且增加等级值</td></tr><tr><td align="center">&lt;</td><td align="left">包含，且减少等级值</td></tr><tr><td align="center">()</td><td align="left">把词组成子表达式（允许子表达式作为一个组被包含、排除、排列等）</td></tr><tr><td align="center">~</td><td align="left">取消一个词的排序值</td></tr><tr><td align="center">*</td><td align="left">词尾的通配符</td></tr><tr><td align="center">“”</td><td align="left">定义一个短语（匹配整个短语以便包含或排除这个短语）</td></tr></tbody></table><pre class="line-numbers language-none"><code class="language-none">select note_textfrom productnoteswhere MATCH (note_text) AGAINST (&#39;rabbit dog&#39; in boolean mode); 检索 productnotes 表的 note_text 中含有 rabbit 或 dog 的数据where MATCH (note_text) AGAINST (&#39;rabbit -dog&#39; in boolean mode); 检索 productnotes 表的 note_text 中含有 rabbit 且不含 dog 的数据where MATCH (note_text) AGAINST (&#39;+rabbit +dog&#39; in boolean mode); 检索 productnotes 表的 note_text 中必须同时含有 rabbit 和 dog 的数据where MATCH (note_text) AGAINST (&#39;&quot;rabbit dog&quot;&#39; in boolean mode); 检索 productnotes 表的 note_text 中含有 rabbit dog 短语的数据where MATCH (note_text) AGAINST (&#39;&gt;rabbit &lt;dog&#39; in boolean mode); 检索 productnotes 表的 note_text 中含有 rabbit 或 dog 的数据，且以 rabbit 为主计算文本匹配良好程度where MATCH (note_text) AGAINST (&#39;+rabbit +(&lt;dog)&#39; in boolean mode); 检索 productnotes 表的 note_text 中必须同时含有 rabbit 和 dog 的数据，且以 rabbit 为主计算文本匹配良好程度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>提供数据</strong></p><blockquote><p>匹配词语<br>排斥词语：如果某行包含这个词，则不返回该行，即使包含匹配词语<br>排列提示：指定匹配词语的等级<br>表达式分组</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-基础</title>
      <link href="/202109/1115868.html"/>
      <url>/202109/1115868.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要对 MySQL的基础通识知识 进行简单介绍</p><span id="more"></span><h1 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1. 简单介绍"></a>1. 简单介绍</h1><h2 id="1-1-逻辑架构"><a href="#1-1-逻辑架构" class="headerlink" title="1.1 逻辑架构"></a>1.1 逻辑架构</h2><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/Logic_framer.jpg" alt="Logic_framer"></p><p><strong>连接层</strong>：</p><p>Connectors，提供与客户端的连接服务，主要包括连接处理、授权认证、安全方案等，引入线程池的概念，为通过安全认证的连接提供线程</p><p><strong>服务层</strong>：提供SQL接收接口（针对 select 语句会优先进行缓存查询），随后完成SQL的解析（形成解析数）和优化（索引、连接顺序等，形成优化后的解析数）及部分内置函数的执行</p><ul><li><p>Connection Management：连接池，进行连接管理</p></li><li><p>SQL Interface：SQL接口</p></li><li><p>Parser：解析器</p></li><li><p>Optimizer：优化器</p></li><li><p>Caches &amp; Buffers：缓存和缓冲</p></li><li><p>Management Service &amp; Utilities：</p></li></ul><p><strong>存储引擎层</strong>：真正实现 MySQL 的数据存储和提取，较常用的是 MyISAM（5.5及之前默认） 和 InnoDB（5.5 之后默认，可进行配置）</p><p>Pluggable Storage Engines(可拔插存储引擎)，插件式的存储引擎架构将查询处理、其他系统任务和数据存储提取相分离，可根据合适的业务场景选择哈市的存储引擎</p><pre class="line-numbers language-none"><code class="language-none">show engines;                            -- 查看现在提供的存储引擎列表，Support中为default为当前默认的存储引擎show variables like &quot;%storage_engine%&quot;;  -- 查看当前默认提供的存储引擎<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>数据存储层</strong>：将数据存储在硬件设备上，并完成与存储引擎的交互</p><p>File System(文件系统)</p><h2 id="磁盘文件"><a href="#磁盘文件" class="headerlink" title="磁盘文件"></a>磁盘文件</h2><p>查看文件存放位置：show variables like ‘datadir’; 最多可以创建20亿个表，每个表最多1024个列，记录数没有明显限制（受到存储空间的限制）</p><h2 id="1-2-表格类型"><a href="#1-2-表格类型" class="headerlink" title="1.2 表格类型"></a>1.2 表格类型</h2><h3 id="1-2-1-常见五种类型"><a href="#1-2-1-常见五种类型" class="headerlink" title="1.2.1 常见五种类型"></a>1.2.1 常见五种类型</h3><ul><li><p>MyISAM</p></li><li><p>InnoDB</p></li><li><p>ISAM：简称为索引顺序访问方法，由 IBM 开发用于在磁带等辅助存储系统上存储和检索数据</p></li><li><p>Merge</p></li><li><p>Heap：内存表；存储于内存中，用于临时高速存储，存储引擎是memory；表结构存储在磁盘中，数据存储在内存中，服务器重启后，仅保留 heap 表结构；存储引擎 memory 比 myisam 快</p></li><li><p>ISAM：简称为索引顺序访问方法，由 IBM 开发用于在磁带等辅助存储系统上存储和检索数据</p><p>表的大小通过 Mysql 配置变量 max_heap_table_size 来控制；不允许存储 BLOB 或 TEXT 数据类型；只能使用比较运算符 &lt;=&gt; ；4.1版本之前不支持 AUTO_INCREMENT ；索引不可为 NULL</p></li></ul><pre class="line-numbers language-none"><code class="language-none">CREATE TABLE &#96;tb_name&#96; (&#96;col_name&#96; datatype(long) 列属性选项) TYPE &#x3D; HEAP(5.2以前) &#x2F; engine &#x3D; memory(5.2以后)表结构定义与普通表一致，仅在后面申明 TYPE &#x3D; HEAP &#x2F; engine&#x3D;memory；添加主键、索引方式也与普通表一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-2-2-其他类型"><a href="#1-2-2-其他类型" class="headerlink" title="1.2.2 其他类型"></a>1.2.2 其他类型</h3><ul><li>Federated：访问在远程数据库的表中的数据；在本地构建一个federated表来连接远程数据表，本地表的数据可以直接跟远程数据表同步；引擎里面是不真实存放数据的，所需要的数据都是连接到其他MySQL服务器上获取<br><strong>注意事项</strong>：<ol><li>对本地虚拟表的结构修改，并不会修改远程表的结构 </li><li>truncate 命令，会清除远程表数据 </li><li>drop命令只会删除虚拟表，并不会删除远程表</li><li>不支持 alter table 命令</li><li>limit 操作运行速度较慢，读取所有满足条件的记录，再进行 limit 处理</li></ol></li></ul><pre class="line-numbers language-none"><code class="language-none">install plugin federated soname &#39;ha_federated.so&#39;;  -- 安装federated引擎在my.cnf中加入一行federated；保存重启  -- 启动federated引擎CREATE TABLE tb_name (&#96;col_name&#96; datatype(long) 列属性选项) ENGINE &#x3D; FEDERATED CONNECTION &#x3D; &#39;mysql:&#x2F;&#x2F;username:password@ip:port&#x2F;db_name&#x2F;tb_name&#39;表名可以不一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>临时表：默认存储引擎是 myisam，表结构、数据都存储在内存中，服务器重启后，都将会丢失<pre class="line-numbers language-none"><code class="language-none">CREATE TEMPORARY TABLE &#96;tb_name&#96; (&#96;col_name&#96; datatype(long) 列属性选项) <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>dual：伪表，不真实存在</li></ul><blockquote><p>单表最大的存储空间是 65535TB，单列最大的存储空间4GB（仅 LONGBLOB、LONGTEXT 支持）</p></blockquote><h2 id="1-3-存储引擎"><a href="#1-3-存储引擎" class="headerlink" title="1.3 存储引擎"></a>1.3 存储引擎</h2><p><strong>存储引擎</strong>：文件系统的实现，数据、索引和其他对象的存储方式</p><h3 id="1-3-1-MyISAM"><a href="#1-3-1-MyISAM" class="headerlink" title="1.3.1 MyISAM"></a>1.3.1 MyISAM</h3><p>不支持事务，但每次查询都是原子的，不支持外键<br>支持表级锁（对整表加锁）<br>按照记录插入顺序保存，存储表的总行数<br>一个MyISAM有三个文件：表结构文件（frm）、索引文件（myi）和数据文件（myd）；数据可被压缩，存储空间较小；跨平台转移时较方便，备份恢复时可单独对某个表进行操作<br>采用非聚簇索引，索引文件的数据域存储指向数据文件的指针，辅索引与主索引基本一致，但辅索引不用保证一致性</p><h3 id="1-3-2-InnoDB"><a href="#1-3-2-InnoDB" class="headerlink" title="1.3.2 InnoDB"></a>1.3.2 InnoDB</h3><p>存储结构逻辑上可分为：<strong>表空间</strong>tablespace，<strong>段</strong>segment，<strong>区</strong>extent，<strong>页</strong>page，<strong>行</strong>row(一条记录)<br><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/Data_Save_Structure.png" alt="Data_Save_Structure"></p><p><strong>表空间</strong>：</p><ul><li>系统表空间：也叫共享表空间，关闭独占表空间后：innodb_file_per_table = ，所有的数据都会存储到ibdata1文件里面</li><li>用户表空间：也叫独占表空间，开启独占表空间后：innodb_file_per_table = 1，每张表的数据都会存储到一个独立的ibd文件里面，文件名为tb_name.ibd，表大小受操作系统文件大小的限制，一般2G</li><li>通用表空间</li><li>临时表空间</li><li>undo表空间</li></ul><p><strong>段</strong>：开启独占表空间后，会创建一个数据段(ibd文件)和索引段(frm文件)，段的空间大小随表的大小自动扩展，一个段至少会有一个区，段扩展的最小空间是区</p><ul><li>数据段：存储着索引树里的叶子结点的数据</li><li>索引段：存储着索引树里的非叶子结点的数据</li><li>回滚段</li></ul><p><strong>区</strong>：由64个连续的页组成，大小为1M = 64 * 16K(一个页的大小)，为保证区中页的连续性，扩展时会一次性申请4~5个区</p><p><strong>页</strong>：大小为16k，一个数据页对应B+Tree的一个叶子节点；是MySQL InnoDB存储引擎内存和磁盘交互的最小单位，内存中有数据页和索引页</p><ul><li>支持ACID的事务，支持事物的四种隔离原则</li><li>支持事务、行级锁及外键约束，支持写并发</li></ul><blockquote><p>需要对 insert、delete 、update、for update 操作进行加锁<br>添加行级锁是针对索引进行加锁</p></blockquote><ul><li>按主键大小有序插入，不存储总行数</li><li>主键采用聚集索引，辅索引的数据域存储主键的值，此时主键尽量采用自增主键；建议使用自增主键，避免插入时大量调整 B+树 结构，影响效率</li></ul><h3 id="1-3-3-MEMORY"><a href="#1-3-3-MEMORY" class="headerlink" title="1.3.3 MEMORY"></a>1.3.3 MEMORY</h3><p>所有数据都存储在内存中，数据处理速度极快，安全性不高，容易丢失</p><h3 id="1-3-4-比较"><a href="#1-3-4-比较" class="headerlink" title="1.3.4  比较"></a>1.3.4  比较</h3><table><thead><tr><th align="left">Feature 特性</th><th align="left">MyISAM</th><th align="left">Memory</th><th align="left">InnoDB</th><th align="left">Archive</th><th align="left">NDB</th></tr></thead><tbody><tr><td align="left">B-tree indexes <strong>B树索引</strong></td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Backup/point-in-time recovery (note 1) <strong>时间点恢复</strong></td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Cluster database support</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Clustered indexes</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Compressed data <strong>数据压缩</strong></td><td align="left">Yes (note 2)</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">No</td></tr><tr><td align="left">Data caches <strong>数据缓存</strong></td><td align="left">No</td><td align="left">N/A</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Encrypted data</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 4)</td><td align="left">Yes (note 3)</td><td align="left">Yes (note 3)</td></tr><tr><td align="left">Foreign key support <strong>外键支持</strong></td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 5)</td></tr><tr><td align="left">Full-text search indexes <strong>全文索引</strong></td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 6)</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Geospatial data type support</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Geospatial indexing support</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes (note 7)</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Hash indexes <strong>哈希索引</strong></td><td align="left">No</td><td align="left">Yes</td><td align="left">No (note 8)</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Index caches <strong>索引缓存</strong></td><td align="left">Yes</td><td align="left">N/A</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Locking granularity <strong>锁粒度</strong></td><td align="left">Table</td><td align="left">Table</td><td align="left">Row，适合高并发</td><td align="left">Row</td><td align="left">Row</td></tr><tr><td align="left">MVCC</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">Replication support (note 1)</td><td align="left">Yes</td><td align="left">Limited</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">Storage limits</td><td align="left">256TB</td><td align="left">RAM</td><td align="left">64TB</td><td align="left">None</td><td align="left">384EB</td></tr><tr><td align="left">T-tree indexes <strong>T树索引</strong></td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Transactions <strong>事务支持</strong></td><td align="left">No</td><td align="left">No</td><td align="left">Yes</td><td align="left">No</td><td align="left">Yes</td></tr><tr><td align="left">Update statistics for data dictionary</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr></tbody></table><p>更多内容见<a href="https://dev.mysql.com/doc/refman/5.6/en/storage-engines.html"><font face = "微软雅黑" color = 1E90FF size = 5>官网: Chapter 15 Alternative Storage Engines</font></a></p><p><strong>Notes:</strong></p><ol><li><p>Implemented in the server, rather than in the storage engine.  在服务器中实现，而不是在存储引擎中实现</p></li><li><p>Compressed MyISAM tables are supported only when using the compressed row format. Tables using the compressed row format with MyISAM are read only.  只有在使用压缩行格式时才支持压缩的MyISAM表。使用MyISAM压缩行格式的表是只读的。</p></li><li><p>Implemented in the server via encryption functions.  在服务器端通过加密功能实现。</p></li><li><p>Implemented in the server via encryption functions; In MySQL 5.7 and later, data-at-rest encryption is supported.  在服务器端通过加密功能实现；MySQL 5.7及以后版本支持数据静止加密。</p></li><li><p>Support for foreign keys is available in MySQL Cluster NDB 7.3 and later.  MySQL Cluster NDB 7.3及更高版本支持外键。</p></li><li><p>Support for FULLTEXT indexes is available in MySQL 5.6 and later.  在MySQL 5.6及更高版本中提供了对全文索引的支持。</p></li><li><p>Support for geospatial indexing is available in MySQL 5.7 and later.  MySQL 5.7及更高版本支持地理空间索引。</p></li><li><p>InnoDB utilizes hash indexes internally for its Adaptive Hash Index feature.  InnoDB在内部利用哈希索引实现自适应哈希索引特性。</p></li></ol><p><strong>区别</strong>：</p><ul><li><p><strong>InnoDB 很多时候是行级锁，而 MyISAM 是表级锁，InnoDB 的并发高</strong></p></li><li><p><strong>InnoDB 支持事务，外键，数据完整性约束要强；MyISAM 不支持</strong></p></li><li><p>数据和索引的保存的文件不同：MyISAM 是分开保存，而 InnoDB 是保存到表空间</p></li><li><p>MyISAM  支持索引压缩，而 InnoDB 索引和数据是绑定保存不压缩，体积大</p></li><li><p>InnoDB 不支持 FULLTEXT 类型的索引(新版本的InnoDB 也支持)</p></li><li><p>InnoDB 中不保存表的具体行数，即执行select count(*) from table时，InnoDB要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含 where条件时，两种表的操作是一样的</p></li><li><p>对于AUTO_INCREMENT类型的字段，InnoDB 中必须包含只有该字段的索引，但是在MyISAM 表中，可以和其他字段一起建立联合索引</p></li><li><p>一个MyISAM表有三个文件：表结构文件、索引文件和数据文件；一个InnoDB存储引擎在一个文件空间（共享表空间，表大小不受操作系统限制，一个表可能分布在多个文件里），或多个文件空间中（设置为独立表空间，表大小受操作系统限制，一般为2G），受操作系统文件大小限制</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据指标管理-基础</title>
      <link href="/202109/0430301.html"/>
      <url>/202109/0430301.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录数据指标管理的相关基础内容</p><span id="more"></span><h1 id="数据指标管理"><a href="#数据指标管理" class="headerlink" title="数据指标管理"></a>数据指标管理</h1><p><strong>数据指标</strong>：是衡量目标的方法，即预期达到的用数据表示的指数、规格、标准等<br><strong>数据指标管理</strong>：通过对企业若干核心业务和关键业务环节相互联系的统计数据指标进行全面化、结构化、层次化和系统化的构建，实现数据指标的标准化，统一数据指标标准，规范企业业务统计分析语言，帮助提升分析应用和数据质量，进而提升企业数据质量和数据资产价值</p><h2 id="1-数据指标"><a href="#1-数据指标" class="headerlink" title="1. 数据指标"></a>1. 数据指标</h2><h3 id="1-1-存在问题"><a href="#1-1-存在问题" class="headerlink" title="1.1 存在问题"></a>1.1 存在问题</h3><ol><li>指标口径不统一：存在数据指标名称相同，但统计口径、计算方法不同的情形，反之亦然</li><li>指标体系不完整：企业各部门根据自身业务需求，构建各自量化指标，不够全面，也缺乏方法论知道</li><li>指标问题追溯难：数据指标经过多重计算，难以定位出错原因和责任部门</li></ol><h3 id="1-2-设计目的"><a href="#1-2-设计目的" class="headerlink" title="1.2 设计目的"></a>1.2 设计目的</h3><p><strong>横向协同</strong>：集团相关职能部门接和业务决策、分析、管理工作需要，持续更新、完善扩展指标体系框架内容，满足集团化经营管理<br><strong>纵向贯通</strong>：下属企业提供集团级经营管理所需的数据指标源，支撑集团级业务决策分析和管理，结合自身特点，扩展和完善自身业务指标框架内容</p><h3 id="1-3-设计原则"><a href="#1-3-设计原则" class="headerlink" title="1.3 设计原则"></a>1.3 设计原则</h3><p><strong>系统性原则</strong>：充分承接整个企业的战略目标，形成以战略目标为核心的指标体系，指标间有清晰的关联逻辑，促进战略执行<br><strong>全面性原则</strong>：全面覆盖企业管理相关因素，包括外部环境、核心资源、业务活动、产品服务与经营业绩等，推动整体优化运营<br><strong>结构性原则</strong>：以数据和信息为基础，将指标划分成战略层、管理层相互支撑的结构<br><strong>差异性原则</strong>：区别与下属企业的指标体系，结合企业的实际业务，针对性的建立落地指标体系<br><strong>重要性原则</strong>：选取核心业务，明确相关的关联业务，关注管理平静与重点，推动集团总部各部门之间的管理协同</p><h3 id="1-4-数据指标标准分类"><a href="#1-4-数据指标标准分类" class="headerlink" title="1.4 数据指标标准分类"></a>1.4 数据指标标准分类</h3><p><strong>基础指标</strong>：是表达业务实体“原子量化”属性的概念集合，是直接对单一变量的明细数据进行简单计算得到切不可进一步拆解的指标，如销售量、订单数等<br><strong>复合指标</strong>：是建立在基础指标之上，由若干个基础指标通过一定的运算规则计算得到且在业务角度无法拆解的指标，如利润率，增长率等<br><strong>派生指标</strong>：是基础指标或复合指标与一个或多个维度值结合产生的指标，如月均销售量、年利润等</p><h3 id="1-5-数据指标标准属性"><a href="#1-5-数据指标标准属性" class="headerlink" title="1.5 数据指标标准属性"></a>1.5 数据指标标准属性</h3><p><strong>业务属性</strong>：使数据在业务层面的定义，描述数据和企业业务相关联的特性，是数据业务含义的统一解释及要求，包括业务定义、业务规则、参考标准、计量单位等<br><strong>技术属性</strong>：十数据在技术层面的定义，描述数据和信息技术实现相关联的特性，包括数据类型、数据格式等<br><strong>管理属性</strong>：是数据在管理层面的定义，描述数据标准和数据管理相关联的特性，是数据管理在数据标准管理领域的统一要求，包括指标编码、数据提出者、数据使用者、数据负责人、颁布日期、废止日期等</p><h2 id="2-数据指标指定"><a href="#2-数据指标指定" class="headerlink" title="2. 数据指标指定"></a>2. 数据指标指定</h2><h3 id="2-1-数据指标选取原则"><a href="#2-1-数据指标选取原则" class="headerlink" title="2.1 数据指标选取原则"></a>2.1 数据指标选取原则</h3><p><strong>正确性</strong>：每项指标正确、科学地反映评价对象某一方面的信息<br><strong>唯一性</strong>：保证指标选取的全面，避免指标重复<br><strong>完整性</strong>：指标信息应避免缺项，保证内容完整</p><h3 id="2-2-数据指标选取方法"><a href="#2-2-数据指标选取方法" class="headerlink" title="2.2 数据指标选取方法"></a>2.2 数据指标选取方法</h3><blockquote><p>面向主题：可以按照业务线、主题域、业务过程三级目录方式管理指标<br>确定原子指标；根据统计范围、统计粒度、业务限定组成派生指标<br>借鉴行业最佳管理实践，综合考虑内外部环境因素及上级要求，建立指标体系的总体框架，保证指标体系框架的完整性<br>通过对企业战略、管理层及下属企业业务的全面梳理，识别企业生产运作中关键和主要业务环节中的要素，初步形成企业级指标体系框架<br>进一步筛选、合并同类指标，去除重复和不重要的指标，根据专家建议调整指标，保证指标体系的科学合理按照价值链进行区分</p></blockquote><ul><li><strong>自上而下</strong>：先将一级业务领域划分财务、人力资源、销售等，在划分二级业务域，如销售划分为市场营销、客户管理、订单管理等（根据实际业务情况选择划分三级分类），构建指标分类的初步框架</li><li><strong>自下而上</strong>：从业务系统出发，从系统中识别功能模块，找出业务单据中可以作为指标展示的数值字段</li></ul><h3 id="2-3-数据指标选取依据"><a href="#2-3-数据指标选取依据" class="headerlink" title="2.3 数据指标选取依据"></a>2.3 数据指标选取依据</h3><p><strong>增长引擎</strong>：关注内外部环境条件分析和战略目标选择、现有业务与新业务增长路径的选择等<br><strong>运营卓越</strong>：关注集团特色，核心的运营活动包括从产业链协同层面进行专项分析，同时关注各版块运营的规模、效率、效益和安全，从工程基建到管理和服务分别展开分析<br><strong>财务表现</strong>：关注利润贡献、资产运营效率、偿债、资金保障（价值创造）等<br><strong>创新驱动</strong>：关注管理及制度创新，科技创新环境、方向、体系、投入及产出等<br><strong>人员保障</strong>：关注人员配置、人工效能、培训成长、分配激励等<br><strong>宏观环境</strong>：关注宏观政治经济环境、行业动态的分析和竞争策略等<br><strong>绿色发展</strong>：关注经济增长与发展、环境可持续、能源获取和安全等</p><h2 id="3-数据指标管理"><a href="#3-数据指标管理" class="headerlink" title="3. 数据指标管理"></a>3. 数据指标管理</h2><h3 id="3-1-数据指标管理内容"><a href="#3-1-数据指标管理内容" class="headerlink" title="3.1 数据指标管理内容"></a>3.1 数据指标管理内容</h3><p><strong>指标批量导入导出</strong>：按指标名称、指标体系或指标范围版本的个性化需求选择指标，并导出为指标卡片文件<br><strong>指标录入</strong>：通过手工方式进行指标的添加、提交、审核等<br><strong>指标信息维护</strong>：包括指标工作区、指标候选库和指标库</p><blockquote><p><strong>指标工作区</strong>：用于收集各单位与专业部门对指标的需求，形成需求状态的指标卡片，经过审核提交到各单位的指标候选库中<br><strong>指标候选库</strong>：根据各部门与专业部门对需求状态的指标卡片进行审批后逐级上报，经过定期梳理形成最终生效的候选指标<br><strong>指标库</strong>：企业通过计划部门审批的所有指标集合，在指标候选库中为生效状态的指标通过审批后才能进入企业指标库</p></blockquote><p><strong>指标申报管理</strong>：可实现指标库中指标生效和失效管理功能<br><strong>指标查询</strong>：可实现快速查询、自定义查询功能<br><strong>指标发布管理</strong>：指通过手工录入指标并通过审核，成为正式指标后将其发布使用</p><h3 id="3-2-数据指标管理过程"><a href="#3-2-数据指标管理过程" class="headerlink" title="3.2 数据指标管理过程"></a>3.2 数据指标管理过程</h3><ul><li><p><strong>梳理系统指标</strong>：导出各系统中的各报表指标</p><ul><li><p>梳理系统及报表指标</p><blockquote><p><strong>系统产生的指标</strong></p><blockquote><p>PLM：Product Life Cycle Management，产品生命周期管理<br>ERP：Enterprise Resource Planning，企业资源计划<br>MES：Manufacturing Execution System，生产过程执行系统<br>WMS：Warehouse Management System，仓储管理系统<br>CRM：Customer Relationship Management，客户关系管理<br>SCM：Supply chain management，供应链管理<br>SRM：Supplier Relationship Management，供应商关系管理</p></blockquote><p><strong>报表产生的指标</strong>：各类报表涉及的指标</p></blockquote></li><li><p>梳理系统指标维度</p><blockquote><p><strong>通用维度</strong>：时间、空间、组织、业务板块、业务阶段、统计口径等六个统计口径<br><strong>非通用维度</strong>：通过多种途径获取，包括但不仅限于访谈、分析数据等，并按照重要性进行排序</p></blockquote></li></ul></li><li><p><strong>梳理手工报表指标</strong>：收集、整理、分析手工报表中的指标</p></li><li><p><strong>收集访谈指标</strong></p><blockquote><p>通过 <strong>调查问卷</strong> 收集指标：下发调查问卷、资料收集等形式，收集各部门、各版块满足业务分许和管理需要的指标<br>通过 <strong>现场访谈</strong> 收集指标：根据各部门核心骨干对访谈提纲的回答收集相关指标</p></blockquote></li><li><p><strong>收集已编制的指标成果</strong>：借鉴和收集以编、在编项目标准中的基本类指标，并收集项目过程中的报表，以形成实际指标</p></li><li><p><strong>汇总指标，形成指标库</strong>：将上述指标按照统一模板进行梳理、汇总，形成完整的指标库</p></li></ul><h3 id="3-3-数据指标项定义"><a href="#3-3-数据指标项定义" class="headerlink" title="3.3 数据指标项定义"></a>3.3 数据指标项定义</h3><p><strong>指标分类</strong>：针对企业业务数据指标分为级别不同的类<br><strong>指标代码</strong>：数据指标对应的代码<br><strong>指标名称</strong>：数据指标对应的名称<br><strong>指标定义</strong>：对指标进行解释说明<br><strong>计算逻辑</strong>：若为计算指标，列出计算逻辑<br><strong>指标单位</strong>：指标对应的计算单位<br><strong>分析维度</strong>：指标主要的分析维度，包含物料维度、空间维度、时间维度、数据层次等<br><strong>取数维度</strong>：指标在管理上提取数据的频率，可为班、日、旬、月、季、年等</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
            <tag> 数据指标 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据实践-01阿里-数据管理</title>
      <link href="/202109/0256600.html"/>
      <url>/202109/0256600.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录大数据实践-01阿里-数据管理的相关内容</p><span id="more"></span><h1 id="1-元数据"><a href="#1-元数据" class="headerlink" title="1. 元数据"></a>1. 元数据</h1><p><strong>元数据</strong>：Metadata，元数据是关于数据的数据，记录了数据从产生到消费的全过程，主要记录数据仓库中模型的定义、各层级间的映射关系、监控数据仓库的数据状态及 ETL 的任务运行状态</p><blockquote><p>技术元数据：存储关于数据仓库系统技术细节的数据，用于开发和管理数据仓库使用的数据</p><blockquote><p><strong>分布式计算系统存储元数据</strong>：如 MaxCompute 表、列、分区等信息，表名、分区信息、责任人信息、文件大小、表类型，生命周期，以及列的字段名、字段类型、字段备注、是否是分区字段等信息<br><strong>分布式计算系统运行元数据</strong>： MaxCompute 上所有作业运行等信息，包括作业类型、实例名称、输入输出、 SQL 、运行参数、执行时间、最细粒度的 Fuxi Instance (MaxCompute MR 执行的最小单元）执行信息等；类似于 Hive 的 Job 日志<br><strong>数据开发平台中数据任务调度元数据</strong>：包括数据同步的输入输出表和字段，以及同步任务本身的节点信息：计算任务主要有输入输出、任务本身的节点信息 任务调度主要有任务的依赖类型、依赖关系等，以及不同类型调度任务的运行日志等<br><strong>数据质量和运维相关元数据</strong>：如任务监控、运维报警、数据质量、故障等信息，包括任务监控运行日志、告警配置及运行日志、故障信息等</p></blockquote><p>业务元数据：业务角度描述了数据仓库中的数据，提供了介于使用者和实际系统之间的语义层，使得不懂计算机技术的业务人员也能够“读懂”数据仓库中的数据</p><blockquote><p><strong>OneData 元数据</strong>：如维度及属性、业务过程、指标等的规范化定义，用于更好地管理和使用数据<br><strong>数据应用元数据</strong>：如数据报表、数据产品等的配置和运行元数据</p></blockquote></blockquote><h2 id="1-1-统一元数据体系建设"><a href="#1-1-统一元数据体系建设" class="headerlink" title="1.1 统一元数据体系建设"></a>1.1 统一元数据体系建设</h2><p><img src="https://qizhongyi.gitee.io/images//Data/DataManage/Ali_Practice/0301_%E5%85%83%E6%95%B0%E6%8D%AE%E4%BD%93%E7%B3%BB%E5%BB%BA%E8%AE%BE.png" alt="0301_元数据体系建设"></p><blockquote><p>首先梳理清楚元仓底层数据，对元数据做分类，减少数据重复建设，保障数据的唯一性<br>丰富表和字段使用说明，方便使用和理解<br>根据元仓底层数据构建元仓中间层，依据 OneData 规范，建设元数据基础宽表,打通从数据产生到消费整个链路<br>基于元数据中间层，对外提供标准统一的元数据服务出口，保障元数据产出的质量</p></blockquote><h2 id="1-2-元数据应用"><a href="#1-2-元数据应用" class="headerlink" title="1.2 元数据应用"></a>1.2 元数据应用</h2><h3 id="1-2-1-Data-Profile"><a href="#1-2-1-Data-Profile" class="headerlink" title="1.2.1 Data Profile"></a>1.2.1 Data Profile</h3><p><strong>Data Profile</strong>：为纷繁复杂的数据建立一个脉络清晰的血缘图谱，通过图计算、标签传播算法等技术 ，系统化、自动化地对计算与存储平台上的数据进行打标、整理、归档；可以节约研发人员的时间成本，更直观地理解数据、利用数据，提升数据的研发效率</p><blockquote><p>基础标签：针对数据的存储情况、访问情况、安全等级等进行打标<br>数仓标签：针对数据的增量全量、是否可再生、数据的生命周期来进行标签化处理<br>业务标签：根据数据归属的主题域、产品线、业务类型为数据打上不同的标签<br>潜在标签：说明数据潜在的应用场景， 如社交、媒体、广告、电商、金融等</p></blockquote><h3 id="1-2-2-元数据门户"><a href="#1-2-2-元数据门户" class="headerlink" title="1.2.2 元数据门户"></a>1.2.2 元数据门户</h3><p><strong>元数据门户</strong>：一站式数据管理平台、一体化数据市场；包括前台和后台，前台为数据地图；后台产品为数据管理平台</p><ul><li><strong>数据地图</strong>：定位消费市场，服务于数据分析、数据开发、数据挖掘、算法工程师、数据运营等数据表的使用者和拥有者；实现检索数据、理解数据等找数据需求，拥有功能强大的血缘信息及影响分析；利用表使用说明、评价反馈 、表收藏及精品表机制，为用户浮现高质量、高保障的目标数据；</li><li><strong>数据管理平台</strong>：定位于一站式数据管理，服务于个人开发者 BU 管理者、系统管理员等用户；提供个人和 BU 全局资产管理、成本管理和质量管理，实现安全管理等</li></ul><h3 id="1-2-3-应用链路分析"><a href="#1-2-3-应用链路分析" class="headerlink" title="1.2.3 应用链路分析"></a>1.2.3 应用链路分析</h3><p><strong>应用链路分析</strong>：通过应用链路分析，产出表级血缘、字段血缘和表的应用血缘；明确某个数据计算任务或表的重要程度、下游使用情况等</p><ul><li><strong>表级血缘</strong></li></ul><blockquote><p>通过 MaxCompute 任务日志进行解析<br>根据任务依赖进行解析</p></blockquote><ul><li><strong>表的应用血缘</strong>：依赖不同的应用，按照应用和物理表的配置关系，可以分为配置型和无配置型，主要用于影响分析、重要性分析、下线分析、链路分析、寻根溯源、故障排查等</li></ul><h3 id="1-2-4-数据建模"><a href="#1-2-4-数据建模" class="headerlink" title="1.2.4 数据建模"></a>1.2.4 数据建模</h3><p><strong>数据建模</strong>：通过元数据驱动的数据仓库模型建设，取代采用经验建模的方式；提高数据仓库建模的数据化指导，提升建模效率</p><ul><li><strong>使用的元数据</strong></li></ul><blockquote><p>表的基础元数据，包括下游情况、查询次数、关联次数、聚合次数、产出时间等<br>表的关联关系元数据，包括关联表、关联类型、关联字段、关联次数等<br>表的字段的基础元数据，包括字段名称、字段注释、查询次数、关联次数、聚合次数、过滤次数等</p></blockquote><ul><li><strong>使用元数据</strong></li></ul><blockquote><p>基于下游使用中关联次数大于某个阔值的表或查询次数大于某个阐值的表等元数据信息，筛选用于数据模型建设的表<br>基于表的字段元数据，如字段中的时间字段、字段在下游使用中的过滤次数 ，选择业务过程标识字段<br>基于主从表的关联关系、关联次数，确定和主表关联的从表<br>基于主从表的字段使用情况，如字段的查询次数、过滤次数、关联次数、聚合次数等，确定进入目标模型的字段</p></blockquote><h3 id="1-2-5-驱动ETL开发"><a href="#1-2-5-驱动ETL开发" class="headerlink" title="1.2.5 驱动ETL开发"></a>1.2.5 驱动ETL开发</h3><p><strong>驱动 ETL 开发</strong>：通过元数据，指导 ETL 工作，提高 ETL 的效率</p><h1 id="2-计算管理"><a href="#2-计算管理" class="headerlink" title="2. 计算管理"></a>2. 计算管理</h1><h2 id="2-1-系统优化"><a href="#2-1-系统优化" class="headerlink" title="2.1 系统优化"></a>2.1 系统优化</h2><h3 id="2-1-1-HBO"><a href="#2-1-1-HBO" class="headerlink" title="2.1.1 HBO"></a>2.1.1 HBO</h3><p><strong>HBO</strong>： History-Based Optimizer，基于历史的优化器，根据任务历史执行情况为任务分配更合理的资源，包括内存、 CPU 以及 Instance 个数，是对集群资源分配的 种优化；任务执行历史＋集群状态信息＋优化规则→更优的执行配置</p><ul><li><strong>背景</strong></li></ul><ol><li>MaxCompute 原资源分配策略</li></ol><blockquote><p>Map Task 任务最多允许99999个 Instance 实例，使用 Input_Table_Size / Map_Split_Size分配算法分配 Instance 实例；Reduce Task / Join Task 的最大任务数是1111个，主要依据父 Task 的 Instance 个数进行评估分配<br>Instance 处理的数据量远远没有达到预期；如果 Instance 处理的数据量很大，容易导致任务长尾；总结 ：在默认的 Instance 算法下，把处理数据量小的任务存在资源浪费，而处理数据量大的任务却资源不足</p></blockquote><ol start="2"><li>HBO 的提出：系统中存在大量的周期性调度的脚本（物理计划稳定），且输入比较稳定，对其进行优化会显著提升整个集群的计算资源的使用率</li></ol><ul><li><strong>原理</strong><br><strong>前提</strong>：最近7天内任务代码没有发生变更且任务运行4次<br><strong>Instance 分配逻辑</strong>：基础资源估算值＋加权资源估算值<br><strong>CPU／内存分配逻辑</strong>：基础资源估算值＋加权资源估算值</li></ul><blockquote><p>基础资源数量的逻辑</p><blockquote><p>对于 Map Task ，系统需要初始化不同的输入数据 ，根据期望的每个 Map 能处理的数据量，再结合用户提交任务的输入数据量，估算出用户提交的任务所需要的 Map 数量；采用分层的方式，提供平均每个 Map 能处理的数据量，避免集群的资源会被超大任务占有，保证集群上任务的整体吞吐量<br>对于 Reduce Task ，比较 Hive 使用 Map 输入数据量， MaxCompute 使用最近 7天 Reduce 对应 Map 的平均输出数据量作为 Reduce 的输入数据 ，用于计算 Instance 的数量</p></blockquote><p>加权资源数量的逻辑</p><blockquote><p>对于 Map Task ，系统需要初始化期望的每个 Map 能处理的数据量；通过该 Map 在最近一段时间内的平均处理速度与系统设定的期望值做比较，如果平均处理速度小于期望值，则按照同等比例对基础资源数量进行加权，估算出该 Map 的加权资源数量；<br>对于 Reduce Task ，系统需要初始化期望的每个 Reduce 能处理的数据量；通过该 Reduce 在最近一段时间内的平均处理速度与系统设定的期望值做比较，如果平均处理速度小于期望值，则按照同等比例对基础资源数量进行加权，估算出该 Reduce 的加权资源数量；</p></blockquote></blockquote><ul><li><strong>效果</strong></li></ul><ol><li><strong>提高 CPU 利用率</strong>：通过适当降低每个 Instance CPU 资源数，集群利用率提升一倍，早上 4: 00 -7: 00 节省的 CPU 资源可以供6万个 Instance 并发使用</li><li><strong>提高内存利用率</strong>：在保障并行度，同时又能提高执行效率的基础上，合理分配内存，早上 4: 00 - 7: 00 节省的内存资源可以供4万个 Instance 并发使用</li><li><strong>提高 Instance 并发数</strong>：合理设置 Task Instance 个数， Instance 峰值并发数提升了 57%</li><li><strong>降低执行时长</strong>：集群有 3700 台机器，任务数约 16 万个 ，开启 HBO 后总执行时长为 3884 小时，总执行时长减少 4472 小时</li></ol><ul><li><strong>改进与优化</strong>：HBO 是基于执行历史来设置计划，日常数据量波动不大，工作良好；不能应对数据量暴涨的情况，如大促“双 ”和“双 12 ”期间，增加依据 Map 的数据量增长情况进行调整动态调整 Instance 数的功能</li></ul><h3 id="2-1-2-CBO"><a href="#2-1-2-CBO" class="headerlink" title="2.1.2 CBO"></a>2.1.2 CBO</h3><p><strong>CBO</strong>： Cost-Based Optimizer，基于代价的优化器，根据收集的统计信息来计算每种执行方式的代价，进而选择最优的执行方式</p><ul><li><strong>优化器原理</strong>：引入重新排序 Join (Join Reorder ）和自动 MapJoin (Auto MapJoin ）优化规则，基于  Volcano 模型的优化器会尽最大的搜索宽度来获取最优计划；Meta Manager （元数据）、 Statistics （统计信息）、 Rule Set （优化规则集）、 Volcano Planner Core（核心计划器）多个模块相互组合协调工作</li></ul><blockquote><p><strong>Meta Manager</strong>： Meta 模块主要提供元数据信息，包括表的元数据、统计信息元数据等，优化器会根据元数据的 些信息进行优化；对于 Meta 的管理， MaxCompute 提供了 Meta Manager 与优化器进行交互；如表分区裁剪（ TableScan Part on Prunning）优化时， 需要通过 Meta 信息获取表的分区数据，然后根据过滤条件来裁剪分区<br><strong>Statistics</strong>：为优化器选择计划提供准确的统计信息；如表的 Count 值、列的 Distinct 值、 TopN 值等；优化器会根据 Join 的输入数据量（ Count 值）选择 Hash Join 或 Merge Join；优化器提供 UDF 来收集 Distinct 值、 TopN 等，Count 值等是由底层 Meta 直接提供<br><strong>Rule Set</strong>：优化规则是根据不同情况选择不同的优化点，然后由优化器根据代价模型（ Cost Model ）来选择优化规则；如工程合并规则(Project Merge Rule ）， 将临近的两个 Project 合并成一个 Project ；过滤条件下推规则（ Filter Push Down ），将过滤条件尽量下推，减少其他操作的数据量；规则被分为 Substitute Rule （优化肯定好的规则）、 Explore Rule （优化后需要考虑多种优化结果）、Build Rule （优化后的结果不能再次使用规则进行优化）；用户可以通过 set 等命令来控制所使用的规则<br><strong>Volcano Planner Core</strong>：会将所有信息（ Meta 信息、统计信息、规则）统一起来处理，然后根据代价模型的计算，获得最优计划</p><blockquote><p>代价模型：根据不同操作符计算不同的代价，如 Join、Project 等，然后计算出整个计划中最小代价的计划；由行数、 I/O 开销、 CPU 开销三个维度组成<br>工作原理：假设 Planner 的输入是一棵由 Compiler 解析好的计划树，简称 RelNode 树，每个节点简称 Re!Node</p><blockquote><ol><li>Volcanno Planner 创建：将 Planner 在优化过程中要用到的信息传递给执行计划器，包括规则集，用户指定要使用的规划； Meta Provider ，每个ReINode Meta 计算；代价模型，计算每个 RelNode 的代价等</li><li>Planner 优化</li></ol><blockquote><p><strong>规则匹配</strong>（ Rule Match ）：是指 RelNode 满足规则的优化条件而建立的一种匹配关系；Planner 首先将整个 Re!Node 树的每一个 ReINode 注册到 Planner 内部，同时在注册过程中，会在规则集中找到与每个 Re!Node 匹配的规则，然后加入到规则应用（ Rule Apply ）的队列中；使用规则时从队列中取出<br><strong>规则应用</strong>（ Rule Apply ）：是指从规则队列（ Rule Queue ）中弹出（ Pop）一个匹配成功的规则进行优化；当获取到一个匹配的规则进行处理时，如果规则优化成功，则肯定会产生至少一个新的 Re!Node ；需要再次进行注册以及规则匹配操作，把与新产生的 Re!Node 匹配的规则加入到规则队列中，然后接着下次规则应用；Planner 会一直应用所有的规则，包括后来叠加的规则，直到不会有新的规则匹配到<br><strong>代价计算</strong>（ Cost Compute ）： 每当规则应用之后，如果规则优化成功，则会产生新的 ReINode ，过程中计算 RelNode 的代价</p><blockquote><p>如果不存在代价，或者 Child 的代价还没有估算（默认是最大值），则忽略<br>如果存在代价，则会将本身的代价和 Child （输入的所有RelNode ）的代价进行累加， 若小于 Best ，则认为优化后的 ReINode 是当前最优的；并且会对其 Parent 进行递归估算代价，即传播代价计算（ Propagate Calculate Cost ）</p></blockquote></blockquote></blockquote></blockquote></blockquote><ul><li><strong>优化器新特性</strong></li></ul><ol><li>重新排序 Join：将 Join 的所有不同输入进行一个全排列，然后找到代价最小的一个排列</li><li>自动 MapJoin：Join 实现算法目前主要有 Merge Join MapJoin，MapJoin Merge Join 性能更优；自动 MapJoin 充分利用优化器的代价模型进行估算，获得更优的 MapJoin，代替用户指定 Hint 方式进行处理</li></ol><ul><li><strong>优化器使用</strong>：提供 set 等命令支持用户自定义设置优化器规则黑白名单</li></ul><pre class="line-numbers language-none"><code class="language-none">set odps.optimizer.cbo.rule.filter.white &#x3D; pojr, hj;  &#x2F;&#x2F; 开启规则set odps.optimizer.cbo.rule.filter.black &#x3D; pojr, hj;  &#x2F;&#x2F; 关闭规则注：重新排序 Join 和自动 MapJoin ，对应的标记分别是 porj 和 hj<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>注意事项</strong>：Optimizer 提供谓词下推（ Predicate Push Down ）优化 ，尽量早地进行谓词过滤，以减少后续操作的数据量，提高性能</li></ul><ol><li>UDF：不会任意下推带有用户意图的函数，是因为不同用户书写的函数含义不一样，不能一概而论</li><li>不确定函数：对于不确定函数，优化器也不会任意下推；如 sample 函数</li><li>隐式类型转换：应尽量避免 Jo in Key 存在隐式类型转换，如 String = Bigint 会转换为 ToDouble(String) = ToDouble(Bigint)，可能导致转换失败，报错或执行成功，结果与用户期望不一致</li></ol><h2 id="2-2-任务优化"><a href="#2-2-任务优化" class="headerlink" title="2.2 任务优化"></a>2.2 任务优化</h2><p><strong>运算细分步骤</strong>：SQL/MR → MaxCompute Instance → Fuxi Job → Fuxi Task → Fuxi Instance</p><blockquote><p>MaxCompute Instance：类似于 Hive Job 的概念<br>Fuxi Job：对于 MaxCompute Instance 生成一个或多个由 Fuxi Task 组成的有向无环图，即 Fuxi Job<br>Fuxi Task：主要包含三种类型，分别是 Map Reduce 和 Join 类似于 Hive 中 Task 的概念<br>Fuxi Instance：真正的计算单元，和 Hive 中的槽位（ slot ）对应</p></blockquote><h3 id="2-2-1-Map倾斜"><a href="#2-2-1-Map倾斜" class="headerlink" title="2.2.1 Map倾斜"></a>2.2.1 Map倾斜</h3><p><strong>背景</strong>：Map 端是 MR 任务的起始阶段， 主要将磁盘中的数据读人内存<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0302_Map%E7%AB%AF%E8%BF%87%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="0302_Map端过程示意图"></p><blockquote><p>每个输入分片会由一个 Map Instance 来处理，在默认情况下，以 Pangu 文件系统的一个文件块的大小（默认为 256MB ）为一个分片；Map Instance 输出的结果会暂时放在 个环形内存缓冲区中，当该缓冲区快要溢出时会在本地文件系统中创建一个溢出文件 Write Dump；通过“ set odps.mapper.split.size=256 ”来调节 Map Instance 的个数，提高数据读入的效率，通过“ set odps.mapper.merge.limit.size=64 ”来控制 Map Instance 读取文件的个数<br>写人磁盘之前，线程首先根据 Reduce Instance 的个数划分分区，数据会根据 Key 值Hash 到不同的分区上，一个 Reduce Instance 对应一个分区的数据；Map 端也会做部分聚合操作，减少输入 Reduce 端的数据量；数据是根据 Hash 分配的可能会导致数据资源分配不均的问题</p></blockquote><p><strong>Map端长尾</strong>：读入数据的文件大小分布不均匀，UDF 函数性能、 Join 、聚合操作等，导致 Map Instance 读取并且处理的数据不均衡</p><blockquote><p>上游表文件的大小特别不均匀，并且小文件特别多，导致当前表Map 端读取的数据分布不均匀，引起长尾；可以通过设置“ set odps.sql.mapper.merge.limit.size=64 ”和“ set odps .sql.mapper.s plit.size=256”两个参数来调节<br>Map 端做聚合时，由于某些 Map Instance 读取文件的某个值特别多而引起长尾，主要是指 Count Distinct 操作；可以使用“ distribute by rand()”来打乱数据分布，使数据尽可能分布均匀</p></blockquote><h3 id="2-2-2-Join-倾斜"><a href="#2-2-2-Join-倾斜" class="headerlink" title="2.2.2 Join 倾斜"></a>2.2.2 Join 倾斜</h3><p><strong>Join操作</strong>：参与 Map 和 Reduce 的整个阶段；Join 执行阶段会将 Join Key 相同的数据分发到同一个执行 Instance 上处理，如果某个 Key 上的数据量比较大，会导致该 Instance 执行时间较长</p><blockquote><p>Join 的某路（从表：左外连接中的右表）输入比较小，可以采用 MapJoin ，避免分发引起长尾<br>Join 的每路输入都较大，且长尾是空值导致的，可以将空值处理成随机值，避免聚集<br>Join 的每路输入都较大，且长尾是热点值导致的，可以对热点值和非热点值分别进行处理，再合并数据</p></blockquote><p><strong>方案</strong></p><ul><li><strong>MapJoin 方案</strong>：Join 倾斜时，如果从表输入比较小，则可以采用 MapJoin 避免倾斜；MapJoin 的原理是将 Join 操作提前到 Map 端执行， 将小表读人内存，顺序扫描大表完成 Join；可以避免因为分发 key 不均匀导致数据倾斜；在 select 后面加上 /*+MAPJOIN (a) * / ，a代表小表的别名；默认小表大小不能超过 512MB，可以通过设置“ set odps.sql.mapjoin.memory.max=2048 ”加大内存，最大为 2048MB</li><li><strong>Join 因为空值导致长尾</strong>：如果关联 key 为空值且数据量比较大，可以将空值处理成随机值；因为空值无法关联上，只是分发到一处，随机值既不会影响关联结果，也能很好地避免聚焦导致长尾</li><li><strong>Join 因为热点值导致长尾</strong>：因为热点值导致的长尾，并且 Join 的输入比较大无法使用MapJoin，可以先将热点 key 取出，对于主表数据用热点 key 切分成热点数据和非热点数据两部分分别处理，最后合并</li></ul><h3 id="2-2-3-Reduce-倾斜"><a href="#2-2-3-Reduce-倾斜" class="headerlink" title="2.2.3 Reduce 倾斜"></a>2.2.3 Reduce 倾斜</h3><p><strong>Reduce</strong>：负责对 Map 端梳理后的有 key-value 键值对进行聚合，即进行 Count 、Sum、 Avg 等聚合操作，得到最终聚合的结果，Distinct 的执行原理是将需要去重的宇段以及 Group By 宇段联合作为 key 将数据分发到 Reduce 端</p><blockquote><p>对同一个表按照维度对不同的列进行 Count Distinct 操作，造成Map 端数据膨胀，从而使得下游的 Join 和 Reduce 出现链路上的长尾<br>Map 端直接做聚合时出现 key 值分布不均匀，造成 Reduce 端长尾<br>动态分区数过多时可能造成小文件过多，引起 Reduce 端长尾<br>多个 Distinct 同时出现在 SQL 代码中时，数据会被分发多次，不仅会造成数据膨胀多倍，还会把长尾现象放多倍</p></blockquote><h1 id="3-存储和成本管理"><a href="#3-存储和成本管理" class="headerlink" title="3. 存储和成本管理"></a>3. 存储和成本管理</h1><h2 id="3-1-数据压缩"><a href="#3-1-数据压缩" class="headerlink" title="3.1 数据压缩"></a>3.1 数据压缩</h2><p><strong>数据备份</strong>：为提高数据的可用性与性能 ，通常会将数据存储3份<br><strong>数据压缩</strong>：MaxCompute 中提供 archive 压缩方法，将数据保存为 RAID file 的形式，存储比由1:3 提高到 1:1.5；恢复数据块的时间将要比原来的方式更长，损失一定的读性能；应用于冷备数据与日志数据的压缩存储</p><h2 id="3-2-数据重分布"><a href="#3-2-数据重分布" class="headerlink" title="3.2 数据重分布"></a>3.2 数据重分布</h2><p><strong>数据重分布</strong>：通过修改表的数据重分布，避免基于列存储导致的列热点，主要通过修改 distribute by 和 sort by 字段的方法进行数据重分布，一般筛选出、重分布效果高于 15% 表进行优化处理</p><h2 id="3-3-存储治理项优化"><a href="#3-3-存储治理项优化" class="headerlink" title="3.3 存储治理项优化"></a>3.3 存储治理项优化</h2><p><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0303_%E5%AD%98%E5%82%A8%E6%B2%BB%E7%90%86%E9%A1%B9%E4%BC%98%E5%8C%96.png" alt="0303_存储治理项优化"><br><strong>存储优化治理项</strong>：未管理表、 空表、最近 62 天未访问表、数据无更新无任务表 、数据无更新有任务表、开发库数据大于 100GB 且无访问表、长周期表等<br><strong>存储治理项优化流程</strong>：现状分析、 问题诊断、管理优化、效果反馈闭环</p><h2 id="3-4-生命周期管理"><a href="#3-4-生命周期管理" class="headerlink" title="3.4 生命周期管理"></a>3.4 生命周期管理</h2><h3 id="3-4-1-生命周期管理策略"><a href="#3-4-1-生命周期管理策略" class="headerlink" title="3.4.1 生命周期管理策略"></a>3.4.1 生命周期管理策略</h3><ol><li><strong>周期性删除策略</strong>：周期性删除一定期限的失效数据</li><li><strong>彻底删除策略</strong>：及时删除无用表数据或者 ETL 过程产生的临时数据，以及不需要保留的数据，包括相关元数据</li><li><strong>永久保留策略</strong>：重要且不可恢复的底层数据和应用数据需要永久保留；如底层交易的增量数据</li><li><strong>极限存储策略</strong>：超高压缩重复镜像数据，通过平台化配置手段实现透明访问；数据质量要求非常高，配置与维护成本比较高，分区有超过 5G 的镜像数据（如商品维表、用户维表）就使用极限存储</li><li><strong>冷数据管理策略</strong>：冷数据管理是永久保留策略的扩展，将永久保留的数据迁移到冷数据中心永久保存，同时将 MaxCompute 中对应的数据删除</li><li><strong>增量merge 表策略</strong>：增量同步与全量 merge 的方式，对应的 delta 增量表保留，默认保留 93 天；如交易增量数据，使用订单创建日期或者订单结束日期作为分区，同时将未完结订单放在最大分区；对于存储，一个订单在表里只保留一份；对于用户使用，通过分区条件就能查询某一段时间的数据</li></ol><h3 id="3-4-2-通用的生命周期管理矩阵"><a href="#3-4-2-通用的生命周期管理矩阵" class="headerlink" title="3.4.2 通用的生命周期管理矩阵"></a>3.4.2 通用的生命周期管理矩阵</h3><p><strong>历史数据等级划分</strong>：对历史数据进行重要等级划分，分为P0、P1、P2、P3 四个等级</p><blockquote><p>P0：非常重要的主题域数据和非常重要的应用数据，具有不可恢复性，如交易、日志、集团 KPI 数据、 IPO 关联表<br>P1：重要的业务数据和应用数据，具有不可恢复性，如重要业务产品数据<br>P2：重要的业务数据和应用数据，具有可恢复性，如交易 ETL 产生的中间过程数据<br>P3：不重要的业务数据和不重要的应用数据，具有可恢复性，如某些 SNS 产品报表</p></blockquote><p><strong>表类型划分</strong></p><blockquote><p>事件型流水表（增量表）：指数据无重复或者无主键数据，如日志<br>事件型镜像表（增量表）：指业务过程性数据，有主键，但是对于同样主键的属性会发生缓慢变化，如交易、订单状态与时间会根据业务发生变更<br>维表：包括维度与维度属性数据，如用户表、商品表<br>Merge 全量表：包括业务过程性数据或者维表数据，数据新增或者发生状态变更，对于同样主键的数据会保留多份，可根据主键进行 Merge 操作<br>ETL 临时表：ETL 处理过程中产生的临时表数据，不建议保留<br>TT 临时数据：TT 拉取的数据和 DbSync 产生的临时数据最终会流转到 ODS 层，作为原始数据保留下来；使得 TT&amp;DbSync 上游数据成为临时数据，不建议保留很长时间，默认保留 93 天<br>普通全量表：BI 全量拉取的小业务数据或者产品数据，根据历史数据等级确定保留策略</p></blockquote><h2 id="3-5-数据成本管理"><a href="#3-5-数据成本管理" class="headerlink" title="3.5 数据成本管理"></a>3.5 数据成本管理</h2><h3 id="3-5-1-数据成本计量"><a href="#3-5-1-数据成本计量" class="headerlink" title="3.5.1 数据成本计量"></a>3.5.1 数据成本计量</h3><p><strong>数据成本计量</strong>：分为自身的存储成本和计算成本；除了考虑自身的成本外，还要考虑对上游数据表的扫描带来的扫描成本</p><blockquote><p>存储成本是为了计量数据表消耗的存储资源<br>计算成本是为了计量数据计算过程中的 CPU 消耗<br>扫描成本是为了扫描上游数据表的 CPU 消耗</p></blockquote><h3 id="3-5-2-数据使用计费"><a href="#3-5-2-数据使用计费" class="headerlink" title="3.5.2 数据使用计费"></a>3.5.2 数据使用计费</h3><p><strong>数据使用计费</strong>：结合数据成本，分为计算付费、存储付费和扫描付费</p><h1 id="4-数据质量"><a href="#4-数据质量" class="headerlink" title="4. 数据质量"></a>4. 数据质量</h1><h2 id="4-1-数据质量保障原则"><a href="#4-1-数据质量保障原则" class="headerlink" title="4.1 数据质量保障原则"></a>4.1 数据质量保障原则</h2><ol><li><strong>完整性</strong>：指数据的记录和信息是否完整，是否存在缺失的情况；包括记录数据量的缺失和记录中某个字段信息的缺失，是数据质量最基础的保障</li><li><strong>准确性</strong>：指数据中记录的信息和数据是否准确，是否 在异常或错误的信息</li><li><strong>一致性</strong>：对于同一份数据，必须保证一致</li><li><strong>及时性</strong>：描述数据及时产出的能力，希望当天就能够看到前一天的数据</li></ol><h2 id="4-2-数据质量万法概述"><a href="#4-2-数据质量万法概述" class="headerlink" title="4.2 数据质量万法概述"></a>4.2 数据质量万法概述</h2><h3 id="4-2-1-消费场景知晓"><a href="#4-2-1-消费场景知晓" class="headerlink" title="4.2.1 消费场景知晓"></a>4.2.1 消费场景知晓</h3><p><strong>消费场景知晓</strong>：通过数据资产等级和基于元数据的应用链路分析解决消费场景知晓的问题；根据应用的影响程度，确定资产等级；根据数据链路血缘，将资产等级上推至数据生产加工的各个环节，确定数据的不同处理方式</p><ul><li><strong>数据资产等级定义</strong></li></ul><blockquote><p><strong>毁灭性质</strong>：即数据一旦出错，将会引起重大资产损失，面临重大收益损失，造成重大公关风险<br><strong>全局性质</strong>：即数据直接或者间接用于集团级业务和效果的评估、重要平台的运维、对外数据产品的透露、影响用户在阿里系网站的行为等<br><strong>局部性质</strong>：数据直接或间接用于内部一般数据产品或者运营／产品报告，如果出现问题会给事业部或业务线造成影响，或者造成工作效率损失<br><strong>一般性质</strong>：即数据主要用于小二的日常数据分析，出现问题几不会带来影响或者带来的影响极小<br><strong>未知性质</strong>：不能明确说出数据的应用场景，则标注为未知<br>毁灭性质标记 A1 等级，全局性质标记为 A2 等级，局部性质标记为 A3 等级，一般性质标记为 A4 等级，未知性质则标记为 Ax 等级</p></blockquote><ul><li><strong>数据资产等级落地方法</strong>：借助元数据整合整个数据仓库所有表所服务的数据产品，根据数据产品的等级确定数据资产的等级；如生意参谋为 A2 等级的业务，对应这个导出表的资产等级就是 A2 ，所有加工这个表的上游链路上的所有表都将会打上 A2 资产等级的标签，同时会标注为生意参谋产品使用</li></ul><h3 id="4-2-2-数据生产加工各个环节卡点校验"><a href="#4-2-2-数据生产加工各个环节卡点校验" class="headerlink" title="4.2.2 数据生产加工各个环节卡点校验"></a>4.2.2 数据生产加工各个环节卡点校验</h3><p><strong>数据生产加工各个环节卡点校验</strong>：主要包括在线系统（OLTP）和离线系统（OLAP）数据生产加工各个环节的卡点校验</p><ul><li><strong>在线系统卡点校验</strong>：主要是指在在线业务系统的数据生成过程中进行的卡点校验</li></ul><blockquote><p>发布平台工具根据资产等级的不同，当对应的业务系统变更时，包括数据变更和数据库表变更，如数据库扩容和表的DDL变化，决定是否将变更通知下游离线系统<br>对于高资产等级的业务， 当出现新业务数据时，是否纳入统计中，需要卡点审批</p></blockquote><ul><li><strong>离线系统卡点校验</strong>：包括代码开发、测试、发布和历史或错误数据回刷等环节的卡点校验，针对数据资产等级的不同，对校验的要求有所不同</li></ul><blockquote><p>代码提交时的卡点校验：通过代码扫描工具 SQLSCAN，针对每一次提交上线的代码进行扫描，将风险点提示出来<br>任务发布上线时的卡点校验：每一次变更都需要线下完成测试后再发布到线上环境中，线上测试通过后才算发布成功，测试包括 Code Review 和回归测试；发布上线后可以在线上做 Dry Run 测试或真实环境运行测试</p></blockquote><h3 id="4-2-3-风险点监控"><a href="#4-2-3-风险点监控" class="headerlink" title="4.2.3 风险点监控"></a>4.2.3 风险点监控</h3><p><strong>风险点监控</strong>：主要是针对在数据日常运行过程中可能出现的数据质量和 时效等问题进行监控，包括在线数据和离线数据的风险点监控</p><ul><li><strong>在线系统风险点监控</strong>：针对在线系统日常运行产出的数据进行业务规则的校验 ，以保证数据质量，其主要使用实时业务检测平台 BCP (Biz Check Platform ）</li></ul><blockquote><p>用户在 BCP 平台进行数据源订阅，以获取需要校验的数据源<br>针对所订阅的数据源进行规则的编写，即校验的逻辑；只有规则通过，才认为这条记录正确<br>配置告警，针对不同的规则配置不同的告警形式</p></blockquote><ul><li><strong>离线系统风险点监控</strong>：针对离线系统日常运行产出的数据进行数据质量监控和时效性监控，其中数据质量监控主要使用 DQC 时效性监控主要使用摩萨德</li></ul><blockquote><p>数据准确性：使用 DQC 检查保障数据的准确性，DQC 任务也是运行 SQL 任务，嵌套在主任务中，检查点太多会影响整体的性能<br>数据及时性：以天作为时间间隔进行同步，一般从零点开始运行，需要保证重要的任务优先且正确产出</p><blockquote><p>任务优先级：先确定业务的资产等级，高等级业务配置高优先级<br>任务报警：高优先级任务出错或可能出现产出延迟，报警给到任务和业务 Owner</p></blockquote></blockquote><p><strong>实践—摩萨德</strong>：离线任务的监控报警系统，根据离线任务的运行情况实时决策是否告警、 何时告 、告警方式、告警给谁等；提供甘特图的服务，针对业务的运行情况，提供一条关键路径 ，即完成业务的最慢任务链路图</p><blockquote><p><strong>强保障监控</strong>：是摩萨德的核心功能</p><blockquote><p>监控范围一一设置了强保障业务的任务及其上游所有的任务都会被监控<br>监控异常一一包括任务出错、任务变慢、预警业务延迟等<br>告警对象一一默认是任务 Owner ，也可以设置值班表到某个人<br>何时告警一一根据业务设置的预警时间判断何时告警<br>告警方式一一根据任务的重要紧急程度，支持电话、短信、旺旺、邮件告警</p></blockquote><p><strong>告警配置</strong>：用户可以根据自己的需要进行配置</p><blockquote><p>出错告警一一可根据应用、业务、任务三个监控对象进行出错告警配置，监控对象出错即告警给到人／Owner／值班表<br>完成告警一一可根据应用、业务、任务三个监控对象进行完成情况告警配置，监控对象完成即告警给到 Owner／值班表<br>未完成告警一一可根据应用、业务、任务三个监控对象进行未完成情况告警配置，监控对象未完成即告警给到人／Owner／值班表<br>周期性告警一一针对某个周期的小时任务，如果在某个时间未完成， 即告警给到人／Owner / 值班表<br>超时告警一 根据任务运行时长进行超时告警配置，任务运行超过指定时间即告警给到人 Owner／值班表</p></blockquote></blockquote><h3 id="4-2-4-质量衡量"><a href="#4-2-4-质量衡量" class="headerlink" title="4.2.4 质量衡量"></a>4.2.4 质量衡量</h3><p><strong>质量衡量</strong>：既有事前的衡量，如 DQC 覆盖率；又有事后的衡量，主要用于眼进质量问题，确定质量问题原因、责任人、解决情况等，用于数据质量的复盘，避免类似事件再次发生</p><blockquote><p>数据质量起夜率：数据出现问题开发人员起夜进行处理的次数<br>数据质量事件：针对每一个数据质量问题，都记录成一个数据质量事件</p><blockquote><p>用来跟进数据质量问题的处理过程<br>用来归纳分析数据质量原因<br>根据数据质量原因来查缺补漏，针对类似问题给出后续预防方案</p></blockquote><p>数据质量故障体系：对于严重的数据质量事件，将升级为故障</p><blockquote><p>故障定义：识别出重要的业务数据，并注册到系统中，填写相关的业务情况，如技术负责人、业务负责人、数据应用场景、延迟或错误带来的影响、是否会发生资产损失等，完成后，会将这部分数据的任务挂到平台基线上，一旦延迟或错误即自动生成故障单，形成故障<br>故障等级：故障发生后，根据一定标准判断故障等级，如故障时长、客户投诉量、资金损失等，将故障按 p1~ p4 定级<br>故障处理：快速地识别故障原因，并迅速解决，消除影响<br>故障 Review：分析故障的原因、处理过程的复盘、形成后续解决的 Action ，并且都会以文字的形式详细记录，对故障的责任进行归属</p></blockquote></blockquote>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据实践-01阿里-数据模型</title>
      <link href="/202109/0227125.html"/>
      <url>/202109/0227125.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录大数据实践-01阿里-数据模型的相关内容</p><span id="more"></span><h1 id="1-建模综述"><a href="#1-建模综述" class="headerlink" title="1. 建模综述"></a>1. 建模综述</h1><p><strong>数据模型</strong>：是数据组织和存储方法，强调从业务、数据存取和使用角度合理存储数据</p><blockquote><p>性能：良好的数据模型能帮助我们快速查询所需要的数据，减少数据的 I/O 吞吐<br>成本：良好的数据模型能极大地减少不必要的数据冗余，也能实现计算结果复用，极大地降低大数据系统中的存储和计算成本<br>效率：良好的数据模型能极大地改善用户使用数据的体验，提高使用数据的效率<br>质量：良好的数据模型能改善数据统计口径的不一致性，减少数据计算错误的可能性</p></blockquote><h2 id="1-1-数据仓库建模"><a href="#1-1-数据仓库建模" class="headerlink" title="1.1 数据仓库建模"></a>1.1 数据仓库建模</h2><ul><li><strong>ER 模型</strong>：从全企业的高度设计一个3NF 模型，用实体关系（ Entity Relationship, ER ）模型描述企业业务，在范式理论上符合 3NF；将各个系统中的数据以整个企业角度按主题进行相似性组合和合并，并进行一致性处理，为数据分析决策服务；FS-LDM (Financial Services Logical Data Model ）</li></ul><blockquote><p>高层模型：一个高度抽象的模型，描述主要的主题以及主题间的关系，用于描述企业的业务总体概况<br>中层模型：在高层模型的基础上，细化主题的数据项<br>物理模型：也叫底层模型，在中层模型的基础上，考虑物理存储，同时基于性能和平台特点进行物理属性做一些表的合并、分区的设计等</p></blockquote><ul><li><strong>维度模型</strong>：从分析决策的需求出发构建模型，为分析需求服务；如，星形模型、雪花模型等</li></ul><blockquote><ol><li>选择需要进行分析决策的业务过程：业务过程可以是单个业务事件，比如交易的支付、退款等；也可以是某个事件的状态，比如当前的账户余额等；还可以是一系列相关业务事件组成的业务流程，具体需要看我们分析的是某些事件发生情况，还是当前状态，或是事件流转效率</li><li>选择粒度：在事件分析中，我们要预判所有分析需要细分的程度，从而决定选择的粒度；粒度是维度的一个组合</li><li>识别维表：选择好粒度之后，基于此粒度设计维表，包括维度属性，用于分析时进行分组和筛选</li><li>选择事实：确定分析需要衡量的指标</li></ol></blockquote><ul><li><strong>Data Vault 模型</strong>：是 ER模型的衍生，建立一个可审计的基础数据层强调数据的历史性、可追溯性和原子性</li></ul><blockquote><p><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0201_DataValut%E6%A8%A1%E5%9E%8B.png" alt="0201_DataValut模型"><br>Hub ：是企业的核心业务实体，由 实体 key 、数据仓库序列代理键、装载时间、数据来源组成<br>Link ：代表 Hub 之间的关系，与 ER 模型最大的区别是将关系作为一个独立的单元抽象，可以提升模型的扩展性；可以直接描述1：1、1：n、 n：n 关系，不需要做任何变更；由 Hub的代理键、装载时间、数据来源组成<br>Satellite ：是 Hub 的详细描述内容， 一个 Hub 可以有多个 Satellite；由 Hub 的代理键、装载时间、来源类型、详细的 Hub 描述信息组成</p></blockquote><ul><li><strong>Anchor 模型</strong>：对 Data Vault 模型的进一步规范化处理，核心思想是所有的扩展只是添加而不是修改</li></ul><blockquote><p><img src="https://qizhongyi.gitee.io/images//Data/DataManage/Ali_Practice/0202_Anchor%E6%A8%A1%E5%9E%8B.png" alt="0202_Anchor模型"><br>Anchors ：类似于 Data Vault 的 Hub ，代表业务实体，且只有主键<br>Attributes ：类似于 Data Vault 的 Satellite ，更加规范化，将其全部 k-v 结构化， 一个表只有一个 Anchors 的属性描述<br>Ties ：描述 Anchors 之间的关系，单独用表来描述，类似于 Data Vault 的 Link ，可以提升整体模型关系的扩展能力<br>Knots ：代表可能会在多个 Anchors 中公用的属性的提炼，比如性别、状态等这种枚举类型且被公用的属性</p></blockquote><h3 id="1-1-1-数据仓库建模过程"><a href="#1-1-1-数据仓库建模过程" class="headerlink" title="1.1.1 数据仓库建模过程"></a>1.1.1 数据仓库建模过程</h3><ul><li><strong>第一阶段</strong>：完全应用驱动的时代，阿里巴巴的第一代数据仓库系统构建在 Oracle 上，数据完全以满足报表需求为目的，将数据以与源结构相同的方式同步到 Oracle （称作 ODS 层），数据工程师基于 ODS 数据进行统计，基本没有系统化的模型方法体系，完全基于对 Oracle数据库特性的利用进行数据存储和加工，部分采用 一些维度建模的缓慢化维方式进行历史数据处理；数据架构只有 ODS+DSS 两层</li><li><strong>第二阶段</strong>：引入 MPP 架构体系的 Greenplum，同时阿里巴巴的数据团队也在进行一定的数据架构优化，改变烟囱式的开发模型 ，消除冗余 ，提升数据的一致性；采用工程领域比较流行的 ER模型＋维度模型方式，构建出一个四层的模型架构，ODL ：操作数据层 +BDL ：基础数据层 +IDL ：接口数据层 +ADL ：应用数据层； ODL 和源系统保持一致；BDL 引入 ER模型，加强数据整合，构建一致的基础数据模型；IDL 基于维度模型方法构建集市层；ADL 完成应用的个性化和基于展现需求的数据组装；迟迟未能产出</li><li><strong>第三阶段</strong>：以 Hadoop 为代表的分布式存储计算平台结合集团自主研发的分布式计算平台 MaxCompute ；选择以 Kimball 的维度建模为核心理念的模型方法论，对其进行一定的升级和扩展，构建阿里巴巴集团的公共层模型数据架构体系，着力解决数据存储和计算的共享问题；形成是一套统一化的集团数据整合及管理的方法体系（内部称为“OneData ”），包括一致性的指标定义体系 、模型设计方法体系以及配套工具</li></ul><h1 id="2-OneData"><a href="#2-OneData" class="headerlink" title="2. OneData"></a>2. OneData</h1><p><strong>OneData</strong>：是阿里巴巴内部进行数据整合及管理的方法体系和工具；建设统一的、规范化的数据接入层（ ODS ）和数据中间层（ DWD 和 DWS ），通过数据服务和数据产品，完成服务于阿里巴巴的大数据系统的数据公共层建设；提供标准化的（ Standard ）、共享的（ Shared ）、数据服务（ Service ）能力，降低数据互通成本，释放计算、存储、人力等资源，以消除业务和技术之痛</p><p><strong>OneData体系架构</strong></p><blockquote><p><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0203_OneData%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84.png" alt="0203_OneData体系架构"><br>业务板块：阿里巴巴集团业务生态庞大，根据业务的属性划分出几个相对独立的业务板块，业务板块之间的指标或业务重叠性较小；如电商业务板块涵盖淘系、 B2B系和 AliExp ess 系等<br>规范定义： 以维度建模作为理论基础构建总线矩阵，划分和定义数据域、业务过程、维度、度量/原子指标、修饰类型、修饰词、时间周期、派生指标<br>模型设计： 以维度建模理论为基础，基于维度建模总线架构，构建一致、规范定义的维度和事实；在落地表模型时，基于阿里自身业务特点，设计出一套表规范命名体系</p></blockquote><h2 id="2-1-规范定义"><a href="#2-1-规范定义" class="headerlink" title="2.1 规范定义"></a>2.1 规范定义</h2><ul><li><strong>规范定义实例</strong><br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0204_OneData%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84_%E8%A7%84%E8%8C%83%E5%AE%9A%E4%B9%89.png" alt="0204_OneData体系架构_规范定义"></li><li><strong>名词解释</strong></li></ul><blockquote><p>度量/原子指标：基于某一业务行为下的度量，是业务定义中不可再拆分的指标<br>派生指标：由一个原子指标＋多个修饰词（可选）＋时间周期组成，对原子指标业务统计范罔的圈定；如原子指标：支付金额；派生指标：最近1天海外买家支付金额<br>维度：维度是度量的环境，用来反映业务的一类属性，如地理维度（其中包挤罔家、地区、省以及城市等级别的内容）、时间维度（其中包括年、季、月、周、日等级别的内容）<br>维度属性：维度属性隶属于一个维度，如地理维度里面的国家名称、同家 ID 、省份名称等</p></blockquote><ul><li><strong>指标体系</strong><br><strong>基本原则</strong></li></ul><blockquote><p>组成体系之间的关系</p><blockquote><p>派生指标由原子指标、时间周期修饰词、若干其他修饰词组合得到<br>原子指标、修饰类型及修饰词，直接归属在业务过程下，修饰词继承修饰类型的数据域<br>派生指标可以选择多个修饰词，修饰词之间的关系为“或”或“且”，由具体的派生指标语义决定<br>派生指标唯一归属一个原子指标 ，继承原子指标的数据域，与修饰词的数据域无关</p></blockquote><p>命名约定</p><blockquote><p>命名所用术语：指标命名，尽量使用英文简写，其次是英文，指标英文名太长时，可考虑用汉语拼音首字母命名；如中国制造用 zgzz<br>业务过程：英文名：用英文或英文的缩写或者中文拼音简写；中文名：具体的业务过程中文<br>原子指标：英文名 ：动作＋度量：中文名：动作＋度量<br>修饰词：只有时间周期才会有英文名，且长度为2位，加上“_”共三位，如 _id<br>派生指标：英文名：原子指标英文名＋时间周期修饰词（3 位，如_Id) ＋序号（ 4位，如_001 ）；中文名：时间周期修饰词＋［其他修饰词］＋原子指标</p></blockquote><p>算法</p><blockquote><p>算法概述一一算法对应的用户容易理解的阐述<br>举例一一通过具体例子帮助理解指标算法<br>SQL 算法说明一一对于派生指标给出 SQL 的写法或者伪代码</p></blockquote></blockquote><p><strong>操作细则</strong></p><blockquote><p>派生指标的种类</p><blockquote><p>事务型指标：是指对业务活动进行衡量的指标；如新发商品数、重发商品数、新增注册会员数、订单支付金额，这类指标需维护原子指标及修饰词，在此基础上创建派生指标<br>存量型指标：是指对实体对象（如商品、会员）某些状态的统计；例如商品总数、注册会员总数，这类指标需维护原子指标及修饰词，在此基础上创建派生指标，对应的时间周期 般为“历史截至当前某个时间”<br>复合型指标：是在事务型指标和存量型指标的基础上复合而成；如浏览 UV－下单买家数转化率 有些需要 建新原子指标，有些则可以在事务型或存量型原子指标的基础上增加修饰词得到派生指标</p></blockquote><p>复合型指标的规则</p><blockquote><p>比率型：创建原子指标，如 TR 、浏览 UV 下单买家数转化率、满意率等；如“最近1天店铺首页 CTR”，原子指标为“ CTR ”<br>比例型 创建原子指标，如百分比 、占 比；如“最近1天无线支付金额占比”，原子指标为“支付金额占比”<br>变化量型：不创建原子指标，增加修饰词，在此基础上创建派指标；如，“最近1天订单支付金额上的变化量”，原子指标为“订单支付金额”<br>变化率型：创建原子指标。例如，“最近7天海外买家支付金额变化率”，原子指标为“支付金额变化率”<br>统计型：不创建原子指标，增加修饰词，在此基础上创建派生指标；在修饰类型 “统计方法”下增加修饰词，如人均、日均、行业平均、商品平均 90 分位数 70 分位数等；如，“自然月日均 UV”，原子指标为“UV”<br>排名型：创建原子指标， 一般为 top_xxx xxx，或rank 和 top_xxx_xxx 组合；修饰词可以有：统计方法（如降序、升序）、排名名次（如 TOP IO ）、排名范围（如行业、省份、一级来源等）、排序因子（如搜索次数、 PV ）等<br>对象集合型：主要是指数据产品和应用需要展现数据时，将一些对象以 k-v 对的方式存储在一个字段 中；如趋势图、 TOP 排名对象等</p></blockquote></blockquote><p><strong>其他规则</strong></p><blockquote><p>上下层级派生指标同时存在时：如最近 天支付金额和最近 PC 端支付金额，建议使用前者，PC 端作为维度属性存放在物理表中体现<br>父子关系原子指标存在时：优先选择子原子指标；使用子原子指标创建派生指标</p></blockquote><h2 id="2-2-模型设计"><a href="#2-2-模型设计" class="headerlink" title="2.2 模型设计"></a>2.2 模型设计</h2><ul><li><strong>模型设计架构</strong><br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0205_OneData%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84_%E6%A8%A1%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%9E%B6%E6%9E%84.png" alt="0205_OneData体系架构_模型设计架构"></li><li><strong>模型层次</strong>：操作数据层（ ODS ）、公共维度模型层（ CDM ）和应用数据层（ ADS ），其中公共维度模型层包括明细数据层（ DWD ）和汇总数据层（ DWS ）<br><strong>操作数据层（ ODS ）</strong>：把操作系统数据无处理地存放在数据仓库系统中</li></ul><blockquote><p>同步：结构化数据增量或全量同步到 MaxCompute<br>结构化：非结构化（日志）结构化处理并存储至lj MaxCompt闹<br>累积历史、清洗：根据数据业务需求及稽核和审计要求保存历史数据、清洗数据</p></blockquote><p><strong>公共维度模型层（ CDM ）</strong>：存放明细事实数据、维表数据及公共指标汇总数据，其中明细事实数据、维表数据根据 ODS 层数据加工生成；公共指标汇总数据根据维表数据和明细事实数据加工生成</p><blockquote><p>组合相关和相似数据：采用明细宽表，复用关联计算，减少数据扫描<br>公共指标统 加工：基于 OneData 体系构建命名规范、口径一致和算法统一的统计指标，为上层数据产品、应用和服务提供公共指标，建立逻辑汇总宽表<br>建立 致性维度：建立一致的数据分析维表，降低数据计算口径、算法不统一的风险</p></blockquote><p><strong>应用数据层（ ADS ）</strong>：存放数据产品个性化的统计指标数据，根据CDM 层与 ODS 层加工生成</p><blockquote><p>个性化指标加工：不公用性、复杂性（指数型、比值型、排名型指标）<br>基于应用的数据组装 大宽表集市、横表转纵表、趋势指标串</p></blockquote><ul><li><strong>基本原则</strong></li></ul><ol><li>高内聚和低耦合：将高概率同 时访问的数据放一起，将低概率同时访问的数据分开存储</li><li>核心模型与扩展模型分离：核心模型包括的宇段支持常用的核心业务，扩展模型包括的字段支持个性化或少量应用的需要 ，不能让扩展模型的宇段过度侵入核心模型</li><li>公共处理逻辑下沉及单一：不要让公用的处理逻辑暴露给应用层实现，不要让公共逻辑多处同时存在</li><li>成本与性能平衡：适当的数据冗余可换取查询和刷新性能，不宜过度冗余</li><li>数据可回滚：处理逻辑不变，在不同时间多次运行数据结果确定不变</li><li>一致性：具有相同含义的字段在不同表中的命名必须相同，使用规范定义</li><li>命名清晰、可理：表命名需清晰、一致，表名需易于消费者理解和使用</li></ol><h2 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h2><ul><li><p><strong>指导方针</strong>：进行充分的业务调研和需求分析；进行数据总体架构设计，根据数据域对数据进行划分，按照维度建模理论，构建总线矩阵、抽象出业务过程和维度；对报表需求进行抽象整理出相关指标体系，使用 OneData 工具完成指标规范定义和模型设计；代码研发和运维</p></li><li><p><strong>实施工作流</strong></p><ol><li><strong>数据调研</strong><br>业务调研：阿里集团涉及的业务涵盖电商、数 娱乐、导航（高德）、移动互联网服务等领域，细分业务领域、业务线、业务模块和业务流程<br>需求调研：收集数据使用者的需求，如了解分析师、业务运营人员的数据诉求，形成报表需求</li></ol><blockquote><p>与分析师、业务运营人员的沟通（邮件、 IM ）获知需求<br>对报表系统中现有的报表进行研究分析</p></blockquote><ol start="2"><li><strong>架构设计</strong><br>数据域划分：数据域是指面向业务分析，将业务过程或者维度进行抽象的集合；数据域需要抽象提炼，长期维护和更新，谨慎变动<br>构建总线矩阵：明确每个数据域下的业务过程，业务过程与维度关联性；定义每个数据域下的业务过程和维度</li><li><strong>规范定义</strong>：规范定义主要定义指标体系，包括原子指标、修饰词、时间周期和派生指标</li><li><strong>模型设计</strong>：模型设计主要包括维度及属性的规范定义，维表、明细事实表和汇总事实表的模型设计</li><li><strong>总结</strong>：实施过程是一个高度迭代和动态的过程，一般采用螺旋式实施方法；在总体架构设计完成之后，开始根据数据域进行迭代式模型设计和评审</li></ol></li></ul><h1 id="3-维度设计"><a href="#3-维度设计" class="headerlink" title="3. 维度设计"></a>3. 维度设计</h1><p><strong>维度</strong>：将度量称为“事实”，环境描述为“维度”；维度是用于分析事实所需要的多样环境；维度使用代理主键或自然主键标识其唯一性，代理键是不具有业务含义的键，用于处理缓慢变化维；自然键是具有业务含义的键<br><strong>维度属性</strong>：维度所包含的表示维度的列；是查询约束条件、分组和报表标签生成的基本来源，是数据易用性的关键</p><h2 id="3-1-设计方法"><a href="#3-1-设计方法" class="headerlink" title="3.1 设计方法"></a>3.1 设计方法</h2><ol><li>选择维度或新建维度；作为维度建模的核心，在企业级数据仓库中必须保证维度的唯一性；如淘宝商品维度有且只允许有一个维度定义</li><li>确定主维表；主维表一般是 ODS 表，直接与业务系统同步；如淘宝商品维度， s_auction_auctions 是与前台商品中心系统同步的商品表是主维表</li><li>确定相关维表；确定和主维表存在关联关系的表，并结合业务生成维度属性；如淘宝商品维度与类目、 SPU 卖家、店铺等维度存在关联关系</li><li>确定维度属性；先从主维表中选择维度属性或生成新的维度属性，再从相关维表中选择维度属性或生成新的维度属性；如淘宝商品维度的主维表 s_auction_auctions 和类目、 SPU 、卖家、店铺等相关维表中选择维度属性或生成新的维度属性</li></ol><blockquote><p>尽可能生成丰富的维度属性：为下游的数据统计、分析、探查提供良好基础<br>尽可能多地给出包括一些富有意义的文字性描述：一般是编码和文字同时存在，编码用于表间关联，名称用于报表标签<br>区分数值型属性和事实：若通常用于查询约束条件或分组统计，则作为维度属性；若通常用于参与度量的计算，则作为事实<br>尽量沉淀出通用的维度属性：可以提高下游使用的方便性，减少复杂度；可以避免下游使用解析时由于各自逻辑不同而导致口径不一致</p></blockquote><h3 id="3-1-1-注意问题"><a href="#3-1-1-注意问题" class="headerlink" title="3.1.1 注意问题"></a>3.1.1 注意问题</h3><p><strong>层次结构</strong>：维度中的一些描述属性以层次方式或一对多的方式相互关联，可以被理解为包含连续主从关系的属性层次<br><strong>反规范化</strong>：将维度的属性层次合并到单个维度中的操作称为反规范化，评估规范化和易用效能之间的平衡<br><strong>交叉探查</strong>：将不同数据域的商品的事实合并在一起进行数据探查称为交叉探查，如计算转化率等<br><strong>一致性表现</strong></p><blockquote><p>共享维表：如在阿里巴巴的数据仓库中，商品、卖家、买家、类目等维度有且只有一个，可以进行交叉探查<br>一致性上卷：其中一个维度的维度属性是另 一个维度的维度属性的子集，且两个维度的公共维度属性结构和内容相同；如在阿里巴巴的商品体系中，有商品维度和类目维度，其中类目维度的维度属性是商品维度的维度属性的子集，且有相同的维度属性和维度属性值，可以进行交叉探查<br>交叉属性：两个维度具有部分相同的维度属性；如在商品维度中具有类目属性，在卖家维度中具有主营类目属性，两个维度具有相同的类目属性，则可以在相同的类目属性上进行不同业务过程的交叉探查</p></blockquote><h2 id="3-2-高级主题"><a href="#3-2-高级主题" class="headerlink" title="3.2 高级主题"></a>3.2 高级主题</h2><h3 id="3-2-1-维度整合"><a href="#3-2-1-维度整合" class="headerlink" title="3.2.1 维度整合"></a>3.2.1 维度整合</h3><ul><li><strong>整合方式</strong></li></ul><blockquote><p>垂直整合：不同的来源表包含相同的数据集，只是存储的信息不同；如淘宝会员中的会员基础信息表、会员扩展信息表、淘宝会员等级信息表和天猫会员等级信息表，可以整合至会员维度模型中，丰富其维度属性<br>水平整合：不同的来源表包含不同的数据集，不同子集之间存在部分交叉或不交叉，如蚂蚁金服有淘宝会员、 1688 会员、国际站会员、支付宝会员等</p></blockquote><h4 id="3-2-1-1-数据仓库集成"><a href="#3-2-1-1-数据仓库集成" class="headerlink" title="3.2.1.1 数据仓库集成"></a>3.2.1.1 数据仓库集成</h4><p><strong>应用差异</strong></p><blockquote><p>数据存储方式不同；关系型数据库存储（Oracle、 MySQL ）、NoSQL 数据库存储（ HBase、 Tair ）或文件存储（Excel、HDFS）<br>在编码、命名习惯、度量单位等方面会存在很大的差异；如对于用户的性别编码不同，有 0和1 、或 F和M</p></blockquote><p><strong>集成表现</strong></p><blockquote><p>命名规范的统一：表名、字段名等统一<br>字段类型的统一：相同和相似字段的字段类型统一<br>数据代码的统一：公共代码、标志性宇段的数据类型、命名方式等统一<br>业务表的统一：依据高内聚、低稠合的理念，将业务关系大、业务含义相同、源系统影响差异小的表整合；将业务关系小、源系统影响差异大的表分而置之</p></blockquote><p><strong>集成方式</strong></p><blockquote><p>采用主从表的设计方式，将两个表或多个表都有的字段放在主表中（主要基本信息），从属信息分别放在各自的从表中；对于主表中的主键，采用复合主键、源主键和系统或表区别标志；或者采用唯一主键、“源主键和系统或表区别标志”生成新的主键；建议采用复合主键<br>直接合并，共有信息和个性信息都放在同一个表中；可能由于表字段的重合度较低出现大量空值，影响存储和易用性<br>不合并源表的表结构及主键等差异很大的业务表，使用数据仓库存放各自的数据</p></blockquote><h3 id="3-2-1-2-维度拆分"><a href="#3-2-1-2-维度拆分" class="headerlink" title="3.2.1.2 维度拆分"></a>3.2.1.2 维度拆分</h3><p><strong>拆分原则</strong></p><blockquote><p>扩展性：当源系统、业务逻辑变化时，能通过较少的成本快速扩展模型，保持核心模型的相对稳定性；保障高内聚、低稠合<br>效能：在性能和成本方面取得平衡；通过牺牲一定的存储成本，达到性能和逻辑的优化<br>易用性：模型可理解性高、访问复杂度低；用户能够方便地从模型中找到对应的数据表，并能够方便地查询和分析</p></blockquote><ul><li><strong>水平拆分情况</strong></li></ul><blockquote><p>维度的不同分类的属性差异情况：维度属性随类型变化较大<br>业务的关联程度：拆分相关性较低的业务</p></blockquote><ul><li><strong>垂直拆分情况</strong></li></ul><blockquote><p>某些维度属性的来源表产出时间较早，某些维度属性的来表产出时间较晚<br>某些维度属性的热度高、使用频繁，某些维度属性的热度低、较少使用<br>某些维度属性经常变化，某些维度属性比较稳定</p></blockquote><p><strong>解决方案</strong>：出于扩展性、产出时间、易用性等方面的考虑，设计主从维度；主维表存放稳定 产出时间早、热度高的属性；从维表存放变化较快、产出时间晚、热度低的属性</p><h3 id="3-2-2-历史归档"><a href="#3-2-2-历史归档" class="headerlink" title="3.2.2 历史归档"></a>3.2.2 历史归档</h3><blockquote><p>归档策略1：同前台归档策略，在数据仓库中实现前台归档算法，定期对历史数据进行归档；存在问题：前台归档策略复杂，实现成本较高；前台归档策略可能会经常变化，导致数据仓库归档算法也要随之变化，维护和沟通成本较高；适用于前台归档策略逻辑较为简单，且变更不频繁的情况<br>归档策略2：同前台归档策略，采用数据库变更日志的方式；通过数据库 binlog 日志解析获取每日增量，通过增量 merge 全量的方式获取最新的全量数据；使用增量日志的删除标志，作为前台数据归档的标志，通过此标志对数据仓库的数据进行归档；此方式不关注前台归档策略，简单易行；但对前台应用的要求是数据库的物理删除只有在归档时才执行，应用中的删除只是逻辑删除<br>归档策略3：数据仓库自定义归档策略；将归档算法用简单、直接的方式实现，遵循尽量比前台应用晚归档、少归档的原则；避免出现数据仓库中已经归档的数据再次更新的情况</p></blockquote><h2 id="3-3-维度变化"><a href="#3-3-维度变化" class="headerlink" title="3.3 维度变化"></a>3.3 维度变化</h2><h3 id="3-3-1-缓慢变化维"><a href="#3-3-1-缓慢变化维" class="headerlink" title="3.3.1 缓慢变化维"></a>3.3.1 缓慢变化维</h3><blockquote><p>重写维度值：不保留历史数据，始终取最新数据<br>插人新的维度行：保留历史数据，维度值变化前的事实和过去的维度值关联，维度值变化后的事实和当前的维度值关联<br>添加维度列：将变化前后记录的事实归一为变化前的维度或变化后的维度</p></blockquote><h3 id="3-3-2-快照维表"><a href="#3-3-2-快照维表" class="headerlink" title="3.3.2 快照维表"></a>3.3.2 快照维表</h3><p><strong>快照维表</strong>：处理缓慢变化维的问题，采用快照方式周期性（每天）保留一份全量数据；造成大量存储浪费</p><blockquote><p>简单而有效，开发和维护成本低<br>使用方便，理解性好；数据使用方只需要限定日期，即可获取到当天的快照数据，任意一天的事实快照和维度快照通过维度的自然键进行关联</p></blockquote><h3 id="3-3-3-极限存储"><a href="#3-3-3-极限存储" class="headerlink" title="3.3.3 极限存储"></a>3.3.3 极限存储</h3><p><strong>历史拉链存储</strong>：利用维度模型处理缓慢变化维；新增两个时间戳字段（start_dt 和 end_dt ），将所有以天为粒度的变更数据都记录下来；时间戳字段也用作分区，随着时间推移，分区数量会极度膨胀，受到现行数据库分区数量的限制</p><blockquote><p><strong>透明化</strong>：底层用历史拉链存储，上层增加视图或在 Hive 里增加一个 hook，通过语法分析树，把对极限存储前表的查询转换成对极限存储表的查询；对下游用户，极限存储表和全量存储一致</p><pre class="line-numbers language-none"><code class="language-none">select id from A where ds &#x3D; 20210101;等价于select id from A_EXST where start_dt &lt;&#x3D; 20210101 and end_dt &gt; 20210101;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>分月做历史拉链表</strong></p></blockquote><p><strong>优缺点</strong></p><blockquote><p>极大压缩了全量存储的成本<br>对下游用户透明<br>产出效率很低，大部分极限存储通常需要 t-2<br>对于变化频率高的数据并不能达到节约成本的效果</p></blockquote><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>基于极限存储进行额外处理</p><blockquote><p>在极限存储前进行一次全量存储 ，全量存储表仅保留最近一段时间的全量分区数据，历史数据通过映射的方式关联到极限存储表；用户只访问全量存储表，极限存储对用户透明<br>对于部分变化频率频繁的宇段过滤，节约存储成本；如用户表中存在用户积分宇段</p></blockquote><h3 id="3-3-4-微型维度"><a href="#3-3-4-微型维度" class="headerlink" title="3.3.4 微型维度"></a>3.3.4 微型维度</h3><p><strong>微型维度</strong>：将一部分不稳定的属性从主维度中移出，放置到拥有自己代理键的新表中实现；属性相互之间没有直接关联，不存在自然键；通过为每个组合创建新行的一次性过程来加载数据</p><blockquote><p>微型维度的局限性；微型维度是事先用所有可能值的组合加载，需要考虑每个属性的基数，且必须是枚举值<br>ETL 逻辑复杂；对于分布式系统，生成代理键和使用代理键进行ETL 加工都非常复杂， ETL 开发和维护成本过高<br>破坏维度的可浏览性；买家维度和微型维度通过事实表建立联系，无法基于 VIP 等级、信用等级进行浏览和统计；可以通过在买家维度中添加引用微型维度的外键部分来解决，但会带来微型维度未维护历史信息的新问题</p></blockquote><h2 id="3-5-特殊维度"><a href="#3-5-特殊维度" class="headerlink" title="3.5 特殊维度"></a>3.5 特殊维度</h2><h3 id="3-5-1-递归层次"><a href="#3-5-1-递归层次" class="headerlink" title="3.5.1 递归层次"></a>3.5.1 递归层次</h3><p><strong>递归层次</strong>：指的是某维度的实例值的层次关系；按照层级是否固定分为均衡层次结构和非均衡层次结构；均衡层次结构如类目：叶子类目、五级类 目、四级类目、三级类目、二级类目、一级类曰；地区：乡镇／街道、区县、城市、省份、国家；非均衡层次结构如公司：可能存在一个母公司</p><blockquote><p><strong>层次结构扁平化</strong>：通过建立每个维度层级属性字段实现，可以在一定程度上解决上钻和下钻问题，适用于均衡层次结构，对于非平衡层次结构，可以通过预留级别的方式来解决</p><blockquote><p>针对某类目上钻或下钻之前，必须知道其所属的类目层级，然后才能决定限制哪一级类目<br>由于某些叶子类目直接是一级类目或二级类目，造成查询问题；解决此类目对应的三级类目为空 ，则取二=级类目：如果二级类目仍为空，则取一级类目</p></blockquote><p><strong>层次桥接表</strong>：不需要预先知道所属层级，不需要回填，也可解决非均衡层次结构问题；法适合解决更宽泛的分析问题，灵活性好；但复杂性高，使用成本高</p><blockquote><p>桥接表包括父级类目ID、子级类目ID和类目层级间隔三个字段，枚举出所有关联类目之间的关系</p></blockquote></blockquote><h3 id="3-5-2-行为维度"><a href="#3-5-2-行为维度" class="headerlink" title="3.5.2 行为维度"></a>3.5.2 行为维度</h3><p><strong>行为维度</strong>：与事实相关的维度，如交易、物流等</p><blockquote><p>另一个维度的过去行为；如买家最近一次访问淘宝的时间、 买家最近一次发生淘宝交易的时间等<br>快照事实行为维度；如买家从年初截至当前的淘宝交易金额、买家信用分值 、卖家信用分值等<br>分组事实行为维度，将数值型事实转换为枚举值；如买家从年初截至当前的淘宝交易金额按照金额划分的等级 买家信用分值按照分数划分得到的信用等级等<br>复杂逻辑事实行为维度，通过复杂算法加工或多个事实综合加工得到；如卖家主营类目，商品热度根据访问、收藏、加人购物车、交易等情况综合计算得到</p></blockquote><ul><li><strong>处理方式</strong></li></ul><blockquote><p>将其冗余至现有的维表中；如将卖家信用等级冗余至卖家维表中<br>加工成单独的行为维表；如卖家主营类目</p></blockquote><ul><li><strong>处理原则</strong></li></ul><blockquote><p>避免维度过快增长<br>避免稠合度过高</p></blockquote><h3 id="3-5-3-多值维度"><a href="#3-5-3-多值维度" class="headerlink" title="3.5.3 多值维度"></a>3.5.3 多值维度</h3><p><strong>多值维度</strong>：事实表的一条记录在某维表中有多条子记录与之对应；如淘宝交易订单，买家一次购买了多种商品</p><ul><li><strong>处理方式</strong></li></ul><blockquote><p>降低事实表的粒度：将交易订单设计为子订单粒度，对于每个子订单，只有 种商品与之对应；前台业务和商业智能关注交易子订单<br>采用多字段：通过预留宇段的方式存储每一个子项数据，适用于子项不多，如房地产销售中，合同存在多个买受方（夫妻合买）<br>采用较为通用的桥接表：在事实表和维表之间开发一个分组桥接表，通过桥接表建立连接，桥接表包含和事实表关联的分组 KEY和维表外键；桥接表方式更加灵活、扩展性更好，但逻辑复杂、开发和维护成本较高，可能带来双重计算的风险</p></blockquote><h3 id="3-5-4-多值属性"><a href="#3-5-4-多值属性" class="headerlink" title="3.5.4 多值属性"></a>3.5.4 多值属性</h3><p><strong>多值属性</strong>：维表中的某个属性字段同时有多个值，是多值维度的另一种表现形式</p><ul><li><strong>处理方式</strong></li></ul><blockquote><p>保持维度主键不变，将多值属性放在维度的一个属性字段中<br>保持维度主键不变，将多值属性放在维度的多个属性字段中<br>维度主键发生变化，一个维度值存放多条记录</p></blockquote><h3 id="3-5-5-杂项维度"><a href="#3-5-5-杂项维度" class="headerlink" title="3.5.5 杂项维度"></a>3.5.5 杂项维度</h3><p><strong>杂项维度</strong>：是由操作型系统中的指示符或者标志宇段组合而成的，一般不在一致性维度之列；如淘宝交易订单的交易类型包括话费充值、司法拍卖、航旅等；支付状态、物流状态等在源系统中直接保存在交易表中；</p><ul><li><strong>存在问题</strong>：如果作为事实存放在事实表中，会导致事实表占用空间过大；如果单独建立维表，外键关联到事实表，会出现维度过多的情况；如果将这些字段删除，则会结构不统一；ETL 过程比一般维度略微复杂</li><li><strong>处理方式</strong>：建立杂项维度 ，将字段建立到一个维表中，在事实表中只保存一个外键；多个字段的不同取值组成一条记录，生成代理键，存人维表中，并将该代理键保存到相应的事实表字段下；建议不要直接使用所有的组合生成完整的杂项维表，在抽取遇到新的组合时生成相应的记录即可；对于非枚举字段如交易留言、交易属性（由若干k-v 对组成）、交易标签（由二进制位表示），使用实体的主键作为杂项维度的主键</li></ul><h1 id="4-事实表设计"><a href="#4-事实表设计" class="headerlink" title="4. 事实表设计"></a>4. 事实表设计</h1><h2 id="4-1-事实表基础"><a href="#4-1-事实表基础" class="headerlink" title="4.1 事实表基础"></a>4.1 事实表基础</h2><p><strong>事实表</strong>：是数据仓库维度建模的核心，围绕业务过程进行设计，通过获取描述业务过程的度量来表达业务过程，包括引用的维度和与业务过程有关的度量；作为度量业务过程的事实，一般为整型或浮点型的十进制数值，分为可加性、半可加性和不可加性三种；常事实表要细长，行的增加速度也比维表快</p><blockquote><p>可加性事实是指可以按照与事实表关联的任意维度进行汇总<br>半可加性事实只能按照特定维度汇总，不能对所有维度汇总，如库存可以按照地点和商品进行汇总，对时间进行汇总则无意义<br>不可加性事实对所有维度都不能汇总，如比率型事实，不可加性事实可分解为可加的组件实现聚集</p></blockquote><h2 id="4-2-事实表设计原则"><a href="#4-2-事实表设计原则" class="headerlink" title="4.2 事实表设计原则"></a>4.2 事实表设计原则</h2><blockquote><p>尽可能包含所有与业务过程相关的事实，允许存在一定冗余<br>只选择与业务过程相关的事实，如订单的下单业务中，不应该存在支付金额<br>分解不可加性事实为可加的组件，如订单优惠率，应该分解为订单原价金额与订单优惠金额两个事实<br>在选择维度和事实之前必须先声明粒度，粒度用于确定事实表中一行所表示业务的细节层次，决定了维度模型的扩展性；且每个维度和事实必须与所定义的粒度保持一致<br>在同一个事实表中不能有多种不同粒度的事实，事实表中的所有事实需要与表定义的粒度保持一致<br>事实的单位要保持一致<br>对事实的 null 值要处理，建议用零值填充；数据库中常用的数字型字段的 SQL 过滤条件对 null 不生效<br>使用退化维度提高事实表的易用性，采用退化维度的方式，在事实表中存储各种类型的常用维度信息；通过增加冗余存储的方式减少计算开销，提高使用效率</p></blockquote><h2 id="4-3-事实表设计方法"><a href="#4-3-事实表设计方法" class="headerlink" title="4.3 事实表设计方法"></a>4.3 事实表设计方法</h2><ol><li><strong>选择业务过程及确定事实表类型</strong>：选择与需求有关的业务过程，根据具体的业务需求来选择与维度建模有关的业务过程</li><li><strong>声明粒度</strong>：决定事实表度量的细节层次，确保所有的事实按照同样的细节层次记录，应该尽量选择最细级别的原子粒度，以确保事实表的应用具有最大的灵活性</li><li><strong>确定维度</strong>：选择能够描述清楚业务过程所处的环境的维度信息，如淘宝订单付款事务事实表中，粒度为子订单，相关的维度有买家、卖家、商品、收货人信息 业务类型、订单时间等</li><li><strong>确定事实</strong>：选择与业务过程有关的所有事实，且事实的粒度要与所声明的事实表的粒度一致，如淘宝订单付款事务事实表中，同粒度的事实有子订单分摊的支付金额、邮费、优惠金额等</li><li><strong>冗余维度</strong>：通常事实表中会冗余方便下游用户使用的常用维度，以实现对事实表的过滤查询、控制聚合层次、排序数据以及定义主从关系等操作</li></ol><h2 id="4-4-事务事实表"><a href="#4-4-事务事实表" class="headerlink" title="4.4 事务事实表"></a>4.4 事务事实表</h2><p><strong>淘宝交易订单过程</strong>：重点介绍将多种商品加入到购物车中一起结算：对于每种商品都会产生一个订单 ，同时对于同一个店铺会额外产生一个父订单，父订单会承载订单物流、店铺优惠等信息；对于每一种商品产生的订单就称为子订单，子订单记录了父订单的订单号，并且有子订单标志；如果在同一个店铺只购买了一种商品，则会将父子订单进行合并 ，只保留一条订单记录</p><h3 id="4-4-1-设计过程"><a href="#4-4-1-设计过程" class="headerlink" title="4.4.1 设计过程"></a>4.4.1 设计过程</h3><ol><li><strong>选择业务过程</strong>：淘宝交易订单的流转过程包括四个重要过程：创建订单、买家付款、 卖家发货、买家确认收货，即下单、支付、发货和成功完结四个业务过程</li><li><strong>确定粒度</strong>：下单、支付和成功完结三个业务过程选择交易子订单粒度，即每个子订单为事务事实表的一行；每个子订单所表达的细节信息为： 交易时间、卖家、买家、商品；对于卖家发货确定为物流单粒度</li><li><strong>确定维度</strong>：按照经常用于统计分析的场景，确定维度包含：买家、卖家、商品、商品类目、发货地区、收货地区、父订单维度以及杂项维度；如订单的业务类型、是否无线交易、订单的 attributes 属性等使用较多却又无法归属维度的属性新建一个杂项维度进行存放</li><li><strong>确定事实</strong>：在下单业务过程中，包含下单金额、下单数量、下单分摊金额；在支付业务过程中，包含支付金额、分摊邮费、折扣金额、红包金额、积分金额；在完结业务过程中包含确认收货金额等；对于父订单的父订单邮费、父订单折扣需要分摊到子订单中</li><li><strong>冗余维度</strong>：将买卖家星级、标签、店铺名称、商品类型、商品特征、商品属性、类目层级等维度属性都冗余到事实表中；提高对事实表进行过滤查询、统计聚合的效率</li></ol><h3 id="4-4-2-单事务事实表"><a href="#4-4-2-单事务事实表" class="headerlink" title="4.4.2 单事务事实表"></a>4.4.2 单事务事实表</h3><p><strong>单事务事实表</strong>：针对每个业务过程设计一个事实表，可以方便地对每个业务过程进行独立的分析研究<br><strong>1688 交易</strong>：主要流程也是下单、支付、发货和完结，选择下单和支付两个业务过程设计事务事实表；对于1688 交易订单下单事务事实表，确定子订单粒度，选择买家、卖家、商品、父订单、收货地区维度，事实包含下单分摊金额和折扣金额；对于 1688 交易订单支付事务事实表 ，粒度和维度与交易订单下单事务事实表相同，所表达的事实则不一样 ，包含支付金额、支付调整金额和支付优惠等；当天数据进入当天的事实表中</p><h3 id="4-4-3-多事务事实表"><a href="#4-4-3-多事务事实表" class="headerlink" title="4.4.3 多事务事实表"></a>4.4.3 多事务事实表</h3><p><strong>多事务事实表</strong>：将不同的事实放到同 个事实表中，即同一个事实表包含不 同的业务过程</p><ul><li><strong>事实处理方式</strong></li></ul><blockquote><p>不同业务过程的事实使用不同的事实字段进行存放<br>不同业务过程的事实使用同一个事实字段进行存放，增加一个业务过程标签</p></blockquote><h4 id="4-4-3-1-实践"><a href="#4-4-3-1-实践" class="headerlink" title="4.4.3.1 实践"></a>4.4.3.1 实践</h4><p><strong>淘宝交易事务事实表</strong>：包含下单、支付和成功完结三个业务过程；拥有相同的子订单粒度，适合放到同一个事实表中；发货的粒度比子订单更细，需要单独一张事实表；常用维度一致，包括买家、卖家、商品、类目、店铺、收发货地区等，事实表中需要包含下单度量、支付度量和成功完结度量信息，针对每一个度量采用一个字段存储数据，其他数据使用零值填充；对业务过程添加标签字段进行标识<br><strong>淘宝收藏商品事务事实表</strong>：收藏业务包含收藏商品和删除商品两个业务过程，确定业务为用户加上商品粒度，使用“收藏事件类型”个字段区分存放是收藏商品还是删除商品，收藏事务事实表是无事实的事实表，一般用于统计收藏或者删除的次数<br><strong>多事务事实表的选择</strong>：</p><blockquote><p>当不同业务过程的度量比较相似、差异不大时，可采用类似<strong>淘宝收藏商品事务事实表</strong>的设计方式，使用同 个字段来表示 数据；在同一个周期内可能会存在多条记录<br>当不同业务过程的度量差异较大时，可采用类似<strong>淘宝交易事务事实表</strong>的设计方式，将不同业务过程的度量使用不同字段段冗余到表中，非当前业务过程则置零表示；度量字段零值较多</p></blockquote><h3 id="4-4-4-两种事实表对比"><a href="#4-4-4-两种事实表对比" class="headerlink" title="4.4.4 两种事实表对比"></a>4.4.4 两种事实表对比</h3><table><thead><tr><th></th><th><strong>单事务事实表</strong></th><th><strong>多事务事实表</strong></th></tr></thead><tbody><tr><td><strong>业务过程</strong></td><td>一个</td><td>多个</td></tr><tr><td><strong>粒度</strong></td><td>相互之间不相关</td><td>相同粒度</td></tr><tr><td><strong>维度</strong></td><td>相互之间不相关</td><td>一致</td></tr><tr><td><strong>事实</strong></td><td>只取当前业务过程中的事实</td><td>保留多个业务过程的事实，非当前业务置零</td></tr><tr><td><strong>冗余维度</strong></td><td>多个业务过程，需要冗余多次</td><td>不同业务过程只需要冗余一次</td></tr><tr><td><strong>理解程度</strong></td><td>易于理解，不会混淆</td><td>难以理解，需要通过标签限定</td></tr><tr><td><strong>计算存储成本</strong></td><td>较高，每个业务过程都需要计算存储一次</td><td>较低，多个业务过程融合到一起降低了存储计算量，非当前业务存在大量零值</td></tr></tbody></table><h3 id="4-4-4-1-父子事实的处理方式"><a href="#4-4-4-1-父子事实的处理方式" class="headerlink" title="4.4.4.1 父子事实的处理方式"></a>4.4.4.1 父子事实的处理方式</h3><pre class="line-numbers language-none"><code class="language-none">子订单下单全额 ＝ 下单商品数量 × 商品价格子订单分摊的有效下单全额 ＝ 下单商品数量 × 商品价格 ＋ 父订单邮费 × 下单分摊比例 - 子订单折扣 - 父订单折扣 × 下单分摊比例下单分摊比例 ＝（下单商品数量 × 原价 - 子订单折扣）&#x2F; sum（下单商品数量 × 原价 - 子订单折扣）子订单分摊的支付金额 ＝ 父订单支付金额 × 支付分摊比例支付分摊比例 ＝ （下单商品数量 × 原价 - 子订单折扣 ＋ 调价）&#x2F; sum（下单商品数量 × 原价 - 子订单折扣 ＋ 调价）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-4-4-5-事实的设计准则"><a href="#4-4-4-5-事实的设计准则" class="headerlink" title="4.4.4.5 事实的设计准则"></a>4.4.4.5 事实的设计准则</h3><ol><li><strong>事实完整性</strong>：事实表包含与其描述的过程有关的所有事实，尽可能多地获取所有的度量</li><li><strong>事实一致性</strong>：确定事务事实表的事实时，明确存储每一个事实以确保度量的一致性</li><li><strong>事实可加性</strong>：将非可加性度量拆分转换为可加性度量</li></ol><h2 id="4-5-周期快照事实表"><a href="#4-5-周期快照事实表" class="headerlink" title="4.5 周期快照事实表"></a>4.5 周期快照事实表</h2><p><strong>周期快照事实表</strong>：简称“快照事实表”，在确定的间隔内对实体的度量进行抽样，表示当前状态度量，如账户余额、买卖家星级、商品库存、卖家累积交易额等</p><h3 id="4-5-1-特性"><a href="#4-5-1-特性" class="headerlink" title="4.5.1 特性"></a>4.5.1 特性</h3><ol><li><strong>用快照采样状态</strong>：以预定的间隔采样状态度量，间隔联合一个或多个维度，被用来定义快照事实表的粒度</li><li><strong>快照粒度</strong>：采样周期和采样内容组合成事实表粒度</li><li><strong>密度与稀疏性</strong>：事务事实表是稀疏的，只记录当天业务过程发生的事实；快照事实表是稠密的，无论当天是否有业务过程发生，都会记录一行</li><li><strong>半可加性</strong>：快照事实表收集到的状态度量都是半可加的，不能根据时间维度获得有意义的汇总结果</li></ol><h3 id="4-5-2-实践"><a href="#4-5-2-实践" class="headerlink" title="4.5.2 实践"></a>4.5.2 实践</h3><p><strong>单维度的每天快照事实表—淘宝卖家历史至今汇总事实表</strong>：</p><ol><li><strong>确定粒度</strong>：采样周期为每天，针对卖家、买家、商品、类目 、地区等维度建设快照事实表</li><li><strong>确定状态度量</strong>：针对粒度确定需要采样的状态度量，包含历史截至当日的下单金额、历史截止当日的支付金额等</li></ol><p><strong>混合维度的每天快照事实表—淘宝买卖家历史至今快照事实</strong>：</p><ol><li><strong>确定粒度</strong>：采样周期是每天，维度是卖家加买家</li><li><strong>确定状态度量</strong>：不同买家对于不同卖家的下单支付金额</li></ol><p><strong>全量快照事实表—淘宝好中差评快照事实表</strong></p><ol><li><strong>确定粒度</strong>：淘宝好中差评每天都在变化，下游统计分析也是每天都在进行；确定采样周期是每天；采样维度针对评价本身，每一条好中差评价就是快照事实表的最细粒度</li><li><strong>确定状态度量</strong>：对于好中差评价的度量关注更多的是评价本身，设计为无事实的事实表，更多关注评价的状态；冗余子订单维度、商品维度、评论者维度、被评论维度以及杂项维度 ，包括评论内容、是否匿名等信息</li></ol><h3 id="4-5-3-产出模式"><a href="#4-5-3-产出模式" class="headerlink" title="4.5.3 产出模式"></a>4.5.3 产出模式</h3><blockquote><p>从事务事实表进行汇总产出，如淘宝卖家历史至今汇总事实表、淘宝买卖家历史至今快照事实<br>直接使用操作型系统的数据作为周期快照事实表的数据源进行加工，如淘宝卖家星级、卖家 DSR （物流服务、描述相符和服务态度）事实表</p></blockquote><h3 id="4-5-4-注意事项"><a href="#4-5-4-注意事项" class="headerlink" title="4.5.4 注意事项"></a>4.5.4 注意事项</h3><ol><li><strong>事务与快照成对设计</strong>：事务事实表和快照事实表往往都是成对设计的 ，互相补充，以满足更 的下游统计分析需求，在事务事实表的基础上加工得到快照事实表</li><li><strong>附加事实</strong>：附加上一个采样周期的状态度量</li><li><strong>周期到日期度量</strong>：关注自然年至今、季度至今、财年至今的状态度量，如淘宝卖家财年至今的下单金额、淘宝商品自然年至今的收藏次数等</li></ol><h2 id="4-6-累积快照事实表"><a href="#4-6-累积快照事实表" class="headerlink" title="4.6 累积快照事实表"></a>4.6 累积快照事实表</h2><p><strong>累积快照事实表</strong>：研究事件之间时间间隔的需求，如统计买家下单到支付的时长、买家支付到卖家发货的 时长、买家从下单到确认收货的时长等</p><h3 id="4-6-1-设计过程"><a href="#4-6-1-设计过程" class="headerlink" title="4.6.1 设计过程"></a>4.6.1 设计过程</h3><ol><li><strong>选择业务过程</strong>：针对淘宝交易累积快照事实表，选择买家下单、买家支付、卖家发货、买家确认收货业务四个业务过程</li><li><strong>确定粒度</strong>：选择子订单粒度，累积快照事实表考察实体的唯一实例，子订只有一行记录，业务事件发生时，更新实例</li><li><strong>确定维度</strong>：维度主要有买家、卖家、店铺、商品、类目、发货地区、收货地区等，四个业务过程的时间字段，对应于日期维表；新建杂项维度存放订单类型、子类型、支付状态、物流状态、 attributes、options 等</li><li><strong>确定事实</strong>：将每个过程的时间间隔作为事实放在事实表中</li><li><strong>退化维度</strong>：提高下游用户的使用效率，降低数据获取的复杂性，减少关联的表数量</li></ol><h3 id="4-6-2-特点"><a href="#4-6-2-特点" class="headerlink" title="4.6.2 特点"></a>4.6.2 特点</h3><ol><li><strong>数据不断更新</strong>：累积快照事实表则对实体的某一实例定期更新业务发生时间</li><li><strong>多业务过程日期</strong>：累积快照事实表记录每一个实例从诞生到消亡等一系列过程的发生时间</li></ol><h3 id="4-6-3-特殊处理"><a href="#4-6-3-特殊处理" class="headerlink" title="4.6.3 特殊处理"></a>4.6.3 特殊处理</h3><ul><li><strong>非线性过程</strong>：并不是所有的交易都会按照正常交易流程（下单→支付→发货→确认收货）进行</li></ul><blockquote><p>下单→关闭订单：下单之后不支付，自己关闭订单或者经过一段时间后系统自动关闭订单<br>下单→支付→关闭订单：下单并支付之后，申请退款</p><blockquote><p>买家申请退款→卖家同意退款→退款达成<br>买家申请退款→卖家不同意退款→退款关闭<br>买家申请退款→卖家不同意退款→买家申请退款→卖家不同意退款→直到退款关闭</p></blockquote></blockquote><p><strong>处理情况</strong></p><blockquote><p>业务过程的统一：由交易完成作为结束标志变为交易完成和交易关闭作为结束标志<br>针对业务关键里程碑构建全面流程：将相关累积快照事实表的相关业务过程的时间字段和事实置空<br>循环流程的处理：基于商业用户进行里程碑日期的选择</p></blockquote><ul><li><strong>多源过程</strong>：业务过程可能来自于不同的系统或者来源于不同的表</li><li><strong>业务过程取舍</strong>：根据商业用户需求，选取关键业务的里程碑</li></ul><h3 id="4-6-4-物理实现"><a href="#4-6-4-物理实现" class="headerlink" title="4.6.4 物理实现"></a>4.6.4 物理实现</h3><ol><li><strong>全量表</strong>：一般为日期分区表，每天的分区存储昨天的全量数据和当天的增量数据合并的结果，保证每条记录的状态最新；适用于全量数据较少的情况</li><li><strong>全量表变形</strong>：每天的分区存储业务实体最大生命周期间隔的数据和当天的增量数据；如每天分区只存储最近100天的数据；用于存储事实表数据量较大的情况，数据量较大导致存储消耗较大</li><li><strong>以业务实体的结束时间分区</strong>：每天的分区存放当天结束的数据，设计一个时间非常大的分区，如 3000-12-31 ，存放截至当前未结束的数据，可能存在业务系统无法标识业务实体的结束时间</li></ol><blockquote><p>使用相 关业务系统的业务实体的结束标志作为此业务系统的结束标志；如针对物流订单，可以使用交易订单（理论上交易订单完结，则物流订单完结）<br>和前端业务系统确定口径或使用前端归档策略</p></blockquote><h2 id="4-7-三种事实表的比较"><a href="#4-7-三种事实表的比较" class="headerlink" title="4.7 三种事实表的比较"></a>4.7 三种事实表的比较</h2><table><thead><tr><th></th><th><strong>事务事实表</strong></th><th><strong>周期快照事实表</strong></th><th><strong>累积快照事实表</strong></th></tr></thead><tbody><tr><td><strong>时期/时间</strong></td><td>离散事务时间点</td><td>以有规律的、可预测的间隔产生快照</td><td>用于时间跨度不确定的不断变化的工作流</td></tr><tr><td><strong>日期维度</strong></td><td>事务日期</td><td>快照日期</td><td>相关业务过程涉及的多个日期</td></tr><tr><td><strong>粒度</strong></td><td>每行代表实体一个事务</td><td>每行代表某时间周期的一个实体</td><td>每行代表一个实体的生命周期</td></tr><tr><td><strong>事实</strong></td><td>事务事实</td><td>累积事实</td><td>相关业务过程事实和时间间隔事务</td></tr><tr><td><strong>事实表加载</strong></td><td>插入</td><td>插入</td><td>捅入与更新</td></tr><tr><td><strong>事实表更新</strong></td><td>不更新</td><td>不更新</td><td>业务过程变更时更新</td></tr></tbody></table><p>事务事实表记录的事务层面的事实，用于跟踪业务过程的行为,支持几种描述行为的事实，保存的是最原子的数据，也称为“原子事实表”<br>周期快照事实表以具有规律性的、可预见的时间间隔来记录事实，如余额、库存、层级、温度等，时间间隔为每天、每月、每年等，如库存日快照表等<br>累积快照事实表被用来跟踪实体的一系列业务过程的进展情况，通常具有多 个日期字段，用于研究业务过程中的里程碑过程的时间间隔</p><h2 id="4-8-无事实的事实表"><a href="#4-8-无事实的事实表" class="headerlink" title="4.8 无事实的事实表"></a>4.8 无事实的事实表</h2><p><strong>无事实的事实表</strong>：不包含事实或度量的事实表，用来支持业务过程的度量</p><blockquote><p>事件类的，记录事件的发生；如用户的浏览日志：某会员某时间点浏览了淘宝首页、某卖家的店铺中的某商品详情页等<br>条件、范围或资格类的，记录维度与维度多对多之 间的关系；如客户和销售人员的分配情况、产品的促销范围等</p></blockquote><h2 id="4-9-聚集型事实表"><a href="#4-9-聚集型事实表" class="headerlink" title="4.9 聚集型事实表"></a>4.9 聚集型事实表</h2><p><strong>聚集型事实表</strong>：聚集是指针对原始明细粒度的数据进行汇总；阿里巴巴将使用频繁的公用数据，通过聚集进行沉淀，形成公共汇总层”</p><ul><li><strong>聚集的基本原则</strong></li></ul><blockquote><p><strong>一致性</strong>：聚集表必须提供与查询明细粒度数据 致的查询结果<br><strong>避免单一表设计</strong>：不要在同一个表中存储不同层次的聚集数据，可以通过显式加人数据层级列以示区别<br><strong>聚集粒度可不同</strong>：聚集并不需要保持与原始明细粒度数据一样的粒度，只聚集关心查询的维度</p></blockquote><h3 id="4-9-1-聚集的基本步骤"><a href="#4-9-1-聚集的基本步骤" class="headerlink" title="4.9.1 聚集的基本步骤"></a>4.9.1 聚集的基本步骤</h3><ol><li><strong>确定聚集维度</strong>：根据用户关心的维度聚集数据</li><li><strong>确定一致性上钻</strong>：根据用户需求确定上钻维度，如按月汇总或按天汇总，按商品汇总或按类目汇总</li><li><strong>确定聚集事实</strong>：根据用户需求明确聚集的事实数据，如按照交易额汇总还是按照成交数量汇总</li></ol><h3 id="4-9-2-阿里公共汇总层"><a href="#4-9-2-阿里公共汇总层" class="headerlink" title="4.9.2 阿里公共汇总层"></a>4.9.2 阿里公共汇总层</h3><ul><li><strong>聚集基本原则</strong>：应遵守聚集的基本原则，还有个性化的原则</li></ul><blockquote><p><strong>数据公用性</strong>：聚集经常用于数据分析中或有第三者使用的基于某个维度<br><strong>不跨数据域</strong><br><strong>区分统计周期</strong>：在表的命名上要能说明数据的统计周期</p></blockquote><ul><li><strong>交易汇总表设计</strong>：淘宝交易事务事实表</li></ul><ol><li>按商品粒度汇总</li></ol><blockquote><p>确定聚集维度—卖家<br>确定一致性上钻一按卖家最近 天和最近 30 天汇总<br>确定聚集事实一交易额</p></blockquote><ol start="2"><li>按卖家、买家、商品粒度汇总</li></ol><blockquote><p>确定聚集维度一卖家、买家、商品<br>确定一致性上钻一按卖家、买家、商品）最近1天汇总<br>确定聚集事实一交易额</p></blockquote><ol start="3"><li>按二级类目汇总</li></ol><blockquote><p>确定聚集维度一类目<br>确定一致性上钻一按最近1天类目维度的二级维度属性汇总<br>确定聚集事实一交易额</p></blockquote><h3 id="4-9-3-聚集补充说明"><a href="#4-9-3-聚集补充说明" class="headerlink" title="4.9.3 聚集补充说明"></a>4.9.3 聚集补充说明</h3><ol><li><strong>聚集是不跨越事实的</strong>：聚集是针对原始星形模型进行的汇总，聚集的维度和度量与原始模型保持一致，获取和查询与原始模型一致的结果</li><li><strong>聚集带来的问题</strong>：聚集会带来查询性能的提升，也会增加 ETL 的维护难度</li></ol>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据实践-01阿里-数据技术</title>
      <link href="/202109/0125760.html"/>
      <url>/202109/0125760.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录大数据实践-01阿里-数据技术的相关内容</p><span id="more"></span><h1 id="1-数据采集"><a href="#1-数据采集" class="headerlink" title="1. 数据采集"></a>1. 数据采集</h1><h2 id="1-1-日志数据采集"><a href="#1-1-日志数据采集" class="headerlink" title="1.1 日志数据采集"></a>1.1 日志数据采集</h2><h3 id="1-1-1-浏览器页画日志"><a href="#1-1-1-浏览器页画日志" class="headerlink" title="1.1.1 浏览器页画日志"></a>1.1.1 浏览器页画日志</h3><p>Web端日志采集技术方案：Aplus.JS</p><blockquote><p>页面浏览日志：页面被浏览器加载呈现时的日志，统计指标包括：页面浏览量（ Page View, PV）和访客数（ Unique Visitors, UV ）<br>页面交互日志：用户在页面上直性各种操作的日志</p></blockquote><h4 id="1-1-1-1-页面浏览日志采集"><a href="#1-1-1-1-页面浏览日志采集" class="headerlink" title="1.1.1.1 页面浏览日志采集"></a>1.1.1.1 页面浏览日志采集</h4><p><strong>网页访问过程</strong>：浏览器请求、服务器响应并返回所请求内容（ HTML 文档的形式），整个过程遵守HTTP 协议（超文本传输协议）<br><strong>采集原理</strong>：在返回的 HTML文档 内增加一个日志采集节点，当浏览器解析到这个节点时，将自动触发特定的HTTP请求 到日志采集服务器，根据日志采集服务器接是否收到请求判断浏览器是否成功地接收和打开了页面<br><strong>采集过程</strong></p><blockquote><p>客户端日志采集：由一小段被植入 HTML文档 内的 JavaScript脚本 自动执行，采集当前页面参数、浏览行为的上下文信息（如用户访问当前页面的上一步页面等）以及运行环境信息（如当前的浏览器和分辨率等），日志采集脚本的可以由业务服务器在响应业务请求时动态执行，也可以在开发页面时由开发人员手动植入<br>客户端日志发送：采集脚本执行时，会向日志服务器发起请求，将采集到的数据发送到日志服务器，采集完成后执行发送<br>服务器端日志采集：日志服务器接收到客户端发来的日志请求，回复浏览器客户端请求成功的响应，将日志请求的内容写入日志缓冲区，完成收集<br>服务器端日志解析存档：浏览日志进入缓冲区后，通过日志处理程序顺序读出并按照约定的日志处理逻辑解析</p></blockquote><h4 id="1-1-1-2-页面交互日志采集"><a href="#1-1-1-2-页面交互日志采集" class="headerlink" title="1.1.1.2 页面交互日志采集"></a>1.1.1.2 页面交互日志采集</h4><p><strong>采集难点</strong>：终端类型、页面内容、交互方式和用户实际行为不可预估，无法规定统一的采集内容<br><strong>采集过程</strong></p><blockquote><p>业务方在“黄金令箭”的元数据管理界面依次注册需要菜机交互的业务、具体的业务场景以及场景下的具体交互采集点，系统生成对应的交互日志采集代码模板<br>业务方将交互日志采集模板植入目标页面，并将采集代码与需要监测的交互行为绑定<br>当用户在页面上产生指定动作时，采集代码和正常的业务互动响应代码一起被处罚和执行<br>采集代码在采集动作完成后将对应的日志通过 HTTP协议 发送到日志服务器，日志服务器进行简单转储，不做解析处理</p></blockquote><h4 id="1-1-1-3-页画日志数据预处理"><a href="#1-1-1-3-页画日志数据预处理" class="headerlink" title="1.1.1.3 页画日志数据预处理"></a>1.1.1.3 页画日志数据预处理</h4><blockquote><p>识别流量攻击、网络爬虫和流量作弊（虚假流量），避免统计发生偏差或明显谬误，根据过滤规则集进行滤除<br>数据缺项补正，保证基本的数据统计口径一致，如取值归一、标准化处理或反向补正（根据新日志对稍早收集的日志数据项进行回补或修订）<br>无效数据剔除，消除因业务变更或配置不当采集到的无意义、失效或冗余的数据，节约存储空间和运算能力<br>日志隔离分发，隔离处理需要进入公共数据环境的日志数据</p></blockquote><h3 id="1-1-2-无线客户端页画日志"><a href="#1-1-2-无线客户端页画日志" class="headerlink" title="1.1.2 无线客户端页画日志"></a>1.1.2 无线客户端页画日志</h3><p>APP端日志采集技术方案：采集SDK（UserTrack），根据不同的用户行为分成无线客户端日志行为的最小单位—事件，分为页面事件（页面浏览）和控件点击事件（页面交互）</p><h4 id="1-1-2-1-页面事件日志采集"><a href="#1-1-2-1-页面事件日志采集" class="headerlink" title="1.1.2.1 页面事件日志采集"></a>1.1.2.1 页面事件日志采集</h4><p><strong>采集内容</strong></p><blockquote><p>设备及用户基础信息<br>被访问的页面信息：如商品详情页的商品ID、所属店铺等<br>访问基本路径：如页面来源、来源的来源等</p></blockquote><p><strong>采集方式</strong></p><blockquote><p>无痕埋点：无需开发者进行任何编码即可实现，UserTrack（UT）提供页面展现接口、页面退出接口和页面扩展信息接口；进入页面时调用页面展现接口，记录页面进入的一些状态；页面扩展信息接口记录页面信息；离开页面时触发页面退出接口，发送日志；页面展现和页面退出必须成对使用，记录页面停留时间<br>透传参数：将当前页面的某些信息传递到下游页面中，利用SPM（Super Position Model，超级位置模型）追踪来源去向</p></blockquote><h4 id="1-1-2-2-控件点击事件日志采集"><a href="#1-1-2-2-控件点击事件日志采集" class="headerlink" title="1.1.2.2 控件点击事件日志采集"></a>1.1.2.2 控件点击事件日志采集</h4><p><strong>采集内容</strong></p><blockquote><p>设备及用户基础信息<br>被访问的页面信息：如控件所在页面名称、控件名称、控件业务参数等</p></blockquote><h3 id="1-2-3-Hybrid-APP"><a href="#1-2-3-Hybrid-APP" class="headerlink" title="1.2.3 Hybrid APP"></a>1.2.3 Hybrid APP</h3><p><strong>H5页面</strong>：基于浏览器进行日志采集<br><strong>Native</strong>：采集SDK进行日志采集</p><h4 id="1-2-3-1-H5和Native日志统一"><a href="#1-2-3-1-H5和Native日志统一" class="headerlink" title="1.2.3.1 H5和Native日志统一"></a>1.2.3.1 H5和Native日志统一</h4><p><strong>采集方式</strong>：将 HS 日志归到 Native 日志</p><blockquote><p>采集SDK可以得到更多与设备相关的数据<br>采集SDK会先在本地缓存，之后借机上传，保证数据不丢失</p></blockquote><p><strong>采集流程</strong></p><blockquote><p>通过页面开发时手动植入日志采集的 JavaScript脚本，采集页面浏览的页面交互数据，包括上下文信息和运行环境信息<br>JavaScript脚本 将采集到的数据包装到一个对象中，调用 WebView框架的 JSBridge接口，调用移动客户端对应的接口方法，将埋点数据对象当作参数传人<br>移动客户端日志采集 SDK ，封装提供接口将传入的内容转换成移动客户端日志格式，根据日志类别来识别事件类型，调用内部相应的接口进行处理，将埋点数据转换成移动客户端日志的统一格式；先将数据记录到本地日志缓存中，择机上传；通过日志类别的识别来做不同的日志格式转换</p></blockquote><h3 id="1-2-4-案例场景"><a href="#1-2-4-案例场景" class="headerlink" title="1.2.4 案例场景"></a>1.2.4 案例场景</h3><ul><li><strong>日志分流与定制处理</strong>：日志规模高速增长，短时间流量热点爆发，考虑业务分流、日志优先级控制、业务定制处理，尽可能靠前的布置路由差异、进行分流，降低日志处理过程中的分值判断消耗，支持后续的计算资源调配，提高资源利用效率</li><li><strong>采集与计算一体化设计</strong>：基于 URL规则集 进行日志归类汇总的维护和使用成本快速增长，通过 SPM规范 和 SPM元数据中心 进行注册和简单部署，可将任意页面流量进行聚类，得到流量、转化漏斗、引导交易数据和页面元素点击数据等</li></ul><h1 id="2-数据同步传输"><a href="#2-数据同步传输" class="headerlink" title="2. 数据同步传输"></a>2. 数据同步传输</h1><h2 id="2-1-常见数据同步方式"><a href="#2-1-常见数据同步方式" class="headerlink" title="2.1 常见数据同步方式"></a>2.1 常见数据同步方式</h2><p><strong>直连同步</strong>：通过定义好的规范接口和基于动态链接库的方式直接连接业务库，如 JDBC、ODBC等，支持完全相同的函数调用和 SQL 实现<br><strong>数据文件同步</strong>：通过约定好的文件编码、大小、格式等，直接从源系统生成的文本文件由专门的文件服务器（FTP服务器）传输到目标系统，加载到目标数据库系统中，可通过校验文件避免上传下载过程中的丢包或错误<br><strong>数据库日志解析同步</strong>：通过解析日志文件获取发生变更的数据，满足数据同步的要求，性能好、效率高</p><blockquote><p>数据延迟：业务系统做批量补录可能会使数据更新量超出系统处理峰值，导致数据延迟<br>投入较大：需要在源数据库与目标数据库之间部署一个实时抽取系统<br>数据漂移和遗漏：一张表的同一个业务日期包含前后凌晨的数据或丢失当天的变更数据</p></blockquote><h2 id="2-2-阿里数据仓库同步方式"><a href="#2-2-阿里数据仓库同步方式" class="headerlink" title="2.2 阿里数据仓库同步方式"></a>2.2 阿里数据仓库同步方式</h2><ul><li><strong>批量数据同步</strong>：离线型数据需要将不同的数据源批量同步到数据仓库，DataX通过插件形式提供服务，将数据从数据源读出并转换为中间状态，然后将中间状态的数据转换为目标数据系统数据格式</li></ul><blockquote><p>DataX 采用 Framework + Plugin 的开放式框架实现，Framework 处理缓冲、流程控制、并发、上下文加载，提供简单的接口与插件接入；插件需实现对数据处理系统的访问，编写方便；数据传输在单进程（单机模式）／多进程（分布式模式）下完成，传输过程全内存操作，不读写磁盘，也没有进程间通信，实现了在异构数据库或文件系统之间的高速数据交换</p></blockquote><pre class="line-numbers language-none"><code class="language-none">Job：数据同步作业Splitter：作业切分模块，将大任务切分成并行的小任务Sub-Job：切分后的小任务，也称TaskReader：数据读入模块，运行切分后的小任务，将数据装载到 DataXChannel： Reader Writer 通过 Channel 交换数据Writer ：数据写出模块，负责将数据从 DataX 导入目标数据系统<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>实时数据同步</strong>：建立日志数据交换中心，通过服务器读取日志数据，或者解析数据库系统的 binlog 或归档日志，将增量数据以数据流的方式同步到日志交换中心，通知订阅数据仓库自动获取，通过 TimeTunnel（TT，实时数据传输平台）实现，是一种基于生产者、消费者和 Topic 消息标识的消息中间件，将消息数据持久化到 HBase 的高可用、分布式数据交互系统</li></ul><blockquote><p>生产者：消息数据的产生端，向 TimeTunnel 集群发送消息数据<br>消费者：消息数据的接收端，从 TimeTunnel 集群中获取数据进行业务处理<br>Topic ：消息类型的标识，生产 Client 和消费 Client 需要知道对应的Topic 字<br>Broker 模块：负责责处理客户端收发消息数据的请求，然后往 HBase 取发数据</p></blockquote><p><strong>TimeTunnel</strong>：TT，实时数据传输平台，高性能、高可靠性的数据传输协议</p><blockquote><p>既包括数据库的增量数据传输，也包括日志数据的传输<br>既支持实时流式计算，也支持各种时间窗口的批量计算<br>通过数据同步工具（ DataX和同步中心，同步中心基于 DataX 易用性封装）直连异构数据库来抽取各种时间窗口的数据</p></blockquote><h2 id="2-3-数据同步问题与解决万案"><a href="#2-3-数据同步问题与解决万案" class="headerlink" title="2.3 数据同步问题与解决万案"></a>2.3 数据同步问题与解决万案</h2><ul><li><strong>分库分表的处理</strong>：分布式数据库访问引擎 TDDL ( Taobao Distributed Data ayer ）通过建立中间状态的逻辑表来整合统一分库分表的访问</li></ul><blockquote><p>TDDL 是位于持久层框架之下、 JDBC 驱动之上的中间件，与 JDBC 规范保持一致，有效解决了分库分表的规则引擎问题，实现了 SQL解析、规则计算、表名替换、选择执行单元并合并结果集的功能，同时解决了数据库表的读写分离、高性能主备切换的问题，实现了数据库配置信息的统一管理</p></blockquote><ul><li><strong>高效同步和批量同步</strong>：通过 OneClick 产品，实现数据的一键化和批量化同步，一键完成 DDL、DML 生成；通过库名和表名进行唯一定位，通过 IDB 接口获取元数据信息自动生成配置信息，实现不同数据源的数据同步配置透明化</li><li><strong>增量全量同步合并</strong>：推荐全外连接（full outer join）和全量覆盖（insert overwrite）代替传统 merge方式（insert + insert），当天增量和前一天全量进行全外连接，重新加载最新的全量数据，通过保留一段时间内每天的全量数据解决数据更新错误问题；物理删除数据时，数据仓库内永久存储最新全量数据的快照</li><li><strong>数据同步性能处理</strong>：通过目标数据库的元数据估算同步任务的线程数，通过数据同步任务的业务优先级决定同步线程的优先级，提升同步任务的执行效率和稳定性</li></ul><blockquote><ol><li>用户创建并提交同步任务</li><li>根据系统提前获知及设定的数据，估算该同步任务的数据量、平均同步速度、首轮期望线程、总线程数</li><li>根据同步的总线程数将数据拆分成相等数量的数据块，一个线程处理一个数据块，并将该任务所有线程提交至同步控制器</li><li>同步控制器采用多级多线程的数据同步模式，准备该任务第一轮县城的调度，优先发送等待时间最长、优先级最高且同一任务的线程</li><li>同步控制器准备一定数据量的虚拟线程，采用单机多线程的数据同步模式，准备该任务相应实体线程和虚拟线程调度，优先发送等待时间最长、优先级最高且单机 CPU 剩余资源可以支持首轮所有线程数且同一任务的线程，若没有满足条件的机器，则选择 CPU 剩余资源最多的及其进行首轮发送</li><li>数据任务开始同步</li><li>数据任务同步结束</li></ol></blockquote><ul><li><strong>数据漂移问题处理</strong></li></ul><blockquote><p><strong>问题</strong></p><blockquote><p>数据库表中用来标识数据记录更新时间的时间戳字段（modified_time）：会因为不更新 modified_time 而导致数据遗漏，或者凌晨时间产生的数据记录漂移到后一天<br>数据库日志中用来标识数据记录更新时间的时间戳字段（log_time）：由于网络或者系统压力问题， log_time 会晚于proc_time ，从而导致凌晨时间产生的数据记录漂移到后一天<br>数据库表中用来记录具体业务过程发生时间的时间戳字段（proc_time）：仅根据 proc_time 限制，只能获取包含一个业务过程所产生的记录，会遗漏其他过程的变化记录<br>标识数据记录被抽取到时间的时间戳字段（extract_time）</p></blockquote><p><strong>解决</strong></p><blockquote><p>多获取后一天的数据：保障数据只多不少<br>通过多个时间戳字段限制时间：</p><blockquote><p>首先根据 log_time 冗余前一天最后 15分钟和后一天凌晨开始 15 分钟的数据，并用 modified_timee 过滤非当天数据<br>然后根据 log_time 获取后一天凌晨开始 15 分钟的数据，按照主键根据 log_time 做升序排列去重<br>最后将前两步的结果数据做全外连接，通过限制业务时间proc_time 来获取所需要的数据</p></blockquote></blockquote></blockquote><h1 id="3-数据计算"><a href="#3-数据计算" class="headerlink" title="3. 数据计算"></a>3. 数据计算</h1><p>阿里离线数据仓库的存储和计算都在阿里云大数据计算服务 MaxCompute 上完成</p><h2 id="3-1-离线数据开发"><a href="#3-1-离线数据开发" class="headerlink" title="3.1 离线数据开发"></a>3.1 离线数据开发</h2><h3 id="3-1-1-离线计算平台-MaxCompute"><a href="#3-1-1-离线计算平台-MaxCompute" class="headerlink" title="3.1.1 离线计算平台 MaxCompute"></a>3.1.1 离线计算平台 MaxCompute</h3><p><strong>MaxCompute</strong>：采用抽象的作业处理框架 ，将不同场景的各种计算任务统一在同一个平台之上，共享安全、存储 、数据管理和资源调度，为来自不同用户需求的各种数据处理任务提供统一的编程接口和界面；提供数据上传／下载通道、SQL、MapReduce 、机器学习算法、图编程模型和流式计算模型多种计算分析服务，提供完善的安全解决方案</p><ul><li><strong>MaxCompute体系架构</strong><br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0101_MaxCompute%E6%9E%B6%E6%9E%84.png" alt="0101_MaxCompute架构"></li></ul><blockquote><p><strong>客户端</strong></p><blockquote><p>Web：以 RESTful API 的方式提供离线数据处理服务<br>SDK ：通过 Java 实现对 RESTful API 的封装<br>CLT ：Command Line Tool，运行在 Windows/Linux 下的客户端工具，通过 CLT 提交命令完成 Project 管理、 DDL DML等操作<br>IDE ：上层可视化 ETL/BI 工具， 阿里内部名称是在云端（D2 ) ，用户可以基于在云端完成数据同步、任务调度、报表生成等常见操作</p></blockquote><p><strong>接入层</strong>：提供 HTTP 服务、 Cache 、负载均衡，实现用户认证和服务层面的访问控制<br><strong>逻辑层</strong>：又称作控制层，是 MaxCompute 的核心部分；实现用户空间和对象管理、命令解析与执行逻辑、数据对象的访问控制与授权等功能；有 Worker、Scheduler、Executor 三个角色</p><blockquote><p>Worker：处理所有的 RESTful 请求，包括用户空间（Project）管理操作、资源（Resource）管理操作、作业管理等，对于 SQL DML、MR 等需要启动 MapReduce 的作业，会生成 MaxCompute Instance （类似于 Hive 中的 Job），提交给 Scheduler 进一步处理<br>Scheduler：负责 MaxCompute Instance 的调度和拆解，并向计算层的计算集群询问资源占用情况以进行流控<br>Executor：负责 MaxCompute Instance 的执行，向计算层的计算集群提交真正的计算任务</p></blockquote><p><strong>存储计算层</strong>：飞天内核（ Apsara Core ），运行在和控制层相互独立的计算集群上 ，包括 Pangu（分布式文件系统）、Fuxi （资源调度系统）、Nuwa/ZK（ Jamespace 服务） 、Shennong （监控模块）等；MaxCompute 中的元数据存储在阿里云计算的另一个开放服务 OTS（Open Table Service ，开放结构化数据服务）中，元数据内容主要包括用户空间元数<br>据、Table/Partition Schema、ACL、 Job 元数据、安全体系等</p></blockquote><ul><li><strong>MaxCompute特点</strong></li></ul><blockquote><p>计算性能高且更加普惠<br>集群规模大且稳定性高<br>功能组件非常强大</p><blockquote><p>MaxCompute SQL ：标准 SQL 的语法，提供各类操作和函数来处理数据<br>MaxCompute MapReduce ：提供 Java MapReduce 编程模型，通过接口编写 MR 程序处理 MaxCompute 中的数据；提供基于MapReduce 的扩展模型 MR2 ，Map 函数后可以接入连续多个 Reduce 函数，执行效率比普通的 MapReduce 型高<br>MaxCompute Graph ：面向迭代的图计算处理框架，典型应用有PageRank 、单源最短距离算法、K-均值聚类算法<br>Spark ：使用 Spark 接口编程处理存储在 Max Compute 中的数据<br>RMaxCompute ：使用 R 处理 MaxCompute 中的数据<br>Volume：MaxCompute 以 Volume 形式支持文件，管理非二维表数据</p></blockquote><p>安全性高</p></blockquote><h3 id="3-1-2-统一开发平台"><a href="#3-1-2-统一开发平台" class="headerlink" title="3.1.2 统一开发平台"></a>3.1.2 统一开发平台</h3><ul><li><strong>在云端（D2）</strong>：集成了任务开发、调试及发布，生产任务调度及大数据运维，数据权限申请及管理功能的一站式数据开发平台，支持数据分析</li></ul><blockquote><ol><li>使用 IDE 创建计算节点，如 SQL/MR 任务、Shell任务、数据同步任务等，编写节点代码、设置节点属性和输入输出关联节点间依赖</li><li>用户提交进入开发环境中，成为某个工作流的节点，通过人工或系统自动触发，下发到调度系统执行引擎 ALisa 中，完成资源分配和执行的整个过程</li><li>如在开发环境中运行无误后，发布到生产环境中使用</li></ol></blockquote><ul><li><strong>SQL-SCAN</strong>：将任务开发中遇到的各种问题，如质量差、性能低、不遵守规范中的SQL，总结后形成规则，通过系统及研发流程保障，事前解决故障隐患，避免事后处理</li></ul><blockquote><p><strong>执行过程</strong></p><blockquote><p>用户在 D2 中编写代码，将代码、调度信息传入 SQL-SCAN<br>SQL-SCAN 根据所配置的规则进行校验，将检查成功或者失败的信息传回 D2<br>D2 的 IDE 显示 OK （成功）、 WARNNING （警告）、 FAILE（失败，禁止用户提交）等消息</p></blockquote><p><strong>校验规则</strong></p><blockquote><p>代码规范类规则：如表命名规范、生命周期设置、表注释等<br>代码质量类规则：如调度参数使用检查、分母为0提醒、 NULL值参与计算提醒、插入字段顺序错误等<br>代码性能类规则：如分区裁剪失效、扫描大表提醒、重复计算检测等<br>SQL-SCAN 规则有强规则和弱规则两类；触发强规则，任务提交会被阻断，必须修复代码后才能再次提交；触发弱规则，只会显示违反规则的提示，用户可以继续提交任务</p></blockquote></blockquote><ul><li><strong>DQC</strong>：Data Quality Center ，数据质量中心，通过配置数据质量校验规则，自动在数据处理任务过程中进行数据质量监控；主要有数据监控和数据清洗两大功能，数据监控规则和SQL-SCAN 规则一样有强弱之分；数据清洗采用非侵人式的清洗策略，避免影响数据同步的效率，数据进入ODS 层之后执行数据清洗，在 DQC 置清洗规则，将符合清洗规则的数据清洗掉，并保存至DIRTY 表归档</li><li><strong>在彼岸</strong>：解决新增业务需求、数据迁移、重构和修改而开发的大数据系统的自动化测试平台，将通用的、重复性的操作沉淀在测试平台中，提高测试效率</li></ul><blockquote><p><strong>数据对比</strong>：支持不同集群、异构数据库的表做数据对比；表级对比规则主要包括数据量和全文对比；字段级对比规则主要包括字段的统计值（如 SUM、AVG、MAX、MIN 等）、枚举值、空值、去重数、长度值<br><strong>数据分布</strong>：提取表和字段的一些特征值 ，与预期值进行比对；表级数据特征提取主要包括数据量、主键等；字段级数据特征提取主要包括字段枚举值分布、空值分布、统计值（如 SUM、AVG、MAX、MIN 等）、去重数、长度值等<br><strong>数据脱敏</strong>：将敏感数据模糊化；在数据安全的大前提下，实现线上数据脱敏，在保证数据安全的同时又保持数据形态的分布，以便业务联调、数据调研和数据交换</p></blockquote><h2 id="3-2-实时数据开发"><a href="#3-2-实时数据开发" class="headerlink" title="3.2 实时数据开发"></a>3.2 实时数据开发</h2><h3 id="3-2-1-实时数据处理特征"><a href="#3-2-1-实时数据处理特征" class="headerlink" title="3.2.1 实时数据处理特征"></a>3.2.1 实时数据处理特征</h3><blockquote><p><strong>时效性高</strong>：数据实时采集、实时处理，延时粒度在秒级甚至毫秒级<br><strong>常驻任务</strong>：属于常驻进程任务， 一旦启动后就会一直运行，直到人为地终止；计算成本会相对比较高<br><strong>性能要求高</strong>：处理吞吐量要和采集吞吐量相匹配<br><strong>应用局限性</strong>：在数据具有上下文关系的情况下，数据到达时间的不确定性导致实时处理结果的不确定性；也无法支持双流关联或者需要数据回滚的情况</p></blockquote><h3 id="3-2-2-实时计算平台-Strea-Compute"><a href="#3-2-2-实时计算平台-Strea-Compute" class="headerlink" title="3.2.2 实时计算平台 Strea Compute"></a>3.2.2 实时计算平台 Strea Compute</h3><p><strong>实时计算平台</strong>：也称流式大数据平台</p><h4 id="3-2-2-1-流式技术架构"><a href="#3-2-2-1-流式技术架构" class="headerlink" title="3.2.2.1 流式技术架构"></a>3.2.2.1 流式技术架构</h4><ul><li><p><strong>数据采集</strong>：数据的源头，一般来自于各个业务的日志服务器（例如网站的浏览行为日志、订单的修改日志等）</p><blockquote><p><strong>数据库变更日志</strong>：如 MySQL 的 binlog 志、 HBase 的 hlog日志、 OceanBase 的变更日志、Oracle 的变更日志等<br><strong>引擎访问日志</strong>：如用户访问网站产生的 Apache 擎日志、搜索引擎的接口查询日志等</p></blockquote><p><strong>采集原则</strong>：数据库变更日志、引擎访问日志，都会在业务服务器上落地成文件，出于吞吐量以及系统压力上的考虑，基于数据大小限制和时间阈值限制原则，监控文件的内容发生变化，采集工具采集最新的数据下来</p><blockquote><p><strong>数据大小限制</strong>：当文件变化大小达到限制条件时，把目前采集到的新数据作为一批采集，如 512KB写一批<br><strong>时间阈值限制</strong>：当时间长度达到限制条件时，把目前采集到的新数据作为一批采集，如 30  秒写一批</p></blockquote><p><strong>数据分发</strong>：将采集到的数据通过数据交换平台（数据中间件系统）分发给下游如开源的系统 Kafka ，阿里巴巴集团的是 TimeTunnel （原理同 Kafka），还有 MetaQ、Notify 等消息系统</p></li><li><p><strong>数据处理</strong>：数据被采集到中间件中后，需要下游实时订阅数据，并拉取到流式计算系统的任务中进行加工处理，常见的流计算引擎有 Twitter 开源的 Storm 系统、雅虎开源的 S4 系统、 Apache park 的Streaming ，最近兴起的 Flink ，阿里巴巴的 StreamCompute<br><strong>典型问题</strong></p></li></ul><blockquote><p><strong>去重指标</strong></p><blockquote><p>精确去重：去重的明细数据必须要保存下来的，可以通过数据倾斜来进行处理，把一个节点的内存压力分到多个节点上<br>模糊去重：在去重的明细数据量非常大，而业务的精度要求不高的情况下，可以使用去重算法，把内存的使用量，提高内存的利用率</p><blockquote><p><strong>布隆过滤器</strong>：不保存真实的明细数据，只保存明细数据对应哈希值的标记位；会出现误差率可以控制的哈希值碰撞，计算出来的去重值比真实值小，存储1亿条数据只需要 100 多MB 空间；适用统计精度要求不高，统计维度值非常多的情况；如统计全网各个商家的 UV 数据，结果记录数达到上千万条，各个维度之间共用布隆过滤器<br><strong>基数估计</strong>：利用哈希的原理，按照数据的分散程度来估算现有数集的边界，从而得出大概的去重值总和，存储 亿条数据只需要几 KB内存；适用场景：统计精度要求不高，统计维度非常粗的情况，如整个大盘的 UV 数据，每天的结果只有一条记录；基数估计在各个维度值之间不能共用</p></blockquote></blockquote><p><strong>数据倾斜</strong>：单个节点的计算数据量超出处理能力，需要对数据进行分桶处理</p><blockquote><p>去重指标分桶：对去重值进行分桶 Hash ，相同的值被放在同一个桶去重，最后再把每个桶里面的值进行加和得到总值，利用了每个桶的 CPU 和内存资源<br>非去重指标分桶：数据随机分发到每个桶中，最后再把每个桶的值汇总，主要利用的是各个桶的 CPU 能力</p></blockquote><p><strong>事务处理</strong>：提供数据自动 ACK 、失败重发以及事务信息等机制，解决系统的不稳定性导致数据处理失败的情况；如网络的抖动导致数据发送不成功、机器重启导致数据丢失等</p><blockquote><p>超时时间：数据处理按批次进行，当一批数据处理超时，会从拓扑的 spout 端重发数据，批次处理的数据量不宜过大，可以通过限流的功能（限定一批数据的记录数或者容量），避免数据处理超时<br>事务信息：每批数据都会附带一个事务 ID 信息，重发时开发者自己根据事务信息判断数据第一次到达和重发时不同的处理逻辑<br>备份机制：开发人员需要保证内存数据可以通过外部存储恢复，按需将计算中用到的中间结果数据需要备份到外部存储中</p></blockquote></blockquote><ul><li><strong>数据存储</strong>：数据被实时加工处理（比如聚合、清洗等）后，会不断增量写入在线服务的存储系统中，供下游调用方使用；在实践中一般使用 HBase、 Tair、 MongoDB 等列式存储系统，先写内存再落磁盘</li></ul><blockquote><p>中间结果：保存状态数据（如去重指标的明细数据），用于发生故障时，使用数据库数据恢复内存现场<br>最终结果：指的是通过 ETL 处理后的实时结果数据，数据实时更新，高频写，可以被下游直接使用<br>维表数据：供实时任务来关联实时流数据</p></blockquote><ul><li><strong>数据服务</strong>：在存储系统上架设一层统一的数据服务层（比如提供 HSF 接口、HTTP 服务 ），用于获取实时计算结果，使用方就可以通过统一的数据服务获取到实时数据</li></ul><blockquote><p>不需要直连数据库，数据源等信息在数据服务层维护，存储迁移时，对下游透明<br>调用方只使用服务层暴露的接口，不需要关心底层取数逻辑实现<br>屏蔽存储系统间的差异，统一的调用日志输出，便于分析和监控下游使用情况</p></blockquote><h4 id="3-2-2-2-流式数据模型"><a href="#3-2-2-2-流式数据模型" class="headerlink" title="3.2.2.2 流式数据模型"></a>3.2.2.2 流式数据模型</h4><p><strong>数据模型</strong>：整体上分为五层（ ODS、 DWD、 DWS、 ADS、 DIM ），在每一层中，按照重要性划分为 P0、 P1、 P2、 P3 等级， P0 属于最高优先级保障；根据不同的优先级给实时任务分配不同的计算和存储资源</p><blockquote><p>ODS：属于操作数据层，直接从业务系统采集过来的最原始数据，包含所有业务的变更过程，数据粒度最细；和离线计算的数据源、统计指标口径基本统一，方便进行实时和离线间数据比对<br>DWD：是在 ODS 层基础上，根据业务过程建模出来的实时事实明细层<br>DWS：汇集订阅明细层的数据；计算各个垂直业务线通用的各个维度的汇总指标，形成大宽表<br>ADS：个性化维度汇总层，统计个性化的统计维度数据，计算只有自身业务才会关注的维度和指标，常用于垂直创新业务中<br>DIM：实时维表层的数据从离线维表层导出来，抽取到在线系统中供实时应用调用</p></blockquote><h4 id="3-2-2-3-案例—大促"><a href="#3-2-2-3-案例—大促" class="headerlink" title="3.2.2.3 案例—大促"></a>3.2.2.3 案例—大促</h4><p><strong>大促</strong>：大促是一场对数据计算的高吞吐量、低延时、高保障性、高准确性的挑战</p><ul><li><strong>特征</strong></li></ul><blockquote><p>毫秒级时延<br>洪峰明显：售时的峰值陡峰一般是日常峰值的几十倍<br>高保障性：要做多链路冗余（从采集、处理到数据服务整个数据链路都需要做物理隔离），透明切换到备链路<br>公关特性</p></blockquote><ul><li><strong>实时任务优化</strong></li></ul><blockquote><p>独占资源和共享资源的策略：避免抢不到 资源导致吞吐量急剧下降<br>合理选择缓存机制，尽量降低读写库次数：让最热和最可能使用的数据留在内存中，降低读写库次数<br>计算单元合并，降低拓扑层级：拓扑结构层级越深 性能越差<br>内存对象共享，避免字符拷贝：注意不合理使用带来的内存溢出问题<br>在高吞吐量和低延时间取平衡</p></blockquote><ul><li><strong>数据链路保障</strong>：数据同步→数据计算→数据存储→数据服务；需要对整条计算链路都进行多链路搭建，做到多机房容灾、异地容灾</li><li><strong>压力测试</strong></li></ul><blockquote><p>数据压测：主要是蓄洪压测<br>产品本身压测<br>前端页面稳定性测试</p></blockquote><h2 id="3-3-任务调度系统"><a href="#3-3-任务调度系统" class="headerlink" title="3.3 任务调度系统"></a>3.3 任务调度系统</h2><p><strong>任务调度系统</strong>：整个调度系统共有两个核心模块：调度引擎（ Phoenix Engine ）和<br>执行引擎 Alisa ）；调度引擎的作用是根据任务节点属性及依赖关系进行实例化， 生成各类参数的实值，并生成调度树；执行引擎的作用是根据调度引擎生成的具体任务实例和配置信息，分配 CPU、内存、运行节点等资源 在任务对应的执行环境中运行节点代码</p><ul><li><strong>调度引擎</strong>：基于任务状态机模型、工作流状态机模型原理，以事件驱动的方式运行，为数据任务节点生成实例，并在调度树中生成具体执行的工作流；任务节点实例在工作流状态机、任务状态机和事件处理器之间转换，其中调度引擎只涉及任务状态机的未运行和 待运行两种状态，其他5种状态存在于执行引擎中<br><strong>调度引擎工作原理</strong><br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0102_Schedule_%E8%B0%83%E5%BA%A6%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="0102_Schedule_调度引擎工作原理"></li></ul><blockquote><p>Async Dispatcher ：异步处理任务调度<br>Sync Dispatcher ：同步处理任务调度<br>Task 事件处理器：任务事件处理器，与任务状态机交互<br>DAG 事件处理器：工作流事件处理器，与工作流状态机交互，一个DAG 事件处理器包含若干个 Task 件处理器</p></blockquote><p><strong>任务状态机模型</strong><br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0103_Schedule_%E4%BB%BB%E5%8A%A1%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="0103_Schedule_任务状态机模型"><br><strong>工作流状态机模型</strong><br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0104_Schedule_%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%8A%B6%E6%80%81%E6%9C%BA%E6%A8%A1%E5%9E%8B.png" alt="0104_Schedule_工作流状态机模型"></p><ul><li><strong>执行引擎</strong><br><strong>执行引擎逻辑架构</strong><br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0105_Schedule_%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84.png" alt="0105_Schedule_执行引擎逻辑架构"></li></ul><blockquote><p><strong>任务管理接口</strong>：供用户系统向 Alisa 中提交、查询和操作离线任务，并获得异步通知<br><strong>系统管理接口</strong>：供系统管理员进行后台管理，包括为集群增加新机器、划分资源组、查看集群资源和负载、追踪任务状态<br><strong>Driver</strong>：Alisa 的调度器，实现了任务管理接口和系统管理接口；负责任务的调度策略、集群容灾和伸缩、任务失效备援、负载均衡实现；采用可插拔替换的任务调度策略，满足不同的使用场景；使用 Resource manager 管理整个集群的负载；类似于 Hadoop 的 Job Tracker<br><strong>Task pool</strong>：Driver 将提交的各状态全部任务放入 Task pool 管理，包括等待资源、数据质量检测、运行中、运行成功和失败的所有任务；当用户获取到任务运行完成（成功或失败）的状态通知， Driver 将任务从 Task pool 中移除；Driver 和 Node 通过 Task pool 提供的事件机制进行可靠的通信；整个系统全部状态（除与运行无关的部分管理信息外）都保存在 Task pool 中，实现系统其他部分的高可用性和伸缩性；Task pool 采用 Zookeeper实现，本身也具备高可用能力<br><strong>Resource manager</strong>：专注于集群整体资源的管理<br><strong>Task container</strong>：为 Task 提供运行的容器，类似于 Web Server（Web Server 为 Action 提供运行的容器）；负责处理Task 的公共逻辑，如文件下载，任务级 Session 、流程级 Session的维护等；同时 Task container 负责收集机器的实际负载并上报给 Resource manager<br><strong>Session manager</strong>：对 Task session 进行管理<br><strong>Node</strong>：代表 Alisa 集群中的一个节点；负责提供任务运行所需的物理资源；Node 是逻辑概念，一台物理机器上可部署一个或者多个 Node（类似于 Hadoop 的 TaskTracker）</p></blockquote><h3 id="3-3-1-任务调度系统功能"><a href="#3-3-1-任务调度系统功能" class="headerlink" title="3.3.1 任务调度系统功能"></a>3.3.1 任务调度系统功能</h3><ul><li><strong>调度配置</strong>：输入输出配置和自动识别相结合的方式；任务提交时，SQL 解析引擎自动识别此任务的输入表和输出表，输入输出表自动关联产出此表的任务；可以自动调整任务依赖，避免依赖配置错误</li><li><strong>定时调度</strong>：根据实际需要，设定任务的运行时间，共有5种时间类型：分钟、小时、日、周、月，具体可精确到秒</li><li><strong>周期调度</strong>：可按照小时、日等时间周期运行任务，如离线数据处理的大多数日任务</li><li><strong>手动运行</strong>：在开发环境（ IDE ）中写好脚本后发布到生产环境，再通过手动触发运行；常用于生产环境需要做一些数据修复或其他一次性的临时数据操作</li><li><strong>补数据</strong>：设定需要补的时间区间，并圈定需要运行的任务节点，生成一个补数据的工作流，支持并行的运行方式以节约时间；补齐历史数据</li><li><strong>基线管理</strong>：按优先级进行分层分类统一管理，充分利用计算资源，保证重点业务数据优先产出，合理安排各类优先级任务的运行</li><li><strong>监控报警</strong>：针对出错的节点、运行超时未完成的节点，以及可能超时的基线等，设置电话、短信、邮件等不同的告警方式，实现日常数据运维的自动化</li></ul><h1 id="4-数据服务"><a href="#4-数据服务" class="headerlink" title="4. 数据服务"></a>4. 数据服务</h1><h2 id="4-1-数据服务架构"><a href="#4-1-数据服务架构" class="headerlink" title="4.1 数据服务架构"></a>4.1 数据服务架构</h2><p><strong>数据服务架构</strong>：阿里数据服务架构演进过程为 DWSOA、 OpenAPI、 SmartDQ 和OneService 的四个阶段</p><ul><li><strong>DWSOA架构</strong>：将业务方对数据的需求通过 SOA 服务的方式发布；由需求驱动，一个需求开发一个或者几个接口，编写接口文档，开放给业务方调用<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0106_DataService_DWSOA%E6%9E%B6%E6%9E%84.png" alt="0106_DataService_DWSOA架构"></li></ul><blockquote><p>接口粒度比较粗，灵活性不高，扩展性差，复用率低<br>开发效率不高，无法快速响应业务</p></blockquote><ul><li><strong>OpenAPI</strong>：将数据按照统计粒度进行聚合，同样维度的数据，形成一张逻辑表，采用同样的接口描述；有效地收敛接口数量<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0107_DataService_OpenAPI%E6%9E%B6%E6%9E%84.png" alt="0107_DataService_OpenAPI架构"></li><li><strong>SmartDQ架构</strong>：在OpenAPI 的基础上抽象一层，用 DSL (Domain Specific Language ，领域专用语言）来描述取数需求；采用标准的 SQL 语法，做限制和特殊增强；封装标准 DataSource ，可以使用ORM (Object Relation Mapping ，对象关系映射）框架来解决对象关系映射问题，如Hibernate、 MyBatis；开放给业务方通过写 SQL 的方式对外提供服务；封装了跨异构数据源和分布式查询功能<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0108_DataService_SmartDQ%E6%9E%B6%E6%9E%84.png" alt="0108_DataService_SmartDQ架构"></li><li><strong>OneService架构</strong>：提供OneService-SmartDQ、OneService-Lego、 OneService-iPush、 OneService-uTiming等多种服务类型来满足用户需求<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0109_DataService_OneService%E6%9E%B6%E6%9E%84.png" alt="0109_DataService_OneService架构"></li></ul><blockquote><p>OneService-Lego：采用插件化方式开发服务， 一类需求开发一个插件，目前共生产5个插件；可以将插件做成微服务、用 Docker 做隔离避免插件之间相互影响<br>OneService-iPush：要提供 Web Socket 和 long polling 两种方式，主要用于商家端实时直播<br>OneService-uTiming：提供即时任务和定时任务两种模式，满足用户运行大数据量任务的需求</p></blockquote><h2 id="4-2-数据服务技术架构"><a href="#4-2-数据服务技术架构" class="headerlink" title="4.2 数据服务技术架构"></a>4.2 数据服务技术架构</h2><ul><li><strong>SmartDQ应用架构</strong><br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0110_DataService_OneService-SmartDQ%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="0110_DataService_OneService-SmartDQ应用架构"></li></ul><blockquote><p>查询数据库：SmartDQ 底层支持多种数据源，可以通过实时公共层的计算作业直接将计算结果写入 HBase ；或通过同步作业将公共层的离线数据同步到对应的查询库<br>服务层</p><blockquote><p><strong>元数据配置</strong>：数据发布者到元数据中心进行元数据配置，建立物理表与逻辑表的映射关系，服务层会将元数据加载到本地缓存中，以便进行后续的模型解析<br><strong>主处理模块</strong></p><blockquote><p>DSL 解析：对用户的查询 DSL 进行语法解析，构建完整的查询树<br>逻辑 Query 构建：遍历查询树，通过查找元数据模型，转变为逻辑 Query<br>物理 Query 构建：通过查找元数据模型中的逻辑表与物理表的映射关系，将逻辑 Query 转变为物理 Query<br>Query 拆分：如果该次查询涉及多张物理表，并且在该查询场景下允许拆分，则将 Query 拆分为多个 SubQuery<br>SQL 执行：将拆分后的 SubQuery 组装成 SQL 语句，交给对应DB 执行<br>结果合并：将 DB 执行的返回结果进行合井，返回给调用者</p></blockquote><p><strong>其他模块</strong>：专门用于性能及稳定性方面的优化</p></blockquote></blockquote><p>  <strong>OneService-SmartDQ元数据模型架构</strong>：逻辑表到物理表的映射<br>  <img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0111_DataService_OneService-SmartDQ%E5%85%83%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84.png" alt="0111_DataService_OneService-SmartDQ元数据模型架构"></p><blockquote><p>数据源：支持跨数据源查询，底层支持接人多种数据源，如MySQL、HBase、OpenSearch<br>物理表：是具体某个数据源中的一张表，每张物理表都需要指明主键列，明确统计粒度<br>逻辑表：可以理解为数据库中的视图、一张虚拟表；或由若干主键相同的物理表构成的大宽表<br>主题：逻辑表 般会挂载在某个主题下，以便进行管理与查找</p></blockquote><ul><li><p><strong>iPush应用架构</strong>：面向 TT、MetaQ 等不同消息源，通过定制滤规则，向 Web 、无线等终端推送消息的中间件平台；核心服务器端基于高性能异步事件驱动模型的网络通信框架 Netty4 实现，结合使用 Guava 缓存实现本地注册信息存储， Filter 和 Server 之间的通信采用 Thrift 异步调用高效服务实现，消息基于 Disruptor 高性能的异步处理框架（最快的消息框架）的消息队列，在服务器运行中Zookeeper 实时监控服务器状态，通过 Diamond 作为统一的控制触发中心<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0112_DataService_OneService-iPush%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="0112_DataService_OneService-iPush应用架构"></p></li><li><p><strong>Lego应用架构</strong>：面向中度和高度定制化数据查询需求、支持插件机制的服务容器；本身提供日志 、服务注册、 Diamond 配置监听、鉴权、数据源管理等一系列基础设施，数据服务由服务插件提供；采用轻量级的 Node.JS 技术核实现，适合处理高并发、低延迟的 IO 密集型场景 ，目前主要支撑用户识别发码、用户识别、用户画像、人群透视和人群圈选等在线服务；底层根据需求选用 Tair、HBase、ADS 存储数据<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0113_DataService_OneService-Lego%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="0113_DataService_OneService-Lego应用架构"></p></li><li><p><strong>uTiming应用架构</strong>：是基于在云端的任务调度应用，提供批量数据处理服务，支撑用户识别、用户画像、人群圈选三类服务的离线计算，以及用户识别、用户画像、人群透视的服务数据预处理、人库；uTiming-scheduler 负责调度执行 SQL 或特定配置的离线任务，用户使用数据超市工具或 Lego API 建立任务，保证任务调度接口透明<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0114_DataService_OneService-uTiming%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84.png" alt="0114_DataService_OneService-uTiming应用架构"></p></li></ul><h2 id="4-3-实践"><a href="#4-3-实践" class="headerlink" title="4.3 实践"></a>4.3 实践</h2><h3 id="4-3-1-性能"><a href="#4-3-1-性能" class="headerlink" title="4.3.1 性能"></a>4.3.1 性能</h3><ul><li><strong>资源分配</strong>：资源利用最大化</li></ul><blockquote><p>剥离计算资源：剥离复杂的计算统计逻辑，将其全部交由底层的数据公共层进行处理，只保留核心的业务处理逻辑<br>查询资源分配：分为Get 接口（只返回一条数据）和 List 接口（返回多条数据）；Get 查询基本都转换为 K-V查询，响应时间较短，查询代价较小，但队列等待时间长； List 查询的响应时间相对较长，且返回记录数比较多，增加了序列化以及网络传输的成本，查询代价会更高；设计两个独立的线程池： Get 线程池和 List 线程池，分别处理 Get 请求和 List 请求，提升系统的 QPS<br>执行计划优化</p><blockquote><p>查询拆分：对于复杂指标，可以将调用者的请求拆分成多个独立的查询，并发执行，引擎层会将多个查询的结果汇总返回给调用者<br>查询优化：分析用户请求中的 SQL 语句，将符合条件的 List 查询转换为 Get 查询</p><blockquote><p>解析 SQL 语句中的 WHERE 子句，提取出筛选字段以及筛选条件<br>假如筛选字段中包含该逻辑表的所有主键，且筛选条件都为equal ，说明主键都已经确定为固定值，返回记录数肯定为1条，可以将 List 查询就转换为 Get 查询</p></blockquote></blockquote></blockquote><ul><li><strong>缓存优化</strong></li></ul><blockquote><p>元数据缓存：查询引擎需要频繁地调用元数据信息，在服务启动时将全量数据加载到本地缓存；后台对数据生产者的发布信息进行监听，一旦更新，就增量加载</p><blockquote><p>查询解析：需要从元数据中得出逻辑表与物理表的映射关系，从而将逻辑 Query 解析为物理 Query<br>SQL 安全检查：需要根据元数据中的逻辑表配置信息来检查调用者的调用参数是否合法；比如 LIMIT 是否超过上限、必传字段是否遗漏等<br>字段权限检查：需要通过权限元数据来判断调用者是否有权限进行本次访问</p></blockquote><p>模型缓存：是将 DSL 解析后的模型（包括逻辑模型、物理模型）缓存在本地，遇到相似的 SQL 时，直接从缓存中得到解析结果，省略生成 逻辑Query、物理Query、Query拆分的过程，直接执行SQL</p><blockquote><p>对 DSL 进行语法、词法分析，并替换 WHERE 中的常量<br>以替换后的语句做 key ，去本地缓存中进行查找；如果命中，则提取出缓存中的模型，直接将 SQL 提交给 DB 查询；如果没有命中， 则进行正常的解析处理，并缓存解析后的结果</p></blockquote><p>结果缓存</p><blockquote><p>某些查询可能比较复杂，直接查询 DB 响应时间较长的结果<br>如获取某件物品所属类目的统计指标， 一个类目下有超大量物品，这些物品请求的结果完全一致，都是同一类目</p></blockquote></blockquote><ul><li><strong>查询能力</strong></li></ul><blockquote><p>合并查询：将离线数据和实时数据合并查询，优先取离线数据，没有再去取实时数据；实现离线数据替换实时数据，不需要考虑离线数据未产出等问题<br>推送服务：监听数据提供者，新数据产生时及时推送给用户；代替轮询请求</p><blockquote><p>对消息生产者进行监听：如监听消息源 TT，进行消息过滤<br>考虑将符合条件的消息放置在采用无锁的队列 Disruptor中<br>采用基于高性能异步事件的网络通信框架 Netty 实现消息基于 Socket 的推送<br>采用多线程解决IO 集型系统的性能问题，采用协程方式减少采用多线程带来的上下文切换问题<br>适当地控制线程数以及流量，为重要的业务消息节约服务器资源<br>对注册的在线用户信息做本地缓存，可以极大地提高读性能</p></blockquote></blockquote><h3 id="4-3-2-稳定性"><a href="#4-3-2-稳定性" class="headerlink" title="4.3.2 稳定性"></a>4.3.2 稳定性</h3><ul><li><strong>发布系统</strong></li></ul><blockquote><p>元数据隔离：设计三套元数据 ：日常元数据、预发元数据和线上元数据；日常环境用于线下开发测试；预发环境隔离外部用户访问，用于在正式发布前校验即将上线的代码，会定期将预发元数据同步到日常环境</p><blockquote><p>用户在元数据管理平台上进行操作，修改元数据；改变预发元数据，未落地缓存<br>用户点击预发，在预发环境中就可以看到用户的最新修改了，以验证用户的修改是否会影响线上已有的功能<br>验证通过，用户点击式发布，预发元数据会将变更同步到线上元数据，并加载到引擎的本地缓存中，可以在线上环境中看到用户变更</p></blockquote><p>隔离发布：不同用户的发布不会相互影响</p><blockquote><p>资源划分：根据需求确定隔离的最小单元；如，将隔离的粒度控制在逻辑表层面上<br>资源独占：用户开始修改时，系统会锁定其正在修改的逻辑表及其下挂的物理表等资源，禁止其他用户修改；正式发布变更后，释放锁定的资源<br>增量更新：增量更新用户修改的逻辑表信息</p></blockquote></blockquote><ul><li><strong>隔离</strong>：将系统划分为若干个独立模块，当某个模块出现问题时不影响整体功能的使用</li></ul><blockquote><p>机房隔离：将服务器部署在两个机房中，每个机房独立部署一个集群，且机器数量尽量保持均衡，实现双机房容灾<br>分组隔离：根据业务条件将调用者进行分层 ，然后将服务端的机器划分为若干个分组，每个分组都有明确的服务对象和保障等级；可以动态地调整分组规则；当某个分组出现性能较差的查询，或者有突发大流量涌入，不会影响其他分组的正常使用</p></blockquote><ul><li><strong>安全限制</strong></li></ul><blockquote><p>最大返回记录数：数据库的查询强制带上 LIMIT 限制，具体数值以用户配置为准<br>必传字段：每张逻辑表都会配置主键，并标识调用者必须传入的字段，防止全表扫描<br>超时时间：设置合适的超时时间，以使得超时的查询能及时终止并释放资源，保障系统不会被偶发的超时拖垮</p></blockquote><ul><li><strong>监控</strong></li></ul><blockquote><p>调用日志采集：保证调用日志的完整性</p><blockquote><p>基础信息：包括调用时间、接口名、 方法名、返回记录数等<br>调用者信息：包括调用者应用名、来源 IP 地址等<br>调用信息：包括调用指标、查询筛选条件等<br>性能指标：包括响应时间、是否走缓存等<br>错误信息：包括出错原因、错误类型、数据源、错误堆械等</p></blockquote><p>调用监控：监控系统的健康状况，及时发现问题</p><blockquote><p>性能趋势：总体 QPS 趋势图、 RT 趋势图、响应时长区间分布、分组性能统计、单机 QPS 统计，以对当前系统容量做评估<br>零调用统计：找出最近一段时间无调用的表，进行下线处理，节约成本<br>慢 SQL 查找：找出响应时间较长的 SQL ，及时进行优化<br>错误排查：当系统的调用错误数突增时，能从错误日志中及时发现出错原因、出错的数据源等</p></blockquote></blockquote><ul><li><strong>限流降级</strong></li></ul><blockquote><p>限流：采用应用内的 QPS 保护，对调用者、数据源等关键角色进行 QPS 阔值控制<br>降级</p><blockquote><p>通过限流措施，将 QPS 置为 0，使对应的所有访问全部立即失败，防止故障扩散<br>通过修改元数据，将存在问题的资源置为失效状态，重新加载元数据后，对应的访问就全部失败，不再消耗系统资源</p></blockquote></blockquote><p>云数据库 ApsaraDB for RDS （简称“ RDS ”）和表格存储（Table Store ）</p><h1 id="5-数据挖掘"><a href="#5-数据挖掘" class="headerlink" title="5. 数据挖掘"></a>5. 数据挖掘</h1><p><strong>数据挖掘</strong>：包含特征数据与结果数据两类数据</p><h2 id="5-1-阿里巴巴数据挖掘算法平台"><a href="#5-1-阿里巴巴数据挖掘算法平台" class="headerlink" title="5.1 阿里巴巴数据挖掘算法平台"></a>5.1 阿里巴巴数据挖掘算法平台</h2><p><strong>阿里巴巴数据挖掘算法平台</strong>：支持海量样本的高维特征训练，是基于阿里云 MaxCompute 的MPI 实现<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0115_MaxComputeMPI_%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="0115_MaxComputeMPI_处理流程"><br>伏羲为阿里云飞天系统的分布式调度系统，女娲为阿里云飞天系统的分布式一致性协同服务系统，盘古为阿里云飞天系统的分布式文件存储系统</p><h3 id="5-3-1-挖掘数据中台"><a href="#5-3-1-挖掘数据中台" class="headerlink" title="5.3.1 挖掘数据中台"></a>5.3.1 挖掘数据中台</h3><p><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0116_%E6%8C%96%E6%8E%98%E6%95%B0%E6%8D%AE%E4%B8%AD%E5%8F%B0.png" alt="0116_挖掘数据中台"></p><ul><li><strong>FDM 层</strong>：用于存储在模型训练前常用的特征指标，并进行统一的清洗和去噪处理，提升机器学习特征工程环节的效率</li><li><strong>IDM 层</strong>：个体挖掘指标中间层，面向个体挖掘场景，用于存储通用性强的结果数据，主要包含商品、卖家、买家、行业等维度的个体数据挖掘的相关指标</li><li><strong>RDM 层</strong>：关系挖掘指标中间层，面向关系挖掘场景，用于存储通用性强的结果数据，主要包含商品间的相似关系、竞争关系，店铺间的相似关系、竞争关系等</li><li><strong>ADM 层</strong>：用来沉淀比较个性偏应用的数据挖掘指标，用偏好的类目、品牌等，数据经过深度的加工处理，满足某一特点业务或产品的使用</li></ul><h3 id="5-3-2-挖掘算法中台"><a href="#5-3-2-挖掘算法中台" class="headerlink" title="5.3.2 挖掘算法中台"></a>5.3.2 挖掘算法中台</h3><p><strong>数据挖掘应用</strong>：可以分为个体挖掘应用与关系挖掘应用：个体挖掘应用指对单个实体的行为特征进行预测与分析，如预测某商品的销量、划分某行业的价格区间等； 关系挖掘应用指研究多个实体间的关系特征，如商品的相似关系、竞争关系等<br><strong>机器学习算法</strong></p><blockquote><p>分类算法：LogisticRegression、kNN、GBDT、DTC5.0、Randomforest、linearSVM、nonlinearSVM、NavieBayes、Bayes、Fisher 判别、马氏距离判别、标签传播分裂等<br>聚类算法：K-Means、Canopy、PSC 普聚类、标签传播聚类、 EM 聚类等<br>回归算法：LinearRegression、GBDT、LASSO、RidgeRegression、Factorization Machines、XGBoost等<br>推荐算法：etrec 协同过滤、 SVD 协同过滤、 ALS 协同过滤等<br>深度学习：Word2Vec、Doc2Vec、CNN、DBN、DeepMatchModel等<br>其他算法：PageRank、LOA、pLSA 、关联规则、 NMF、SVD、 RankSVM、PCA、kcore、sssp、Modularity计算等</p></blockquote><h3 id="5-3-3-数据挖掘案例"><a href="#5-3-3-数据挖掘案例" class="headerlink" title="5.3.3 数据挖掘案例"></a>5.3.3 数据挖掘案例</h3><ul><li><strong>用户画像</strong>：基于用户网购、搜索和娱乐影音等行为的数据洞察，利用数据分析辅以算法的视角对用户进行 360 全方位的特征刻画，为用户打上各种各样的标签，如年龄、性别、职业、商品牌偏好、商品类别偏好等</li></ul><blockquote><p>提取女装行业下的商品标题文本，对其进行分词，得到庞大的女装描绘词库<br>根据词语权重去除无效的停用词，如计算 TF-IDF 值<br>利用无监督机器学习，如 LDA ，计算一种风格所包含的词汇及重要性<br>针对每种行为赋予不同的行为强度（比如浏览行为强度弱于交易行为），再考虑该商品的风格元素组成，通过合理的方式获知买家对该风格的偏好程度</p></blockquote><ul><li><strong>互联网反作弊</strong><br><strong>反作弊内容</strong></li></ul><blockquote><p>账户／资金安全与网络欺诈防控<br>非人行为和账户识别<br>虚假订单与信用炒作识别<br>广告推广与 APP 安装反作弊<br>UGC 恶意信息检测</p></blockquote><p><strong>反作弊方法</strong></p><blockquote><p>基于业务规则的方法：根据实际的业务场景，不断地发现总结作弊和获利手法，通过反作弊规则的不断拓展或产品设计的完善来识别、缓解甚至消除作弊现象<br>基于有监督学习的方法：按照有监督分类算法的流程来建模，通过正负样本标记、特征提取、模型训练及预测等过程来识别作弊行为<br>基于无监督学习的方法：通过假设检验、统计分析、聚类分析等手段进行异常检测</p></blockquote><h1 id="6-数据应用"><a href="#6-数据应用" class="headerlink" title="6. 数据应用"></a>6. 数据应用</h1><h2 id="6-1-生意参谋"><a href="#6-1-生意参谋" class="headerlink" title="6.1 生意参谋"></a>6.1 生意参谋</h2><ul><li><strong>首页</strong>：专属用户的个性化首页，可定制，常用功能模块聚合入口</li><li><strong>实时直播</strong>：以店铺实时动态数据为切人点，提供实时数据的查询与分析；如数据作战室</li><li><strong>经营分析</strong>：结合大环境，对经营全链路的各个环节进行分析、诊断等；如装修分析</li><li><strong>市场行情</strong>：以行业分析、竞争情况为切入点，对市场动态进行分析</li><li><strong>自助取数</strong>：提供数据定制、查询、导出等离端数据服务、灵活可配置，周期可定制</li><li><strong>专题工具</strong>：着重专细分析和一站式优化工具，含竞争情报、流量纵横等</li><li><strong>数据学院</strong>：教学相长，可帮助商家快速提升数据化运营能力<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/Ali_Practice/0117_%E7%94%9F%E6%84%8F%E5%8F%82%E8%B0%8B%E6%9E%B6%E6%9E%84.png" alt="0117_生意参谋架构"><br><strong>看我情</strong>：优先关注自身店铺<br><strong>看行情</strong>：关注行业动态<br><strong>看敌情</strong>：在保障商家隐私和数据安全的前提下提供竞争分析</li></ul><h2 id="6-2-阿里数据产品平台"><a href="#6-2-阿里数据产品平台" class="headerlink" title="6.2 阿里数据产品平台"></a>6.2 阿里数据产品平台</h2><p><strong>数据产品</strong></p><blockquote><p>报表：如静态报表、 Dashboard 等简单统计分析<br>多维分析：如 OLAP 、即席查询分析等工具型数据产品<br>专题分析型数据产品：面向某一类业务场景，沉淀分析思路<br>智能型数据应用产品 ：如个性化搜索、推荐、广告定向推送、精准营销等</p></blockquote><p><strong>阿里数据产品</strong></p><ul><li><strong>数据监控</strong>：提供最基础的报表工具—孔明灯，供用户自助取数、多维分析、 DIY个性化数据门户</li><li><strong>专题分析</strong>：实时直播分析产品，根据实时数据调整资源及流量分配；行业一体化分析产品，从行业视角提供行业数据，沉淀行业分析思路；流量分析产品，从流量角度提供流量数据，包括对站点、页面、区块、位置的浏览，曝光、点击分布，以及获得资源位的活动技放等</li><li><strong>应用分析</strong>：能够通过条件筛选出目标数据，支持自助分析，条件满足需求对接前台应用系统，实现个性化、精准营销、选品选商、搭建专场的需求</li><li><strong>数据决策</strong>：需要宏观的业务数据和可下沉的数据，还需要丰富的趋势数据来辅助决策，了解业务进展、当前进展是否合理、业务方向等，为高管提供宏观决策分析支撑平台 ，分析历史数据规律，预测未来发展趋势，洞察全行业动态</li></ul>]]></content>
      
      
      <categories>
          
          <category> 实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据中台-基础</title>
      <link href="/202108/3157880.html"/>
      <url>/202108/3157880.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据中台使用 的相关基础内容</p><span id="more"></span><h1 id="1-数据中台"><a href="#1-数据中台" class="headerlink" title="1. 数据中台"></a>1. 数据中台</h1><p><strong>数据中台</strong>：通过 <strong>数据技术</strong> 对 <strong>企业内外部多源异构数据</strong> 进行采集、存储、计算、服务（包括建模、分析）等，<strong>统一数据标准和口径</strong>，形成 <strong>全域级、可复用</strong> 的 <strong>数据资产中心和数据存储中心</strong> ，包括所有数据资源、数据研发管理、数据资产管理的统一的数据资源池，是 <strong>数据 + 技术</strong> (向下连接后台、向上连接前端的先进的与时俱进的技术) <strong>+ 产品</strong>(经过抽象和设计形成的通用化、标准化、可扩展的服务) <strong>+ 组织</strong> 的组合，对内优化管理、赋能业务，对外开展数据合作，释放数据价值，核心理念是：<strong>数据取之于业务，用之于业务</strong></p><blockquote><p>效用意义：数据中台是实现数据资产化的工具，帮助企业实现数字化转型<br>技术角度：数据中台是新型的IT架构，底层是以Hadoop为代表的大数据计算、存储基础设施<br>管理角度：数据中台是新型的组织管理模式和理念</p></blockquote><h2 id="1-1-发展"><a href="#1-1-发展" class="headerlink" title="1.1 发展"></a>1.1 发展</h2><ul><li><p>数据库阶段：Oracle、MySQL等</p></li><li><p>传统数仓：明确数据分析应该采用独立的解决方案实现，不再依赖于业务数据库；<strong>自顶(数据来源)向下(数据应用)，分层建模</strong>，构建成本较高，适用于应用场景固定的业务(金融)，数据冗余较少 和 <strong>自底向上（数据分析需求出发，拆分维度和事实），维度建模</strong>，适用于变化较快的业务(互联网)</p></li><li><p>大数据平台：大数据平台解决方案：CDH、HDP</p></li><li><p>数据中台</p><blockquote><p>解决指标口径不一致问题：源于业务口径不一致、计算逻辑不一致、数据来源不一致等</p><p>实现数据复用：数据重复建设，需求响应时间长</p><p>解决取数效率低问题：构建企业全局的数据资源目录，方便快捷的定位想要的数据</p><p>解决数据质量差的问题：存储数据链路，进行数据稽核</p></blockquote></li></ul><h1 id="2-数据中台技术组件"><a href="#2-数据中台技术组件" class="headerlink" title="2. 数据中台技术组件"></a>2. 数据中台技术组件</h1><h2 id="2-1-数据采集"><a href="#2-1-数据采集" class="headerlink" title="2.1 数据采集"></a>2.1 数据采集</h2><p><strong>数据采集</strong>：又称为数据获取，利用一种装置从系统外部不同数据源经过收集、整理、清洗、转换后，加载到系统内部新数据源中</p><ul><li><strong>通用数据采集</strong>：包括结构化数据和非结构化数据</li></ul><blockquote><p>实现结构化数据从数据源头到目录数据平台的分布式 ETL 操作<br>结构化数据支持 HANA、SAP BW、HDFS、Hive、Kafka、Flume、Hbase等文件类数据源<br>非结构化数据支持 HDFS、Hive、Kafka、Flume、Hbase等文件类数据源<br>支持分布式 ETL 任务，任务处理能力可横向扩展<br>支持过滤、数学运算和字符运算等数据转换等</p></blockquote><ul><li><strong>流式数据采集</strong>：实现对流数据的抽取、转换和加载功能，支持对应用日志、系统日志及数据库日志文件的增量采集</li></ul><blockquote><p>提供高并发、高吞吐、低延迟、可容错、可持久化的实时消息系统，如 Kafka、RabbitMQ 等<br>支持可扩展的分布式流数据 ETL 操作<br>支持失败任务断点恢复<br>支持分级并发任务调度<br>提供任务管理、任务监控的 Web 管理界面<br>具备完善的用户及权限管理功能</p></blockquote><h3 id="2-1-1-技术路线"><a href="#2-1-1-技术路线" class="headerlink" title="2.1.1 技术路线"></a>2.1.1 技术路线</h3><ul><li><strong>ETL</strong>：将数据从源系统通过 ETL 按照一定的周期（每天、每小时等）传输到目标系统，根据业务场景进行数据治理，如质量监测、格式转换和数据规范化、数据替换，保证数据完整性等</li><li><strong>实时数据采集</strong>：通过实时数据采集工具，如 Flume、Kafka，进行流数据采集处理，如数据源的操作日志、网络监控的流量管理、金融应用的股票记账和 Web服务器的用户访问数据等</li><li><strong>互联网数据采集</strong>：通过 Scribe 等网络爬虫在合法范围内按照一定规则，自动抓取互联网信息的程序或脚本，支持图片、音频、视频等文件</li></ul><blockquote><p>Scribe： Facebook 开发的数据(日志)收集系统，又称为网页蜘蛛、网络机器人、网络爬虫</p></blockquote><ul><li><strong>数据采集接口</strong>：通过与软件技术服务商合作，使用特定系统接口采集企业内部数据</li></ul><blockquote><p>数据库视图：从指定数据库视图中提取数据<br>数据表：从指定数据表中提取数据<br>自定义SQL：用自定义SQL 从指定数据库提取数据<br>Web Service：从 Web Service 提供的方法中提取数据<br>文件：从 XML、Excel、Access、DBF文件中提取数据</p></blockquote><h2 id="2-2-数据存储"><a href="#2-2-数据存储" class="headerlink" title="2.2 数据存储"></a>2.2 数据存储</h2><p><strong>数据存储组件</strong>：HDFS、Kafka、Hbase、ElasticSearch</p><ul><li><strong>分布式数据存储</strong></li></ul><blockquote><p>具备可扩展的分布式数据存储功能<br>支持结构化、半结构化、非结构化数据的可扩展分布式存储<br>支持1:4的数据压缩比<br>支持高可用和故障自动切换部署<br>具备数据安全策略，避免数据丢失<br>支持 SQL 语法（ANSI SQL 2003）</p></blockquote><ul><li><strong>NoSQL 数据存储</strong></li></ul><blockquote><p>可扩展的分布式 Key-Value 数据库功能<br>支持对象存储<br>支持图数据库<br>支持高可用和故障自动切换部署<br>具备数据安全策略，避免数据丢失<br>具备 Web 图形化管理界面</p></blockquote><h2 id="2-3-数据计算"><a href="#2-3-数据计算" class="headerlink" title="2.3 数据计算"></a>2.3 数据计算</h2><p><strong>数据计算组件</strong>：MapReduce、Spark、Flink</p><h3 id="2-3-1-分布式查询"><a href="#2-3-1-分布式查询" class="headerlink" title="2.3.1 分布式查询"></a>2.3.1 分布式查询</h3><blockquote><p>支持联机分析处理 ROLAP<br>支持 SQL 语法，支持 UDF<br>具备良好的水平扩展性<br>支持高可用和故障自动切换部署<br>具备完善的用户及权限管理功能<br>具备 Web 图形化管理界面</p></blockquote><h3 id="2-3-2-分布式计算"><a href="#2-3-2-分布式计算" class="headerlink" title="2.3.2 分布式计算"></a>2.3.2 分布式计算</h3><blockquote><p>支持结构化、非结构化的分布式批处理功能<br>支持大规模水平扩展<br>支持高可用和故障自动切换部署<br>支持任务失败恢复能力<br>具有高效的分布式内存计算引擎，如 Spark、Flink 等<br>支持 Java、Pyhton等</p></blockquote><h3 id="2-3-3-数据建模"><a href="#2-3-3-数据建模" class="headerlink" title="2.3.3 数据建模"></a>2.3.3 数据建模</h3><blockquote><p>提供数据库建模工具、可自动生成物理实体<br>提供基于 Web 的集成开发环境，支持数据库开发、数据处理、数据集成等<br>支持数据中台模型开发，可定义维度、度量、ODS、Cube 的大数据模型<br>支持特征工程创建<br>支持主流统计分析算法及模型<br>提供基于 Web 的图形化模型设计、训练、评估</p></blockquote><h3 id="2-3-4-数据分析"><a href="#2-3-4-数据分析" class="headerlink" title="2.3.4 数据分析"></a>2.3.4 数据分析</h3><blockquote><p>支持对多维模型的钻取(Drill-down)、上卷(Roll-up)、切片(Slice)、切块(Dice)、旋转(Pivot)等操作<br>支持用户多维度展示分析</p><p>数据量小：MySQL、Hive数仓，Spark计算引擎的结果导出到MySQL</p><p>数据量大：Hbase、ElasticSearch，解决海量数据的低延时高效查询</p><p>多维分析：ClickHouse、Kylin、Greenplum，提供在线分析能力</p><p>高时效性：Redis，提供高性能单点查询能力</p></blockquote><h2 id="2-4-数据服务"><a href="#2-4-数据服务" class="headerlink" title="2.4 数据服务"></a>2.4 数据服务</h2><p><strong>数据服务</strong>：是指数据在存储、应用程序和组织之间的移动及整合相关的过程。制定合适的数据服务标准，针对不用的场景合理采用相应的数据服务技术，为企业新的管理模式和业务模式提供灵活可靠的数据支持</p><h3 id="2-4-1-数据服务技术"><a href="#2-4-1-数据服务技术" class="headerlink" title="2.4.1 数据服务技术"></a>2.4.1 数据服务技术</h3><ul><li><strong>文件共享</strong>：从一个系统中导出数据文件，再导入另一个系统，需要双方规定好数据格式，数据传递不及时，需要人工干预，数据可能出现异常</li><li><strong>数据库中间表</strong>：双方约定公用数据库，一方写入数据库，另一方读数据，跨系统可通过跨数据库实现</li><li><strong>点对点接口技术</strong>：Web Service ，部署 Web Service ，其他 Web Service 应用程序调用它部署的服务，典型协议有 SOAP（Simple Object Access Protocol，简单对象访问协议）、REST（Representational State Transfer，表述性状态转移)</li><li><strong>消息队列技术</strong>：将数据打包成消息，放入消息队列，等对需求方获取，消息队列是消息传输过程中保存消息的容器，当消息接收者不可用会保留信息，消息一定被送达且只送达一次，消息只能放在接收方的消息队列中，双方接口协议一致</li><li><strong>服务总线交换技术</strong>：基于消息队列产生，服务总线通过列已转换、路由分发控制接口泛滥，保证接口重用</li><li><strong>ETL技术</strong>：基于SQL数据库复制批量数据的技术，将数据从业务系统数据库转移到企业数据仓库</li></ul><h3 id="2-4-2-数据服务方式"><a href="#2-4-2-数据服务方式" class="headerlink" title="2.4.2 数据服务方式"></a>2.4.2 数据服务方式</h3><ul><li><strong>数据集</strong>：以表格形式出现的数据集合，数据库批量导出部分数据明细进行提供</li><li><strong>API 网关</strong>：提供 API网关的生成、登记发布、调用申请、审核等功能</li></ul><blockquote><p><strong>优点</strong></p><blockquote><p>简单易用：基于云平台，用户可以直接在管理控制平台中对 API网关服务进行图形化配置，无需搭建 API网关部署需要的设备<br>易于维护：提供对 API网关的可视化监控，以及资源管理、租户隔离、权限控制等一系列运维能力<br>高可靠性： API网关是分布式集群部署，及时应对网关节点故障，实现高可靠性<br>高性能：可承载大规模、大流量的 API调用访问<br>安全：通过多种认证方式，确保 API的访问安全性，通过严格流量控制，避免用户服务过载，通过全面的监控告警，保证用户的可用性</p></blockquote><p><strong>便利</strong><br>规范化接口：内部多套业务系统对外提供统一 、规范化的 API<br>下沉管理：通过 API权限鉴别实现下沉到平台层进行管理，简化服务代码，减少冗余<br>开放合作：通过 API网关将企业内部服务能力以标准API 的形式开放给合作伙伴，共享服务、能力和数据，达成深度合作</p></blockquote><ul><li><strong>数据报表</strong>：按照规定的业务逻辑，通过简单的统计处理，以数据集合或图形展示</li><li><strong>数据报告</strong>：对数据进行深度加工，并基于数据分析，加上文字或图表解释，将数据反映的问题展现出来</li><li><strong>数据标签</strong>：对一组数据的基本特性或共同特性进行提炼</li><li><strong>数据订阅</strong>：通过统一、开放的数据订阅通道，使用户高效获取订阅对象的实时增量数据</li><li><strong>数据组件</strong>：具备特定数据处理逻辑的工具，可以根据需要直接处理数据或作为数据应用的调用对象</li><li><strong>数据应用</strong>：数据服务的高级形式，通过功能、程序处理后，进行复杂的数据处理和多样的数据展示</li></ul><h3 id="2-4-3-数据服务工具"><a href="#2-4-3-数据服务工具" class="headerlink" title="2.4.3 数据服务工具"></a>2.4.3 数据服务工具</h3><ul><li><strong>功能</strong></li></ul><blockquote><p>支持不同地域的服务器端连接<br>支持 IaaS架构，提供多种高可用性，能够在服务器节点之间进行请求转移<br>具备事件触发、定时任务、数据触发（敏感数据变化时主动触发）等数据服务请求<br>具备完善的日志管理机制，对服务进行全过程监控合和日志管理<br>支持实时数据交换</p></blockquote><h2 id="2-5-其他组件"><a href="#2-5-其他组件" class="headerlink" title="2.5 其他组件"></a>2.5 其他组件</h2><p><strong>OLAP(数仓)组件</strong>：离线数仓：Hive；实时数仓：ClickHouse</p><p><strong>集群资源管理调度组件</strong>：Yarn、Spark Standalone、Flink Standalone</p><p><strong>通用协调服务组件</strong>：Zookeeper</p><p><strong>数据集成</strong>：flume、canal、sqoop、datax、waterdrop</p><p><strong>任务调度</strong>：azkaban、oozie、dophinscheduler、airflow</p><p><strong>部署运维</strong>：cloudera、manager、ambari、saltstack</p><p><strong>监控告警</strong>：Alertmanager+Prometheus、zabbix、openfalcon</p><p><strong>安全权限</strong>：kerberos、ranger</p><h1 id="3-案例"><a href="#3-案例" class="headerlink" title="3. 案例"></a>3. 案例</h1><ul><li><strong>阿里</strong><br><a href="https://qizhongyi.gitee.io/202109/0125760.html"><font face = "微软雅黑" color = 1E90F size = 5> 实践1：阿里-数据技术 </font></a><br><a href="https://qizhongyi.gitee.io/202109/0227125.html"><font face = "微软雅黑" color = 1E90F size = 5> 实践1：阿里-数据模型 </font></a><br><a href="https://qizhongyi.gitee.io/202109/0256600.html"><font face = "微软雅黑" color = 1E90F size = 5> 实践1：阿里-数据管理 </font></a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据和数据科学-基础</title>
      <link href="/202108/3056358.html"/>
      <url>/202108/3056358.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录大数据与数据科学相关内容</p><span id="more"></span><h1 id="1-大数据与数据科学"><a href="#1-大数据与数据科学" class="headerlink" title="1. 大数据与数据科学"></a>1. 大数据与数据科学</h1><h2 id="1-1-大数据战略"><a href="#1-1-大数据战略" class="headerlink" title="1.1 大数据战略"></a>1.1 大数据战略</h2><ol><li><strong>定义大数据战略和业务需求</strong>：大数据战略需要与整体业务战略和业务需求保持一致</li></ol><blockquote><p>组织需要解决和分析的问题<br>确定获取使用的数据源<br>提供数据的及时性和范围：实时提供或定时快照<br>对其他数据结构的影响以及与其他数据结构的相关性：可能需要对其他数据结构进行结构或内容改造，使其适合与大数据集成整合<br>对现有建模数据的影响：包括扩展对客户、产品和营销方法的知识</p></blockquote><ol start="2"><li><strong>选择数据源</strong>：数据源的选择由组织试图解决的问题驱动</li></ol><blockquote><p>数据源信息</p><blockquote><p>数据源头系统<br>数据格式<br>数据元素表示含义<br>连接其他数据的方式<br>数据的更新频率</p></blockquote><p>数据源管理内容</p><blockquote><p>基础数据：在销售分析中考虑基础数据组件，如 POS（销售终端）<br>粒度：理想以最细粒度的形式获取数据，可用于各种目的聚合<br>一致性：选择超越可视化和认知限制、合适且一致的数据<br>可靠性：选择长时间稳定可靠的数据源<br>检查分析新数据源：添加新数据集之前，需要对变更情况进行测试</p></blockquote></blockquote><ol start="3"><li><strong>获得和接收数据源</strong>：获取需要用到的数据源，采用加载或购买，获取数据源、关键元数据等相关内容</li><li><strong>制定数据假设方法</strong>：构建统计模型，指定数据科学解决方案，展出数据元素和数据及内部二者的关系</li><li><strong>继承和调整数据进行分析</strong>：准备数据中的内容、查找各种来源的数据间链接，以及调整常用数据以供使用</li><li><strong>使用模型探索数据</strong></li></ol><blockquote><ul><li>填充预测模型：使用历史信息预先填充配置预测模型，涉及模型中的客户、市场、产品或模型触发因素之外的其他因素</li><li>训练模型：通过数据模型进行基于数据重复运行模型以验证假设训练，根据结果进行更改</li><li>评估模型：针对训练集进行模型构建、评估和验证，完善业务需求</li><li>创建数据可视化：模型的数据可视化必须满足与模型目的相关的特定需求，每个可视化能够回答一个问题或提供一个见解</li></ul></blockquote><ol start="7"><li><strong>部署和监控</strong>：将满足业务需求的模型部署到生产中，进行持续监控</li></ol><blockquote><ul><li>揭示洞察和发现：与行动项目相关联进行洞察、发现新关系，获取利益</li><li>使用附加数据源迭代：依据展示发现和数据洞察，触发新一轮的数据科学研究，迭代更新</li></ul></blockquote><h2 id="1-2-数据可视化"><a href="#1-2-数据可视化" class="headerlink" title="1.2 数据可视化"></a>1.2 数据可视化</h2><h3 id="1-2-1-数据可视化的技术进步"><a href="#1-2-1-数据可视化的技术进步" class="headerlink" title="1.2.1 数据可视化的技术进步"></a>1.2.1 数据可视化的技术进步</h3><blockquote><p>大规模并行处理（MPP）：数据在多个处理服务器 / 计算节点进行逻辑分区，每个服务器用各自的内存处理本地数据，处理服务器之间的通信由管理节点控制<br>数据库内的高级分析：使用类似MPP的原则<br>非结构化数据分析（Hadoop、MapReduce）</p><blockquote><p>MapReduce 有三个步骤：映射（Map）：识别和获取需要分析的数据；洗牌（Shuffle）：依据所需的分析模式组合数据；归并（Reduce）：删除重复或执行聚合，以便将结果数据及大小减少到需要的规模</p></blockquote><p>分析结果与操作系统的集成<br>跨多媒体和数据的可视化<br>链接结构化和非结构化信息的语义<br>使用物联网的新数据源<br>高级可视化能力<br>数据扩展能力<br>技术和工具集的协作</p></blockquote><h3 id="1-2-2-数据可视化工具"><a href="#1-2-2-数据可视化工具" class="headerlink" title="1.2.2 数据可视化工具"></a>1.2.2 数据可视化工具</h3><p><strong>数据可视化工具</strong>：传统工具具有数据和图形组件，高级可视化和发现工具使用内存架构，使用户能够与数据交互，展示难以识别的大数据集模式，Apache Mahout</p><ul><li><strong>优势</strong></li></ul><blockquote><p>复杂的分析和可视化类型，如格子图、火花线、热图、直方图、瀑布图和子弹图等<br>内置可视化最佳实践<br>交互性，实现视觉发现</p></blockquote><h3 id="1-2-3-可视化标准"><a href="#1-2-3-可视化标准" class="headerlink" title="1.2.3 可视化标准"></a>1.2.3 可视化标准</h3><blockquote><p>分析范例、用户团体、主题域的工具标准<br>新数据的请求<br>数据集流程标准<br>采用中立、专业的陈述过程，避免产生有偏见的结果，确保所有要素都以公平一致的方式完成，如</p><blockquote><p>数据包含和排除<br>模型中的假设<br>结果统计的有效性<br>结果解释的有效性<br>采用适当的方法</p></blockquote></blockquote><h2 id="1-3-度量指标"><a href="#1-3-度量指标" class="headerlink" title="1.3 度量指标"></a>1.3 度量指标</h2><ol><li>技术使用指标：使用技术分析手段查找数据热点（最常访问的数据），以便管理数据分发和保持性能</li><li>加载和扫描指标：定义了数据提取率以及与用户社区的交互</li><li>学习和故事场景：衡量有形式成果，证明投入成本的合理性，包括效益的量化、成本预防或避免，以及启动和实现效益之间的时间长度</li></ol><blockquote><p>已开发模型的数量和准确性<br>已识别的机会中实现的收入<br>避免以识别的威胁所降低的成本</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> 数据科学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管控战略-基础</title>
      <link href="/202108/2939064.html"/>
      <url>/202108/2939064.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍数据管控战略相关的基础内容</p><span id="more"></span><h1 id="1-数据管控战略"><a href="#1-数据管控战略" class="headerlink" title="1. 数据管控战略"></a>1. 数据管控战略</h1><p><strong>数据战略</strong>：包括使用数据信息以获得竞争优势和支持企业目标的业务计划，来自于对业务战略固有数据需求的深度理解<br><strong>数据管控</strong>：是企业开展数据治理的重要基础性保障，为数据治理提供人才团队、制度规范、文化氛围等</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><blockquote><p>短期目标：满足基本的管理决策与业务协同<br>中期目标：创新与转型<br>长期目标：定义企业在数字化竞争生态中的角色和地位</p></blockquote><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><blockquote><p>数据战略与业务战略一致<br>企业各级领导高度重视<br>业务部门全面配合<br>加强规范管理</p></blockquote><h2 id="1-3-数据管控体系"><a href="#1-3-数据管控体系" class="headerlink" title="1.3 数据管控体系"></a>1.3 数据管控体系</h2><ul><li><p><strong>组织架构</strong>：涉及数据治理各项职能活动的人员组织方式<br><strong>架构层级</strong></p><ol><li>决策层：开展数据治理各项工作的最高决策机构，由CTO、CIO、CDO担任，落实国家、企业相关的法律、规定等，对重大数据治理事项进行决策，指导督促其他部门工作</li><li>管理层：开展日常数据治理工作并对整个过程进行管理协调的专职机构</li><li>执行层：由“机构 + 专业 ”双维度构成的矩阵式组织体系，落实数据占率的相关要求，接受考核并优化工作机制</li><li>监督层：监督数据治理管理和执行工作，参与实际考核评价过程</li></ol><p><strong>组织模式</strong></p><ol><li>分散模式：内部各部门自行组建数据治理团队</li><li>归口模式：内部明确组织数据治理归口管理部门，业务部门成立数据治理团队，接受归口管理部门的指导安排</li><li>半集中模式：内部明确组织数据治理归口管理部门，向其他部门派驻分团队或小组，结合业务部门进行</li><li>全集中模式：构建全集中的数据治理团队，包括数据治理技术人员、业务部门、管理团队等，相关问题直接向分管经理报告</li></ol></li><li><p><strong>制度规范</strong>：有关数据治理各项职能活动的相关管理办法、实施细则、指导意见和操作指南等制度性意见</p><ol><li>数据政策：企业进行数据治理的纲领性文件，落实数据治理的最根本原则，内容不易太多，直击要点</li><li>管理制度：基于数据政策的原则性文件，结合组织、业务特点制定的数据治理职能范围的总体性管理制度，根据职能域进行划分</li><li>数据治理实施细则：是管理制度的从属性文件，用于补充解释特定轰动或任务中的具体内容</li><li>数据治理操作手册：针对数据治理执行活动的具体执行性文件，用于指导具体操作</li></ol><p><strong>标准体系</strong></p><blockquote><p><strong>技术标准</strong>：大数据术语、总则、参考架构、技术架构，以及描述大数据集、进行数据全生命周期操作的技术标准等，如描述模型、质量模型、分类方法<br><strong>数据标准</strong>：包括元数据、数据指标、主数据、数据代码、数据规范、时序数据、数据交易与数据共享等<br><strong>应用标准</strong>：参考国际标准或行业标准，或直接采用<br><strong>管理标准</strong>：包括数据管理制度与规范、数据安全与隐私保护、数据质量管理与认责体系、数据资产目录管理与数据全生命周期管理</p></blockquote></li><li><p><strong>执行流程</strong>：针对数据治理具体职能活动，结合企业自身组织架构制定的一系列规范性和标准化工作实施和流转过程</p><ol><li>数据标准：收集分析数据需求—&gt;制定更新—&gt;审核—&gt;颁布—&gt;落实与反馈</li><li>数据质量：准备工作—&gt;问题发现—&gt;问题定位和优先级划分—&gt;制定方案—&gt;提升质量—&gt;评估改进结果</li><li>数据安全：制定或更新数据安全策略—&gt;指定数据安全分级和授权犯方法—&gt;审核与发布—&gt;落实—&gt;使用与反馈</li></ol></li><li><p><strong>培训宣传</strong>：培养数据治理相关专业人才，营造良好的数据治理氛围</p></li><li><p><strong>设计机制</strong>：实现数据治理工作内容形成的各类管理和保障过程</p><ol><li>决策机制</li><li>监督机制</li><li>保障机制</li><li>认责机制</li><li>激励机制</li><li>沟通机制</li></ol></li><li><p><strong>绩效体系</strong>：对数据治理的工作行为业绩进行全面评价，并正确引导未来的工作内容</p><ol><li>制定考核方案</li><li>制定考核指标：量化为主，定性为辅</li><li>明确考核标准</li><li>开展考核评估</li></ol></li></ul><h2 id="1-4-模型架构"><a href="#1-4-模型架构" class="headerlink" title="1.4 模型架构"></a>1.4 模型架构</h2><ul><li><strong>战略一致性模型（SAM）</strong>：模型的中心是数据与信息之间的关系，业务战略、IT战略、组织与流程、信息系统，如下图所示：<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/DM_%E6%88%98%E7%95%A5%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B.png" alt="DM_战略一致性模型"></li><li><strong>阿姆斯特丹信息模型（AIM）</strong>：从战略角度看待业务域IT的一致性，分为9个单元，如下图所示：<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/DM_%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E4%B8%B9%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9E%8B.png" alt="DM_阿姆斯特丹信息模型"></li><li><strong>DAMA-DBBOK模型</strong></li></ul><blockquote><p>DAMA车轮图，将数据治理作为数据管理的核心，如下图所示：<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/DM_DAMA%E8%BD%A6%E8%BD%AE%E6%A8%A1%E5%9E%8B.png" alt="DM_DAMA车轮模型"><br>环境因素六边形图，显示了人、过程和技术之间的关系，如下图所示：<br>知识领域语境关系图，描述了人员、流程和技术等知识领域的相关细节，基于产品管理的 <strong>SIPOC图</strong>的概念，包括如下内容：</p><blockquote><p>定义：知识领域的简要定义<br>目标：知识领域内指导活动执行的目的、基本原则<br>活动：实现知识领域目标所需的行动和任务，分为计划、控制、开发和运营</p><blockquote><p>计划活动 Plan：为实现数据管理目标指定战略战术工作<br>控制活动 Control：持续确保数据质量<br>开发活动 Develop：围绕数据生命周期开展分析、设计、构建、测试、准备和部署工作<br>运营活动 Operate：支持系统和流程的使用、维护和增强</p></blockquote><p>输入：知识领域启动活动需要的有形实物<br>交付成果：知识领域内的产出<br>角色和职责<br>相关参与方：供给者，消费者，参与者<br>工具<br>方法<br>质量指标</p></blockquote></blockquote><ul><li>战略地图</li><li>差距分析</li><li>SWOT分析</li><li>PEST分析</li><li>5W1H分析</li><li>发展驱动力分析</li><li>波特五力分析</li><li>BCG矩阵分析</li></ul><h2 id="1-5-成功因素"><a href="#1-5-成功因素" class="headerlink" title="1.5 成功因素"></a>1.5 成功因素</h2><ol><li>高管支持：确保受数据管理影响的利益相关方获得必要的指导</li><li>明确愿景：所有利益相关方明确数据管理呢能够带来的效益</li><li>积极变更：数据管理过程需要不断的迭代更新</li><li>领导共识：确保数据管理规划的一致性和统一支持</li><li>持续沟通：保持一定频率的公开沟通</li><li>广泛参与：利益相关方积极参与，助力理解数据管理变更影响的内容</li><li>指导培训：对不同群体进行不同类型和层次的培训</li><li>度量策略：帮助了解数据管理路线的有效性</li></ol><blockquote><p>是否采用数据标准<br>改进的程度，或相对增量<br>数据管理的有利方面，对可测量解决方案的影响<br>改进的流程和项目<br>识别并规避风险<br>数据管理的创新方面，改变业务的方式<br>可信度分析</p></blockquote><ol start="9"><li>指导原则：阐明组织的共同价值观战略愿景</li><li>非革命演进：减少重大变化或大规模高风险项目</li></ol>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据质量管理-基础</title>
      <link href="/202108/2860861.html"/>
      <url>/202108/2860861.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍数据质量管理相关的基础内容</p><span id="more"></span><h1 id="1-数据质量管理"><a href="#1-数据质量管理" class="headerlink" title="1. 数据质量管理"></a>1. 数据质量管理</h1><p><strong>数据质量管理</strong>：包括规划和实施质量管理技术，测量、评估和提高企业内数据的适用性，提高数据对业务和管理的满意度，是一项持续地任务</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><p>提高组织数据价值和数据利用的机会、降低低质量数据导致的风险和成本、提高组织效率和生产力、保护和提升组织的声誉、定义数据质量控制的标准和规范</p><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><p><strong>重要认知</strong>：结合对企业和用户的重视程度和数据不正确的风险水平确定数据重要性，确定数据改进顺序<br><strong>周期管理</strong>：数据质量管理覆盖从产生采集到处置的全数据生命周期，包括系统内部和系统之间的数据流转<br><strong>预防为主</strong>：数据质量反感的重点应放在预防数据错误和降低数据可用性的情形<br><strong>根因修正</strong>：优化数据流程和系统设计，从根本上解决数据质量问题<br><strong>治理促进</strong>：数据治理活动和数据质量管理活动二者相互促进<br><strong>标准驱动</strong>：用可测量的标准和期望定义可量化的数据质量需求<br><strong>客观一致测量</strong>：数据质量水平需要得到客观一致的测量<br><strong>嵌入业务流程</strong>：在各个业务流程中实时数据标准<br><strong>系统强制执行</strong>：系统必须强制执行数据质量要求<br><strong>关联服务水平</strong>：数据质量报告和问题应纳入服务水平协议（SLA）</p><p><strong>早预防、早发现、早恢复</strong></p><h2 id="1-3-管理环节"><a href="#1-3-管理环节" class="headerlink" title="1.3 管理环节"></a>1.3 管理环节</h2><ol><li>制定考核指标（管理层面）</li><li>选择管理对象（业务层面）</li><li>制定管理规则（管理+业务）</li><li>作业执行管理规则，形成指令分析报告（技术层面）</li><li>处理错误数据（技术+业务）</li><li>持续改善机制（技术+管理）</li></ol><h1 id="2-数据质量"><a href="#2-数据质量" class="headerlink" title="2. 数据质量"></a>2. 数据质量</h1><h2 id="2-1-数据质量维度"><a href="#2-1-数据质量维度" class="headerlink" title="2.1 数据质量维度"></a>2.1 数据质量维度</h2><h3 id="2-1-1-管理内容"><a href="#2-1-1-管理内容" class="headerlink" title="2.1.1 管理内容"></a>2.1.1 管理内容</h3><p>数据内容及背景分析、数据结构及路径分析、数据成分及业务规则合规分析、数据间的关系及相关资源分配、识别数据转换机制、建立数据有效性及准确性规则、检验数据间的依赖性</p><p><strong>Strong-Wang 框架</strong>：</p><ul><li><strong>内在数据质量</strong>：准确性、客观性、可信度、信誉度</li><li><strong>场景数据质量</strong>：增值性、关联性、及时性、完整性、适量性</li><li><strong>表达数据质量</strong>：可解释性、易理解性、表达一致性、简洁性</li><li><strong>访问数据质量</strong>：可访问性、访问安全性</li></ul><p><strong>Larry English</strong>：《<em>Improving Data Warehouse and Bussiness Information Quality</em>》——《改善数据仓库和业务信息质量》</p><ul><li><strong>固有质量特性</strong>：定义一致、值域完备、有效性或业务规则一致、数据源准确、反映实时准确、精确、非冗余、冗余或分布数据的等效、冗余或分布数据的并发性</li><li><strong>实用质量特性</strong>：可访问性、及时性、语境清晰性、可用性、多源数据的可整合性、适当性或事实完整性</li></ul><p><strong>DAMA UK</strong>：</p><ul><li><strong>完备性</strong>：存储数据量与潜在数据量的百分比</li><li><strong>唯一性</strong>：在满足对象识别基础上不应多次记录实体实例</li><li><strong>及时性</strong>：数据从要求的时间点起代表现实的程度</li><li><strong>有效性</strong>：数据符合其定义的语法（格式、类型、范围等）</li><li><strong>准确性</strong>：数据正确的描述现实世界对象或事件的程度</li><li><strong>一致性</strong>：比较事务多种表述与定义的差异</li></ul><h3 id="2-1-2-常用评估内容"><a href="#2-1-2-常用评估内容" class="headerlink" title="2.1.2 常用评估内容"></a>2.1.2 常用评估内容</h3><p><strong>完整性</strong>：数据是否存在缺失记录或缺失字段，字段非空<br><strong>规范性</strong>：对数据标准、数据模型、业务规则、元数据和参考数据进行完整性、质量及归档的度量<br><strong>一致性</strong>：保证数据内容在信息含义上一致<br><strong>准确性</strong>：考察数据内容的正确性、如时间逻辑、字典取值、业务计算逻辑等<br><strong>唯一性</strong>：在满足业务需求下不允许重复同时也解决了数据不一致的潜在可能<br><strong>关联性</strong>：关联数据的缺失或未建立索引</p><p><strong>及时性</strong>：数据的最近更新时间</p><h2 id="2-2-数据质量低下的原因"><a href="#2-2-数据质量低下的原因" class="headerlink" title="2.2 数据质量低下的原因"></a>2.2 数据质量低下的原因</h2><p><strong>领导力问题</strong>：领导员工缺乏意识、缺乏领导力和管理能力</p><p><strong>数据输入问题</strong>：人员操作问题、数据输入接口问题、业务系统变更(包括表结构变更、源数据格式异常)</p><p><strong>数据处理问题</strong>：有关数据源的错误假设（如：错误或变更、系统文档不完整或过时、知识转移不够充分等）、过时的业务规则、变更的数据结构</p><p><strong>系统设计问题</strong></p><blockquote><p>未能执行参照完整性、唯一性约束</p><blockquote><p>产生破坏唯一性约束的重复数据<br>既可以包含、又可以排除在某些报表中的孤儿数据，导致同样的计算生成多个值<br>由于参照完整性要求以还原或更改，无法升级<br>由于丢失的数据被分配为默认值二导致数据准确性降低</p></blockquote><p>编码不准确和分歧<br>缺少有效的审核纠错机制<br>数据模型不准确，各系统数据交换标准不一<br>字段重载<br>时间数据不匹配<br>主数据管理薄弱，应用程序缺乏全面校验流程<br>数据复制</p><blockquote><p>单源-多个本地实例<br>多源-单一本地实例</p></blockquote></blockquote><h3 id="2-2-1-常见脏数据"><a href="#2-2-1-常见脏数据" class="headerlink" title="2.2.1 常见脏数据"></a>2.2.1 常见脏数据</h3><p><strong>缺失值</strong>：确定缺失值范围，根据字段的重要性和缺失率指定不同的清洗策略(重要缺多——重新取数，重要缺少——算法填充或业务逻辑填充等，不重要缺多——考虑删除或统一置数，为零、平均数、中位数、众数等，不重要缺少——统一置数)<br><strong>异常值</strong>：即离群点：去重、不合理的值(修正、删除、缺失值处理)、矛盾内容(业务判断、删除、重构)<br><strong>格式内容不一致</strong>：统一时间、日期、数值单位、语言、半全角等，数据出现不规范内容，如首尾空格、异常标点等，数据错列等<br><strong>内容未知的值</strong><br><strong>无效值</strong></p><h2 id="2-3-数据质量管理方法"><a href="#2-3-数据质量管理方法" class="headerlink" title="2.3 数据质量管理方法"></a>2.3 数据质量管理方法</h2><ol><li><p><strong>数据清理</strong>：通过数据转换使数据符合数据标准和域规则</p><blockquote><p>实施控制以防止数据输入错误<br>纠正源系统中的数据<br>改进数据录入的业务流程</p></blockquote></li><li><p><strong>数据增强</strong>：给数据集添加属性以提高其质量和可用性的过程</p><blockquote><p>时间戳<br>审计数据：记录血缘<br>参考词汇表<br>语境信息：添加位置、环境或访问方法等上下文语境信息<br>地理信息<br>人口统计信息<br>心理信息：按特定行为、习惯或偏好对目标人群进行细分的数据<br>评估信息：针对资产评估、库存和销售数据等使用数据增强</p></blockquote></li><li><p><strong>数据解析和格式化</strong>：使用预先确定的规则来解释其内容或值的分析过程</p></li><li><p><strong>数据转换与标准化</strong>：通过触发数据规则将数据转换为目标体系结构可读取的格式</p></li><li><p><strong>关联与统一服务</strong>：结合实际业务规则关联多个业务系统，确定权威数据，形成统一视图</p></li></ol><h3 id="2-3-1-改进流程控制"><a href="#2-3-1-改进流程控制" class="headerlink" title="2.3.1 改进流程控制"></a>2.3.1 改进流程控制</h3><p><strong>戴明环</strong>：PDCA （计划-执行-检查-行动）</p><ul><li>计划阶段（Plan）：数据质量团队评估已知问题的范围、影响和优先级，并评估解决这些问题的备选方案</li><li>执行阶段（Do）：数据质量团队解决引起问题的根本原因，并作出对持续监控数据的计划</li><li>检查阶段（Check）：积极监控按要求测量的数据质量</li><li>处理阶段（Act）：处理解决新出现的数据质量问题</li></ul><h2 id="2-4-数据质量管理过程"><a href="#2-4-数据质量管理过程" class="headerlink" title="2.4 数据质量管理过程"></a>2.4 数据质量管理过程</h2><h3 id="2-4-1-定义高质量数据"><a href="#2-4-1-定义高质量数据" class="headerlink" title="2.4.1 定义高质量数据"></a>2.4.1 定义高质量数据</h3><p>了解业务战略和目标、与利益相关方面谈，以识别痛点、风险和业务驱动因素、通过资料收集和其他剖析形式直接评估数据、记录业务流程中的数据依赖关系、记录业务流程中的技术架构和系统支持</p><h3 id="2-4-2-定义数据质量战略"><a href="#2-4-2-定义数据质量战略" class="headerlink" title="2.4.2 定义数据质量战略"></a>2.4.2 定义数据质量战略</h3><p>了解并优先考虑业务需求、确定满足业务需求的关键数据、根据业务需求定义业务规则和数据质量标准、根据预期评估数据、分享调查结果，并从利益相关方获得反馈、优先处理和管理问题、确定并优先考虑改进机会、测量、监控和报告数据质量、管理通过数据质量流程生成的元数据、将数据质量控制集成到业务和技术流程中</p><h3 id="2-4-3-识别关键数据和业务规则"><a href="#2-4-3-识别关键数据和业务规则" class="headerlink" title="2.4.3 识别关键数据和业务规则"></a>2.4.3 识别关键数据和业务规则</h3><ul><li><p><strong>关键数据</strong><br>监管报告、财务报告、商业政策、持续经营、商业战略（尤其是差异化竞争战略）</p></li><li><p><strong>业务规则类型</strong></p></li></ul><p><strong>定义一致性</strong>：确认对数据定义的理解相同，并在整个组织过程中得到实现和正确的使用<br><strong>记录完整性</strong>：定义数值缺失的情况是否可接受的规则<br><strong>格式符合性</strong>：按指定模式分配给数据元素的值，如设置电话号码格式的标准<br><strong>值域匹配性</strong>：指定数据元素的赋值需包含在某数据值域的枚举值中<br><strong>范围一致性</strong>：数据元素赋值必须在定义的数字、词典或时间范围内<br><strong>映射一致性</strong>：表示分配给数据元素的值，必须映射到其他等效对应值域中选择的值<br><strong>一致性规则</strong>：指根据某些属性的实际值，在两个或多个属性之间关系的条件判定<br><strong>准确性验证</strong>：将数据值与记录系统或其他来源中的对应值进行比较，以验证是否匹配<br><strong>及时性验证</strong>：表明与数据可访问性和可用性预期相关特征的规则</p><h3 id="2-4-4-执行初始数据质量评估"><a href="#2-4-4-执行初始数据质量评估" class="headerlink" title="2.4.4 执行初始数据质量评估"></a>2.4.4 执行初始数据质量评估</h3><ol><li><p>定义评估目标，推动工作进展</p></li><li><p>确定需要评估的数据，重点放在某个特定的数据集或特定数据质量问题上</p></li><li><p>识别数据的用途和使用者</p></li><li><p>利用评估的数据识别已知风险，包括数据问题对组织过程的潜在影响</p></li><li><p>根据已知和建议的规则检查数据</p></li><li><p>记录不一致的级别和问题类型</p></li><li><p>根据初步发现进行深入分析，以便</p><blockquote><p>量化结果<br>根据业务影响优化问题<br>提出关于数据问题根本原因假设</p></blockquote></li><li><p>与数据管理专员、领域专家和数据消费者会面，确认问题优先级</p></li><li><p>实用调查结果作为规划的基础</p><blockquote><p>找到问题的根本原因解决问题<br>控制改进处理流程，防止问题重复发生<br>持续控制和汇报</p></blockquote></li></ol><h3 id="2-4-5-识别改进方向并确认优先排序"><a href="#2-4-5-识别改进方向并确认优先排序" class="headerlink" title="2.4.5 识别改进方向并确认优先排序"></a>2.4.5 识别改进方向并确认优先排序</h3><p>通过对交大数据及进行全面的数据分析，了解现有问题；与利益相关方沟通数据影响问题，并跟踪分析其业务影响；结合数据分析人员和利益相关方的讨论排定最终优先顺序</p><h3 id="2-4-6-定义数据质量改进目标"><a href="#2-4-6-定义数据质量改进目标" class="headerlink" title="2.4.6 定义数据质量改进目标"></a>2.4.6 定义数据质量改进目标</h3><p>受影响数据的关键性（重要性排序）；受影响的数据量；数据的龄期；受问题影响的业务流程数量和类型；受问题影响的消费者、客户、供应商或员工数量；与问题相关的风险；纠正根本原因的成本；潜在的工作成本</p><h3 id="2-4-7-开发和部署数据质量操作"><a href="#2-4-7-开发和部署数据质量操作" class="headerlink" title="2.4.7 开发和部署数据质量操作"></a>2.4.7 开发和部署数据质量操作</h3><ol><li><p><strong>管理数据质量规则</strong></p><blockquote><p>记录一致性：建立记录规则的标准和模板<br>根据数据质量维度定义：质量维度有助于了解正在测算的内容<br>与业务影响挂钩：数据质量标准和规则应该与组织业务成功直接关联，不应采取与业务流程无关的度量<br>数据分析支持：数据质量分析人员应该根据数据测试规则，而不应猜测规则，规则显示数据存在的问题<br>由领域专家确认：规则的目的是描述数据形态，由主题专家确认或解释数据分析结果，产生知识<br>所有数据消费者都可以访问：所有数据消费者都应该能够访问记录的规则，以方便更好地了解数据</p></blockquote></li><li><p><strong>测量和监控数据质量</strong>：向数据消费者通报质量水平、管理业务或技术流程，改变引入的变更风险</p></li><li><p><strong>制定管理数据问题的操作过程</strong></p><ul><li><strong>诊断问题</strong>：身缠数据质量事件的症状，跟踪相关数据的血缘，确定问题及其来源，并查明问题根本原因<blockquote><p>在适当的信息处理流程下查看数据问题，并隔离出现缺陷过程的位置<br>评估环境变化导致错误的可能性<br>评估其他过程导致数据质量问题的可能性<br>评估外部数据影像数据质量问题的可能性</p></blockquote></li><li><strong>制定补救方案</strong><blockquote><p>纠正非技术性根本原因，如缺乏培训、缺乏领导支持、责任所有权不明等<br>修改系统以消除技术类根本原因<br>制定控制措施以防止问题发生<br>引入额外的检查和检测<br>直接修正有缺陷的数据<br>基于变更的成本和影响对比更正后的数据价值分析，不采取任何操作</p></blockquote></li><li><strong>解决问题</strong><blockquote><p>评估替代方案的相对成本和优点<br>推荐计划中的一个备选方案<br>提供开发和实施该解决方案的计划<br>实施该解决方案</p></blockquote></li><li><strong>跟踪解决方案</strong><blockquote><p>标准化数据质量问题和活动：定义相关概念的标准词汇表，用于简化分类和报告，简化衡量问题和活动的数量、确定系统和参与者之间的模式和相互依赖关系以及报告数据质量活动的总体影响<br>提供数据问题的分配过程：操作过程指导分析人员将数据质量事件分配给个人进行诊断，并提供解决方案<br>管理问题升级过程：根据问题的影响、持续时间或紧急程度制定明确的升级机制，明确规定数据质量服务级别协议中的升级顺序<br>管理数据质量解决方案工作流：数据质量服务水平协议规定了监控、控制和解决的目标，定义了操作工作流的集合</p></blockquote></li></ul></li><li><p>**制定数据质量服务水平协议(SLA)**：规定了组织对每个系统中数据质量问题进行响应和补救的期望</p><blockquote><p>协议涵盖的数据元素<br>与数据缺陷相关的业务影响<br>与每个数据元素相关的数据质量指标<br>从每个已确定指标的数据元素出发，识别数据价值链上每个应用程序系统中的质量期望<br>测量这些期望的方法<br>每次测量的可接受性阈值，如超出阈值，应及时通知数据管理专员<br>预期解决或补救问题的时间和截止日期<br>升级策略，以及可能的奖励和惩罚</p></blockquote></li><li><p><strong>编写数据质量报告</strong></p><blockquote><p>数据质量评分卡<br>数据质量趋势<br>服务水平协议指标<br>数据质量问题管理<br>数据质量团队与治理政策的一致性<br>IT 和业务团队对数据质量政策的一致性<br>改善项目带来的积极影响</p></blockquote></li></ol><h2 id="2-5-数据治理下的数据质量工作"><a href="#2-5-数据治理下的数据质量工作" class="headerlink" title="2.5 数据治理下的数据质量工作"></a>2.5 数据治理下的数据质量工作</h2><p>设定优先级；确定和协调有权参加各种数据质量相关决定和相关活动的人；制定和维护数据质量标准；报告企业范围内数据质量的相关测量；提供有助于员工参与的指导；建立知识共享的沟通机制；制定和应用数据质量和合规政策；监控和报告绩效；共享数据质量报告检查结果，以提高认识、确定改进机会，并就改进达成共识；解决变化和冲突，提供方向性指导</p><h2 id="2-6-数据质量问题预防"><a href="#2-6-数据质量问题预防" class="headerlink" title="2.6 数据质量问题预防"></a>2.6 数据质量问题预防</h2><ol><li><p>建立数据输入控制</p></li><li><p>培训数据生产者</p><blockquote><p>导致数据问题的常见原因<br>组织数据生态系统中的关系<br>糟糕数据造成的后果<br>持续改进的必要性<br>要推动数据语言化，阐述数据对组织战略与成功、监管报告和客户满意度的影响</p></blockquote></li><li><p>定义和执行规则</p></li><li><p>要求数据供应商提供高质量数据</p></li><li><p>实施数据治理和管理制度</p></li><li><p>指定正式的变更控制</p></li></ol><h2 id="2-7-数据质量问题纠正"><a href="#2-7-数据质量问题纠正" class="headerlink" title="2.7 数据质量问题纠正"></a>2.7 数据质量问题纠正</h2><ul><li><strong>自动纠正</strong>：基于规则的标准化、规范化和更正，修改后的值在没有人工干预的情况下自动获取、生成和提交，需要具有定义良好的标准、普遍接受的规则和已知的错误模式等</li><li><strong>人工检查纠正</strong>：使用自动工具矫正和纠正数据，人工检查后将纠正持久化存储</li><li><strong>人工修正</strong>：通过人工按照数据质量规则处理变更</li></ul><h2 id="2-8-度量指标"><a href="#2-8-度量指标" class="headerlink" title="2.8 度量指标"></a>2.8 度量指标</h2><ul><li><p>投资回报：关于改进工作的成本和改进数据质量好处的声明</p></li><li><p>质量水平：一个数据集内或多个数据集间的错误或不满足甚至违反需求情况的数量和比率</p></li><li><p>数据质量趋势：随时间推移，针对阈值和目标的质量改进，或个阶段的质量事件</p></li><li><p>数据问题管理指标</p><blockquote><p>按数据质量指标对问题分类与计数<br>各业务职能部门及其问题状态<br>按优先级和严重程度对问题排序<br>解决问题的时间</p></blockquote></li><li><p>服务水平一致性：包括负责人员在内的组织单位对数据质量评估项目干预过程的一致性</p></li><li><p>数据质量计划示意图：现状和扩展路线图</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
            <tag> 数据质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>元数据管理-基础</title>
      <link href="/202108/2719375.html"/>
      <url>/202108/2719375.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 元数据管理 的相关基础内容</p><span id="more"></span><h1 id="1-元数据管理"><a href="#1-元数据管理" class="headerlink" title="1. 元数据管理"></a>1. 元数据管理</h1><p><strong>元数据</strong>：描述数据的数据，对数据资源进行描述、解释 、定位等，便于检索和管理，包括技术和业务流程、数据规则和约束，还包括逻辑数据结构和物理数据结构等。用来描述数据本身（如数据库、数据元素、数据模型），数据表示的概念（如业务流程、应用系统软件代码、技术基础设施），数据与概念之间的联系（关系），便于进行血缘分析、影响分析等</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><blockquote><p>收集记录元数据内容，确保元数据完整性<br>建立元数据标准，提供标准路径访问元数据和元数据标准语义<br>整合管理不同来源的元数据进行统一管理<br>确保元数据的数据质量、数据一致性、数据及时性和数据安全<br>创建准确的血缘分析、关联度分析和影响分析，增加对数据流向的认识<br>满足数据监规范，合理使用数据<br>提供全面的数据背景、历史和来源，降低培训成本和人员流动影响<br>提供上下文语境和执行数据质量检查，提高数据可信度<br>明确数据语义，提高数据使用者和IT人员的沟通效率<br>明确数据流程，识别冗余、过时和不正确的数据<br>扩展元数据用途，增加战略信息（如主数据）的价值</p></blockquote><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><p><strong>组织承诺</strong>：确保组织对元数据的承诺（高级管理层的支持和资金）<br><strong>战略规划</strong>：制定元数据发展战略，包括元数据创建、维护、继承和访问<br><strong>企业视角</strong>：通过企业视角、采用迭代和衡量交付确保未来的可扩展性<br><strong>潜移默化</strong>：宣导元数据的用途和必要性，潜移默化的鼓励业务使用元数据，同时为业务提供知识辅助<br><strong>访问控制</strong>：确保相关人员了解访问和使用元数据<br><strong>质量控制</strong>：元数据是通过现有流程（数据建模、SDLC、业务流程定义）生成的，所以流程应该对元数据数据质量负责<br><strong>审计控制</strong>：制定、实施和审核元数据标准，简化元数据的集成和使用<br><strong>改进建议</strong>：建立反馈机制</p><h1 id="2-元数据"><a href="#2-元数据" class="headerlink" title="2. 元数据"></a>2. 元数据</h1><h2 id="2-1-分类"><a href="#2-1-分类" class="headerlink" title="2.1 分类"></a>2.1 分类</h2><ul><li><strong>业务元数据</strong>：关注数据的内容和条件，包括与数据治理详细信息：主题域、概念、实体、属性的非技术名称和定义、属性的数据类型和其他特征，如 <strong>业务定义（范围描述）、业务术语、业务规则（包括计算公式、算法和有效值域等）、业务指标等</strong></li></ul><blockquote><p>程序、应用、数据的名称和描述，数据主题分类、关联指标等<br>数据信息的编码标准，包括数据定义规范、约束条件；数据安全标准、数据质量标准<br>业务活动定义及描述；业务规则、数据转换规则、计算公式和推导公式等<br><strong>来源</strong></p><blockquote><p>ERP系统，如财务计算公式、过程逻辑、业务规则等<br>报表：包含合计、平均数等带有总结性质的列、计算公式等<br>表格：Excel的表头、计算公式、“描述”列等<br>文件：标题、作者、修改时间等<br>BI工具：上下钻取的过程中包含的产品等级和组织结构等级等</p></blockquote></blockquote><ul><li><strong>技术元数据</strong>：数据技术领域的实现，包括 <strong>数据结构定义（包括数据模型、数据库表、字段类型、字段长度、存储位置）、数据映射关系（ETL脚本）、转换规则（SQL脚本、接口程序）等</strong></li></ul><blockquote><p>数据库对象属性和字段属性，如数据类型、长度、值域、主键、外键、索引、分区、CRUD规则、存储大小等<br>数据库名、表名、字段名和之间的从属关系，数据血缘，包括上游和下游变更影响的信息等<br>数据的角色、用户组、访问权限之间的关系<br>ETL作业详细信息，周期作业（内容更新）的调度计划和依赖</p></blockquote><ul><li><strong>操作元数据</strong>：数据处理的过程与关系，包括 <strong>数据所有者、数据质量定责、数据安全等级、数据访问权限，数据处理作业的结果</strong></li></ul><blockquote><p>数据访问频率、调用次数，数据使用说明，恢复和备份规则、灾备恢复预案；数据更新计划等<br>数据利益相关方（如数据所有者、数据管理员）的联系信息和操作信息等<br>查询的访问模式、频率和执行时间<br>作业执行日志、抽取历史和结果；调度异常处理、错误日志<br>版本维护计划、系统执行情况，当前版本号<br>数据清洗标准、SLA 要求和规定，数据归档、保留规则和相关归档文件<br>数据共享规则和协议，容量使用模式</p></blockquote><p>在图书馆或信息科学领域</p><ul><li>描述元数据：描述资源并支持识别检索，如标题、作者和主题等</li><li>结构元数据：描述资源及其组成组件之间的关系，如页数、章节等</li><li>管理元数据：描述管理生命周期的元数据，如版本号、存档日期，人员角色、岗位职责、管理流程等</li><li>内容元数据：非结构化数据</li></ul><blockquote><p>数据格式：决定数据的访问方法，如电子非结构化数据的电子索引<br>可搜索性：具备搜索相关非结构化数据的工具<br>自我描述：元数据是否具有自我描述能力，如在文件系统中<br>既有模式：采用或适配现有的方法和模式，如图书馆目录<br>需求满足：进行彻底和详细的检索能力，如制药或核工业</p></blockquote><h2 id="2-2-来源"><a href="#2-2-来源" class="headerlink" title="2.2 来源"></a>2.2 来源</h2><ul><li><strong>应用程序中元数据存储库</strong>：存储元数据的物理表，通常内置在建模工具、BI工具和其他应用程序中</li><li><strong>业务术语表</strong>：记录和存储组织的业务概念、术语、定义以及术语之间的关系，包含足够完整和高质量的信息</li></ul><blockquote><p>术语名称、定义、缩写或简称，以及任何同义词<br>负责管理与术语相关的数据业务部门或应用程序<br>维护术语的人员姓名和更新日期<br>术语的分类或分类间的关联关系<br>需要解决的冲突定义、问题性质、行动时间表等<br>常见的误解<br>支持定义的算法<br>血缘<br>支持该术语的官方或权威数据来源</p></blockquote><ul><li><strong>商务智能工具</strong>：商务智能工具生成与商务智能设计相关的各类元数据，包括概述信息、类、对象、衍生信息和计算的项，过滤器、报表、报表字段、报表展现、报表用户、报表发布频率和报表发布渠道等</li><li><strong>配置管理工具</strong>：配置管理工具或数据库（CMDB）提供了管理和维护IT资产及其之间关系的合同细节相关的元数据</li><li><strong>数据字典</strong>：定义数据机的结构和内容，用于管理数据模型中每个元素的名称、描述、结构、特征、存储要求、默认值、关系、唯一性和其他属性，包括表或文件定义</li><li><strong>数据集成工具</strong>：用于可执行文件将数据从一个系统到另一个系统，活在同一系统的不同模块之间移动，提供血缘关系和临时元数据，还包括数据集成作业执行的元数据</li><li><strong>数据库管理和系统目录</strong>：数据库目录描述了数据库的内容、信息大小、软件版本、部署状态、网络正常运行时间、基础架构正常运行时间、可用性以及其他操作元数据属性</li><li><strong>数据映射管理工具</strong>：用于项目分析和设计阶段，将需求转化为映射规范，由数据集成工具生成数据集成代码</li><li><strong>数据质量工具</strong>：数据质量工具通过验证规则评估数据质量，提供了与其他元数据存储库交换质量分数和质量概况的功能，元数据存储库能够将质量分数附加到相关物理资产上</li><li><strong>字典和目录</strong>：包括有关组织内数据的系统、源、位置的信息</li><li><strong>事件消息工具</strong>：描述数据通过事件消息工具在不同系统之间的移动过程，包括图形接口、管理数据移动逻辑、接口实现细节</li><li><strong>建模工具和存储库</strong>：建模工具用于构建各种类型的数据模型，包括概念模型、逻辑模型和物理模型，生成与应用程序或系统模型设计相关的元数据，如主题域、逻辑实体、逻辑属性、实体属性关系</li><li><strong>参考数据库</strong>：参考数据记录各种类型的枚举数据的业务价值和描述，用于系统上下文</li><li><strong>服务注册</strong>：是从面向服务的架构角度管理和存储有关服务和服务终端的技术信息，如定义、接口、操作、输入输出参数，还有与服务相关的最重要元数据包括服务版本、服务位置、数据中心、服务端口、IP地址等</li><li><strong>其它元数据存储</strong>：只特定格式的清单，如事件注册表、源列表接口、代码集、时空模式、空间参考等</li></ul><h1 id="3-元数据管理实施"><a href="#3-元数据管理实施" class="headerlink" title="3. 元数据管理实施"></a>3. 元数据管理实施</h1><h2 id="3-1-确定元数据功能需求"><a href="#3-1-确定元数据功能需求" class="headerlink" title="3.1 确定元数据功能需求"></a>3.1 确定元数据功能需求</h2><ul><li><strong>更新频次</strong>：元数据属性和属性集更新的频率</li><li><strong>同步情况</strong>：数据源头变化后的更新时间</li><li><strong>历史信息</strong>：是否需要保留原数据的历史版本</li><li><strong>访问权限</strong>：通过特定的用户界面功能、访问员数据的人员和方式</li><li><strong>存储结构</strong>：元数据如何通过建模来存储</li><li><strong>集成要求</strong>：元数据从不同数据源的整合程度和整合规则</li><li><strong>运维要求</strong>：更新元数据的处理过程和规则（记录日志和提交申请）</li><li><strong>管理要求</strong>：管理员数据的角色和职责</li><li><strong>质量要求</strong>：元数据质量要求</li><li><strong>安全要求</strong>：确保元数据安全，以免泄露高度保密数据的信息</li></ul><h2 id="3-2-元数据国际规范"><a href="#3-2-元数据国际规范" class="headerlink" title="3.2 元数据国际规范"></a>3.2 元数据国际规范</h2><p><strong>ISO/IEC 11179元数据注册表</strong><br><strong>公共仓库元模型(CWM)</strong></p><blockquote><p>管理类元模型：系统资源、人员管理、任务管理等<br>技术类元模型：关系型数据库、OLAP、接口、ETL、ERWin<br>业务类元模型：指标、API、报表<br>编码规则：信息分类及编码模型规则</p></blockquote><p><strong>都柏林核心元素集</strong><br><strong>MOF规范</strong>：Meta Object Facility，称为元对象设施，四层元模型框架</p><blockquote><img src="https://qizhongyi.gitee.io/images/Data/DataManage/DM_MOF模型.png" /><ol><li>M3层，元元模型层：MOF为定义元模型提供的结构，包含类、属性、关联等</li><li>M2层，元模型层：由MOF构造的实例组成，包括内容模型中文件对应的类、文件的属性、内容模型之间的关系，类型等</li><li>M1层，模型层：是元模型层结构的实例，包含各类模型，如File类、Folder类等</li><li>M0层，对象层：模型构造的实例，对象和数据，体现现实世界中的事物对象　</li></ol></blockquote><h2 id="3-3-定义元数据架构"><a href="#3-3-定义元数据架构" class="headerlink" title="3.3 定义元数据架构"></a>3.3 定义元数据架构</h2><h3 id="3-3-1-功能"><a href="#3-3-1-功能" class="headerlink" title="3.3.1 功能"></a>3.3.1 功能</h3><blockquote><p>元数据采集、存储、查找、变更控制和对比分析能力；支持多种数据源<br>血缘分析/关系分析能力，支持字段级别的血缘<br>基于角色的访问权限控制和分层能力<br>业务元数据管理能力<br>数据生命周期管理能力<br>与其他系统的集成能力</p></blockquote><h3 id="3-3-2-元数据架构"><a href="#3-3-2-元数据架构" class="headerlink" title="3.3.2 元数据架构"></a>3.3.2 元数据架构</h3><ul><li><p><strong>集中式元数据架构</strong>：单一的元数据存储库，包含来自不同的院的原数据副本</p><p><strong>优点</strong></p><blockquote><p>高可用性，独立于源系统<br>快速的元数据检索，存储库和查询功能在一起<br>解决了数据库结构问题，使其不受第三方或商业系统特有属性的影响<br>抽取元数据时可进行转换、自定义或使用其他源系统中的元数据进行补充，提高了元数据质量</p></blockquote><p><strong>缺点</strong></p><blockquote><p>维护集中式存储库的成本可能很高<br>必须使用复杂的流程确保元数据源头中的更改能够快速同步到存储库中<br>元数据的抽取可能需要自定义模块或中间件<br>验证和维护自定义代码会增加对内部 IT 人员和软件供应商的要求</p></blockquote></li><li><p><strong>分布式元数据架构</strong>：一个完全分布式架构中维护一个单一的接入点，元数据检索引擎通过实时从源系统检索数据来响应用户请求，分布式元数据架构没有持久化的存储库<br><strong>优点</strong></p><blockquote><p>元数据是从其他数据源中直接检索的，总是尽可能保持最新且有效<br>查询是分布式的，可能会提高响应和处理的效率<br>来自专有系统的元数据仅限于查询处理，最大限度的减少实施和维护所需的工作量<br>自动化元数据查询处理的开发更简单<br>减少了批处理，没有原数据复制或同步过程</p></blockquote><p><strong>缺点</strong></p><blockquote><p>无法支持用户定义或手动插入元数据项<br>需要统一的、标准化的展示方式呈现来自不同系统的元数据<br>查询功能受源系统可用性影响<br>元数据质量完全取决于源系统</p></blockquote></li><li><p><strong>混合式元数据架构</strong>：结合了集中式和分布式的特性，元数据直接从源系统移动到集中式存储库，仅考虑用户添加的源数据重要的标准化元数据、以及手工来源添加的元数据</p></li><li><p><strong>双向元数据架构</strong>：允许元数据在架构的任何部分进行更改，然后将变更从存储库同步到其原始源实现反馈</p></li></ul><h3 id="3-3-3-构建过程"><a href="#3-3-3-构建过程" class="headerlink" title="3.3.3 构建过程"></a>3.3.3 构建过程</h3><ol><li><p><strong>创建元模型</strong>：创建元数据存储库的数据模型</p></li><li><p><strong>应用元数据标准</strong>：遵循元数据战略中定义的对内对外标准，监督标准的执行情况</p></li><li><p><strong>管理元数据存储</strong>：实施控制活动管理元数据环境</p><p> <strong>日常控制活动</strong>：作业调度和监控；家在统计分析；备份、恢复、归档、消除；配置修改；性能调优；查询统计分析；查询和报表生成；安全管理<br> <strong>质量控制活动</strong>：质量保证、质量控制；数据更新频率源时间表匹配；缺失元数据报告；未更新的元数据报告<br> <strong>元数据管理活动</strong>：加载、探测、导入和标记数据资产；记录余元的映射和迁移关系；记录版本；用户界面管理；连接数据集的元数据维护，为NoSQL提供支持；数据对内数据采集建立连接，自定义连接和作业元数据；外部数据源和订阅源的许可<br> <strong>培训活动</strong>：教育和培训用户的数据专员；生成和分析管理指标；对控制活动、查询、报告进行培训</p></li></ol><h2 id="3-4-创建和维护元数据"><a href="#3-4-创建和维护元数据" class="headerlink" title="3.4 创建和维护元数据"></a>3.4 创建和维护元数据</h2><h3 id="3-4-1-元数据技术"><a href="#3-4-1-元数据技术" class="headerlink" title="3.4.1 元数据技术"></a>3.4.1 元数据技术</h3><p><strong>Metacat</strong>：管理技术元数据，数据字典类，支持多数据源的可扩展架构</p><p><strong>IBM InfoSphere 和 Congos</strong>：IBM 公司集成企业元数据的解决方案</p><p><strong>SQLFlow</strong></p><p><a href="https://qizhongyi.gitee.io/202203/1519375.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Atlas</strong></font></a>：管理数据血缘，采用方案2，通过 Neo4j （图数据库）存储</p><ol><li>静态解析SQL，获取输入表和输出表，获得血缘：存在SQL语法错误问题</li><li>实时抓取正在执行的SQL，解析执行计划，获得血缘</li><li>解析任务日志，获取已执行SQL的输入表和输出表，获得血缘：可以确保准确，但时效性较差，需要分析大量任务日志数据</li></ol><p><strong>Clogdera Navigator</strong>：付费商业产品</p><ol><li><p><strong>整合元数据</strong>：集成过程中从整个企业范围内收集和整合元数据，包括从企业外部获取数据中的元数据，使用适配器、扫描仪、网桥应用程序或直接访问源数据存储来提取元数据</p><blockquote><p><strong>专用接口</strong>：采用单步方式，扫描程序从源系统中采集元数据，直接调用特定格式的装载程序将元数据加载到元数据存储中，元数据采集和装载一步完成<br><strong>半专用接口</strong>：采用两步方式，扫描程序从源系统中采集元数据，并输出到特定格式的数据文件中，只产生目标存储库能够正确读取和加载的数据文件，可通过多种方式读取数据文件</p><blockquote><p>控制文件：包含数据模型的数据源结构信息<br>重用文件：包含管理装载流程的重用规则信息<br>日志文件：每一阶段、每次扫描或抽取生成的日志文件<br>临时和备份文件：在流程中使用或做追溯流程使用的文件</p></blockquote></blockquote></li><li><p><strong>发布和传递元数据</strong></p><blockquote><p>元数据内部网站，提供浏览、搜索、查询、报告和分析功能<br>报告、术语表和其他文档<br>数据仓库、数据集市和 BI工具<br>建模和软件开发工具<br>消息传送和事物<br>Web 服务和应用程序接口<br>外部组织接口方案</p></blockquote></li><li><p><strong>查询和分析元数据</strong></p></li></ol><h2 id="3-5-度量指标"><a href="#3-5-度量指标" class="headerlink" title="3.5 度量指标"></a>3.5 度量指标</h2><p><strong>元数据存储库完整性</strong>：将企业元数据的理想覆盖率与实际覆盖率进行比较<br><strong>元数据管理成熟度</strong>：根据能力成熟度模型的成熟度评估方法，开发用于判断企业元数据成熟度的指标<br><strong>专职人员配备</strong>：通过专职人员的任命情况、整个企业的专职人员覆盖范围，以及职位描述中的角色定义说明，来评估组织对元数据的承诺<br><strong>元数据使用情况</strong>：通过存储库的访问次数衡量用户对元数据存储库的使用情况和接受程度<br><strong>业务术语活动</strong>：显示 SOA解决方案中数据的重用情况<br><strong>元数据文档质量</strong>：自动评估方式包括两个源执行冲突逻辑的对比、测量二者匹配的程度以及随时间推移的变化趋势；度量具有定义属性的百分比，以及随时间推移而发生变化的趋势；手动评估包括基于企业质量定义进行随机或完整的调查<br><strong>元数据存储库可用性</strong>：正常运行的时间、处理时间（批处理或查询）</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
            <tag> 元数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据仓库和商务智能-基础</title>
      <link href="/202108/2634627.html"/>
      <url>/202108/2634627.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录数据仓库和商务智能相关内容</p><span id="more"></span><h1 id="1-数据仓库和商务智能"><a href="#1-数据仓库和商务智能" class="headerlink" title="1. 数据仓库和商务智能"></a>1. 数据仓库和商务智能</h1><p>**数据仓库 **：Data Warehouse，简写为DW或DWH，是一个面向主题的、集成的、稳定的、随时间变化的数据集合，是面向分析的集成化数据环境，通过形成分析报告和各类报表提供企业决策支持<br><strong>商务智能</strong>：包括理解组织诉求和寻找机会的数据分析活动，及其相关的技术集合。促成了数据挖掘、报表分析、数据可视化等</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><blockquote><p>方便地存取数据，及时、一致地展示信息<br>支持商务智能活动<br>赋能商业分析和高效决策<br>能够适应实时变化，基于数据洞察寻找创新方法</p></blockquote><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><blockquote><p>聚焦业务：确保数据仓库用于组织最优先级的业务并解决业务问题<br>以终为始：以业务优先级和最终交付成果驱动数据仓库内容建设<br>规划指导：进行全局性的思考和设计，局部进行行动和建设<br>持续优化：以原始数据为基础，不断汇总聚合，满足业务和性能要求<br>透明简单：提升透明度和自助服务<br>数据溯源：与数据仓库一起建立元数据库，解决数据溯源问题<br>协同合作：与数据治理、数据质量、元数据管理协同推进<br>个性推荐：为每种数据消费者提供正确的工具和产品</p></blockquote><h2 id="1-3-组成部分"><a href="#1-3-组成部分" class="headerlink" title="1.3 组成部分"></a>1.3 组成部分</h2><blockquote><p>应用程序：处理业务流程，产生明细数据，传至数据仓库和操作性数据存储，用作数据分析<br>数据暂存区：介于业务系统源数据库和目标数据仓库之间的临时存储数据库，用于数据抽取、转换和加载，对最终用户透明<br>集成与转换：将来自不同数据源的数据转换整合为数仓和 ODS里的标准企业模型<br>操作性数据存储：ODS，Operational Data Store，是业务数据的集成数据库，仅存储当前、近期的数据<br>数据集市：为后续的数据分析提供必须的数据，用于支持特定分析和特定种类的消费者<br>操作型数据集市：OpDM，是专注于运营决策支持的数据集市<br>数据仓库：为企业数据提供一个统一的整合入口，以支持管理决策、战略分析和规划<br>运营报告：存数据存储中输出<br>参考数据、主数据和外部数据</p></blockquote><h2 id="1-4-区别"><a href="#1-4-区别" class="headerlink" title="1.4 区别"></a>1.4 区别</h2><blockquote><p>数据是按主题域进行组织，而不是按功能需求<br>是整合的数据，不是孤立的烟囱数据<br>是随时间变化的系列数据，而不是仅当前数据<br>数据在数据仓库中的延迟比在应用程序中高<br>数据仓库中提供的历史数据比应用程序中提供的历史数据多</p></blockquote><h2 id="1-5-管理活动"><a href="#1-5-管理活动" class="headerlink" title="1.5 管理活动"></a>1.5 管理活动</h2><ul><li><strong>确认需求</strong>：包括业务领域及其范围内流程的安政业务背景</li><li><strong>确定架构</strong>：描述数据的来源、去向、流动时间、目的和方式等</li></ul><blockquote><p>确定数据仓库和商务智能技术架构：提供一种能够以原子化的数据处理方式支撑交易级和运营级报表需求的机制，可以避免数据仓库存贮每一笔交易细节<br>确定数据仓库和商务智能管理流程：通过协调和集成维护流程进行生产管理，定期向业务团队发布</p></blockquote><ul><li><strong>开发数据仓库</strong></li></ul><blockquote><p>将源映射到目标<br>修正和转换数据</p></blockquote><ul><li><strong>加载数据仓库</strong>：将经过数据准备和预处理的数据加载到数据仓库，主要考虑时效性要求、源可用性、一致性等</li><li><strong>实施商务智能产品组合</strong>：为业务部门选择合适的工具</li></ul><blockquote><p>根据需要求给用户分组<br>将工具与用户需求相匹配</p></blockquote><ul><li><strong>维护数据产品</strong></li></ul><blockquote><p>发布管理：新增功能、增强生产部署，确保为已部署的资产提供定期维护<br>管理数据产品开发生命周期：为下一次迭代做准备<br>监控和调优加载过程：监控整个系统的加载处理，了解性能瓶颈和性能依赖路径<br>监控和调优商务智能活动和性能：定义和显示一组面向客户满意度的指标</p></blockquote><h2 id="1-6-度量指标"><a href="#1-6-度量指标" class="headerlink" title="1.6 度量指标"></a>1.6 度量指标</h2><ul><li>使用指标</li><li>主题域覆盖率</li><li>响应时间和性能指标</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据仓库 </tag>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主数据管理-基础</title>
      <link href="/202108/2554322.html"/>
      <url>/202108/2554322.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 主数据管理 的相关基础知识</p><span id="more"></span><h1 id="1-参考数据和主数据管理"><a href="#1-参考数据和主数据管理" class="headerlink" title="1. 参考数据和主数据管理"></a>1. 参考数据和主数据管理</h1><p><strong>主数据</strong>：是描述核心业务实体的数据，是企业的核心业务对象、交易业务的执行主体。如雇员、客户、产品等，以通用和抽象概念形式为业务交易和分析提供语境数据，包括业务交易涉及的内部和外部的详细信息（定义和标识符），以满足跨部门业务协同需要、反映核心业务实体状态属性的基础信息，相对固定，变化缓慢<br><strong>参考数据</strong>：描述组织中的其他数据，或将组织数据与外部信息联系起来，如代码表和描述表</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><blockquote><p>确保组织在各个流程中都拥有完整、一致、最新且权威的参考数据和主数据<br>促使组织在各业务单元和应用系统之间共享参考数据和主数据<br>通过标准的、通用的数据模型和整合模式，降低数据使用和数据整合的成本及复杂性</p></blockquote><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><blockquote><p>共享数据：参考数据和主数据在企业范围内共享<br>所有权：参考数据和主数据的所有权属于整个组织<br>质量控制：参考数据和主数据需要持续进行数据质量监控和治理<br>管理职责：业务数据管理员保证和控制参考数据和主数据的质量<br>变更控制：在实施变更前应该进行沟通并获得批准<br>权限控制：建立主数据库存储从记录系统提取的参考数据和主数据，实现共享</p></blockquote><h1 id="2-参考数据"><a href="#2-参考数据" class="headerlink" title="2. 参考数据"></a>2. 参考数据</h1><h2 id="2-1-参考数据存储技术"><a href="#2-1-参考数据存储技术" class="headerlink" title="2.1 参考数据存储技术"></a>2.1 参考数据存储技术</h2><ul><li><strong>关系数据库中的代码表</strong>：通过外键与其他表链接，以保持数据库管理系统中的参照完整性</li><li><strong>参考数据库管理系统</strong>：用于维护业务实体，允许未来状态、弃用值以及术语映射规则，以支持更广泛的应用和数据整合使用</li><li><strong>元数据指定允许值</strong>：用特定于对象属性的元数据指定允许值，重点在于应用程序的调用接口或用户界面访问</li></ul><h2 id="2-2-参考数据结构"><a href="#2-2-参考数据结构" class="headerlink" title="2.2 参考数据结构"></a>2.2 参考数据结构</h2><ul><li><strong>列表</strong>：由代码值和代码描述组成的列表</li><li><strong>交叉参考数据列表</strong>：由不同应用场景标识相同内容的代码值和代码描述组成的列表</li><li><strong>分类法</strong>：分类参考数据体系根据不同级别的差异性获取信息，分类法利用内容分类和多方位导航支持商务智能</li><li><strong>本体</strong>：将用于管理网站内容的本体作为参考数据</li></ul><h2 id="2-3-分类"><a href="#2-3-分类" class="headerlink" title="2.3 分类"></a>2.3 分类</h2><ul><li><strong>专有参考数据</strong>：组织内部特有的规范形成的参考数据，支持内部流程和应用，通常随时间变化而快速增长</li><li><strong>行业参考数据</strong>：由行业协会或政府机构创建和维护的数据集，为编码重要的概念提供通用标准</li><li><strong>地理参考数据</strong>：根据地理信息进行分类或分析</li><li><strong>计算参考数据</strong>：通用的、持续计算的数据，如汇率</li><li><strong>标准参考数据集的元数据</strong>：解决参考数据随时间变化而变化的问题</li></ul><h1 id="3-主数据"><a href="#3-主数据" class="headerlink" title="3. 主数据"></a>3. 主数据</h1><blockquote><p>参与方：如个人和组织，及其扮演的角色，如客户、厂商、雇员等<br>产品和服务：包括内部和外部的产品及服务<br>财务体系：如合同、总账、成本中心、利润中心<br>位置信息：地址和 GPS坐标</p></blockquote><ul><li><strong>参与方主数据</strong>：是关于个人、组织及其在业务关系中扮演角色的数据</li></ul><blockquote><p>个人和组织扮演角色之间关系的复杂性<br>唯一标识的困难<br>数据源的数量及其之间的差异<br>多个移动通信信道和社交媒体<br>数据的重要性<br>客户的参与期望</p></blockquote><ul><li><strong>财务主数据</strong>：包括有关业务部门、成本中心、利润中心、总账账户、预算、计划和项目的数据</li><li><strong>法律主数据</strong>：包括合同、法规和其他法律事务的数据</li><li><strong>产品主数据</strong>：专注于组织的内部产品和服务，或全行业的产品和服务</li></ul><blockquote><p>产品生命周期管理<br>产品数据管理<br>企业资源规划<br>制造执行系统<br>客户关系管理</p></blockquote><ul><li><strong>位置主数据</strong>：提供跟踪和共享地理信息的能力，并根据地理信息创建层次关系或地图</li></ul><blockquote><p>位置知参考数据包括行政区域数据，如国家、省/州的编号或邮政编码，以及地理位置坐标<br>位置主数据包括业务方地址和位置，以及组织拥有设备的地址和位置</p></blockquote><ul><li><strong>行业主数据</strong>：参考目录是主数据实体的权威清单，组织可以购买和使用主数据实体作为交易的基础</li></ul><blockquote><p>为新纪录的匹配和连接提供起始点<br>提供在记录创建时可能较难获得的其他数据元素<br>当组织记录与参考目录匹配、协调时，可信记录将偏离参考目录，并且可以追溯到其他源记录，贡献属性和转换规则</p></blockquote><p><strong>特点</strong>：跨部门、跨流程、跨主题、跨系统、跨技术</p><h2 id="3-1-主数据管理"><a href="#3-1-主数据管理" class="headerlink" title="3.1 主数据管理"></a>3.1 主数据管理</h2><h3 id="3-1-1-管理目的"><a href="#3-1-1-管理目的" class="headerlink" title="3.1.1 管理目的"></a>3.1.1 管理目的</h3><blockquote><p>显示数据在整个组织中的共享使用情况<br>在管理系统和应用程序中识别数据的血缘关系<br>辅助进行问题根本原因的分析<br>展示数据整合和消费整合技术的有效性<br>通过数据消费展示源系统的数据值延迟<br>确定在集成组件中执行的业务规则和和转换的有效性</p></blockquote><h3 id="3-1-2-管理步骤"><a href="#3-1-2-管理步骤" class="headerlink" title="3.1.2 管理步骤"></a>3.1.2 管理步骤</h3><p>理需求—画蓝图—定职责—定标准—洗数据—搭平台—接服务—建体系—促应用</p><ul><li><strong>主数据识别</strong>：识别主数据实体和候选数据源</li><li><strong>数据模型管理</strong>：形成清晰一致的逻辑数据定义</li><li><strong>数据采集</strong>：提取主数据实体</li></ul><blockquote><p>接受并应对新的数据源采集要求<br>使用数据清理和数据分析工具进行快速、即时、匹配和高级的数据质量评估<br>评估数据并将数据整合的复杂性传递给请求者，以帮助他们进行成本效益分析<br>试点数据采集及其对匹配规则的影响<br>为新数据源确定数据质量指标<br>确定由谁负责监控和维护新数据源的质量<br>完成与整体数据管理环境的集成</p></blockquote><ul><li><strong>数据验证、标准化和数据丰富</strong>：尽可能保持数据一致，实现实体解析</li></ul><blockquote><p>验证：识别被证明是错误的或可能不正确的或默认的数据<br>标准化：确保数据内容符合标准参考数据值、标准格式<br>数据丰富：添加可以改进实体解析服务的属性</p></blockquote><ul><li><strong>实体解析和标识符管理</strong></li></ul><blockquote><p>匹配：匹配或候选识别是识别不同记录与单个实体相关联的过程</p><blockquote><p>假阳性：不代表同一实体的两个对象被关联在一个标识符下，导致一个标识符指向多个现实世界的实体实例<br>假阴性：代表同一实体的两个对象没有关联在一个标识符下，导致多个标识符指向现实世界的多个实体实例，而一个实体应只对应一个标识符<br>确定式算法：解析和标准化依靠确定的模式和规则，按照制定的权重计算相似度分值<br>或然式算法：依赖于训练数据的采集能力，训练需要观察全部记录的一个子集预期结果，再进行匹配器调优，实现匹配器基于计算结果的自我调整</p></blockquote><p>身份解析：较多数值精确匹配，少量数值冲突问题</p><blockquote><p>具有相同基础信息的两条数据，联系电话、联系地址或姓名不同，是否可以确定为同一个人的修改操作<br>若唯一社会映射主键信息未知，识别其他判断匹配的标识符，匹配的标识符</p></blockquote><p>匹配流程或协调类型</p><blockquote><p>重复标识匹配规则：重点关注能唯一识别的标识实体的元素，识别合并机会并不采取合并操作<br>匹配链接规则：标识可能与主数据相关的记录，只建立交叉引用关系而不更新这些被交叉引用记录的内容<br>匹配配合规则：重点关注记录的匹配，并将这些纪录中的数据合并为单一、统一协调且全面的记录</p></blockquote><p>主数据ID管理：管理主数据涉及管理标识符，如全局标识符和交叉引用信息<br>从属关系管理：从属关系管理负责建立和维护具有现实世界关系的实体主数据记录之间的关系，如所有权从属关系、雇佣关系等</p><blockquote><p>隶属关系：通过程序逻辑提供了大量的灵活性，也可以用来表示父子层次结构<br>父子关系：需要较少的程序逻辑<br>数据共享和管理责任：通过管理工作解决数据错误匹配问题</p></blockquote></blockquote><h3 id="3-1-3-主数据业务标准"><a href="#3-1-3-主数据业务标准" class="headerlink" title="3.1.3 主数据业务标准"></a>3.1.3 主数据业务标准</h3><blockquote><p>编码规则：主数据代码的编码规则<br>分类规则：按照业务环境和管理需求形成分类原则<br>描述规则：又称命名规范</p></blockquote><h3 id="3-1-4-主数据清洗要求"><a href="#3-1-4-主数据清洗要求" class="headerlink" title="3.1.4 主数据清洗要求"></a>3.1.4 主数据清洗要求</h3><blockquote><p>唯一性：在满足业务需求下不允许重复<br>准确性：数据内容与对应客观实体一致<br>完整性：数据不存在缺失记录或缺失字段<br>一致性：同一实体同一属性在不同系统中一致<br>有效性：数据满足客观实体的业务规范</p></blockquote><h3 id="3-1-5-主数据整合中心环境"><a href="#3-1-5-主数据整合中心环境" class="headerlink" title="3.1.5 主数据整合中心环境"></a>3.1.5 主数据整合中心环境</h3><ul><li>注册表：指向多种记录系统中主数据记录的索引，记录系统管理应用程序本地的主数据</li><li>交易中心：各应用系统与中心系统交互，实现对主数据的访问和更新</li><li>混合模式：注册表和交易中心的混合体</li></ul><h3 id="3-1-6-应用方式"><a href="#3-1-6-应用方式" class="headerlink" title="3.1.6 应用方式"></a>3.1.6 应用方式</h3><blockquote><p>数据订阅/分发服务<br>主数据查询服务<br>主数据申请服务<br>数据调用API服务<br>公共数据资源池</p></blockquote><h3 id="3-1-7-衡量标准"><a href="#3-1-7-衡量标准" class="headerlink" title="3.1.7 衡量标准"></a>3.1.7 衡量标准</h3><blockquote><p>反复引用的角色、组织、地点和事物<br>被用来描述人、组织、地点和事物的数据<br>数据的来源，存储、提供和访问位置<br>组织系统内的数据变化过程<br>数据使用者和使用目的<br>衡量数据来源及其质量和可靠性的方式</p></blockquote><h2 id="3-2-度量指标"><a href="#3-2-度量指标" class="headerlink" title="3.2 度量指标"></a>3.2 度量指标</h2><blockquote><p>数据质量和遵从性<br>数据变更活动<br>数据获取和消费<br>服务水平协议<br>数据管理专员覆盖率<br>拥有总成本<br>数据共享量和使用情况</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
            <tag> 主数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据文件和内容管理-基础</title>
      <link href="/202108/2426382.html"/>
      <url>/202108/2426382.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍文件和内容管理相关的基础内容</p><span id="more"></span><h1 id="1-文件和内容管理"><a href="#1-文件和内容管理" class="headerlink" title="1. 文件和内容管理"></a>1. 文件和内容管理</h1><p><strong>文件内容管理</strong>：针对存储在关系型数据库之外的数据和信息的采集、存储、访问和使用过程的管理，重点保证文件和非结构化、半结构化数据的信息完整性</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><blockquote><p>确保能够高速有效的采集使用非结构化数据与信息<br>确保结构化和非结构化数据之间的整合能力<br>遵守法律业务并达到客户预期</p></blockquote><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><blockquote><p>问责制度：指派适当的高级管理人员，采用制度和流程来指导员工，并确保计划的可审计性<br>完整原则：建立信息治理和规划，使组织创建或管理的档案和信息具有合理性以及适当的真实性和可靠性保证<br>保护原则：建立信息治理和规划，确保对个人信息或其他需要保护的信息提供合理的保护<br>遵从原则：建立信息治理和规划，遵从适用的法律法规和其他有约束力的机构及组织的制度要求<br>可用原则：组织应确保已及时、高效和准确检索信息的原则维护信息<br>保留原则：基于运营、法律、监管和财政以及其他所有相关约束的要求确保组织保留适当的时间<br>处置原则：根据制度、适用的法律法规以及其他有约束力的机构要求，提供安全和适当的信息处置<br>透明原则：组织应以工作人员和利益相关方可以理解的方式记录其制度、流程和活动，包括信息治理规划</p></blockquote><h2 id="1-3-内容分发"><a href="#1-3-内容分发" class="headerlink" title="1.3 内容分发"></a>1.3 内容分发</h2><ul><li><strong>推式分布</strong>：用户按照预先确定的时间表选择传送给他们的内容类型，发布方创建内容并在多处发布，如简易信息聚合</li><li><strong>拉式分发</strong>：用户通过互联网获取内容，如在线零售店</li><li><strong>交互分发</strong>：交互式内容分布方法，如第三方电子销售点</li></ul><h3 id="1-3-1-受控词表"><a href="#1-3-1-受控词表" class="headerlink" title="1.3.1 受控词表"></a>1.3.1 受控词表</h3><p><strong>受控词表</strong>：被明确允许用于通过浏览和搜索对内容进行索引、分类、标引、排序和检索术语的定义列表，如都柏林元素集</p><ul><li><strong>词汇表管理</strong>：与时俱进的维护词汇表，满足采用一致并便于检索的方式描述内容对象</li></ul><blockquote><p>确定支持的信息概念<br>确定词汇表受众、支持流程和角色<br>评估词汇表的必要性，支持应用、内容管理或分析<br>确定首选术语的制定机构<br>确定现有词汇表的创建方式、负责人、信息分类现状和安全隐私问题现状等<br>确定现有词汇表的业务支持度</p></blockquote><ul><li><strong>词汇表视图或微控制词汇表</strong>：词汇表视图是受控词表的子集，涵盖了受控词表领域内有限范围的主题；微控制词汇表包含一般词汇表中不包含的高度专业化术语的词汇表</li><li><strong>术语和选择列表</strong>：术语列表不描述术语之间的关系，仅列举出术语；选择列表通常隐藏在应用程序中，选择列表和控制词汇转换为可用于主页搜索的选择列表</li><li><strong>术语管理</strong>：建立术语之间的关系</li></ul><blockquote><p>等价术语关系：同时使用多个不交叉的术语，常用的属于映射功能<br>层次化关系：描述一般到特定或整体到局部的关系<br>关联关系：受控词汇表中非层次化关联的术语</p></blockquote><ul><li><strong>同义词环和规范表</strong>：同义词环是指一组大致相同的术语，允许用户搜索访问同义词环中的其他内容；规范表是指描述性的受控词汇表，旨在促进特定领域或范围内的信息检索</li><li><strong>分类法</strong>：指任何分类或受控词汇表的总称</li></ul><blockquote><p>扁平分类法：受控类别集之间没有关系，类别平等<br>层次分类法：一种节点通过规则关联的树状结构，至少有两个结构，且是双向的<br>多重层级结构：具有多个节点关系规则的树状结构，可以有多个父节点<br>面分类法：每个节点与中心节点相关联，每个面都是中心对象的一个属性<br>网状分类法：既可用于层级结构，可以用于刻面结构，两个节点依赖关联建立连接，如搜索引擎</p></blockquote><ul><li><strong>分类方案和打标签</strong>：分类方案是代表受控词表的代码，如杜威十进制分类法</li><li><strong>主题词表</strong>：又称叙词表，是一种用于内容检索的受控词表，结合了同义词环和分类方案的特征，提供相关的每个术语及其相关术语的关系信息，相关标准有 ISO 25964、ANSI / NISO Z39.19等</li><li><strong>本体</strong>：代表一套概念和在某个领域内概念之间的关联，提供语义网络的基本知识代表，用于语义网络与应用程序之间的信息交换</li></ul><blockquote><p>无法区分实例关系和子类关系<br>将事件建模为关系<br>术语缺乏清晰度和独特性<br>将角色建模为类<br>无法重复使用<br>混淆建模语言的语义和概念</p></blockquote><h2 id="1-4-文件和档案管理"><a href="#1-4-文件和档案管理" class="headerlink" title="1.4 文件和档案管理"></a>1.4 文件和档案管理</h2><p><strong>文件</strong>：包含任务说明，对执行任务的方式和时间要求，以及任务执行和决策的日志等电子或纸质对象<br><strong>档案</strong>：用于证明所作决策和采取行动是符合程序的，可作为组织业务活动和法规遵从的证据</p><h3 id="1-4-1-文件档案生命周期"><a href="#1-4-1-文件档案生命周期" class="headerlink" title="1.4.1 文件档案生命周期"></a>1.4.1 文件档案生命周期</h3><blockquote><p>编目：识别已有的新建的文件或档案<br>制度：创建、批准和实施文件档案的制度<br>分类：对文件档案进行分类<br>存储：结合实际业务需要，对文档和档案进行电子或纸质、长期或短期存储<br>检索和流转：在合规的前提下，允许文件档案进行访问和流通<br>保存和处置：在合规的前提下，允许文件档案进行归档和销毁</p></blockquote><h3 id="1-4-2-要求"><a href="#1-4-2-要求" class="headerlink" title="1.4.2 要求"></a>1.4.2 要求</h3><blockquote><p>内容准确、完整和真实<br>背景充足，包括创建者、创建时间、与其他档案关系的描述性信息等<br>档案在事件、行为和决定发生后及时创建<br>建立档案后，在法定保存期限内不允许轻易改变<br>档案内容的外观和排版结构需要清晰易读</p></blockquote><h3 id="1-4-3-成熟度评估"><a href="#1-4-3-成熟度评估" class="headerlink" title="1.4.3 成熟度评估"></a>1.4.3 成熟度评估</h3><ul><li>1级：低于标准：信息治理和档案保管问题没有得到解决，或只是最低限度的解决</li><li>2级：意识发展：认识到信息治理和档案保管可能对组织的影响</li><li>3级：基本保证：满足法律法规和行业规范的最低要求</li><li>4级：积极发展：拥有以持续改进为重点的主动信息治理计划</li><li>5级：完成变革：信息治理融入到组织的基础架构和业务流程中</li></ul><h2 id="1-5-管理实践"><a href="#1-5-管理实践" class="headerlink" title="1.5 管理实践"></a>1.5 管理实践</h2><h3 id="1-5-1-创建内容处理制度"><a href="#1-5-1-创建内容处理制度" class="headerlink" title="1.5.1 创建内容处理制度"></a>1.5.1 创建内容处理制度</h3><blockquote><p>审计的范围和合理性<br>重要档案的鉴定和保护<br>保留档案的目的和保管期限表<br>如何响应信息保留命令（特殊保护令），针对已过保留期的诉讼信息要求<br>本地和异地存储档案的要求<br>硬盘驱动器和共享网络驱动器的使用和维护<br>对电子邮件管理，从内容管理的角度进行处理<br>合理的档案销毁方法，如预先批准供应商和销毁证据的收据<br>社交媒体制度<br>设备访问制度<br>处理敏感数据<br>应对诉讼</p><blockquote><p>给每个部门（法律、档案管理、IT）建立制度和过程清单<br>为各主题起草制度，如诉讼保留、文件保管、归档和备份<br>评估IT工具的能力，如电子取证索引、搜索和收集、数据隔离和保护工具以及非结构化 ESI源<br>识别和分析相关的法律问题<br>指定沟通和培训计划<br>确定提前准备的材料，根据法律案例进行裁剪<br>在需要外部服务的情况下分析供应商服务<br>制定如何处理通知的流程并保持指引手册的最新状态</p></blockquote></blockquote><h3 id="1-5-2-定义内容信息架构"><a href="#1-5-2-定义内容信息架构" class="headerlink" title="1.5.2 定义内容信息架构"></a>1.5.2 定义内容信息架构</h3><blockquote><p>受控词表<br>分类法和本体<br>元数据映射<br>搜索功能规格<br>用例<br>用户流</p></blockquote><h3 id="1-5-3-实施生命周期管理"><a href="#1-5-3-实施生命周期管理" class="headerlink" title="1.5.3 实施生命周期管理"></a>1.5.3 实施生命周期管理</h3><blockquote><p>获取档案和内容<br>管理版本的控制</p><blockquote><p>正式控制：需要正式的变更启动、对影响的全面评估、变更管理机构的决策以及利益相关方一份全面执行和验证的状态报告<br>修订控制：需要在变更时通知利益相关方并升级版本<br>托管控制：最不正式，仅需要安全存储黑桃检索方法</p></blockquote><p>备份和恢复<br>管理保管和处置<br>审计文件和档案</p><blockquote><p>定义组织驱动因素<br>确定检查、测量的内容和要使用的工具<br>收集数据<br>报告结果<br>制定下一步计划和时间表</p></blockquote></blockquote><h3 id="1-5-4-分布和分发布内容"><a href="#1-5-4-分布和分发布内容" class="headerlink" title="1.5.4 分布和分发布内容"></a>1.5.4 分布和分发布内容</h3><blockquote><p>开放访问、搜索和检索<br>通过可接受的渠道分发</p></blockquote><h2 id="1-6-数据格式"><a href="#1-6-数据格式" class="headerlink" title="1.6 数据格式"></a>1.6 数据格式</h2><ul><li>**可扩展标示语言(XML)**：是一种表示结构化和非结构化数据和信息的语言，将数据结构转换为用于数据交换的文件结构，通过简单的嵌套和引用提供数据元素之间的关系</li></ul><blockquote><p>能够将结构化数据整合到具有非结构化数据的关系型数据库中，非结构化数据可以存储在关系型数据管理系统中的 BLOB（二进制大对象）或 XML文件中<br>可以将结构化数据与文件、报表、电子邮件、图像、图形、音频和视频文件中的非结构化数据集成在一起<br>可以用于建立公司门户网站（B2B、B2C），为用户提供一个可以连接到各种内容的接入点<br>可以识别标记非结构化内容，以便进行理解和处理</p></blockquote><ul><li><strong>JSON</strong>：Java Script Object Notation，基于 JavaScript 的轻量数据交换格式，一种开放的、轻量级的数据交换标准格式，基于C语言的习惯方式，有键值对和数组两种存储结构</li><li><strong>资源描述框架(RDF)<strong>：是描述各种网络资源信息的通用框架，用于在 Web 上进行数据交换的标准模型，RDF 以主语（资源）—谓语（属性名称）—宾语（属性值）表达式或三元组描述资源，主谓宾都由统一资源标示符(URI)描述，谓语不允许为空；</strong>网络本体语言</strong>（W3C Web Ontology Language）是 RDF 的词汇表拓展，是一种语义标记语言，用于在网络上发布共享 OWL文件（本体）</li><li><strong>Schema.org</strong>：用于页面标记的共享词汇表或模式，便于主流搜索引擎理解</li></ul><h2 id="1-7-度量指标"><a href="#1-7-度量指标" class="headerlink" title="1.7 度量指标"></a>1.7 度量指标</h2><ul><li><strong>档案管理</strong></li></ul><blockquote><p>每个用户被认为是公司档案的文件和电子邮件比率<br>公司档案的控制率<br>所有存储的档案应用适当的保管规则的比率</p></blockquote><ul><li><strong>电子取证</strong></li><li><strong>企业内容管理</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据集成与互操作-基础</title>
      <link href="/202108/2311121.html"/>
      <url>/202108/2311121.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍数据集成和互操作相关的基础内容</p><span id="more"></span><h1 id="1-数据集成与互操作"><a href="#1-数据集成与互操作" class="headerlink" title="1. 数据集成与互操作"></a>1. 数据集成与互操作</h1><p><strong>数据集成和互操作</strong>：描述了数据在不同数据存储、应用程序和组织三者内部和之间进行移动和整合的相关过程，数据集成是将数据整合成，核心是ETL操作</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><blockquote><p>及时以数据消费者所需的格式提供数据<br>将数据物理地或虚拟地合并到数据中心<br>通过开发共享模型和接口来降低管理解决方案的成本和复杂度<br>识别有意义的事件，自动触发警报并采取行动<br>支持商务智能、数据分析、主数据管理以及运营效率的提升</p></blockquote><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><blockquote><p>采用企业视角通过迭代和增量交付确保未来的可扩展性设计<br>平衡本地数据需求与企业需求<br>确保数据集成和互操作设计和活动的可靠性</p></blockquote><h2 id="1-3-功能实现"><a href="#1-3-功能实现" class="headerlink" title="1.3 功能实现"></a>1.3 功能实现</h2><blockquote><p>数据迁移和转换<br>数据整合到数据中心或数据集市<br>将供应商的软件包集成到组织的应用系统框架中<br>在不同应用程序或组织之间数据共享<br>跨数据存储库和数据中心分发数据<br>数据归档<br>数据接口管理<br>获取接受外部数据<br>结构化和非结构化数据集成<br>提供运营智能化和管理决策支持</p></blockquote><h2 id="1-4-ETL"><a href="#1-4-ETL" class="headerlink" title="1.4 ETL"></a>1.4 ETL</h2><p>ETL：将数据通过Extract（抽取）、Transform（转换）、Load（加载）的过程从源系统转移到目标系统，结合实际情况支持ELT<br><strong>抽取</strong>：从源数据中选择所需的数据进行提取<br><strong>转换</strong>：让选定的数据库与目标数据库结构相融</p><blockquote><p>格式变化：如从EBCDIC到ASCLL的格式转换<br>结构变化：从非规范化到规范化的记录<br>语义变化：保持语义的一致性表达，如代码变解释<br>消除重复：在满足业务需求的前提下，删除重复键值或记录<br>重新排序：在满足业务需求的前提下，改变数据元素或记录顺序以适应已定义的模式</p></blockquote><p><strong>加载</strong>：在目标系统中物理存储或呈现转换结果<br><strong>映射</strong>：建立源结构到目标结构的查找矩阵，明确需求源数据、抽取转换规则和使用目标数据</p><h2 id="1-5-交互模型"><a href="#1-5-交互模型" class="headerlink" title="1.5 交互模型"></a>1.5 交互模型</h2><ul><li><strong>点到点</strong>：适用于小组系统模型，系统增加时，带来的风险如下</li></ul><blockquote><p>影响处理：操作性系统中提供数据的工作量可能会影响交易处理<br>管理接口：管理系统互联接口的工作量巨大<br>潜在不一致：当多个系统需要不同的版本或数据格式时，会由于设计问题导致接口接受的数据与提供的数据不一致</p></blockquote><ul><li><strong>中心辐射型</strong>：将共享数据整合到应用程序都偶可以使用的中央数据中心</li><li><strong>发布与订阅</strong>数据订阅系统订阅数据发布系统，数据发布系统会自动推送更新数据到数据订阅系统</li></ul><h2 id="1-6-数据集成解决"><a href="#1-6-数据集成解决" class="headerlink" title="1.6 数据集成解决"></a>1.6 数据集成解决</h2><h3 id="1-6-1-集成规划"><a href="#1-6-1-集成规划" class="headerlink" title="1.6.1 集成规划"></a>1.6.1 集成规划</h3><ol><li><strong>定义数据继承和生命周期需求</strong>：涉及理解组织的业务目标，以及实现这些目标需要的数据和建议的技术方案，包括与业务数据相关的法律法规</li><li><strong>进行数据探索</strong>：确定数据集成工作确定潜在的数据来源和数据在组织中的流动信息</li><li><strong>记录数据血缘</strong>：包括组织获取或创建数据的方式，在组织中移动变化轨迹和用于分析、决策或事件触发的方式</li><li><strong>剖析数据</strong>：理解数据的内容和结构</li></ol><blockquote><p>数据结构中定义的数据格式和从实际数据中推断出的格式<br>数据的数量，包括null值、空或默认数据的级别<br>数据值以及其与定义的有效值集合的紧密联系<br>数据及内部的模式和关系，如相关字段和基数规则<br>与其他数据集的关系</p></blockquote><ol start="5"><li><strong>收集业务规则</strong>：用于定义或约束业务处理，业务规则分为专业术语定义、相互关联的术语事实、约束或行为断言以及派生</li></ol><blockquote><p>评估潜在的源数据集和目标数据集的数据<br>管理组织中的数据流<br>监控组织中的操作数据<br>指示何时自动触发事件和警报</p></blockquote><h3 id="1-6-2-设计解决方案"><a href="#1-6-2-设计解决方案" class="headerlink" title="1.6.2 设计解决方案"></a>1.6.2 设计解决方案</h3><ol><li><strong>设计解决方案</strong>：基于企业和单个解决方案两个层面统筹考虑</li></ol><blockquote><p>选择交互模式：选择点到点、中心辐射型或发布订阅交互模式，尽可能重用系统，减少开发<br>设计数据服务或交换模式：创建或重用现有的集成流来移动数据</p></blockquote><ol start="2"><li><strong>建模数据中心、接口、消息、数据服务</strong>：对数据集成和互操作中所需的数据结构、数据持久化数据结构、临时用于移动或转换的数据结构进行建模</li><li><strong>映射数据源到目标</strong>：解决源结构到目标结构的数据转换</li></ol><blockquote><p>指明源数据和目标数据的技术格式<br>指明源数据和目标数据之间所有中间暂存点所需的转换<br>描述最终或中间目标数据存储区中每个属性的填充方式<br>描述是否需要对数据值进行转换，如通过在表示适当目标值的表中查找源值<br>描述需要进行的计算类型</p></blockquote><ol start="4"><li><strong>设计数据编排</strong>：数据流程编排是从开始到结束的数据流模式，包括完成转换、事务所需的所有中间步骤</li></ol><h3 id="1-6-3-开发数据集成"><a href="#1-6-3-开发数据集成" class="headerlink" title="1.6.3 开发数据集成"></a>1.6.3 开发数据集成</h3><ol><li><strong>开发数据服务</strong>：开发服务来获取、转换和交付指定的数据，并且匹配所选的交互模型</li><li><strong>开发数据流编排</strong>：对集成或ETL数据流通常会采用专用工具以特有的方式进行开发，批量数据流通常在一个调度器（企业标准调度器）中开发，以管理执行已开发的数据集成组建的顺序、频率和依赖关系，互操作性要求开发数据存储之间的映射或协调点</li><li><strong>制定数据迁移方法</strong>：数据迁移需要将数据转换为接收应用程序的格式，数据迁移一般出现在上线新程序、应用程序退役或合并时</li><li><strong>制定发布方式</strong>：创建和维护关键数据提供给其他系统制度</li><li><strong>开发复杂事件处理流</strong></li></ol><blockquote><p>准备有关预测模型的个人、组织、产品或市场和迁移前的历史数据<br>处理实时数据流，充分填充预测模型、识别有意义的事件<br>根据预测执行触发的动作</p></blockquote><ol start="6"><li><strong>维护数据集成和互操作元数据</strong></li></ol><h2 id="1-7-度量指标"><a href="#1-7-度量指标" class="headerlink" title="1.7 度量指标"></a>1.7 度量指标</h2><blockquote><p>数据可用性：请求数据的可获得性<br>数据量和速度：包括传送和转换的数据量、分析数据量、传送速度、数据更新与可用性之间的时延、事件触发动作之间的时延、新数据元的可用时间<br>解决方案成本和复杂度：包括及解决方案开发和管理成本、获取新数据的便利性、解决和运营的复杂度、使用数据集成方案的系统数量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据安全管理-基础</title>
      <link href="/202108/2228179.html"/>
      <url>/202108/2228179.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍数据安全管理相关的基础内容</p><span id="more"></span><h1 id="1-数据安全管理"><a href="#1-数据安全管理" class="headerlink" title="1. 数据安全管理"></a>1. 数据安全管理</h1><p><strong>数据安全管理</strong>：采用各种技术和管理措施，保证数据的机密性、完整性和可用性，确保数据不被破坏，且能被适当访问，包括数据访问安全标准、监控和审计程序和存储安全标准等，包括安全策略和过程的规划</p><h2 id="1-1-管理动力来源"><a href="#1-1-管理动力来源" class="headerlink" title="1.1 管理动力来源"></a>1.1 管理动力来源</h2><blockquote><p>利益相关方：识别利益相关方隐私和保密需求<br>政府法规：保护利益相关方的利益<br>特定业务关注点：对专有数据进行特殊保护<br>合法访问需求：不同角色的人员合理的访问、使用和管理数据<br>合同义务：在合同或安全保密协议里对数据的要求</p></blockquote><h2 id="1-2-业务目标"><a href="#1-2-业务目标" class="headerlink" title="1.2 业务目标"></a>1.2 业务目标</h2><ul><li><strong>降低风险</strong><ul><li>支持适当访问并组织对企业数据资产的不当访问</li><li>支持对隐私、保护和保密制度、法规的遵从</li><li>确保满足利益相关方的隐私保密要求</li></ul></li><li><strong>业务增长</strong></li><li><strong>安全性作为资产</strong></li></ul><h2 id="1-3-管理原则"><a href="#1-3-管理原则" class="headerlink" title="1.3 管理原则"></a>1.3 管理原则</h2><blockquote><p>协同合作：由IT安全管理员、数据管理专员、内外部审计团队及法律部门协调合作<br>企业统筹：确保安全策略与企业发展战略规划一致<br>主动管理：相关人员主动、动态维护数据安全管理<br>明确责任：明确界定角色和责任<br>元数据驱动<br>减少接触以降低风险：最大限度的减少非生产环境中减少敏感、机密数据的泄漏</p></blockquote><h2 id="1-4-安全风险"><a href="#1-4-安全风险" class="headerlink" title="1.4 安全风险"></a>1.4 安全风险</h2><p><strong>安全风险</strong>：既指损失的可能性，也指构成潜在损失的事务或条件</p><h3 id="1-4-1-计算风险"><a href="#1-4-1-计算风险" class="headerlink" title="1.4.1 计算风险"></a>1.4.1 计算风险</h3><blockquote><p>威胁发生的概率及可能的频率<br>可能造成的损害类型和规模，包括声誉损害<br>损害对收入或业务运营的影响<br>发生损害后的修复成本<br>预防威胁的成本，包括漏洞修复手段<br>攻击者可能的目标或意图</p></blockquote><h3 id="1-4-2-风险漏洞"><a href="#1-4-2-风险漏洞" class="headerlink" title="1.4.2 风险漏洞"></a>1.4.2 风险漏洞</h3><blockquote><p>系统漏洞：主机、软件、安全配置问题、弱口令<br>Web漏洞：注入攻击、跨站脚本、文件包含、钓鱼攻击、信息泄露、恶意编码、表单绕过<br>数据库漏洞：数据库配置、数据库用户弱口令、弱点检测与弱点分析、补丁检测、存储过程监测等<br>基线漏洞：涵盖操作系统、数据库、中间件、防火墙、路由器、交换机等<br>滥用特权、合法职权或未经授权的特权升级等<br>服务账户或共享账户滥用<br>平台入侵攻击<br>注入漏洞<br>默认密码<br>数据备份泛滥</p></blockquote><h3 id="1-4-3-风险数据分类"><a href="#1-4-3-风险数据分类" class="headerlink" title="1.4.3 风险数据分类"></a>1.4.3 风险数据分类</h3><blockquote><p>关键风险数据：关键风险数据具有直接的财务价值，如个人信息<br>高风险数据：高风险数据为公司提供竞争优势，具有潜在的财务价值<br>中风险数据：几乎没有实际价值的组织非公开信息</p></blockquote><h2 id="1-4-4-安全管理过程"><a href="#1-4-4-安全管理过程" class="headerlink" title="1.4.4 安全管理过程"></a>1.4.4 安全管理过程</h2><ul><li><p><strong>4A</strong>：通过数据识别和分类达标、访问控制、角色组、用户和密码保证4A，保证数据安全</p><ul><li>访问（Access）：允许具有授权的用户及时正常地访问系统</li><li>审计（Audit）：审查安全操作和用户活动，确保符合法规和公司制度标准</li></ul><blockquote><p>账号审计：账号创建、销毁制度，实现“一人一账号”<br>授权审计：账号授权管理制度，实现账号权限分类、账号最小化权限控制、确定授权责任人<br>认证审计：禁止绕过安全管理平台直接跳转访问资源的违规行为<br>访问控制审计：基于地址、端口等进行访问控制<br>重要操作审计：全面记录安全运维人员的运维操作记录<br>敏感信息审计：全面分析业务敏感数据，对前 / 后台查询、删除、导出等操作进行安全管控</p></blockquote><ul><li>验证（Authentication）：在用户登录时，验证用户访问权限</li><li>授权（Authorization）：授予用户访问与其角色匹配的特定数据视图</li><li>权限（Entitlement）：是由单个访问授权决策向用户公开所有数据元素的总和</li></ul></li><li><p><strong>监控</strong>：检测意外事件（包括潜在的安全违规）的监视控制</p></li></ul><h3 id="1-4-5-安全管理策略"><a href="#1-4-5-安全管理策略" class="headerlink" title="1.4.5 安全管理策略"></a>1.4.5 安全管理策略</h3><ul><li><strong>加密</strong>：将纯文本转换为复杂代码，以隐藏特权信息、验证传送完整性或信息发送者身份</li></ul><blockquote><p>哈希加密：将任意长度的数据转换为固定长度数据表示，常见算法有MD5，SHA等<br>对称加密：一组秘钥，进行加密解密工作，数据发送方、数据接收方都持有，速度快，常见算法有DES、AES、IDEA等<br>非对称加密：两组秘钥，公钥和私钥，公钥进行加密，数据发送方、数据接收方持有；私钥进行解密，仅数据接收方持有，速度慢，常见算法有RSA加密算法、Diffie-Hellman密钥交换协议等</p></blockquote><ul><li><strong>混淆或脱敏</strong><br><strong>混淆</strong>：将数据变模糊或不明确<br><strong>脱敏</strong>：删除、打乱或以其他方式更改数据外观</li></ul><blockquote><p><strong>分类</strong></p><blockquote><p>静态脱敏（SDM）：直接通过屏蔽、变形、替换、随机格式保留加密和强加密等多种加密算法对数据进行掩码扰乱(数据存储发生改变)</p><blockquote><p>落地脱敏：当数据源（生产环境）和目标（非生产环境）相同时，可采用落地脱敏，从数据源读取未脱敏数据，进行脱敏操作后直接覆盖原始数据<br>不落地脱敏：当在数据源和目标环境之间移动需要脱敏获混淆处理时，会采用不落地脱敏</p></blockquote><p>动态脱敏（DDM）：精确解析SQL语句匹配脱敏条件，可根据IP、主机、用户、时间等改写SQL语句，返回脱敏后的数据(数据存储未改变)</p></blockquote><p><strong>方式</strong></p><blockquote><p><strong>替换</strong>：将字符或整数值替换为查找或标准模式中的字符或整数值<br><strong>混排</strong>：在一个记录中交换相同数据类型的数据或交换不同记录统一属性的值<br><strong>时空变异</strong>：将日期时间前后移动若干天，要求无法识别且小到能够保留趋势<br><strong>数值变异</strong>：应用随机因素（正负百分比等）改变数值，要求重要到不可识别且小到足以保持趋势<br><strong>取消或删除</strong>：删除不应出现在测试系统的数据<br><strong>随机选择</strong>：将部分或全部数据元素替换为随机字符或一系列单个字符<br><strong>加密技术</strong>：通过密码代码将可识别、有意义的字符流转换为不可识别的字符流，如利用  * 号屏蔽无效化，掩码屏蔽等<br><strong>表达式脱敏</strong>：通过一个表达式更改所有数据的值，如偏移、取整、集算器数据脱敏 SPL 脚本等<br><strong>键值脱敏</strong>：指定的脱敏算法或进程的结果必须是唯一且可重复的，用于数据库键值字段或类似字段脱敏</p></blockquote></blockquote><h3 id="1-4-6-全周期管理"><a href="#1-4-6-全周期管理" class="headerlink" title="1.4.6 全周期管理"></a>1.4.6 全周期管理</h3><p><strong>数据采集阶段</strong>：明确数据采集规范，制定数据采集策略，完善数据采集风险评估，确保数据采集的合规合法性<br><strong>数据传输阶段</strong>：使用合适的数据加密算法对数据进行加密传输<br><strong>数据存储阶段</strong>：制定存储介质标准和存储系统的安全防护标准<br><strong>数据处理阶段</strong>：明确需要数据脱敏的业务场景和统一的数据脱敏算法<br><strong>数据共享阶段</strong>：建立数据交换和共享的审核流程和监管平台<br><strong>数据销毁阶段</strong>：保证整个销毁过程管理和技术保障措施</p><blockquote><p>覆写法<br>消磁法<br>损坏法：捣碎、焚毁等</p></blockquote><h2 id="1-5-数据安全内容"><a href="#1-5-数据安全内容" class="headerlink" title="1.5 数据安全内容"></a>1.5 数据安全内容</h2><ul><li><strong>设施安全</strong>：抵御恶意行为人员的第一道防线仅允许授权员工访问</li><li><strong>设备安全</strong>：防止U盘、笔记本丢失被盗带来的损失<ul><li>使用移动设备连接的访问策略，如笔记本、CD、USB驱动器等</li><li>在便携式设备上存储数据</li><li>符合记录管理策略的设备数据擦除和处置</li><li>反恶意软件和加密软件安装</li><li>安全漏洞意识</li></ul></li><li><strong>凭据安全</strong><ul><li>身份管理系统</li><li>电子邮件系统的用户ID标准</li><li>密码标准</li><li>多因素识别</li><li>电子通信安全</li></ul></li></ul><h3 id="1-5-1-制约因素"><a href="#1-5-1-制约因素" class="headerlink" title="1.5.1 制约因素"></a>1.5.1 制约因素</h3><ul><li><strong>保密等级</strong></li></ul><blockquote><p>对普通受众公开<br>仅内部使用<br>机密：无恰当的保密协议或类似内容，不得在组织以外共享<br>受限机密：要求个人通过许可才能访问<br>绝密：必须签署法律协议才能访问数据</p></blockquote><ul><li><strong>监管要求</strong></li></ul><blockquote><p>法规要求：个人身份信息、财务敏感信息、医疗敏感数据或个人健康信息、教育记录等<br>行业要求：支付卡行业数据安全标准（PCI-DSS）、竞争优势或商业秘密、合同限制等</p></blockquote><h2 id="1-6-恶意软件"><a href="#1-6-恶意软件" class="headerlink" title="1.6 恶意软件"></a>1.6 恶意软件</h2><p><strong>恶意软件</strong>：是指为破坏、更改或不当访问计算机或网络而创建的软件</p><blockquote><p>广告软件：监控计算机的使用<br>间谍软件：未经同意嵌入计算机以跟踪在线活动的任何程序<br>特洛伊木马：通过伪装或嵌入合法软件进入计算机系统的恶意程序<br>病毒：将自身附加到可执行文件或易受攻击的应用程序上，产生让人讨厌到具有破坏性的后果<br>蠕虫：自己在可以网络中进行复制和传播的程序</p></blockquote><h2 id="1-7-数据安全架构"><a href="#1-7-数据安全架构" class="headerlink" title="1.7 数据安全架构"></a>1.7 数据安全架构</h2><blockquote><p>用于管理数据安全的工具<br>数据加密标准和机制<br>外部供应商和承包商的数据访问指南<br>通过互联网的数据传输协议<br>文档要求<br>远程访问标准<br>安全漏洞事件报告规程</p></blockquote><h3 id="1-7-1-安全实施控制"><a href="#1-7-1-安全实施控制" class="headerlink" title="1.7.1 安全实施控制"></a>1.7.1 安全实施控制</h3><ul><li><p><strong>分配密级</strong>：根据组织分类方案，确定合适的数据密级</p></li><li><p><strong>分配监管类别</strong>：创建采用能确保满足法规遵从要求的分类方案</p></li><li><p><strong>管理维护数据安全</strong></p><ul><li>控制数据可用性 / 以数据为中心的安全性</li><li>监控用户身份验证和访问行为：缺乏自动化监控的风险如下</li></ul><blockquote><p>监管风险：薄弱的数据库审计机制与政府监管要求相违背<br>监测和恢复风险<br>管理和审计职责风险<br>依赖与不适当的本地审计工具的风险</p></blockquote></li><li><p><strong>管理安全制度遵从性</strong></p><ul><li>管理法规遵从性</li></ul><blockquote><p>衡量授权细则和程序合规性<br>确保所有数据需求可衡量、可审计<br>使用标准工具和流程保护存储和运行中的受监管数据<br>发现潜在不合规问题以及存在违反法规遵从性时，使用上报程序和通知机制</p></blockquote><ul><li>审计数据安全合规活动</li></ul><blockquote><p>评估制度和细则，确保明确定义合规并满足法规要求<br>分析实施程序和用户授权实践，确保符合监管目标、制度、细则和预期结果<br>评估授权标准和规范是否充分符合技术要求<br>发现潜在不合规问题以及存在违反法规遵从性时，使用上报程序和通知机制<br>审查外包和外部供应商合同、数据共享协议以及合规义务，确保业务合作伙伴履行义务及组织履行其保护受监管数据的法律义务<br>评估组织内安全时间成熟度<br>推进合规制度变革和运营合规改进</p></blockquote></li></ul><h2 id="1-8-度量指标"><a href="#1-8-度量指标" class="headerlink" title="1.8 度量指标"></a>1.8 度量指标</h2><ul><li><strong>安全实施指标</strong></li></ul><blockquote><p>安装最先安全补丁程序的企业计算机百分比<br>安装并运行最新反恶意软件的计算机百分比<br>成功通过背景调查员工的百分比<br>在年度安全实践实验中优秀的员工百分比<br>成功通过天灾恢复测试的业务流程百分比<br>已成功解决审计发现的问题百分比</p></blockquote><ul><li><strong>安全意识指标</strong></li></ul><blockquote><p>风险评估结果<br>风险事件和配置文件<br>正式的反馈调查和访谈<br>事故复盘、经验教训和受害者访谈<br>补丁有效性审计</p></blockquote><ul><li><strong>数据保护指标</strong></li></ul><blockquote><p>特定数据类型和信息系统的关键性排名<br>数据丢失、损坏相关的事故、黑客攻击、盗窃或灾难的年损失预期<br>与特定数据丢失的风险相关的某些类别的受监管信息以及补救优先级排序<br>数据与特定义务流程的风险映射<br>数据资源及其传输媒介遭受攻击的可能性<br>对可能意外或有意泄漏敏感信息的业务流程的特定部分进行娄总评估</p></blockquote><ul><li><strong>安全事件指标</strong></li></ul><blockquote><p>检测到并组织了入侵尝试数量<br>通过防止入侵节省的安全成本投资回报</p></blockquote><ul><li><strong>机密数据扩散</strong>：衡量数据副本数量，以减少扩散</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
            <tag> 数据安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据存储与操作-基础</title>
      <link href="/202108/2113176.html"/>
      <url>/202108/2113176.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍数据存储与操作相关的基础内容</p><span id="more"></span><h1 id="1-数据存储和操作"><a href="#1-数据存储和操作" class="headerlink" title="1. 数据存储和操作"></a>1. 数据存储和操作</h1><p><strong>数据存储与设计</strong> 包括对存储数据的设计、实施和支持，包括标准工具、数据库性能和业务连续性标准等，最大化数据资源价值，贯穿整个数据生命周期，包括数据库操作支持和数据库技术支持两个活动</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><p>在整个数据生命周期中管理数据的可用性；确保数据资产的完整性；管理数据交易事务的性能</p><h2 id="1-2-操作原则"><a href="#1-2-操作原则" class="headerlink" title="1.2 操作原则"></a>1.2 操作原则</h2><p><strong>识别自动化机会并采取行动</strong>：自动化实施数据库开发过程、开发工具和流程，缩短每个开发周期<br><strong>构建是考虑重构</strong>：开发抽象的可重用的数据对象，避免应用程序与数据库模式的紧耦合（对象-关系阻抗不匹配）<br><strong>理解并使用最佳实践</strong>：将数据库标准和最佳实践作为需求进行推广实施<br><strong>支持数据库标准需求</strong>：形成服务水平协议（SLA），确保数据完整性和数据安全性<br><strong>为项目中的DBA角色设置期望值</strong>：DBA在项目定义阶段参与工作</p><h2 id="1-3-DBA"><a href="#1-3-DBA" class="headerlink" title="1.3 DBA"></a>1.3 DBA</h2><p><strong>DBA</strong>(DataBase Administrator，数据库管理员)，与网络、系统管理员协调，建立系统的项目集成机制，包括标准化、整合、虚拟化、数据自动备份与恢复，以及数据安全</p><p><strong>生产DBA</strong>：主要负责数据操作管理</p><blockquote><p>通过性能调优、监控、错误报告等活动，确保数据库性能及可靠性<br>建立备份与恢复机制，确保在任一情况下数据都能恢复<br>建立集群和容错机制，确保数据连续可用<br>执行其他数据库维护活动，如建立数据归档机制</p></blockquote><p><strong>应用程序DBA</strong>：负责所有环境（开发、测试、QA）中的多套数据库，为应用程序开发人员提供更好的支持服务</p><p><strong>过程开发DBA</strong>：</p><ul><li>过程DBA：负责审查和管理数据库过程对象，开发和支持关系数据库控制和执行的过程逻辑：存储过程、触发器和用户自定义函数（UDFs）</li><li>开发DBA：创建、管理特殊用途的数据库，如数据沙盒、数据探索区等</li></ul><h2 id="1-4-数据库架构类型"><a href="#1-4-数据库架构类型" class="headerlink" title="1.4 数据库架构类型"></a>1.4 数据库架构类型</h2><p><strong>集中式数据库</strong>：将所有数据存放在一个地方的一个系统中，所有用户连接到这套系统进行访问</p><p><strong>分布式数据库</strong>：物理上数据存放在计算机网络的各个节点上，在逻辑上属于一个统一的数据库系统的数据集合</p><ul><li><p><strong>联邦数据库</strong>：将多个自治的数据库系统映射成一个单一的联邦数据库，数据联邦提供的数据不需要对数据源进行额外复制或持久化，组成联邦的数据库分散在不同地理位置，通过计算机网络关联在一起，分为松耦合联邦和紧耦合联邦，松耦合联邦通过多个组件数据库构造，用户通过多数据库语言访问其他组件数据库系统；紧耦合联邦有组件数据库组成，用独立的进程构造，发布一个集成的联邦模式</p></li><li><p><strong>区块链数据库</strong>：属于一种联邦数据库，用于安全管理金融交易，通过合同管理或健康信息交换，区块链有两种结构类型L单条记录和块，每个交易包含一条记录，每个区块包含一组带时间戳的交易，数据库由多个区块形成的链状结构组成，区块存储的交易信息通过哈希算法生成，新区块在链条末端</p></li></ul><p><strong>可视化/云计算平台</strong>：云计算提供计算、软件、数据访问和存储服务，云计算是虚拟化、SOA（面向服务架构）和效用计算广泛使用的自然演进形态，具体实施方法有：虚拟机镜像，数据库即服务（Daas）和云上托管数据库等</p><h3 id="1-5-数据库组织模型"><a href="#1-5-数据库组织模型" class="headerlink" title="1.5 数据库组织模型"></a>1.5 数据库组织模型</h3><p><strong>层次型数据库</strong>：最古老的数据库类型，数据被组织成具有强制父子关系的树形结构，父与子是一对多关系</p><p><strong>关系型数据库</strong>：是建立在关系模型(二维表)上的数据库系统，要求数据记录具有相同的关系结构，基于几何理论和关系代数</p><ul><li><strong>多维数据库</strong>：将数据存储在一种数据结构中，允许同时对多个数据元素过滤器进行搜索，常见于数据仓库和商务智能中，访问数据使用的是一个变体多维表达式（MDX，Multidimensional eXpression）</li><li><strong>时态数据库</strong>：支持处理涉及时间数据的关系型数据库，面向有效时间和事务时间</li></ul><p><strong>非关系型数据库</strong>：将数据存储为简单的字符串或完整的文件</p><ul><li><p><strong>键值对(Key-Value)数据库</strong>：通过键值对存储数据</p></li><li><p><strong>列式数据库</strong>：某列数据仅有唯一值，压缩冗余数据，常用于商务智能</p><p><strong>使用条件</strong>：</p><blockquote><p>一次性向所有行更新某一列<br>需要对多行进行聚合运算，适用于少量列的情况<br>当需要同时获取一行中的许多列，且行的体量相对较小，单次磁盘访问就能将整行数据检索时，面向行的存储组织更高效<br>写入一条新纪录、需要同时要提供所有的行数据，面向行的组织效率更高，整行的数据可以用单次磁盘写入<br>面向行的存储布局适合OLTP，面向列的存储布局适合OLAP</p></blockquote></li><li><p><strong>文档数据库</strong>：由结构和数据组成的文件集合，对每个文档分配一个键</p></li><li><p><strong>图数据库</strong>：关注组成图的节点信息</p></li><li><p><strong>空间数据库</strong>：存储和查询表示几何空间中定义的对象数据</p><blockquote><p><strong>空间评估</strong>：计算线条长度、多边形面积、几何图形之间的距离<br><strong>空间功能</strong>：修改现有特征以创建新特征<br><strong>空间预测</strong>：允许对几何图形之间的空间关系进行真假查询<br><strong>几何构造</strong>：通过描述定义形状的顶点来创建新几何图形<br><strong>观测功能</strong>：查询并返回某个特征的特定信息</p></blockquote></li><li><p><strong>对象 / 多谋体数据库</strong>：包括一个分层存储管理系统，用于管理磁介质和光存储介质</p></li><li><p><strong>平面文件数据库</strong> ：将数据集编码为单个纯文本文件或二进制文件</p></li><li><p><strong>三元组存储数据库</strong>：由主、谓、宾组成数据实体</p><blockquote><p>原生三元组存储：从零开始实现并利用资源描述框架（RDF，Resource Description Framework）数据模型来高效存储访问RDF数据的三元存储<br>RDBMS支持的三元数据存储：在现有的RDBMS之上添加RDF描述层构建的三元存储<br>NoSQL三元存储</p></blockquote></li></ul><h2 id="1-6-数据处理类型"><a href="#1-6-数据处理类型" class="headerlink" title="1.6 数据处理类型"></a>1.6 数据处理类型</h2><p><strong>ACID</strong>：强调一致性，酸</p><ul><li>原子性—A（atomicity）：事务是一个不可分割的工作单位，要么不做，要么全做</li><li>一致性—C（consistency）：事务执行结果正确，事务前后数据的状态必须保持一致</li><li>隔离性—I （isolation）：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离</li><li>持久性—D（durability）：事务完成后，结果直到下一次修改前，永久保存</li></ul><p><strong>BASE</strong>：强调可用性，碱</p><ul><li><p>基本可用—BA（Basically Available）：即使节点故障，仍能保证一定级别的数据可用性</p></li><li><p>软状态    —S  （Soft State）：数据处于流动状态，不保证最新数据</p></li><li><p>最终一致—E  （Eventual Consistency）：数据在节点、数据库最终状态一直，不保证在每个事务中时刻一致</p></li></ul><p><strong>ACID和BASE的区别</strong>：</p><table><thead><tr><th>事项</th><th>ACID</th><th>BASE</th></tr></thead><tbody><tr><td>数据结构-Casting</td><td>模式必须存在</td><td>动态</td></tr><tr><td>数据结构-Casting</td><td>表结构必须存在</td><td>运行中调整</td></tr><tr><td>数据结构-Casting</td><td>数据类型确定</td><td>存储不同的数据类型</td></tr><tr><td>一致性-Consistency</td><td>强一致性可用</td><td>强一致，最终一致或不追求一致</td></tr><tr><td>处理焦点-Processing Focus</td><td>事务</td><td>键值存储</td></tr><tr><td>行 / 列</td><td>宽列存储</td><td></td></tr><tr><td>历史-History</td><td>1970s，结构化存储</td><td>2000年，非结构化存储</td></tr><tr><td>扩展-Scaling</td><td>依赖产品</td><td>商业服务期间自动传播数据</td></tr><tr><td>来源-Origin</td><td>混合（商业和开源）</td><td>开源</td></tr><tr><td>事务-Transaction</td><td>是</td><td>可能</td></tr></tbody></table><p><strong>CAP定理</strong>：分布式系统越大，满足ACID的要求点越少</p><ul><li><p>一致性—C（Consistency）：系统总是按照设计和预期方式运行</p></li><li><p>可用性—A（Availability）：请求发生时系统时刻保持可用状态，并对请求做出反应</p></li><li><p>分区容错—P（partition Tolerance）：偶尔发生数据丢失或部分系统故障时，系统依然能提供服务</p></li></ul><h2 id="1-7-数据存储介质"><a href="#1-7-数据存储介质" class="headerlink" title="1.7 数据存储介质"></a>1.7 数据存储介质</h2><p><strong>磁盘和存储区域网络</strong>：<br>磁盘存储是一种稳定的永久存储数据库方法<br>存储区域网络（SAN，Storage Area Networks），磁盘阵列组成存储区域网络</p><p><strong>内存</strong>：系统启动时，内存数据库（IMDB，In-Memory Database）从永久存储中将数据加载到内存中，所有数据处理都在内存中完成</p><p><strong>列压缩方案</strong>：列式数据库（Columnar-based Database）用于处理大量重复的数据集存储</p><p><strong>闪存</strong>：Flash Memory</p><h2 id="1-8-数据库环境"><a href="#1-8-数据库环境" class="headerlink" title="1.8 数据库环境"></a>1.8 数据库环境</h2><p><strong>生产环境</strong>：处理生产业务流程发生的技术环境，业务数据的产生地</p><p><strong>非生产环境</strong>：系统变化部署到生产环境之前的开发测试环境，检测潜在问题，及时解决</p><ul><li><strong>开发环境</strong>：是生产环境的精简版，开发人员在开发环境下编写代码、测试系统变更</li><li><strong>测试环境</strong>：执行质量保证和用户验收测试<ol><li>质量保证测试（QA）：依据需求进行功能测试</li><li>集成测试：将独立开发或更新的多个模块作为整体进行测试</li><li>用户性能测试（UAT）：从用户视角进行系统功能测试</li><li>性能测试：进行高复杂度或大容量测试，压力测试</li></ol></li><li><strong>数据沙盒或实验环境</strong>：数据沙盒允许以只读方式访问和管理生产数据的环境，进行概念验</li></ul><h2 id="1-9-数据库管理过程"><a href="#1-9-数据库管理过程" class="headerlink" title="1.9 数据库管理过程"></a>1.9 数据库管理过程</h2><ol><li><p>数据归档：是将数据从立即访问的存储介质迁移到查询性能低的存储介质，归档过程必须和分区策略保持一致</p><blockquote><p>传建一个辅助存储区域，优先建在辅助数据库服务器上<br>从当前数据库表分区区分出可归档的单元<br>将不经常使用的数据复制到单独的数据库<br>创建磁盘或磁带备份<br>创建数据库任务，定期清理不再使用的数据</p></blockquote></li><li><p>变动数据捕获：（CDC，Change Data Capture），监测数据变动，并确保变更信息被适当记录</p></li><li><p>数据清除：清除无价值的数据</p></li><li><p>数据保留：数据保持可用的时间</p></li><li><p>数据分片</p></li></ol><p>需要定期进行归档恢复测试，在系统变更时也需要也需要进行恢复测试：</p><blockquote><p>确定是否需要保留历史归档或保留多少，清除不需要的历史归档<br>系统变更前，先将归档数据恢复到原系统，系统变更后，再重新归档<br>对低价值低频的访问归档，根据需要从旧系统的数据格式抽取数据</p></blockquote><h2 id="1-10-数据库衡量"><a href="#1-10-数据库衡量" class="headerlink" title="1.10 数据库衡量"></a>1.10 数据库衡量</h2><blockquote><p>数据架构和复杂性<br>容量和速度限制，包括数据流传送速率<br>应用类别，如事务处理、商务智能、个人资料等<br>特殊功能，如时间计算支持<br>硬件平台及操作系统支持<br>软件支持工具的可用性<br>性能评测，包括实时统计信息<br>可扩展性<br>软件、内存和存储需求<br>韧性，包括错误处理和错误报告<br>组织对技术风险的偏好<br>提供训练有素的专业技术人员<br>拥有成本，如软件许可费、维护费和计算资源成本等<br>供应商声誉<br>供应商支持策略和版本计划<br>其他客户案例</p></blockquote><h2 id="1-11-管理数据库操作"><a href="#1-11-管理数据库操作" class="headerlink" title="1.11 管理数据库操作"></a>1.11 管理数据库操作</h2><p><strong>理解需求</strong>：</p><ul><li><p><strong>定义存储需求</strong>：为DBMS建立存储系统，为NoSQL建立文件存储系统，识别永久性存放和临时性存放数据，   做好增量数据规划和数据存储周期规划</p></li><li><p><strong>识别使用模式</strong></p><blockquote><p>基于事务型<br>基于大数据集的读型或写型<br>基于时间型（月末压力大，周末压力小）<br>基于位置型（人口集中地区更多交易）<br>基于优先级型（某些部门或批处理具有更大权限的优先级）</p></blockquote></li><li><p><strong>定义访问需求</strong>：授权访问不同数据文件</p></li></ul><p><strong>规划业务连续性</strong>：</p><ul><li><p><strong>业务问题</strong>：</p><blockquote><p>物理数据库服务器失效<br>磁盘存储设备失效<br>数据库失效，包括主要数据库、临时存储数据库和事务日志等<br>数据库索引页或数据页损坏<br>数据库和日志段的文件系统失效<br>数据库或事务日志的备份文件失效<br><strong>数据库韧性</strong>：用来评估系统对错误条件容忍度的指标，韧性越高，错误容忍度级别越高</p></blockquote></li><li><p><strong>备份数据</strong>：实现高可用，保证业务连续性，包括数据库备份和数据库事务日志备份等，包括<strong>增量备份</strong>和<strong>全量备份</strong></p></li><li><p><strong>恢复数据</strong>：</p><blockquote><p>立即恢复：通过预判自动切换到备用系统<br>关键恢复：尽快恢复以尽量减少关键业务延迟会业务中断<br>非关键恢复：等非关键业务恢复后恢复的非关键义务</p></blockquote></li></ul><p><strong>创建数据库实例</strong>：安装和更新DBMS软件，维护多种环境的安装，包括多版本的DBMS，安装和管理相关的数据技术</p><ul><li><p><strong>物理存储环境管理</strong>：遵循传统的软件配置管理过程（SCM）或信息技术基础设施库的方法，记录对数据库配置、结构、约束、权限、阈值的修改</p><blockquote><p><strong>配置识别</strong>：DBA与多方协作，定制各个方面的属性配置，形成配置文档和基线，后续配置修改需要提交配置变更控制过程<br><strong>配置变更控制</strong>：用于更改配置项属性并重新对其进行基线化的流程和审批阶段<br><strong>配置状态报告</strong>：及时记录和报告任意点上与每个配置项相关的配置基线<br><strong>配置审计</strong>：在交付或变更时进行审计，物理配置审计确保配置项按照其详细设计文档的要求进行安装；功能配置审计确保配置项的功能属性得以实现</p></blockquote></li><li><p><strong>管理数据访问控制</strong></p><blockquote><p>受控环境：包括网络角色和权限管理、全天候监控和网络健康管理、防火墙管理、补丁管理和微软基准安全分析器集成管理等<br>物理安全：基于简单网络管理协议（SNMP）的监控、数据审计日志记录、灾难管理和数据库备份计划对数据资产的物理安全性进行管理<br>监控：进行连续的软硬件监控<br>控制：通过控制访问、数据库审计、入侵检测和漏洞评估工具维护数据安全</p></blockquote></li><li><p><strong>创建存储容器</strong>：为每个级别的存储对象创建合适的存储容器，便于进行组织、加载、查询等</p></li><li><p><strong>应用物理数据模型</strong>：以物理数据模型创建和管理完整的数据存储环境，以便提供DaaS服务</p></li><li><p><strong>加载数据</strong>：将多种形式的数据加载入建立的空的数据库中</p></li></ul><p><strong>管理数据复制</strong>：</p><ul><li><p><strong>主动复制</strong>：不存在主副本，每个副本主动创建和存储来自其他副本的相同数据；<strong>被动复制</strong>：在主副本上创建和存储数据，将更改的状态传送到其他副本</p></li><li><p><strong>镜像复制</strong>：作为两阶段提交过程的一个部分，主库的更新会立即同步给辅助数据库； <strong>日志复制</strong>：辅助数据库定时接收主库传来的事务日志副本</p></li><li><p><strong>水平数据扩展</strong>：增加更多的数据副本；<strong>垂直数据扩展</strong>：数据存储更远的位置</p></li></ul><p><strong>管理数据库性能</strong>：设置和优化操作系统及应用程序参数，管理数据库连接，优化操作系统、网络和事务处理中间件，提供合适的存储设备，提供容量增长预测，提供操作工作负载和基准，以支持SLA管理、收费计算、服务器容量及规划的生命周期轮换</p><ul><li><p><strong>设置数据库性能水平</strong>：通过SLA来管理系统性能、数据可用性、恢复预期以及团队对问题的响应期望</p></li><li><p><strong>管理数据库可用性</strong></p><p><strong>相关因素</strong></p><blockquote><p>可管理性：创新和维护环境的能力<br>可恢复性：中断后重新建立服务的能力，修复不可预见时间或组件故障导致错误的能力<br>可靠性：在规定时间内提供制定水平服务的能力<br>可维护性：识别存在问题的能力，诊断原因，修复问题</p></blockquote><p><strong>影响因素</strong></p><blockquote><p>计划性停机：出于维护或升级的考虑<br>非计划停机：服务器硬件、磁盘硬件、操作系统、数据库软件或数据中心站点故障等<br>应用问题：安全和授权问题、验证性能问题或恢复失败等<br>数据问题：数据损坏、数据库对象丢失、数据丢失或数据肤质问题等<br>人为错误</p></blockquote><p><strong>维护工具</strong></p><blockquote><p>运行数据库备份工具<br>运行数据库重组工具<br>运行数据完整性检查工具<br>利用表空间局类和分区<br>垮裤进行数据复制保证高可用性</p></blockquote></li><li><p><strong>管理数据库运行</strong>：监视数据库运行、数据变更日志的使用和复制环境的同步情况等</p></li><li><p><strong>维护数据库性能服务水平</strong></p><blockquote><p>事务性能与批处理性能：监控时时发生或批处理发生的数据交易的工作性能，解决其中的错误问题<br>问题修复：内存分配和争用、锁与阻塞、不准确的数据库统计信息、不良代码、低效复杂的表链接、不当索引、应用程序争用活动、服务器过载和数据库短时间变化等</p></blockquote></li><li><p><strong>维护备用环境</strong></p></li></ul><p><strong>管理测试数据集</strong></p><p><strong>管理数据迁移</strong>：在保证数据不变的前提下，在不同存储类型、格式或计算机系统之间传送数据</p><h2 id="1-12-数据审计"><a href="#1-12-数据审计" class="headerlink" title="1.12 数据审计"></a>1.12 数据审计</h2><blockquote><p>指定和审核审计标准<br>进行初步的数据筛选和审查<br>开发数据监控方法<br>应用统计信息、地理统计信息、生物统计信息优化数据分析<br>支持采样及分析<br>审核数据<br>提供数据发现功能的支持</p></blockquote><h2 id="1-13-衡量指标"><a href="#1-13-衡量指标" class="headerlink" title="1.13 衡量指标"></a>1.13 衡量指标</h2><p><strong>存储度量</strong></p><blockquote><p>数据库类型数量<br>汇总交易统计<br>容量指标<br>已使用存储的数量<br>存储容器的数量<br>数据对象中已提交和未提交块或页的数量<br>数据队列<br>存储服务使用情况<br>对存储服务提出的数据请求数量<br>对使用服务的应用程序性能的改进</p></blockquote><p><strong>性能度量</strong></p><blockquote><p>事务频率和数量<br>查询性能<br>API服务性能</p></blockquote><p><strong>操作度量</strong></p><blockquote><p>有关数据检索时间的汇总统计<br>备份的大小<br>数据质量评估<br>可用性</p></blockquote><p><strong>服务度量</strong></p><blockquote><p>按类型的问题提交、解决和升级的数量<br>问题解决事件</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据建模与设计-基础</title>
      <link href="/202108/2040152.html"/>
      <url>/202108/2040152.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍数据建模与设计相关的基础内容</p><span id="more"></span><h1 id="1-数据建模和设计"><a href="#1-数据建模和设计" class="headerlink" title="1. 数据建模和设计"></a>1. 数据建模和设计</h1><p><strong>数据建模</strong>：是发现、分析和确定数据需求的过程，通过数据模型精确地表示和传递数据需求<br><strong>模型分层</strong>：概念模型 —&gt; 逻辑模型(E-R图) —&gt; 物理模型(类图)，模型包括数据结构、数据操作和数据约束三部分</p><blockquote><p>概念模型：面向用户、面向客观世界的模型，用来描述现实世界的概念化结构，与具体的数据库管理系统无关<br>逻辑模型：以概念模型为基础，根据业务线、业务事项、业务流程、业务场景的需要，设计面向业务实现的数据模型，指导在不同数据库管理系统中的实现，包括网状数据模型和层析数据模型<br>物理模型：面向计算机物理表示的模型，描述数据在存储介质上的组织结构，基于逻辑模型成果，保证业务需求实现</p></blockquote><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><blockquote><p>提供有关数据的通用词汇表<br>获取、记录组织内数据和系统的详细信息<br>在项目中作为主要的交流沟通工具<br>提供应用定制、整合、替换的起点</p></blockquote><h2 id="1-2-模型管理内容"><a href="#1-2-模型管理内容" class="headerlink" title="1.2 模型管理内容"></a>1.2 模型管理内容</h2><blockquote><p>数据架构管控：基于业务模型，使用标准化用语等数据要素设计企业数据模型，实现数据模型的标准化审核和统一管理，便于数据整合、提高数据质量<br>标准管控：建立数据标准体系和管理标准代码，如业务用语、域、编码等<br>模型管理：基于企业级逻辑模型和数据标准形成系统级逻辑模型，包括应用系统开发模型和数据仓库模型<br>元数据管控：基于应用系统开发模型提取数据库结构模型、参考数据标准进行完善</p></blockquote><h2 id="1-3-建模数据"><a href="#1-3-建模数据" class="headerlink" title="1.3 建模数据"></a>1.3 建模数据</h2><blockquote><p>类别信息：对事物进行分类和分配事务类型的数据，如按市场类别分类的客户、按颜色分类的产品等<br>资源信息：实时操作流程所需的基本数据，如产品、客户等<br>业务事件信息：在操作过程中创建的数据，如客户订单<br>详细交易信息：通过销售系统产生的详细交易信息</p></blockquote><h2 id="1-4-建模方法"><a href="#1-4-建模方法" class="headerlink" title="1.4 建模方法"></a>1.4 建模方法</h2><p><strong>基于关系建模</strong>（关系模式，Relational）：采用信息工程法的三叉线表示基数（与其他实体参与建立关系的数量），连线表示业务规则<br><strong>基于维度建模</strong>（多维模式，Dimensional）：专注于特定业务流程的业务问题，连线表示导航路径</p><ul><li>事实表：行对应特定的数值型度量值，占据近90%的存储空间</li><li>维度表：表示业务的重要对象，主要包含文字描述，是事实表的入口点或链接，违反高范式，维表中最主要的两种标识键是代理键和自然键，ORC变化（覆盖，新行，新列）</li><li>雪花模型：将星型模型中的平面、单表、维度结构规范为组件层次结构和网络结构</li><li>粒度：是指事实表中单行数据的含义或描述，是每行都有的最详细信息</li><li>一致性维度：在不同维度模型可以共享，具有一致的属于和值的维度</li><li>一致性事实：跨多个数据集市的标准化术语</li></ul><p><strong>面向对象建模</strong>（面向对象模式，Object-Oriented）：规定类和类之间的关系模型<br><strong>基于事实建模</strong>（事实模式，Fact-Based）</p><ul><li>对象角色建模</li><li>完全面向通讯建模</li></ul><p><strong>基于时间建模</strong>（时间序列模式，Time-Based）<br><strong>非关系型建模</strong>（NoSQL模式，NoSQL）</p><ul><li>文档数据库</li><li>键值数据库</li><li>列数据库</li><li>图数据库</li></ul><h1 id="2-数据建模实践"><a href="#2-数据建模实践" class="headerlink" title="2. 数据建模实践"></a>2. 数据建模实践</h1><h2 id="2-1-数据模型管理工具"><a href="#2-1-数据模型管理工具" class="headerlink" title="2.1 数据模型管理工具"></a>2.1 数据模型管理工具</h2><p><strong>数据模型管理工具</strong>：负责企业数据模型的管理、对比、分析、展示提供技术支撑，解决数据模型管理分散、无统一的数据模型视图，数据模型无有效管控过程，数据模型标准设计无法有效落地</p><ul><li><strong>基础功能</strong></li></ul><blockquote><p>数据模型设计：支持正向建模和逆向建模，对数据模型进行标准化设计，保证数据模型和企业架构保持一致<br>模型差异稽核：解决数据模型设计和数据库表实现不一致问题，针对数据库包结构、关系等差别形成差异报告，辅助数据模型管理人员监控数据模型质量问题，提升数据模型设计和实施的质量<br>数据模型变更管理：支持数据模型从设计、提交、评审、发布、实施到消亡的的在线、全过程、流程化管理，实现对各系统数据模型的版本化管理，自动生成版本号、版本变更信息，辅助管理不同版本的数据模型</p></blockquote><ul><li><strong>业务功能</strong></li></ul><ol><li><p>模型抽取和版本管理：收集主流数据库业务系统数据结构，实现数据标准的统计分析，快速分析信息系统数据标准落地情况</p></li><li><p>模型差异报告：自动检测基线模型和业务系统的不一致并预警</p></li><li><p>模型质量报告：在测试阶段进行模型评审</p><blockquote><p>标准的落标引用：自动检查标准的引用和落地，并生成报告<br>自定义数据标准：支持自定义数据标准和词典，完善标准库<br>元数据充足率：自动生成不满足元模型内容的报告</p></blockquote></li><li><p>模型上线流程：模型上线需要提供设计文档、测试报告、使用手册等</p><blockquote><p>模型生产库基线与封板：根据评审时建立的模型分支，建立模型的生产库基线，进行封板操作<br>模型基线报告：提供模型标准数据字典、标准落标报告、模型质量报告等</p></blockquote></li><li><p>新增变更流程：根据变更流程进行标准的修改</p></li></ol><h2 id="2-2-建立数据模型"><a href="#2-2-建立数据模型" class="headerlink" title="2.2 建立数据模型"></a>2.2 建立数据模型</h2><p><strong>正向工程</strong></p><ul><li><p>概念数据模型建模</p><blockquote><p>选择模型类型：关系模式、多维模式面向对象模式、面向对象模式、事实模式、时间序列模式、NoSQL模式<br>选择表示方法：基于模型类型和组织标准和人员习惯确定<br>完成初始概念模型：获取用户观点<br>收集组织最高级概念：包括时间、客户、产品和交易等<br>收集概念的相关活动：包括活动和关系，关系可以是双向的<br>合并专业术语：建立统一的术语标准<br>获取签署</p></blockquote></li><li><p>逻辑数据模型家建模</p><blockquote><p>分析信息需求<br>分析现有文档<br>添加关联实体：该实体仅用于描述多对多关系<br>添加属性：添加属性到概念实体<br>指定域：保证模型属性中的格式与数值集一致<br>指定键</p></blockquote></li><li><p>物理数据建模</p><blockquote><p>解决逻辑抽象：物理将逻辑抽象实体在数据库设计中成为独立对象</p><blockquote><p>子类型吸收：子类型实体属性作为可空列，包括在表示超类型实体的表中<br>超类型分区：超类型实体的属性包含在每个子类型实体创建的单独表中</p></blockquote><p>添加属性细节：向物理模型添加每个表和列、文档和字段的技术名称<br>添加参考数据对象：</p><blockquote><p>创建匹配的单独码表<br>创建主共享代码表<br>将规则或有效代码嵌入到相应对象的定义中</p></blockquote><p>指定代理建：给业务分配与业务无关的不可见的唯一键值，可选步骤<br>逆规范化：在合适情况下，通过逆规范化或增加按冗余提高性能</p><blockquote><p>提前组合来自多个其他表的数据，避免运行时连接<br>创建更小的、预先过滤的数据副本，以减少运行时计算或大型表扫描<br>预先计算和存储昂贵的数据计算结果，避免运行时系统资源竞争</p></blockquote><p>建立索引<br>建立分区</p><blockquote><p>垂直分区：为减少查询返回的结果集，根据列的不同为某表创建子集<br>水平分区：为减少查询返回的结果集，使用某列的值作为区分创建子集表</p></blockquote><p>创建视图</p></blockquote></li></ul><h2 id="2-3-交付成果"><a href="#2-3-交付成果" class="headerlink" title="2.3 交付成果"></a>2.3 交付成果</h2><blockquote><p>图表：精确描述数据需求<br>定义：定义实体、属性和关系<br>遗留问题<br>血缘关系：包括数据流向和数据操作等</p></blockquote><h2 id="2-4-度量指标"><a href="#2-4-度量指标" class="headerlink" title="2.4 度量指标"></a>2.4 度量指标</h2><blockquote><p>模型反应业务需求程度<br>模型完整性程度<br>模型与模式匹配度<br>模型结构<br>模型通用性<br>模型遵循命名标准程度<br>模型可读性<br>模型定义<br>模型与企业数据架构的一致性<br>模型与元数据匹配程度</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据架构-基础</title>
      <link href="/202108/1919413.html"/>
      <url>/202108/1919413.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍数据架构相关的基础内容</p><span id="more"></span><h1 id="1-数据架构"><a href="#1-数据架构" class="headerlink" title="1. 数据架构"></a>1. 数据架构</h1><p><strong>数据架构</strong>：是对数据构件，数据构件之间的关系，数据构件和环境之间的关系，以及数据组件的设计原则和演进记录等基本组织/架构元素进行有组织的设计，包括数据的收集、存储、规划、使用和删除等标准，优化数据系统的功能、性能、成本和用户体验等<br>数据构件：是不同层级的模型、定义、数据流等，包括当前状态的描述、数据需求的定义、数据整合的指引数据管控策略要求的数据资产管理规范<br>数据构件间关系：影响企业数据架构不同角色之间的协作、思维方式和技能等<br>演进记录：记录数据与业务流程应用、数据存储、网段、业务角色等之间的关系</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><blockquote><p>利用新兴技术从战略上帮助组织快速改变产品、服务和数据<br>将业务需求转换为数据和应用需求，确保为业务流程提供数据<br>管理复杂的数据和信息，实现企业内共享<br>确保业务和 IT技术 保持一致<br>为企业改革、转型和提高适应性支撑</p></blockquote><h2 id="1-2-企业架构"><a href="#1-2-企业架构" class="headerlink" title="1.2 企业架构"></a>1.2 企业架构</h2><p>企业架构：由业务架构、应用架构、数据架构和技术架构组成</p><blockquote><p>业务架构：描述企业各业务之间相互作用的关系结构和贯彻企业业务战略的基本业务运作模式<br>数据架构：将企业业务实际抽象为信息对象，将企业的业务运作模式抽象为信息对象的属性和方法，建立面向对象的企业数据模型，描述企业数据模型（数据结构和数据规范）和数据流设计<br>应用架构：以数据架构为基础，建立支撑业务运行的各个业务系统，通过应用系统的集成运行实现企业信息的自动化流动</p></blockquote><p>常见企业架构<br><strong>Zachman架构</strong>：列显示问询沟通，行显示定义转换</p><table><thead><tr><th></th><th>是什么</th><th>怎样做</th><th>在哪里</th><th>是谁</th><th>什么时间</th><th>为什么</th><th></th></tr></thead><tbody><tr><td><strong>管理层</strong></td><td>库存标识</td><td>过程识别</td><td>发布识别</td><td>责任认定</td><td>时间识别</td><td>动机识别</td><td><strong>上下文范围</strong></td></tr><tr><td><strong>业务管理</strong></td><td>库存定义</td><td>流程定义</td><td>发布定义</td><td>责任定义</td><td>时间定义</td><td>动机定义</td><td><strong>业务概念</strong></td></tr><tr><td><strong>架构师</strong></td><td>库存表示</td><td>过程表示</td><td>发布表示</td><td>责任表示</td><td>时间表示</td><td>动机表示</td><td><strong>系统逻辑</strong></td></tr><tr><td><strong>工程师</strong></td><td>库存规格</td><td>流程规范</td><td>发布规范</td><td>责任规范</td><td>时间规范</td><td>动机规范</td><td><strong>实施部署</strong></td></tr><tr><td><strong>技术员</strong></td><td>库存配置</td><td>流程配置</td><td>分发配置</td><td>责任配置</td><td>时间配置</td><td>动机配置</td><td><strong>工具组件</strong></td></tr><tr><td><strong>操作员</strong></td><td>库存实例</td><td>流程实例</td><td>分发实例</td><td>责任实例</td><td>时间实例</td><td>动机实例</td><td><strong>操作实例</strong></td></tr><tr><td></td><td><strong>库存集</strong></td><td><strong>过程流</strong></td><td><strong>分销网络</strong></td><td><strong>责任分配</strong></td><td><strong>时间周期</strong></td><td><strong>动机意图</strong></td><td></td></tr></tbody></table><p>DoDAF架构<br>FEAF架构<br>TOGAF架构</p><h3 id="1-2-1-企业架构开发"><a href="#1-2-1-企业架构开发" class="headerlink" title="1.2.1 企业架构开发"></a>1.2.1 企业架构开发</h3><p>基于 TOGAF架构 的架构开发方法 ADM</p><blockquote><p>阶段A——架构愿景<br>阶段B——业务架构<br>阶段C——信息系统架构 (数据架构和应用架构，优先数据架构)<br>阶段D——技术架构，代表完整的企业架构开发<br>阶段E——架构蓝图开发解决方案(架构实施项目)<br>阶段F——迁移规划的工作内容<br>阶段G——架构开发和解决方案的实施治理<br>阶段H——架构变更管理</p></blockquote><h3 id="1-2-2-企业数据模型"><a href="#1-2-2-企业数据模型" class="headerlink" title="1.2.2 企业数据模型"></a>1.2.2 企业数据模型</h3><p><strong>内容</strong></p><blockquote><p>数据目录：数据共享交换的基础数据，促进企业内部数据共享交换、对外上报和公示等<br>数据资源全景图：是企业全部数据资产的总体视图，包括数据分布、流向和交互关系，还有数据治理、数据服务和数据后期应用的完整视图<br>数据地图分布应用：在数据资产全景图视角查看企业各数据域，识别企业各项业务的核心数据主题，明确各主体之间的交互关系</p></blockquote><p><strong>数据模型分层</strong>：企业域概念模型 -&gt; 主题域模型 -&gt; 逻辑模型 -&gt; 逻辑数据模型<br>企业域概念模型包括多个主题域模型，主题域模型包含具有关系的重要实体（逻辑模型），逻辑模型通过增加属性和不太重要的实体及关系还增加细节，逻辑数据模型限制主题范围和一级外部关系、限制主题物理对象和关系的范围<br>纵向表示不同层级之间的映射关系，横向同一个实体和关系可能出现在同一层级的多个模型中，企业域概念模型可用自下而上的分析现有模型，自上而下的设计主题模型<br><strong>主题域</strong></p><blockquote><p>战略发展类主题：包括战略规划、计划与预算管理、投资管理和绩效管理等<br>管理支持类主题：包括财务管理、人力资源管理、物资管理、项目管理和内控审计管理等<br>生产执行类主题：包括生产管理、生产调度管理、HSE管理、科技与工艺管理和设备管理等</p></blockquote><h3 id="1-2-3-数据流模型"><a href="#1-2-3-数据流模型" class="headerlink" title="1.2.3 数据流模型"></a>1.2.3 数据流模型</h3><p><strong>数据流</strong>：是一种记录血缘的数据加工过程，用于描述数据在业务流程和系统中的流动，可以描述主题域、业务实体和属性等层面的映射关系，数据流入节点 -&gt; 主节点 -&gt; 数据流出节点<br><strong>内容</strong></p><blockquote><p>数据和业务流程中应用的关系<br>数据的存储<br>数据和网段的关系（助力于安全映射）<br>数据和业务角色关系（创建、更新和删除数据等）<br>数据出现局部差异的位置</p></blockquote><p><strong>分类</strong></p><blockquote><p>表级血缘关系：建立源表、源字段和目标表、目标字段的映射关系，一个目标表可以来自多个源表<br>字段级血缘关系：按时间查看记录的所有变更过程，一条记录可以生成多条对应记录</p></blockquote><h3 id="1-2-4-企业数据架构项目"><a href="#1-2-4-企业数据架构项目" class="headerlink" title="1.2.4 企业数据架构项目"></a>1.2.4 企业数据架构项目</h3><ol><li>定义范围：保证范围和接口与企业数据模型一致，理解项目对整体企业数据架构的潜在贡献、项目的建模和设计，确定项目共享或重要的项目控件，整合到企业数据模型和存储库中</li><li>理解需求：获取与数据相关的业务需求，并评估需求的业务价值</li><li>设计：形成详细的目标规范，包括数据生命周期内的业务规则、验证结果的有效性、需要提供的时间、提升模型的扩展性和改进标准模型等</li><li>实施：<ul><li>确定购买时间</li><li>确定重用数据时间</li><li>确定构建时间</li></ul></li></ol><p><strong>构建方式</strong></p><ul><li>瀑布方式：作为企业设计的一部分，在连续阶段中理解需求和构建系统</li><li>迭代方式：逐步学习和构建</li><li>敏捷方式：在离散的交付包中学习，构建并测试(Sprints冲刺)，可采用 DevOps方法</li></ul><h2 id="1-3-基本组成"><a href="#1-3-基本组成" class="headerlink" title="1.3 基本组成"></a>1.3 基本组成</h2><blockquote><p>数据架构成果：包括不同层级的模型、定义、数据流等数据构件<br>数据架构活动：用于形成、部署和实现数据架构的目标<br>数据架构行为：包括影响企业数据架构不同角色之间协作、思维方式和技能等</p></blockquote><h2 id="1-4-工作内容"><a href="#1-4-工作内容" class="headerlink" title="1.4 工作内容"></a>1.4 工作内容</h2><blockquote><p>定义组织中当前的数据状态<br>提供数据和组件的标准业务词汇<br>确保数据架构和企业战略及义务架构保持一致<br>描述组织数据战略需求<br>高阶数据整合概要设计<br>整合企业数据架构蓝图<br>使用数据架构构件定义数据需求、指导数据整合、管控数据资产，确保数据项目投入与企业战略保持一致<br>参与改进业务或IT系统开发利益相关方合作<br>通过数据架构及通用数据词汇，搭建企业数据语言</p></blockquote><h2 id="1-5-构建方法"><a href="#1-5-构建方法" class="headerlink" title="1.5 构建方法"></a>1.5 构建方法</h2><ol><li>选择参考数据模型、数据视图和工具</li><li>梳理当前数据模型，作为基线</li><li>定义未来数据模型，作为目标</li><li>进行基线目标数据模型的差距分析</li><li>消除差距，定义数据模型发展路线图及需要的数据控件</li><li>解决跨架构景观的影响</li><li>引导正式的利益相关方审查</li><li>定稿数据模型</li><li>创建数据模型文件</li></ol><h2 id="1-6-数据架构类型"><a href="#1-6-数据架构类型" class="headerlink" title="1.6 数据架构类型"></a>1.6 数据架构类型</h2><ul><li><strong>集中式数据库</strong>：将所有数据存放在一个地方的一个系统中，所有用户连接到这套系统进行访问</li><li><strong>分布式数据库</strong>：物理上数据存放在计算机网络的各个节点上，在逻辑上属于一个统一的数据库系统的数据集合<ul><li><strong>联邦数据库</strong>：将多个自治的数据库系统映射成一个单一的联邦数据库，数据联邦提供的数据不需要对数据源进行额外复制或持久化，组成联邦的数据库分散在不同地理位置，通过计算机网络关联在一起，分为松耦合联邦和紧耦合联邦，松耦合联邦通过多个组件数据库构造，用户通过多数据库语言访问其他组件数据库系统；紧耦合联邦有组件数据库组成，用独立的进程构造，发布一个集成的联邦模式</li><li><strong>区块链数据库</strong>：属于一种联邦数据库，用于安全管理金融交易，通过合同管理或健康信息交换，区块链有两种结构类型L单条记录和块，每个交易包含一条记录，每个区块包含一组带时间戳的交易，数据库由多个区块形成的链状结构组成，区块存储的交易信息通过哈希算法生成，新区块在链条末端</li></ul></li><li><strong>可视化/云计算平台</strong>：云计算提供计算、软件、数据访问和存储服务，云计算是虚拟化、SOA（面向服务架构）和效用计算广泛使用的自然演进形态，具体实施方法有：虚拟机镜像，数据库即服务（Daas）和云上托管数据库等</li></ul><h2 id="1-7-面临风险"><a href="#1-7-面临风险" class="headerlink" title="1.7 面临风险"></a>1.7 面临风险</h2><p>缺少管理层支持；成功与否缺少证据；缺乏管理者信任；管理层决策不当；文化冲击；项目经理缺乏经验；单一维度视角：业务应用的所有者可能会受本身业务系统影响，决定看待企业级数据结构的看法，牺牲一个更平衡、更包容的观点</p><h2 id="1-8-衡量指标"><a href="#1-8-衡量指标" class="headerlink" title="1.8 衡量指标"></a>1.8 衡量指标</h2><p>架构接受度<br>实施趋势：包括使用、重用、代替和废弃测量以及项目执行效率测量<br>业务价值：包括业务质量、业务操作质量和业务环境改变</p><h1 id="2-数据模型"><a href="#2-数据模型" class="headerlink" title="2. 数据模型"></a>2. 数据模型</h1><p><strong>概念模型</strong>：设计每个实体（表）的核心属性（字段，中文），实体与实体的业务关联关系</p><p><strong>逻辑模型</strong>：设计每个实体（表）的全部属性（字段，中文），完善实体之间的关系</p><p><strong>物理模型</strong>：将中文属性名转换为英文名，用于数据库建表；设计索引、存储过程、分区等</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据治理-基础</title>
      <link href="/202108/1813539.html"/>
      <url>/202108/1813539.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据治理 的相关基础内容</p><span id="more"></span><h1 id="1-数据治理"><a href="#1-数据治理" class="headerlink" title="1. 数据治理"></a>1. 数据治理</h1><p><strong>数据治理</strong>：是指对数据资产管理行使权力和控制的集合，包括规划、监督，执行等，确保根据数据管理制度和最佳实践正确的管理数据，确保组织能从中获利；<strong>将数据作为公司资产进行管理，实现数据的可用管理和可控性增长，从而制定更好的业务决策，降低风险并改善</strong></p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><ul><li><p><strong>减少风险</strong>：控制数据风险、增强数据安全</p><blockquote><p><strong>一般性风险管理</strong>：洞察数据对财务、商誉造成的影响，包括法律和监管问题<br><strong>数据安全</strong>：通过控制活动保护数据资产的可获得性、可用性可审计和数据安全<br><strong>数据隐私</strong>：通过制度对私密信息进行合规性监控</p></blockquote></li><li><p><strong>改进流程</strong>：改善数据质量、降低业务运营成本、提升业务运营效率、赋能管理决策</p><blockquote><p><strong>法规遵从性</strong>：有效持续地响应监管要求<br><strong>数据质量提升</strong>：通过真实可信的数据提升业务绩效<br><strong>元数据管理</strong>：建立业务术语表，定义定位组织中的数据<br><strong>项目开发效率</strong>：在 系统生命周期(SDLC) 中改进，解决整个组织中的数据管理问题<br><strong>供应商管理</strong>：控制数据处理的合同，包括云存储、外部数据采购、数据产品销售和外包数据运维等</p></blockquote></li></ul><p><strong>管理者视图的五域模型</strong>：</p><blockquote><p><strong>管控域</strong>：在数据治理战略指导下制定企业数据治理组织，明确组织的权、责、利、岗位编制及技能要求，主要是领导者<br><strong>过程域</strong>：包括评估与分析、规划与设计、实施的 PDCA循环(Plan、Do、Check和Action循环，也称戴明环)<br><strong>治理域</strong>：是数据治理的主体，明确数据治理的对象和目标。有主数据治理、业务交易数据治理和数据指标治理等<br><strong>技术域</strong>：数据治理的支撑手段，包括数据治理理论、数据架构和治理工具平台，有主数据管理、元数据管理、数据指标管理、数据模型管理、数据质量管理和数据安全管理等<br><strong>价值域</strong>：实现数据变现</p><ul><li>数据价值：进行财务建模和建立数据价值评估模型</li><li>数据共享：实现信息整合和分发</li><li>数据变现：将数据转变为财务意义上的资产</li></ul></blockquote><h2 id="1-2-治理原则"><a href="#1-2-治理原则" class="headerlink" title="1.2 治理原则"></a>1.2 治理原则</h2><p>数据治理要求可持续发展、支持嵌入式（数据治理需要糅合在软件开发、数据分析应用中）和可度量（对财务有积极影响）：<br><strong>领导力和战略</strong>：远见卓识、坚定的领导，合理的治理战略<br><strong>业务驱动</strong>：管理与数据相关的IT决策<br><strong>共担责任</strong>：业务数据管理员和数据管理专业人员共担责任<br><strong>多层面</strong>：数据治理活动发生在企业层面和各地基层<br><strong>基于框架</strong>：基于运营框架定义职责和工作内容<br><strong>原则导向</strong></p><p><strong>治理运营模型</strong>：</p><blockquote><p>集中式管理模式：数据治理组织监督所有业务领域中的活动<br>分布式管理模式：每个业务单元采用相同的数据治理运营模型和标准<br>联邦式管理模式：数据治理组织与多个业务单元协同，以维护一致的定义和标准</p></blockquote><h2 id="1-3-治理战略"><a href="#1-3-治理战略" class="headerlink" title="1.3 治理战略"></a>1.3 治理战略</h2><h3 id="1-3-1-治理战略制定"><a href="#1-3-1-治理战略制定" class="headerlink" title="1.3.1 治理战略制定"></a>1.3.1 治理战略制定</h3><p><strong>制定方法</strong>：</p><blockquote><p>自上而下：规范标准先行，规范型好，见效慢<br>自下而上：业务需求驱动，整合困难，见效快<br>生产系统切入：有大型生产系统开发建设模式、企业数据模型建设模式、主数据建设模式<br>数据系统切入：统一数据平台模式、数据集市模式</p></blockquote><p><strong>制定过程</strong>：</p><ol><li>定义数据治理运营框架<ul><li>数据对组织的价值</li><li>业务模式：考虑分散式与集中式、本地化与国际化等内容</li><li>文化因素</li><li>监管影响：考虑监管程度对数据治理心态和运营模式的改变</li></ul></li><li>制定目标、原则和制度：由数据管理专业人员和业务策略人员起草，数据管理专员和管理人员审核完善，数据管理委员会终审、发布。内容包括数据治理范围、数据所有者确定规则、规定成员任务、制定评估细则、确定数据访问权限等</li><li>推动数据管理项目</li><li>参与变革管理：沟通讨论如下问题<ul><li>提升数据资产价值</li><li>监控数据治理活动反馈并采取行动</li><li>实施数据管理培训</li><li>实施新的指标和关键绩效(KPI)</li></ul></li><li>参与问题管理：需要确定的内容如下：<ul><li>识别、收集、记录和更新的问题</li><li>各项活动的评估和跟踪</li><li>记录利益相关方的观点和可选择的解决方案</li><li>确定、记录和传达问题解决方案</li><li>促进客观、中立的讨论，听取各方意见</li><li>将问题升级到更高权限级别</li></ul></li><li>评估法规遵从性要求，相关法规如下<ul><li>会计准则</li><li>BCBS 239</li><li>CPG 235</li><li>PGI-DSS</li><li>偿付能力标准 (二)</li><li>隐私法</li></ul></li></ol><h3 id="1-3-2-治理战略实施"><a href="#1-3-2-治理战略实施" class="headerlink" title="1.3.2 治理战略实施"></a>1.3.2 治理战略实施</h3><ol><li>发起数据标准和规程</li><li>制定业务术语表<ul><li>对核心业务概念和术语有共同的理解</li><li>降低因业务概念理解不一致导致的数据误用危险</li><li>改进技术资产与业务组织之间的一致性</li><li>最大限度地提高搜索能力，并能够记录在案的组织知识</li></ul></li><li>协调架构团队协作</li><li>发起数据资产估值</li></ol><h2 id="1-4-度量指标"><a href="#1-4-度量指标" class="headerlink" title="1.4 度量指标"></a>1.4 度量指标</h2><ol><li>价值<ul><li>对月目标的贡献</li><li>风险的降低</li><li>运营效率的提高</li></ul></li><li>有效性<ul><li>目标的实现</li><li>采用工具的有效性</li><li>沟通的有效性</li><li>培训的有效性</li><li>采纳变革的速度</li></ul></li><li>可持续性<ul><li>制度和流程的执行情况</li><li>标准和规程的遵从情况</li></ul></li></ol><h1 id="2-数据治理工作"><a href="#2-数据治理工作" class="headerlink" title="2. 数据治理工作"></a>2. 数据治理工作</h1><h2 id="2-1-数据标准"><a href="#2-1-数据标准" class="headerlink" title="2.1 数据标准"></a>2.1 数据标准</h2><p><strong>数据标准管理</strong>：包括标准定义、标准查询、标准发布等功能</p><p><strong>数据标准</strong>：对分散在个系统中的数据提供统一的数据命名、数据定义、数据类型、赋值规则等的定义基准；通过运行维护这套基准可以防止用语的乱用，维持数据模型的一致性，保证数据的一直性和数据质量</p><h3 id="2-1-1-标准化流程"><a href="#2-1-1-标准化流程" class="headerlink" title="2.1.1 标准化流程"></a>2.1.1 标准化流程</h3><ol><li><p><strong>选定标准化对象</strong>：定义标准化指南，包括命名规则；收集源数据，一般从专业词典用语、表定义书、编码定义书、ERD、DB Catalog、专业书籍等收集</p></li><li><p><strong>单词标准化</strong>：词素拆分、定义单词；构建标准单词词典和同义词典；国际/内惯例(标准缩写) -&gt; 行业标准 -&gt; 项目标准</p></li><li><p><strong>域标准化</strong>：定义域范围、定义域的数据类型、数据长度（包括小数点位数）、业务含义等 ；构建标准域词典；编码域（代码）、编号域、组域</p></li><li><p><strong>用语标准化</strong>：判断用语的遵守；构建标准用语词典</p></li></ol><h2 id="2-2-主数据"><a href="#2-2-主数据" class="headerlink" title="2.2 主数据"></a>2.2 主数据</h2><p><a href="https://qizhongyi.gitee.io/202108/2554322.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>主数据管理</strong></font></a>：包括主数据申请、主数据发布、主数据分发等功能<br><strong>分类</strong>：<strong>参与方主数据</strong>：是关于个人、组织及其在业务关系中扮演角色的数据；<strong>财务主数据</strong>：包括有关业务部门、成本中心、利润中心、总账账户、预算、计划和项目的数据；<strong>法律主数据</strong>：包括合同、法规和其他法律事务的数据；<strong>产品主数据</strong>：专注于组织的内部产品和服务，或全行业的产品和服务；<strong>位置主数据</strong>：提供跟踪和共享地理信息的能力，并根据地理信息创建层次关系或地图；<strong>行业主数据</strong>：参考目录是主数据实体的权威清单，组织可以购买和使用主数据实体作为交易的基础</p><h2 id="2-3-元数据"><a href="#2-3-元数据" class="headerlink" title="2.3 元数据"></a>2.3 元数据</h2><p><a href="https://qizhongyi.gitee.io/202108/2719375.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>元数据管理</strong></font></a>：包括元数据采集、血缘分析、影响分析等功能<br><strong>分类</strong>：<strong>业务元数据</strong>：关注数据的内容和条件，包括与数据治理详细信息：主题域、概念、实体、属性的非技术名称和定义、属性的数据类型和其他特征，如范围描述、计算公式、算法和业务规则、有效的值域及其定义；<strong>技术元数据</strong>：数据的技术实现；<strong>操作元数据</strong>：数据处理的过程与关系</p><h2 id="2-4-数据质量"><a href="#2-4-数据质量" class="headerlink" title="2.4 数据质量"></a>2.4 数据质量</h2><p><a href="https://qizhongyi.gitee.io/202108/2860861.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据质量</strong></font></a>：包括质量规则定义、质量检查、提供质量报告等功能；包括规划和实施质量管理技术，测量、评估和提高企业内数据的适用性，提高数据对业务和管理的满意度，是一项持续地任务</p><p><strong>数据质量工作内容</strong>：</p><blockquote><p>设定优先级<br>确定和协调有权参加各种数据质量相关决定和相关活动的人<br>制定和维护数据质量标准<br>报告企业范围内数据质量的相关测量<br>提供有助于员工参与的指导<br>建立知识共享的沟通机制<br>制定和应用数据质量和合规政策<br>监控和报告绩效<br>共享数据质量报告检查结果，以提高认识、确定改进机会，并就改进达成共识<br>解决变化和冲突，提供方向性指导</p></blockquote><p><strong>评估内容</strong>：</p><blockquote><p><strong>完整性</strong>：数据不存在缺失记录或缺失字段<br><strong>唯一性</strong>：在满足业务需求下不允许重复同时也解决了数据不一致的潜在可能<br><strong>及时性</strong>：数据的最近更新时间<br><strong>合理性</strong>：考察数据内容的正确性，数据是否真实可用，保证数据内容在信息含义上一致<br><strong>规范性</strong>：对数据标准、数据模型、业务规则、元数据和参考数据进行完整性、质量及归档的度量<br><strong>关联性</strong>：关联数据的缺失或未建立索引</p></blockquote><p><strong>数据质量问题纠正</strong>：<strong>自动纠正</strong>：基于规则的标准化、规范化和更正，修改后的值在没有人工干预的情况下自动获取、生成和提交，需要具有定义良好的标准、普遍接受的规则和已知的错误模式等；<strong>人工检查纠正</strong>：使用自动工具矫正和纠正数据，人工检查后将纠正持久化存储；<strong>人工修正</strong>：通过人工按照数据质量规则处理变更</p><h2 id="2-5-数据安全"><a href="#2-5-数据安全" class="headerlink" title="2.5 数据安全"></a>2.5 数据安全</h2><p><a href="https://qizhongyi.gitee.io/202108/2228179.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据安全</strong></font></a>：包括数据权限管理、数据脱敏、数据加密等功能；采用各种技术和管理措施，保证数据的机密性、完整性和可用性，确保数据不被破坏，且能被适当访问，包括数据访问安全标准、监控和审计程序和存储安全标准等，包括安全策略和过程的规划，遵循  <strong>最小授权原则</strong><br><strong>安全风险</strong>：既指损失的可能性，也指构成潜在损失的事务或条件</p><p><strong>数据安全内容</strong>：</p><ul><li><strong>设施安全</strong>：抵御恶意行为人员的第一道防线仅允许授权员工访问</li><li><strong>设备安全</strong>：防止U盘、笔记本丢失被盗带来的损失<ul><li>使用移动设备连接的访问策略，如笔记本、CD、USB驱动器等</li><li>在便携式设备上存储数据</li><li>符合记录管理策略的设备数据擦除和处置</li><li>反恶意软件和加密软件安装</li><li>安全漏洞意识</li></ul></li><li><strong>凭据安全</strong><ul><li>身份管理系统</li><li>电子邮件系统的用户ID标准</li><li>密码标准</li><li>多因素识别</li><li>电子通信安全</li></ul></li></ul><h2 id="2-6-数据集成"><a href="#2-6-数据集成" class="headerlink" title="2.6 数据集成"></a>2.6 数据集成</h2><p><a href="https://qizhongyi.gitee.io/202108/2311121.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据集成</strong></font></a>：包括数据处理、数据加工、数据汇集等功能，数据集成是将数据整合成，核心是ETL操作</p><h2 id="2-7-数据资产"><a href="#2-7-数据资产" class="headerlink" title="2.7 数据资产"></a>2.7 数据资产</h2><p><a href="https://qizhongyi.gitee.io/202208/2429729.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据资产</strong></font></a>：包括数据资产编目、数据资产服务、数据资产审批等功能</p><h2 id="2-8-生命周期管理"><a href="#2-8-生命周期管理" class="headerlink" title="2.8 生命周期管理"></a>2.8 生命周期管理</h2><p><strong>生命周期管理</strong>：包括数据归档、数据销毁等功能</p><ul><li>在线阶段</li><li>归档阶段</li><li>销毁阶段</li></ul><h1 id="3-时序数据治理"><a href="#3-时序数据治理" class="headerlink" title="3. 时序数据治理"></a>3. 时序数据治理</h1><p><strong>时序数据</strong>：按照时间顺序记录的数据列，同一数据列的各个数据必须同口径，具有可比性；可以是时期数(一段时间)，也可以是时点数(瞬时数据)，如实时数据：运行监测数据、安全检测数据、环境监测数据等</p><h2 id="3-1-时序数据特点"><a href="#3-1-时序数据特点" class="headerlink" title="3.1 时序数据特点"></a>3.1 时序数据特点</h2><blockquote><p>按时间顺序产生：联网设备按照设定的时间周期或外部事件的触发，源源不断的产生数据，一定带有时间戳<br>结构化数据：由物联网设备产生的结构化数值型数据<br>极少更新：由物联网设备产生的机器日志数据，不允许或没必要修改<br>数据源唯一：物联网数据的采集完全独立，数据的生产者唯一<br>关注时间趋势：用户关注一段时间的趋势，查询、分析基于时间段和某一组设备<br>保留时间有限：基于时长进行留存管理<br>实时分析计算：需要进行实时分析计算，进行实时报警，避免事故发生<br>流量平稳：设备产生数据平稳、有规律，需要的带宽、流量、增量数据大小可预测<br>插值处理：统计时间和数据生成时间不匹配，需要根据数据产生规律进行插值处理或数学函数计算<br>数据量巨大</p></blockquote><h2 id="3-2-技术挑战"><a href="#3-2-技术挑战" class="headerlink" title="3.2 技术挑战"></a>3.2 技术挑战</h2><blockquote><p>高并发、高吞吐量的写入能力：支持每秒千万级数据的写入<br>数据高速聚合：支持秒级速度对亿级数据进行分组聚合运算<br>降低存储成本：数据的高压缩率<br>多维度查询能力：多维度高效查询进行数据分析</p></blockquote><h2 id="3-3-时序数据处理工具"><a href="#3-3-时序数据处理工具" class="headerlink" title="3.3 时序数据处理工具"></a>3.3 时序数据处理工具</h2><ul><li><p><strong>PI代表的实时数据库</strong>：处理工业自动控制或流程制造行业的实时数据，20世纪80年代，美国</p><blockquote><p>没有水平扩展能力，数据量增加，只能依靠硬件纵向扩展解决<br>技术架构老旧<br>数据分析能力偏弱，不支持现在流行的各种数据分析接口<br>不支持云端部署，不支持SaaS</p></blockquote></li><li><p><strong>InfluxDB</strong>：采用 Key-Value 和 LSM技术，支持多列数据写入，采用不需要预先定义数据表结构的 Schemaless 模式，美国 InfluxData公司通过 GO语言开发</p></li><li><p><strong>OpenTSDB</strong>：基于 Hbase开发的 Apache 开源软件，采用 Schemaless 模式，建立在 Hadoop 体系上，性能依靠众多组件，安装部署复杂</p></li><li><p><strong>TDengine</strong>：中国开发的时序数据库开源软件，支持缓存、消息队列、数据订阅、流式计算等</p><blockquote><p>插入查询性能高<br>消耗计算资源少<br>采用列式存储，对不用类型采取不同压缩算法，占用存储资源少<br>无需分库分表，无实时数据、历史数据区别，管理成本低<br>采用标准 SQL语法，可通过标准 JDBC、ODBC接口链接数据库</p></blockquote></li><li><p><strong>TimeScale</strong>：美国基于 Postgres 基础开发的开源项目</p></li></ul><h2 id="3-4-时序数据处理工具功能"><a href="#3-4-时序数据处理工具功能" class="headerlink" title="3.4 时序数据处理工具功能"></a>3.4 时序数据处理工具功能</h2><blockquote><p>高效的分布式系统：时序数据需要分布式、水平扩展，支持数据的快速写入和快速查询<br>实时的处理系统：基于采集数据进行实时预警、决策<br>运营商级别的高可靠服务：实时数据必须支持高可靠、实时备份、异地容灾、在线升级<br>高效的缓存功能：快速获取设备当前状态，用于预警和大屏展示<br>实时流式计算：通过对设备产生的数据流进行实时聚合运算实现实时预警预测<br>支持数据订阅：更新数据实时提醒应用<br>实时数据、历史数据合并处理<br>保证数据能持续稳定地写入<br>支持灵活的多维数据分析<br>支持数据降频、插值、特殊函数计算等<br>支持即席分析和查询：支持多种访问工具进行SQL查询<br>提供灵活的数据管理策略：对不同类型的数据提供多种管理策略<br>开放，支持各种语言开发接口，方便扩展<br>支持异构环境：支持各种档次、不同配置的服务器和存储设备并存<br>支持边云协同：支持根据需要将数据上传到云端，可以更改同步策略<br>单一的后台管理系统：便于查看系统运行状态、管理集群、管理用户、管理各种系统资源等<br>便于私有化部署：保障数据安全</p></blockquote><h1 id="4-数据共享"><a href="#4-数据共享" class="headerlink" title="4. 数据共享"></a>4. 数据共享</h1><p><strong>数据共享管理</strong>：开展数据共享和交换，打通企业内部部门间的共享瓶颈，建立统一规范的数据标准和数据共享制度，实现数据内外部价值，包括数据内部共享、外部流通和对外开放，对外部开放可以直接交易或提供数据分析信息</p><h2 id="4-1-数据共享难点"><a href="#4-1-数据共享难点" class="headerlink" title="4.1 数据共享难点"></a>4.1 数据共享难点</h2><ol><li>主导权之争：数据主权难以确定</li><li>隐私保护难</li><li>数据确权难：数据容易复制，难以明确数据的生产者、使用者、管理者及受益者</li><li>无激励机制：难以量化每个数据贡献者的贡献大小</li></ol><h2 id="4-2-解决"><a href="#4-2-解决" class="headerlink" title="4.2 解决"></a>4.2 解决</h2><p><strong>区块链</strong>：是分布式数据存储、点对点传输、共识机制、加密算法等计算机技术的新型应用模式，包括加密货币的公有链、解决商业社会问题的联盟链</p><blockquote><p>分布式账本技术解决主导权问题<br>密码学技术解决数据隐私保护问题<br>区块链可溯源解决数据确权问题<br>区块链数学算法解决终端用户授权问题<br>基于零知识证明技术实现数据共享<br>基于智能合约的积分激励机制</p></blockquote><h3 id="4-2-1-区块链技术"><a href="#4-2-1-区块链技术" class="headerlink" title="4.2.1 区块链技术"></a>4.2.1 区块链技术</h3><blockquote><p>分布式账本技术：是网络成员之间共享、复制和同步数据的技术，记录网络参与者之间的交易数据，点对点技术的去中心化（每个参与方都有一份账本）、不可被篡改<br>密码学技术：零知识证明、加 / 解密授权（哈希、非对称加密、CA签名）等<br>智能合约<br>激励机制：积分制激励</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
            <tag> 数据治理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据管理-基础</title>
      <link href="/202108/1716965.html"/>
      <url>/202108/1716965.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍数据管理相关的基础内容</p><span id="more"></span><h1 id="1-数据管理"><a href="#1-数据管理" class="headerlink" title="1. 数据管理"></a>1. 数据管理</h1><p><strong>数据管理</strong>：是数据资源获取、控制和价值提升等活动的集合，具体指为保护和提高数据和信息资产价值，在其整个生命周期中制定计划、制度和实践活动，并执行和监督，包括数据治理、数据架构、数据模型与设计、数据存储与操作、数据安全管理、数据集成与互操作、文件和内容管理、参考数据和主数据管理、数据仓库和商务智能、元数据管理、数据质量管理11个管理职能<br><strong>数据战略</strong>：包括使用数据信息以获得竞争优势和支持企业目标的业务计划，来自于对业务战略固有数据需求的深度理解<br><strong>数据管控</strong>：是企业开展数据治理的重要基础性保障，为数据治理提供人才团队、制度规范、文化氛围等</p><h2 id="1-1-业务目标"><a href="#1-1-业务目标" class="headerlink" title="1.1 业务目标"></a>1.1 业务目标</h2><p>满足企业及利益相关方（包括客户、员工和业务合作伙伴等）的信息需求；获取、存储、保护数据，确保数据资产的完整性；确保数据和信息的质量；确保利益相关方的数据隐私和保密性；防止数据和信息未经授权或被不当的访问、操作及使用；确保数据能有效地服务与企业增值的目标；短期目标（满足基本的管理决策与业务协同）、中期目标（创新与转型）、长期目标（定义企业在数字化竞争生态中的角色和地位）</p><h2 id="1-2-原则"><a href="#1-2-原则" class="headerlink" title="1.2 原则"></a>1.2 原则</h2><p>认识到数据是具有独特属性的资产；用经济术语表示数据价值：认识到数据资产的经济价值，进行量化分析；数据管理需要领导层全力推动，进行规划；数据管理需要企业级视角，进行跨职能工作，多角度思考，业务部门全面配合；进行元数据管理、严格的数据质量管理、合理的全生命周期管理，加强规范管理；数据管理需要纳入数据相关风险；数据管理驱动信息技术决策，数据战略与业务战略一致</p><h2 id="1-3-数据管理战略内容"><a href="#1-3-数据管理战略内容" class="headerlink" title="1.3 数据管理战略内容"></a>1.3 数据管理战略内容</h2><p>令人信服的数据管理愿景，数据管理的使命和长期目标；符合 SMART原则（具体、可衡量、可操作、现实、时间限制）的短期数据管理计划目标；指导原则、价值观和管理观点，对数据管理角色和组织的描述，以及其对职责和决策权的总结；数据管理程序组件和初始化任务，具体明确范围的优先工作计划，包含项目和行动任务的实施路线图草案；数据管理的商业案例总结，数据管理成功的建议措施</p><h2 id="1-4-管理职能"><a href="#1-4-管理职能" class="headerlink" title="1.4 管理职能"></a>1.4 管理职能</h2><ul><li><p><a href="https://qizhongyi.gitee.io/202108/1813539.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据治理</strong></font></a>：对数据资产管理行使权力和控制的集合，包括规划、监督，执行等</p><ul><li><p><strong>减少风险</strong>：改善数据质量、控制数据风险、增强数据安全</p><blockquote><p><strong>一般性风险管理</strong>：洞察数据对财务、商誉造成的影响，包括法律和监管问题<br><strong>数据安全</strong>：通过控制活动保护数据资产的可获得性、可用性可审计和数据安全<br><strong>隐私</strong>：通过制度对私密信息进行合规性监控</p></blockquote></li><li><p><strong>改进流程</strong>：降低业务运营成本、提升业务运营效率、赋能管理决策</p><blockquote><p><strong>法规遵从性</strong>：有效持续地响应监管要求<br><strong>数据质量提升</strong>：通过真实可信的数据提升业务绩效<br><strong>元数据管理</strong>：建立业务术语表，定义定位组织中的数据<br><strong>项目开发效率</strong>：在系统生命周期（SDLC） 中改进，解决整个组织中的数据管理问题<br><strong>供应商管理</strong>：控制数据处理的合同，包括云存储、外部数据采购、数据产品销售和外包数据运维等</p></blockquote></li><li><p><strong>区别</strong>：数据治理强调顶层的策略，管理是侧重于流程和执行</p></li></ul></li><li><p><a href="https://qizhongyi.gitee.io/202108/1919413.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据架构</strong></font></a>：用于定义数据需求，整合和控制数据资产，与业务战略匹配的一整套构建规范，包括企业级数据模型、工具标准、系统命名规范、数据资源分布等内容的管理</p><blockquote><p>利用新兴技术从战略上帮助组织快速改变产品、服务和数据<br>将业务需求转换为数据和应用需求，确保为业务流程提供数据<br>管理复杂的数据和信息，实现企业内共享<br>确保业务和 IT技术 保持一致<br>为企业改革、转型和提高适应性支撑</p></blockquote></li><li><p><a href="https://qizhongyi.gitee.io/202108/2040152.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据建模</strong></font></a>：<strong>数据建模与设计</strong>，是发现、分析和确定数据需求的过程，通过数据模型精确表示传达数据需求，包括数据模型管理程序<br><strong>数据建模</strong>：是发现、分析和确定数据需求的过程，通过数据模型精确地表示和传递数据需求<br><strong>数据模式</strong>：关系模式、多维模式、面向对象模式、事实模式、时间序列模式和 NoSQL模式<br><strong>模型分层</strong>：概念模型 —&gt; 逻辑模型（E-R图） —&gt; 物理模型（类图）</p><blockquote><p>提供有关数据的通用词汇表<br>获取、记录组织内数据和系统的详细信息<br>在项目中作为主要的交流沟通工具<br>提供应用定制、整合、替换的起点</p></blockquote></li><li><p><a href="https://qizhongyi.gitee.io/202108/2113176.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据存储</strong></font></a>：<strong>数据存储与操作</strong>，包括对存储数据的设计、实施和支持，包括标准工具、数据库性能和业务连续性标准等，最大化数据资源价值，贯穿整个数据生命周期</p><blockquote><p>在整个数据生命周期中管理数据的可用性<br>确保数据资产的完整性<br>管理数据交易事务的性能</p></blockquote></li><li><p><a href="https://qizhongyi.gitee.io/202108/2228179.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据安全管理</strong></font></a>：采用各种技术和管理措施，保证数据的机密性、完整性和可用性，确保数据不被破坏，且能被适当访问，包括数据访问安全标准、监控和审计程序和存储安全标准等，包括安全策略和过程的规划</p><ul><li><strong>降低风险</strong><ul><li>支持适当访问并组织对企业数据资产的不当访问</li><li>支持对隐私、保护和保密制度、法规的遵从</li><li>确保满足利益相关方的隐私保密要求</li></ul></li><li><strong>业务增长</strong></li><li><strong>安全性作为资产</strong></li></ul></li><li><p><a href="https://qizhongyi.gitee.io/202108/2311121.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据集成</strong></font></a>：<strong>数据集成与互操作</strong>，描述了数据在不同数据存储、应用程序和组织三者内部之间进行移动和整合的相关过程，数据集成是将数据整合成，核心是ETL操作</p><blockquote><p>及时以数据消费者所需的格式提供数据<br>将数据物理地或虚拟地合并到数据中心<br>通过开发共享模型和接口来降低管理解决方案的成本和复杂度<br>识别有意义的事件，自动触发警报并采取行动<br>支持商务智能、数据分析、主数据管理以及运营效率的提升</p></blockquote></li><li><p><a href="https://qizhongyi.gitee.io/202108/2426382.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>文件和内容管理</strong></font></a>：针对存储在关系型数据库之外的数据和信息的采集、存储、访问和使用过程的管理，重点保持文件和非结构化、半结构化数据的信息完整性</p><blockquote><p>确保能够高速有效的采集使用非结构化数据与信息<br>确保结构化和非结构化数据之间的整合能力<br>遵守法律业务并达到客户预期</p></blockquote></li><li><p><a href="https://qizhongyi.gitee.io/202108/2554322.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>主数据管理</strong></font></a>：<strong>参考数据和主数据管理</strong>，满足主数据、参考数据相对稳定，变化缓慢，可唯一识别的业务需求，提供数据共享基础<br>  <strong>参考数据</strong>：描述组织中的其他数据，或将组织数据与外部信息联系起来，如代码表和描述表</p><blockquote><p>确保组织在各个流程中都拥有完整、一致、最新且权威的参考数据和主数据<br>促使组织在各业务单元和应用系统之间共享参考数据和主数据<br>通过标准的、通用的数据模型和整合模式，降低数据使用和数据整合的成本及复杂性</p></blockquote><p><strong>主数据</strong>：是有关业务实体的数据，如雇员、客户、产品等，以通用和抽象概念形式为业务交易和分析提供语境数据，包括业务交易涉及的内部和外部的详细信息（定义和标识符），以满足跨部门业务协同需要、反映核心业务实体状态属性的基础信息</p></li></ul><ul><li><p><a href="https://qizhongyi.gitee.io/202108/2634627.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据仓库</strong></font></a>：<strong>数据仓库和商务智能</strong>，通过数据仓库技术实现商务智能，支持商业决策<br><strong>数据仓库</strong>：Data Warehouse，简写为 DW 或 DWH，是一个面向主题的、集成的、稳定的、随时间变化的数据集合，是面向分析的集成化数据环境，通过形成分析报告和各类报表提供企业决策支持<br><strong>商务智能</strong>：包括理解组织诉求和寻找机会的数据分析活动，及其相关的技术集合。促成了数据挖掘、报表分析、数据可视化等</p><blockquote><p>方便地存取数据，及时、一致地展示信息<br>支持商务智能活动<br>赋能商业分析和高效决策<br>能够适应实时变化，基于数据洞察寻找创新方法</p></blockquote></li><li><p><a href="https://qizhongyi.gitee.io/202108/2719375.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>元数据管理</strong></font></a>：通过元数据资料库（MetaData Repository）进行统一的存储与管理，赋能企业数据资产<br><strong>元数据</strong>：描述数据的数据，对数据资源进行描述、解释 、定位等，便于检索和管理，包括技术和业务流程、数据规则和约束，还包括逻辑数据结构和物理数据结构等。用来描述数据本身（如数据库、数据元素、数据模型），数据表示的概念（如业务流程、应用系统软件代码、技术基础设施），数据与概念之间的联系（关系）</p><blockquote><p>收集记录元数据内容，确保元数据完整性<br>建立元数据标准，提供标准路径访问元数据和元数据标准语义<br>整合管理不同来源的元数据进行统一管理<br>确保元数据的数据质量、数据一致性、数据及时性和数据安全<br>创建准确的血缘分析、关联度分析和影响分析，增加对数据流向的认识<br>满足数据监规范，合理使用数据<br>提供全面的数据背景、历史和来源，降低培训成本和人员流动影响<br>提供上下文语境和执行数据质量检查，提高数据可信度<br>明确数据语义，提高数据使用者和IT人员的沟通效率<br>明确数据流程，识别冗余、过时和不正确的数据<br>扩展元数据用途，增加战略信息（如主数据）的价值</p></blockquote></li><li><p><a href="https://qizhongyi.gitee.io/202108/2860861.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>数据质量管理</strong></font></a>：包括规划和实施质量管理技术，测量、评估和提高企业内数据的适用性，提高数据对业务和管理的满意度，是一项持续的任务</p><blockquote><p>提高组织数据价值和数据利用的机会<br>降低低质量数据导致的风险和成本<br>提高组织效率和生产力<br>保护和提升组织的声誉<br>定义数据质量控制的标准和规范</p></blockquote></li><li><p>数据资产管理：对数据资产进行管理，规划、控制数据及信息资产的业务活动，包括开发、执行和监督有关数据的计划、政策、项目等，确保数据资产保值、升值，贯穿数据整个生命周期<br><strong>数据资产</strong>：由企业拥有或控制的（包括以合法途径获取的企业外部数据资源），未来能够带来经济利益的，以物理或电子方式记录的数据资源等，如文档资料、电子数据等</p></li></ul><p><strong>时代背景</strong>：第四次工业革命，以 CPS（Cyber-Physical Systems，信息物理系统）作为实施核心技术<br><strong>技术特征</strong></p><blockquote><p>智能感知：信息来源、采集方式和管理方式保证了数据的质量和全面性<br>数据信息转化：对数据进行特征提取、筛选、分类和优先级排序<br>网络融合：将机理、环境和群体有机结合，构建能指导实体空间的网络环境，包括景区同步、关键建模、变化记忆、分析预测等<br>自我认知：结合机理模型和数据驱动模型，保证数据解读符合客观规律，并在机理上反映对象状态变化<br>自由配置：根据活动目标进行优化，进而体现决策实现价值</p></blockquote><h2 id="1-5-模型架构"><a href="#1-5-模型架构" class="headerlink" title="1.5 模型架构"></a>1.5 模型架构</h2><ul><li><strong>战略一致性模型（SAM）</strong>：模型的中心是数据与信息之间的关系，业务战略、IT战略、组织与流程、信息系统，如下图所示：<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/DM_%E6%88%98%E7%95%A5%E4%B8%80%E8%87%B4%E6%80%A7%E6%A8%A1%E5%9E%8B.png" alt="DM_战略一致性模型"></li><li><strong>阿姆斯特丹信息模型（AIM）</strong>：从战略角度看待业务域IT的一致性，分为9个单元，如下图所示：<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/DM_%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E4%B8%B9%E4%BF%A1%E6%81%AF%E6%A8%A1%E5%9E%8B.png" alt="DM_阿姆斯特丹信息模型"></li><li><strong>DAMA-DBBOK模型</strong>：DAMA车轮图，将数据治理作为数据管理的核心，如下图所示：<br><img src="https://qizhongyi.gitee.io/images/Data/DataManage/DM_DAMA%E8%BD%A6%E8%BD%AE%E6%A8%A1%E5%9E%8B.png" alt="DM_DAMA车轮模型"><br><strong>环境因素六边形图</strong>：显示人、过程和技术之间的关系<br><strong>知识领域语境关系图</strong>：描述人员、流程和技术等知识领域的相关细节，基于产品管理的 <strong>SIPOC图</strong> 概念，包括如下内容：</li></ul><blockquote><p>定义：知识领域的简要定义<br>目标：知识领域内指导活动执行的目的、基本原则<br>活动：实现知识领域目标所需的行动和任务，分为计划、控制、开发和运营</p><blockquote><p>计划活动 Plan：为实现数据管理目标指定战略战术工作<br>控制活动 Control：持续确保数据质量<br>开发活动 Develop：围绕数据生命周期开展分析、设计、构建、测试、准备和部署工作<br>运营活动 Operate：支持系统和流程的使用、维护和增强</p></blockquote><p>输入：知识领域启动活动需要的有形实物<br>交付成果：知识领域内的产出<br>角色和职责<br>相关参与方：供给者，消费者，参与者<br>工具<br>方法<br>质量指标</p></blockquote><h2 id="1-6-管理实施"><a href="#1-6-管理实施" class="headerlink" title="1.6 管理实施"></a>1.6 管理实施</h2><ul><li><p><strong>统筹规划</strong>：<strong>建立数据管理组织和制度</strong>，明确各级角色和职责，形成规范的管理标准和管理人才；确定管理目标，<strong>盘点数据资产</strong>，熟悉数据来源、采集手段和硬件设备；<strong>制定数据标准规范</strong>，包括元数据模型标准、主数据标准、核心业务指标数据标准、业务数据模型标准等，规划数据仓库、元数据库、主数据库建设</p></li><li><p><strong>管理实施</strong>：搭建大数据管理平台、完成数据汇聚工作，建设或采购必要的数据资管理平台或第三方工具；梳理数据质量规则，建立高质量数据评估标准；建立安全管理体系，执行数据安全管理职能；明确企业核心业务实体数据（主数据），进行规范化管理<br><strong>组织方式</strong></p><ul><li><strong>自上而下</strong>的顶层设计模式：标准规范先行<blockquote><p>调研数据资产分布现状<br>评估数据资产管理水平<br>建设数据资产管理体系</p></blockquote></li><li><strong>自下而上</strong>的各个击破模式：问题导向，建设先行，快速见效</li></ul><p><strong>建设策略</strong></p><ul><li>生产系统入手<blockquote><p>大型生产系统开发建设模式：从大型生产系统开发入手，借助项目建设契机，建立该应用和业务领域数据的企业级标准和质量管控<br>企业数据建设模式：企业数据建设模式是从企业数据模型出发，在建模的同时建立标准，规范生产环节的数据录入，保证数据质量<br>主数据模式：主数据建设模式是从主数据的质量和业务协同入手，推动生产环节在客户、无聊、组织机构、产品、统一编码</p></blockquote></li><li>数据系统入手<blockquote><p>统一数据平台模式：统一数据平台模式是从数仓、大数据平台等统一数据整合平台入手，统一接入各业务各公司的数据，统一语义和标准，提升数据质量<br>数据集市模式：数据集市模式从某个特懂的分析主题入手，在各业务单独建立数据仓库，能满足各自数据分析需求的基础下，统一每个业务数仓的语义和标准规范，实现物理分离、逻辑统一</p></blockquote></li></ul></li><li><p><strong>稽核检查</strong>：数据管理是一项常态化的工作，包括数据标准执行情况检查的常态化，全流程数据质量稽核的常态化和灵活配置数据存储策略的常态化，对数据按照价值进行分类分级，形成数据资产目录，制定相应的存储策略</p></li><li><p><strong>资产运营</strong>：以实现业务价值为导向，用户为中心，为企业内外部不同层面用户提供数据价值，是数据管理实现价值的最终阶段</p></li></ul><h1 id="3-数据处理伦理"><a href="#3-数据处理伦理" class="headerlink" title="3. 数据处理伦理"></a>3. 数据处理伦理</h1><p><strong>伦理</strong>：是建立在是非观念上的行为准则，在没有人注意到的情况下做正确的事<br><strong>数据处理伦理</strong>：以符合伦理准则的方式获取、存储、管理、使用和销毁数据</p><h2 id="3-1-核心问题"><a href="#3-1-核心问题" class="headerlink" title="3.1 核心问题"></a>3.1 核心问题</h2><p><strong>对人的影响</strong>：数据代表个人特征，可用于各类决策，需要保证质量与可靠性<br><strong>滥用的可能</strong>：需要伦理准则防止数据滥用<br><strong>数据经济价值</strong>：需要规定数据所有权，规定使用者、使用方式和受益者等</p><h2 id="3-2-伦理准则"><a href="#3-2-伦理准则" class="headerlink" title="3.2 伦理准则"></a>3.2 伦理准则</h2><p><strong>尊重数据所有者</strong>：尊重个人尊严和自主权，尊重隐私权，提供数据保护<br><strong>数据行善</strong>：不利用数据伤害他人，将利益最大化、伤害最小化<br><strong>待人公平公正</strong>：平衡数据问题带来的利益分配不均<br><strong>尊重法律和公众利益</strong>：确定数据负责人承担相关责任<br><strong>在线言论自由</strong>：在法律允许范围内自由的表达自己的观点，不煽动、挑衅、侮辱他人等<br><strong>允许遗忘</strong>：允许从网上删除侵害个人声誉的个人信息</p><p><strong>数据隐私法的GDPR原则</strong>：</p><table><thead><tr><th><strong>GDPR准则</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>公平、合法、透明</td><td>数据主题中的个人数据应合法、公开、透明的处理</td></tr><tr><td>目的限制</td><td>按照指定、明确、合法的目的采集数据，且不能他用</td></tr><tr><td>数据最小化</td><td>仅限采集与处理目的必要的相关个人数据</td></tr><tr><td>准确性</td><td>保证个人数据最新有效，支持更新删除不准确的数据</td></tr><tr><td>存储限制</td><td>数据以可识别的数据主（个人）体保存，及时销毁</td></tr><tr><td>诚信和保密</td><td>使用适当技术妥善处理，防止数据意外丢失、破坏等</td></tr><tr><td>问责制度</td><td>操作人对数据负责，且符合上述原则</td></tr></tbody></table><p><strong>基于PIPEDA的法定义务</strong>：</p><table><thead><tr><th><strong>准则</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>问责制度</td><td>组织有责任对其下控制的个人信息负责，并接受监督</td></tr><tr><td>目的明确</td><td>明确数据采集目的后再开始采集</td></tr><tr><td>授权</td><td>须获得当事人同意才能能采集数据</td></tr><tr><td>收集、使用、披露和留存限制</td><td>仅通过公平合适的方式采集目标内所需的必要数据，不得随意披露个人数据或另作他用</td></tr><tr><td>准确性</td><td>个人信息必须准确、完整、及时，满足使用要求</td></tr><tr><td>保障措施</td><td>采集的个人数据需要采用匹配的、严格的保密措施</td></tr><tr><td>透明度</td><td>组织需要向当事人提供信息管理制度和具体实践内容</td></tr><tr><td>个人访问</td><td>个人有权访问信息的存在、使用和披露情况，且能质疑</td></tr><tr><td>合规挑战</td><td>个人遵从以上原则，且可向组织发起合规性质疑</td></tr></tbody></table><h2 id="3-3-违背伦理实例"><a href="#3-3-违背伦理实例" class="headerlink" title="3.3 违背伦理实例"></a>3.3 违背伦理实例</h2><ol><li><strong>时机选择</strong>：通过遗漏或根据时间将某些数据点包含在报告或活动中而撒谎</li><li><strong>可视化误导</strong>：利用图表图形误导性呈现数据</li><li><strong>定义不清晰或无效比较</strong>：统计维度不清晰或统计维度不相同的指标进行统计</li><li><strong>偏见</strong>：包括预设结论、片面抽样、背景文化等</li><li><strong>转换和集成数据</strong>：包括不了解数据来源和血缘关系、数据质量较差、元数据不可靠、缺少数据修订的历史文档等</li><li><strong>数据混淆和修订</strong>：用于信息脱敏或信息不公开处理，可能出现在以下情况，包括数据聚合、数据标记（标记敏感数据，控制发布到合适业务系统）、数据脱敏等</li></ol><h2 id="3-4-建立伦理文化"><a href="#3-4-建立伦理文化" class="headerlink" title="3.4 建立伦理文化"></a>3.4 建立伦理文化</h2><ol><li>评审现有的数据处理方法</li><li>识别原则、实践和风险因素：原则应与风险、实践保持一致，通过控制支持实践</li><li>指定合乎伦理的数据处理策略和路线图<ul><li>价值观申明：描述组织的信仰</li><li>数据处理原则：描述组织如何处理数据带来的挑战</li><li>合规架构：合规架构包括驱动阻止业务的因素</li><li>风险评估：定义组织内部特殊问题出现的可能和影响</li><li>培训交流：不间断的培训包括对伦理准则的审核</li><li>路线规划：由管理层批准的活动时间表</li><li>审计和检测方法</li></ul></li><li>采用对社会负责的伦理风险模型，保障个人信息隐私</li></ol><h1 id="4-数据管理成熟度评估"><a href="#4-数据管理成熟度评估" class="headerlink" title="4. 数据管理成熟度评估"></a>4. 数据管理成熟度评估</h1><p><strong>成熟度评估</strong>：明确组织发展现状，对比其他组织或行业基准所处阶段，设置衡量组织目标</p><h2 id="4-1-业务目标"><a href="#4-1-业务目标" class="headerlink" title="4.1 业务目标"></a>4.1 业务目标</h2><p><strong>监管</strong>：对数据管理提出最低成熟度水平要求；<strong>数据治理</strong>：基于数据治理成熟度评估业务规划和合规性目的；<strong>组织准备</strong>：评估当前状态，改进实践过程；<strong>组织变更</strong>：处理组织变更带来的数据管理挑战；<strong>新技术</strong>：评估采用新技术进行管理和使用数据的可能性；<strong>数据管理问题</strong>：评估当前数据管理需要解决的数据质量问题，实施变更</p><h2 id="4-2-评估内容"><a href="#4-2-评估内容" class="headerlink" title="4.2 评估内容"></a>4.2 评估内容</h2><p><strong>数据管控</strong>：包括数据管理战略、数据管理组织、数据管理制度、数据管理绩效等<br><strong>数据架构</strong>：包括数据标准管理、数据模型、主数据管理、元数据管理、数据分布、数据集成与共享等<br><strong>数据质量</strong>：包括数据质量需求、数据质量检查、数据质量评估、数据质量提升等<br><strong>数据生命周期</strong>：包括数据需求、数据设计和开发、数据运维、数据销毁等<br><strong>数据安全</strong>：包括数据安全策略、数据安全保护、数据安全审计等<br><strong>数据价值挖掘</strong>：包括数据分析、数据融合、数据应用、数据资产价值管理等<br><strong>数据资产运营</strong>：包括数据服务、数据共享与开放、数据资产变现等<br><strong>支撑平台</strong>：包括数据治理工具集、数据管理平台等</p><h2 id="4-3-评估分级"><a href="#4-3-评估分级" class="headerlink" title="4.3 评估分级"></a>4.3 评估分级</h2><p><strong>0级</strong>：无能力级，不存在<br><strong>1级</strong>：初始级或临时级，<strong>初始阶段</strong>：数据尚未发挥价值，使用有限的工具进行通用数据管理，成功取决于个人能力<br><strong>2级</strong>：可重复级，<strong>基本管理</strong>：数据支持业务基本工作，制定最初的流程规则，有一致的工具和角色定义支持流程执行<br><strong>3级</strong>：已定义级，<strong>主动管理</strong>：数据基本能满足业务管理要求，已建立标准并使用<br><strong>4级</strong>：已管理级，<strong>量化管理</strong>：数据完全满足业务需求，能力可以被量化和控制<br><strong>5级</strong>：优化级，<strong>持续优化</strong>：数据成为企业核心竞争力，可量化能力提升的目标</p><h2 id="4-4-评估模型"><a href="#4-4-评估模型" class="headerlink" title="4.4 评估模型"></a>4.4 评估模型</h2><ul><li><p><strong>数据管理能力成熟度评估模型DCMM</strong>：数据管理有8个能力域：数据战略、数据治理、数据架构、数据标准、数据质量、数据安全、数据应用和数据生存周期，全国信息技术标准化信息委员会大数据标准工作组（工信部、国家标准化管理委员会指导），可直接使用</p></li><li><p><strong>CMMI数据管理成熟度模型</strong>：CMMI（能力成熟度模型研究所）-DMM，评估标准包括数据管理战略、数据治理、数据质量、平台与架构、数据操作和支持流程等</p></li><li><p><strong>EDM数据管理能力评估模型</strong>：EDM（企业数据管理委员会，Enterprise Data Management Council）-DCAM（数据管理能力评估模型，Data management Capability Assessment Model），描述了与可持续数据管理项目开发相关的能力，重点关注利益相关方的参与程度、流程的形式以及展示能力的组件</p></li><li><p><strong>IBM数据治理委员会成熟度模型</strong>：定义一组可观察期望的行为，评估和设计数据治理项目</p><blockquote><p>结果：数据风险管理和合规、价值创造<br>使能因素：组织结构和认知、政策、管理<br>核心内容：数据质量管理、信息生命周期管理、信息安全和隐私<br>支持内容：数据架构、分类和元数据、审计信息、日志记录和报告</p></blockquote></li><li><p><strong>斯坦福数据治理成熟度模型</strong>：关注数据治理，区分基础部分（意识、形式化、元数据）和项目部分（数据管理、数据质量、主数据），说明人员、政策和能力的驱动因素阐明了每个成熟度级别的特征，提供了定性和定量的测量标准</p></li><li><p><strong>Gartner企业信息管理成熟度模型</strong>：评估了愿景、战略、度量、治理、角色和责任、生命周期和基础架构的标准</p></li></ul><p><strong>数据管理成熟度理论标准</strong></p><blockquote><p><strong>ISO/IEC 38505标准</strong>：基于原则驱动的数据治理方法论，通过评估现在和将来数据利用情况，指导数据准备及实施，并监督数据治理实施的符合性，2015年，国际标准化组织IT服务管理和IT治理分技术委员会<br><strong>GB/T 34960 数据治理规范</strong>：包括顶层设计、数据治理环境、数据治理域和数据治理过程，顶层设计包括战略规划、组织架构和架构规划，是数据治理实施的基础；数据治理环境包括分析业务、市场和利益相关方需求，适应内外部环境变化，营造企业内数据治理文化，是数据治理实施的保障；数据治理域包括数据管理体系和数据价值体系，是数据治理实施的对象；数据治理过程包括统筹规划、构建运行、监控评价、改进优化等，是数据治理实施的方法</p></blockquote><h2 id="4-5-选择标准"><a href="#4-5-选择标准" class="headerlink" title="4.5 选择标准"></a>4.5 选择标准</h2><p><strong>易用性</strong>：以非技术性属于描述实践活动，传达活动的功能本质<br><strong>全面性</strong>：涉及广泛的数据管理活动，包括业务和技术部门<br><strong>可扩展性</strong>和灵活性：支持行业特定或附加的规程，根据组织需要使用组件<br><strong>演进途径</strong>：内置定义每个功能逻辑的前进方式<br><strong>行业特定论</strong>：遵循跨垂直领域的数据管理最佳实践<br><strong>抽象或详细程度</strong>：实践和评估标准详细表达，确保指导相关执行工作<br><strong>非规定性</strong>：描述需要执行的内容<br><strong>按主题组织</strong>：将数据管理活动放置在适当的情境中，是每个活动能够单独评估，又可识别依赖关系<br><strong>可重复</strong>：可以得到一致解释，支持可重复结果<br><strong>中立支持</strong>：由中立的供应商广泛提供，确保最佳实践的广泛代表性<br><strong>技术中立</strong>：模型重点集中于实践<br><strong>培训支持</strong>：支持全面培训，能够掌握框架并优化使用方法</p><h2 id="4-6-评估结果"><a href="#4-6-评估结果" class="headerlink" title="4.6 评估结果"></a>4.6 评估结果</h2><ol><li><p>评估结果报告</p><blockquote><p>评估的业务驱动因素<br>评估的总体结果<br>按主题分类有差距的评级<br>弥补差距的建议方法<br>所观察到的组织优势<br>进展的风险<br>投资和成果选项<br>衡量进展的治理和指标<br>资源分析与未来潜在效用<br>可在组织内使用或重复使用的组件</p></blockquote></li><li><p>管理层简报：向管理层汇报评估调查结果</p></li><li><p>改进建议</p><blockquote><p>对特定数据管理功能进行改进的系列活动<br>实施改进活动的时间表<br>实施改进后，DMMA评级的预期改善情况<br>监督活动，包括时间线上逐渐成熟的监督</p></blockquote></li><li><p>实施改建措施</p></li><li><p>重新评估</p><blockquote><p>通过第一次评估建立基线评级<br>重新定义评估参数，包括组织范围<br>根据跟踪需要，重复 DMM评估<br>跟踪对于初始基线的趋势<br>根据评估结果指定改进建议</p></blockquote></li></ol><h2 id="4-7-度量指标"><a href="#4-7-度量指标" class="headerlink" title="4.7 度量指标"></a>4.7 度量指标</h2><p><strong>DMMA评级</strong>：提供组织能力级别的快照<br><strong>资源利用率</strong><br><strong>风险敞口</strong>：对风险情景做出反应的能力<br><strong>支出管理</strong>：描述组织中分配数据管理成本，确定成本对可持续性和价值的影响</p><blockquote><p>数据管理可持续性<br>实现主动性的目标和目的<br>沟通的有效性<br>教育培训的有效性<br>变更采用的速度<br>数据管理价值<br>对业务目标的贡献<br>降低风险<br>提高运营效率</p></blockquote><p><strong>DMMA的输入</strong>：包括技术、覆盖范围、可用性、系统数量、数据量、涉及团队<br><strong>变革速度</strong>：企业提高自身实力的速度</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PyCharm-安装使用</title>
      <link href="/202107/1118374.html"/>
      <url>/202107/1118374.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文介绍Python的实用工具-PyCharm安装使用的相关知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>PyCharm</strong>：支持 Django 框架下的专业 Web 开发，可以在 Windows、Linux、macOS 下使用</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="2-1-Windows安装"><a href="#2-1-Windows安装" class="headerlink" title="2.1 Windows安装"></a>2.1 Windows安装</h2><ol><li>下载地址：<a href="https://www.jetbrains.com/pycharm/download"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></li><li>选择对应的系统和版本，点击下载，即可下载对应的安装包；</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_choose_versions.png" alt="PyCharm_choose_versions" style="zoom:80%;" /><ol start="3"><li>双击下载好的exe文件，开始安装，点击Next；</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_start_setup.png" alt="PyCharm_start_setup" style="zoom:150%;" /><ol start="4"><li>选择安装路径；</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_choose_path.png" alt="PyCharm_choose_path" style="zoom:150%;" /><ol start="5"><li>选择64位 launcher，加入到环境变量（可选），选择.py，点击Next；</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_add_path.png" alt="PyCharm_add_path" style="zoom:150%;" /><ol start="6"><li>默认选择，开始安装，时间较久，安装完毕后需要重启电脑</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_choose_menu_folder.png" alt="PyCharm_choose_menu_folder" style="zoom:150%;" /><h2 id="2-2-Linux安装"><a href="#2-2-Linux安装" class="headerlink" title="2.2 Linux安装"></a>2.2 Linux安装</h2><p><strong>Linux</strong>：Ubuntu</p><ol><li>下载地址：<a href="https://www.jetbrains.com/pycharm/download"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></li><li>选择对应的系统和版本，点击下载，即可下载对应的安装包；</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_choose_versions.png" alt="PyCharm_choose_versions" style="zoom:80%;" /><ol start="3"><li>解压缩： tar -zxvf tar_name ，解压后会在当前目录下形成对应的 folder</li><li>移动至 /opt： sudo mv folder_name /opt/ ，这样方便其他用户使用</li><li>启动：./pycharm.sh ，切换至切换 bin目录下运行： cd /opt/folder_name/bin</li></ol><h1 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h1><p>用 PyCharm 打开项目，会自动生成一个 .idea 文件夹，里面存储当前项目使用的python解释器版本，当前项目包含的项目文件和项目设置文件</p><h2 id="3-1-配置Python解释器"><a href="#3-1-配置Python解释器" class="headerlink" title="3.1 配置Python解释器"></a>3.1 配置Python解释器</h2><p><strong>配置Python解释器</strong>：指定运行python文件的解释器，大版本有 python 2.x 和 python 3.x：File -&gt; Settings，在弹出的对话框选择 Project:xxx 下拉菜单 Python Interpreter-&gt; 右侧指定 python解释器存放路径 -&gt; 点击 Apply -&gt; 点击 OK</p><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_setting.png" alt="PyCharm_setting" style="zoom:80%;" /><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_setting_Interpreter.png" alt="PyCharm_setting_Interpreter" style="zoom:80%;" /><h2 id="3-2-配置Gitee"><a href="#3-2-配置Gitee" class="headerlink" title="3.2 配置Gitee"></a>3.2 配置Gitee</h2><p><strong>配置Gitee</strong>：前置条件（本机安装Git，拥有Gitee账号）</p><ol><li><strong>配置Git路径</strong>：File -&gt; Settings，在弹出的对话框选择Version COntrol -&gt; 点击Git -&gt; 在右侧配置 Path to Git executable ，选择路径 -&gt; 点击 Apply -&gt; 点击 OK</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_setting.png" alt="PyCharm_setting" style="zoom:80%;" /><p><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_setting_Git.png" alt="PyCharm_setting_Git"></p><ol start="2"><li><strong>安装Gitee插件</strong>：File -&gt; Settings，在弹出的对话框选择 Plugins -&gt; 在搜索框输入 Gitee -&gt; 点击 Install  -&gt; 点击 OK</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_plugins_Gitee.png" alt="PyCharm_plugins_Gitee"  /><ol start="3"><li><strong>添加Gitee到 Version Control</strong>：File -&gt; Settings，在弹出的对话框选择 Plugins -&gt; 点击 Installed -&gt; 勾选 Gitee -&gt; 点击 Apply -&gt; 点击 OK</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_add_plugins_Gitee.png" alt="PyCharm_add_plugins_Gitee"  /><ol start="4"><li><strong>登录Gitee</strong>：File -&gt; Settings，在弹出的对话框选择 Version COntrol -&gt; 点击Gitee -&gt; 在右侧点击 + 号，选择 Log In via Gitee -&gt; 在弹窗中输入登录账号密码（账号只能用邮箱），点击 Log In，成功会在上方出现账号信息 -&gt; 点击 Apply -&gt; 点击 OK</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_login_Gitee_01.png" alt="PyCharm_login_Gitee_01"  /><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_login_Gitee_02.png" alt="PyCharm_login_Gitee_02"  /><ol start="5"><li><strong>配置远程库</strong>：点击菜单栏Git，选择Manage Remotes，在弹窗里面配置远程库 -&gt; 点击 + 号，在新弹窗中输入关联远程库别名（默认origin）-&gt; 点击 OK-&gt; 点击 OK</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_login_Gitee_03.png" alt="PyCharm_login_Gitee_03"  /><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_login_Gitee_04.png" alt="PyCharm_login_Gitee_04"  /><ol start="6"><li><strong>推送</strong>：点击菜单栏Git，选择 Commit，在弹窗里面输入提交信息，可选择提交作者 -&gt; 点击 Commit（仅提交，需要再次点击菜单栏Git，选择Push） 或 Commit and Push（提交同时推送，不需要再次点击Push）</li></ol><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_Gitee_Commit_01.png" alt="PyCharm_Gitee_Commit_01" style="zoom:80%;" /><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_Gitee_Commit_02.png" alt="PyCharm_Gitee_Commit_02"  /><h1 id="4-使用"><a href="#4-使用" class="headerlink" title="4. 使用"></a>4. 使用</h1><h2 id="4-1-设置字体"><a href="#4-1-设置字体" class="headerlink" title="4.1 设置字体"></a>4.1 设置字体</h2><p><strong>设置字体</strong></p><ul><li><strong>编辑页面字体</strong>：File -&gt; Settings，在弹出的对话框选择Editor -&gt; 点击Font，在右侧选择 Font 和 Size -&gt; 点击 Apply -&gt; 点击 OK</li></ul><img src="https://qizhongyi.gitee.io/images/Tools/Python/PyCharm_setting.png" alt="PyCharm_setting" style="zoom:80%;" /><img src="https://qizhongyi.gitee.io/images/Tools/Python/Font_setting.png" alt="Font_setting"  /><ul><li><strong>控制台字体</strong>：File -&gt; Settings，在弹出的对话框选择Editor -&gt; 点击Color Scheme -&gt; 点击Console Font，在右侧选择 Font 和 Size（需要先勾选） -&gt; 点击 Apply -&gt; 点击 OK</li></ul><img src="https://qizhongyi.gitee.io/images/Tools/Python/Console_Font_setting.png" alt="Console_Font_setting"  /><p><strong>忽略代码风格警告</strong></p><ul><li>File - Settings -&gt; Editor -&gt; Inspections -&gt; PEP8 coding style violation(python下)，在下角的Ignore errors里添加需要忽略的<a href="http://pep8.readthedocs.io/en/latest/intro.html#configuration"><font face = "微软雅黑" color = 1E90FF size = 5>警告信息ID</font></a>；<strong>代码规范建议</strong>： <a href="https://www.python.org/dev/peps/pep-0008"><font face = "微软雅黑" color = 1E90FF size = 5>PEP 8</font></a> ；<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/"><font face = "微软雅黑" color = 1E90FF size = 5>PEP 8中文</font></a></li><li>将鼠标移到提示的地方，按 Alt + Enter，选择忽略（Ignore）</li></ul><table><thead><tr><th>警告ID</th><th>警告信息</th></tr></thead><tbody><tr><td><strong>E1</strong></td><td>缩进-Indentation（过多的空格和制表符、非4的倍数等）</td></tr><tr><td><strong>E2</strong></td><td>空格-Whitespace（括号前后、: 前后等）</td></tr><tr><td><strong>E3</strong></td><td>空行-Blank line</td></tr><tr><td><strong>E4</strong></td><td>导入-Import（一行过多导入、导入不在最上方）</td></tr><tr><td><strong>E5</strong></td><td>单行长度-Line length（超过79个字符）</td></tr><tr><td><strong>E7</strong></td><td>申明-Statement</td></tr><tr><td><strong>E9</strong></td><td>运行时间-Runtime</td></tr><tr><td><strong>W1</strong></td><td>缩进警告-Indentation warning</td></tr><tr><td><strong>W2</strong></td><td>空行警告-Whitespace warning</td></tr><tr><td><strong>W3</strong></td><td>空格警告-Blank line warning</td></tr><tr><td><strong>W5</strong></td><td>换行警告-Line break warning</td></tr><tr><td><strong>W6</strong></td><td>弃用警告-Deprecation warning</td></tr></tbody></table><h1 id="5-快捷键"><a href="#5-快捷键" class="headerlink" title="5. 快捷键"></a>5. 快捷键</h1><p>Ctrl + b ：查看函数对应源码</p>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Anaconda-安装使用</title>
      <link href="/202107/109972.html"/>
      <url>/202107/109972.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文介绍Python的实用工具-Anaconda-的简介、安装使用的相关知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>Anaconda</strong>：是一个开源的Python发行版本，包含了conda、Python等180多个科学包及其依赖项、大量科学包</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><ol><li>下载地址：<a href="https://www.anaconda.com/products/individual"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a> ；<a href="https://mirrors.tuna.tsinghua.edu.cn/"><font face = "微软雅黑" color = 1E90FF size = 5>清华镜像</font></a> 搜索 anaconda；</li><li>选择好对应的位数和版本，双击下载好的exe文件，开始安装；</li><li>选择All Users，下一步；</li><li>选择安装路径，下一步；</li><li>加入到环境变量（可选），下一步；</li><li>开始安装，时间较久；</li><li>完成测试：在cmd下运行conda –version</li></ol><h1 id="3-Jupyter"><a href="#3-Jupyter" class="headerlink" title="3. Jupyter"></a>3. Jupyter</h1><p><strong>Jupyter</strong>：是 Anaconda 自带的一个工具，是基于网页的用于交互计算的应用程序，用于全过程计算：开发、文档编写、运行代码和展示结果，<a href="https://jupyter.org/"><font face = "微软雅黑" color = 1E90FF size = 5>Jupyter官网</font></a></p><h2 id="3-1-使用"><a href="#3-1-使用" class="headerlink" title="3.1 使用"></a>3.1 使用</h2><p><strong>安装</strong>：pip install jupyter<br><strong>更新</strong>：pip install –upgrade jupyter<br><strong>启动</strong>：命令行下输入：jupyter notebook，回车；即可在设置的浏览器上打开 jupyter（启动一个Python进程，被称作 <strong>核</strong>，kernel）</p><h3 id="3-1-1-设置默认浏览器"><a href="#3-1-1-设置默认浏览器" class="headerlink" title="3.1.1 设置默认浏览器"></a>3.1.1 设置默认浏览器</h3><ol><li>找到浏览器的起始位置（以 chrome 为例）：C:\Program Files (x86)\Google\Chrome\Application\chrome.exe</li><li>在 C:\Users\xxx\.jupyter 目录下创建 jupyter_notebook_config.py 文件（有就覆盖，没有就新建），输入以下内容<pre class="line-numbers language-none"><code class="language-none">import webbrowserwebbrowser.register(&#39;chrome&#39;, None, webbrowser.GenericBrowser(u&#39;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&#39;))c.NotebookApp.browser &#x3D; &#39;chrome&#39;# 修改为自己电脑上 chrome 的对应位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="3-1-2-设置默认启动路径"><a href="#3-1-2-设置默认启动路径" class="headerlink" title="3.1.2 设置默认启动路径"></a>3.1.2 设置默认启动路径</h3><ol><li>命令行终端运行：jupyter notebook –generate-config</li><li>会出现 Overwrite C:\Users\xxx\.jupyter\jupyter_notebook_config.py with default config? [y/N] 提示，输入 y 或 yes</li><li>会输出 jupyter notebook 配置文件 jupyter_notebook_config.py 的地址</li><li>找到配置文件的 c.NotebookApp.notebook_dir 内容，取消注释，配置默认启动路径：c.NotebookApp.notebook_dir = “C:\Users\xxx\Desktop\Jupyter”</li></ol><h2 id="3-2-I-O"><a href="#3-2-I-O" class="headerlink" title="3.2 I/O"></a>3.2 I/O</h2><ul><li>Jupyter导入.py文件：% load &lt;文件名，带后缀名&gt;</li></ul><h2 id="3-3-安装插件"><a href="#3-3-安装插件" class="headerlink" title="3.3 安装插件"></a>3.3 安装插件</h2><p><strong>安装插件前需要先安装扩展插件的功能</strong></p><pre class="line-numbers language-none"><code class="language-none"># 1. 安装 jupyter_contrib_nbextensionspip install jupyter_contrib_nbextensions# 2. 配置 nbextensionjupyter contrib nbextension install --user# 3. 重启 jupyter notebookjupyter notebook   # cmd 下运行，启动后可以看到 Nbextensions 按钮，取消勾选 disable configuration 后可以通过勾选配置插件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://qizhongyi.gitee.io/images/Tools/Python/Jupyter_Nbextensions.png" alt="Jupyter_Nbextensions"></p><ul><li><strong>显示目录</strong>：需要先安装配置 nbextension，如上文 ；打开 Nbextensions -&gt; 取消勾选 disable configuration… -&gt; 勾选 Table of Contents-&gt; 勾选 disable configuration，即完成</li></ul><img src="https://qizhongyi.gitee.io/images/Tools/Python/Jupyter_contents.png" alt="Jupyter_contents" style="zoom:50%;" /><ul><li><strong>自动补全</strong>：需要先安装配置 nbextension，如上文 ；打开 Nbextensions -&gt; 取消勾选 disable configuration… -&gt; 勾选 Hinterland -&gt; 勾选 disable configuration，即完成；也可以通过 Python内置的 dir() 函数实现获取对象的属性和方法；<strong>*Warning?  可以列举出命名空间中以 Warning 结尾的所有对象</strong>：通配符 * 可匹配任意数量的字符</li></ul><p><img src="https://qizhongyi.gitee.io/images/Tools/Python/Jupyter_Hinterland.png" alt="Jupyter_Hinterland"></p><h2 id="3-4-快捷键"><a href="#3-4-快捷键" class="headerlink" title="3.4 快捷键"></a>3.4 快捷键</h2><p>注释：Ctrl + / </p><p>执行代码：Shift + Enter</p><p>自省：var_name / fun_name / obj_name? ，变量名、函数名、对象名后紧跟着 ? ；可以查看对应内容的信息</p><p>查看函数源码：fun_name?? ，函数名后紧跟着两个英文问号 ??</p><p>运行 .py 文件：%run file_name ，带文件后缀</p>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础-函数</title>
      <link href="/202107/0963870.html"/>
      <url>/202107/0963870.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Python函数 的相关基础内容</p><span id="more"></span><h1 id="1-函数介绍"><a href="#1-函数介绍" class="headerlink" title="1. 函数介绍"></a>1. 函数介绍</h1><h2 id="1-1-查看函数"><a href="#1-1-查看函数" class="headerlink" title="1.1 查看函数"></a>1.1 查看函数</h2><pre class="line-numbers language-none"><code class="language-none">查看函数信息：help(f_name)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><a href="http://docs.python.org/3/library/functions.html"><font face = "微软雅黑" color = 1E90FF size = 5>官方函数</font></a></p><h2 id="1-2-调用函数"><a href="#1-2-调用函数" class="headerlink" title="1.2 调用函数"></a>1.2 调用函数</h2><p><strong>调用函数</strong>：通过函数名进行调用，给定正确的参数，包括参数个数个数据类型</p><pre class="line-numbers language-none"><code class="language-none">num &#x3D; abs(-12.5)  # 计算传入参数 -12.5 的绝对值大小num &#x3D; abs(12, 1)  # 会报 TypeError 的错误，提示传入的参数数量不对num &#x3D; abs(&#39;abs&#39;)  # 会报 TypeError 的错误，提示 str 是错误的参数类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>函数名是指向函数的变量，是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”</p><pre class="line-numbers language-none"><code class="language-none">my_abs &#x3D; absnum &#x3D; my_abs(-12.5)  # 计算传入参数 -12.5 的绝对值大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-3-自定义函数"><a href="#1-3-自定义函数" class="headerlink" title="1.3 自定义函数"></a>1.3 自定义函数</h2><p><strong>自定义函数</strong>：定义一个函数要使用 def 语句，依次写出函数名、参数列表和冒号 : ，在缩进块中编写函数体，函数的返回值用 return 语句返回；外部不需要引用的函数全部定义成private（类似 _xxx 和 __xxx ），只有外部需要引用的函数才定义为public</p><pre class="line-numbers language-none"><code class="language-none">def f_name([p_list]):    xxx    [return xxx]def my_abs(x):   # 返回给定参数的绝对值    if x &gt;&#x3D; 0:        return x    else:        return -xdef f_name():    pass     # 定义空函数，如果还没想好怎么写函数的代码，可以先放一个pass占位符，让代码能运行起来；缺少 pass，代码运行会有语法错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-1-函数类型"><a href="#1-3-1-函数类型" class="headerlink" title="1.3.1 函数类型"></a>1.3.1 函数类型</h3><ul><li><p><strong>无参无返回值</strong></p><pre class="line-numbers language-none"><code class="language-none">def printFruit():    fruits &#x3D; [&#39;apple&#39;, &#39;banana&#39;, &#39;cherry&#39;, &#39;durian&#39;, &#39;peer&#39;]    print(fruits)printFruit()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>无参有返回值</strong></p></li><li><p><strong>有参无返回值</strong></p></li><li><p><strong>有参有返回值</strong></p><pre class="line-numbers language-none"><code class="language-none">import mathdef quadratic(a, b, c):    x1, x2 &#x3D; (math.sqrt(b ** 2 - 4 * a * c) -b)&#x2F;(2 * a), (-math.sqrt(b**2 - 4 * a * c) -b)&#x2F;(2 * a)    return x1, x2a, b, c &#x3D; eval(input(&#39;Please input three numbers:&#39;))x1, x2 &#x3D; quadratic(a, b, c)if a &#x3D;&#x3D; 1:    print(&#39;x^2 + %dx + %d &#x3D; 0 的解分别是: x1 &#x3D; %.2f, x2 &#x3D; %.2f&#39; % (b, c, x1, x2))else:    print(&#39;%dx^2 + %dx + %d &#x3D; 0 的解分别是: x1 &#x3D; %.2f, x2 &#x3D; %.2f&#39; % (a, b, c, x1, x2))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p><strong>函数作为返回值</strong>：把函数作为结果值返回，在函数内部再定义一个函数，父层函数的返回值是子层函数</p><pre class="line-numbers language-none"><code class="language-none">def lazy_sum(*args):    def sum():        ax &#x3D; 0        for n in args:            ax &#x3D; ax + n        return ax    return sumf &#x3D; lazy_sum(1, 3, 5, 7, 9)   # 调用 lazy_sum ，返回 f&#x2F;sum 函数f()  # 调用 f() 函数，显示输出 25<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="1-3-2-函数参数"><a href="#1-3-2-函数参数" class="headerlink" title="1.3.2 函数参数"></a>1.3.2 函数参数</h3><p><strong>位置参数</strong>：按照参数的位顺序进行传递</p><pre class="line-numbers language-none"><code class="language-none">def power(x):     # 计算 x^2 x的平方    return x * xnum &#x3D; power(5)    # 计算 5的平方def power(x, n):  # 计算 x 的 n 次方，此时计算 x的平方 需要按照参数位置传入两个参数     s &#x3D; 1    while n &gt; 0:        n &#x3D; n - 1        s &#x3D; s * x    return snum &#x3D; power(5, 2)  # 计算 5的平方num &#x3D; power(5, 3)  # 计算 5的立方<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>关键字参数</strong>：用于限制关键字参数的名字，命名关键字参数需要一个特殊分隔符 * 号， * 号后面的参数被视为命名关键字参数，只能通过关键字的方式传递参数，即以 p_name = value 形式进行参数传递；如果函数定义中存在一个可变参数，后面跟着的命名关键字参数就不再需要特殊分隔符 *</p><pre class="line-numbers language-none"><code class="language-none">def person(name, age, *, city, job):    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;city:&#39;, city, &#39;job:&#39;, job)person(&#39;Jack&#39;, 24, city &#x3D; &#39;Beijing&#39;, job &#x3D; &#39;Engineer&#39;)name: Jack age: 24 city: Beijing, job: Engineer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>默认参数</strong>：对于某一个常用的参数取值设置成默认值，如上文：经常计算 x的平方，可以将计算平方设置成默认值；<strong>默认参数必须指向不变对象</strong>，推荐把变化大的参数放前面，变化小的参数放后面作为默认参数；<strong>默认参数和可变参数混合使用时，默认参数要放在可变参数的右侧</strong>，并且用关键字指定赋值</p><pre class="line-numbers language-none"><code class="language-none">def power(x, n&#x3D;2):   # 计算 x 的 n 次方，默认计算 x的平方    s &#x3D; 1    while n &gt; 0:        n &#x3D; n - 1        s &#x3D; s * x    return snum &#x3D; power(5)     # 计算 5的平方num &#x3D; power(5, 3)  # 计算 5的立方def add_end(L&#x3D;[]):  # 多次使用默认参数调用时，数据会出错    L.append(&#39;END&#39;)    return LPython 函数在定义的时候，默认参数L的值就被计算出来了，即[]；但默认参数L也是一个变量，指向对象[]；每次调用该函数，函数体改变了L的内容，则下次调用时，默认参数的内容就变为[&#39;END&#39;]，不再是函数定义时的[]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可变位置参数</strong>：传入的参数个数可变，定义可变参数在参数名前加一个 * 号进行申明，<strong>可变参数在函数调用时自动组装为一个 tuple</strong></p><pre class="line-numbers language-none"><code class="language-none">def calc(numbers):    # 计算 1~n 的平方和    sum &#x3D; 0    for n in numbers:        sum &#x3D; sum + n * n    return sumresult &#x3D; calc([1, 2, 3, 4, 5])    # 调用时需要先组装出一个 list 或 tuple 进行传递result &#x3D; calc((1, 2, 3, 4, 5]))def calc(*numbers):    # 参数 numbers 接收到的是一个 tuple    sum &#x3D; 0    for n in numbers:        sum &#x3D; sum + n * n    return sumresult &#x3D; calc(1, 2, 3, 4, 5)  # 可以直接传递任意个数据，包括 0 个result &#x3D; calc(*list_a)  # 对于前文的 list 或 tuple 可以直接在变量名前添加 * 号把 list 或 tuple 的元素变成可变参数进行传递# 求多个数的多次幂的和def fun_pingfang(*args, power_num &#x3D; 2):       # 默认参数和可变参数混合使用时，默认参数要放在可变参数的右侧，并且用关键字指定赋值    result_list &#x3D; []    for n in args:        a &#x3D; 1        b &#x3D; power_num        while b &gt; 0:            a &#x3D; a * n            b &#x3D; b - 1        result_list.append(a)    return result_listtuple_num &#x3D; eval(input(&#39;Please entry two numbers at least:&#39;))power_num &#x3D; input(&#39;Please entry power_number:&#39;)if len(power_num) &#x3D;&#x3D; 0:    print(fun_pingfang(*tuple_num))    # 通过 * 进行拆包传递参数else:    print(fun_pingfang(*tuple_num, power_num &#x3D; int(power_num)))   # 用关键字指定赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>可变关键字参数</strong>：允许传入任意个含参数名的参数，定义可变参数在参数名前加两个 * 号进行申明，<strong>关键字参数在函数内部自动组装为一个 dict</strong></p><pre class="line-numbers language-none"><code class="language-none">def person(name, age, **kw):    print(&#39;name:&#39;, name, &#39;age:&#39;, age, &#39;other:&#39;, kw)extra &#x3D; &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;person(&#39;Jack&#39;, 24, **extra)       # 通过 ** 进行拆包传递参数输出 ： name: Jack age: 24 other: &#123;&#39;city&#39;: &#39;Beijing&#39;, &#39;job&#39;: &#39;Engineer&#39;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>参数组合</strong>：函数的参数可以是上面5种参数的任意组合；参数定义的顺序必须是：必选参数、默认参数、可变位置参数、关键字参数和可变关键字参数</p><pre class="line-numbers language-none"><code class="language-none">def func_1(a, b, c &#x3D; 0, *args, d, **kw):     # 如果函数定义中有可变位置参数，后面跟着的关键字参数就不再需要特殊分隔符 *    print(&#39;a &#x3D; &#39;, a, &#39;b &#x3D; &#39;, b, &#39;c &#x3D; &#39;, c, args, &#39;d &#x3D; &#39;, d, kw)func_1(1, 2, 3, 4, 5, d &#x3D; 6, e &#x3D; 7, f &#x3D; 8)输出：1 2 3 (4, 5) 6 &#123;&#39;e&#39;: 7, &#39;f&#39;: 8&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-简单函数"><a href="#2-简单函数" class="headerlink" title="2. 简单函数"></a>2. 简单函数</h1><h2 id="2-1-内置函数"><a href="#2-1-内置函数" class="headerlink" title="2.1 内置函数"></a>2.1 内置函数</h2><p><strong>内置函数</strong>：语言自身封装的函数，也称为<a href="http://docs.python.org/3/library/functions.html"><font face = "微软雅黑" color = 1E90FF size = 5>官方函数</font></a></p><p>**isinstance(value, datatype)**：数据类型检查，判断给定的数据是否是给定的数据类型，返回对应布尔值</p><pre class="line-numbers language-none"><code class="language-none">num &#x3D; 12b &#x3D; isinstance(num, string)  # 返回 Falseb &#x3D; isinstance(num, (int, float))  # 返回 True<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>range</strong>(&lt;起始位置&gt;:&lt;结束位置&gt;:&lt;步长&gt;)（包含起始位置，不包含结束位置）</p><ul><li>下标有正负两种，正数：从左边开始数，以0开始；负数：从右边开始，从-1开始</li><li>起始位置：可省略，省略表示从头开始</li><li>结束位置：可省略，省略表示截取到最后</li><li>步长：截取的刻度，正数从前往后截，负数从后往前截</li></ul><p>**type(value)**：返回数据的类型</p><pre class="line-numbers language-none"><code class="language-none">type(123)   # 返回 int<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-2-递归函数"><a href="#2-2-递归函数" class="headerlink" title="2.2 递归函数"></a>2.2 递归函数</h2><p><strong>递归函数</strong>：在一个函数在内部调用自身本身，则被称为递归函数，<strong>使用递归函数需要注意防止栈溢出</strong>，可以通过<strong>尾递归</strong>进行优化；理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰<br><strong>尾递归</strong>：是指在函数返回时，调用自身本身，并且，return语句不能包含表达式</p><pre class="line-numbers language-none"><code class="language-none">def fact(n):       # 计算 n 的阶乘    if n &#x3D;&#x3D; 0:        return 1    else:        return fact(n-1) * n<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 尾递归实现def fact(n):    return fact_iter(n, 1)def fact_iter(num, product):    if num &#x3D;&#x3D; 0:        return product    return fact_iter(num - 1, num * product)fact(5)  # 调用，得到 fact_iter(5,1)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-高阶函数"><a href="#3-高阶函数" class="headerlink" title="3. 高阶函数"></a>3. 高阶函数</h1><p><strong>高阶函数</strong>：接收另一个函数作为输入参数的函数</p><pre class="line-numbers language-none"><code class="language-none">def add(x, y, fun_name):    return fun_name(x) + fun_name(y)fun &#x3D; abs      # 函数名其实就是指向函数的变量，可以通过该变量来调用这个函数print(add(-5, 6, fun))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**map(fun_name, Iterable)**：将传入的函数依次作用到序列的每个元素，并把结果作为新的 Iterator 返回；第一个参数是函数对象本身，第二个是 Iterable</p><pre class="line-numbers language-none"><code class="language-none">def fun_square(x):    return x * xlist_iter &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]list_result &#x3D; map(fun_square, list_iter)    # 返回 map 型数据print(list(list_result))  # 显示输出 [1, 4, 9, 16, 25, 36, 49, 64, 81]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**reduce(fun_name, values)**：把函数作用在传入的序列数据上，对相邻两个元素做累积计算，传入函数必须接收两个参数</p><pre class="line-numbers language-none"><code class="language-none">from functools import reducedef fn(x, y):    return x * 10 + yreduce(fn, [1, 3, 5, 7, 9])   # 显示输出 13579<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">from functools import reducedef str2int(s):       # 将传入的字符串转换成对应的整数    def fn(x, y):        return x * 10 + y    def char2num(s):        DIGITS &#x3D; &#123;&#39;0&#39;: 0, &#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3, &#39;4&#39;: 4, &#39;5&#39;: 5, &#39;6&#39;: 6, &#39;7&#39;: 7, &#39;8&#39;: 8, &#39;9&#39;: 9&#125;        return DIGITS[s]    return reduce(fn, map(char2num, s))str2int(&#39;134567098765&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**filter(fun_name, values)**：把传入的函数依次作用于每个元素，然后根据返回的布尔值决定是否保留该元素</p><pre class="line-numbers language-none"><code class="language-none"># 删掉 list 中的偶数，只保留奇数def is_odd(n):    return n % 2 &#x3D;&#x3D; 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))  # 显示输出 [1, 5, 9, 15]# 删掉一个序列中的空字符串def not_empty(s):    return s and s.strip()   # 删除前导和尾随空格list(filter(not_empty, [&#39;A&#39;, &#39;&#39;, &#39;B&#39;, None, &#39;C&#39;, &#39;  &#39;]))  # 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]# 埃氏筛法计算素数def _odd_iter():     # 构造一个从3开始的奇数序列    n &#x3D; 1    while True:        n &#x3D; n + 2        yield ndef _not_divisible(n):     # 定义一个筛选函数    return lambda x: x % n &gt; 0def primes():    yield 2    it &#x3D; _odd_iter() # 初始序列    while True:        n &#x3D; next(it) # 返回序列的第一个数        yield n        it &#x3D; filter(_not_divisible(n), it) # 构造新序列number &#x3D; eval(input(&#39;Pleae input a number: &#39;))for n in primes():    if n &lt; number:        print(n)    else:        break<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**sort(values，key)**：按照 key 函数进行排序，是否以 reverse 方式进行呼出</p><pre class="line-numbers language-none"><code class="language-none">sorted([36, 5, -12, 9, -21], key &#x3D; abs, reverse &#x3D; False)  # 显示输出 [5, 9, -12, -21, 36]，按照绝对值大小进行排序，顺序显示L &#x3D; [(&#39;Bob&#39;, 75), (&#39;Adam&#39;, 92), (&#39;Bart&#39;, 66), (&#39;Lisa&#39;, 88)]def by_name(t):    return t[0]def by_score(t):    return t[1]L_name &#x3D; sorted(L, key &#x3D; by_name)L_score &#x3D; sorted(L, key &#x3D; by_score, reverse &#x3D; True)print(L_name, L_score, sep &#x3D; &#39;\n&#39; )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-1-返回函数"><a href="#3-1-返回函数" class="headerlink" title="3.1 返回函数"></a>3.1 返回函数</h2><p><strong>返回函数</strong>：一个函数返回一个函数，返回一个函数时，该函数并未执行；调用函数时，才真正实现函数功能</p><pre class="line-numbers language-none"><code class="language-none">def lazy_sum(*args):    def sum():        ax &#x3D; 0        for n in args:            ax &#x3D; ax + n        return ax    return sum    # 返回的并不是求和结果，而是求和函数f &#x3D; lazy_sum(1, 3, 5, 7, 9)print(f,f(), sep &#x3D; &#39;\n&#39;)   # 调用函数，才真正计算求和的结果; 每次调用都会返回一个新的函数，即使传入相同的参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>闭包</strong>：使用闭包，就是内层函数引用了外层函数的局部变量。如果只是读外层变量的值，我们会发现返回的闭包函数调用一切正常；如果对外层变量赋值，会报错，需要在内部函数进行 <strong>nonlocal</strong> 申明</p><pre class="line-numbers language-none"><code class="language-none">def count():    fs &#x3D; []    for i in range(1, 4):        def f():            return i * i        fs.append(f)    return fsf1, f2, f3 &#x3D; count()      # fs 列表三个函数分别赋值给f1, f2, f3print(f1(), f2(), f3())   # 返回 9, 9, 9: 并非立刻执行, 等到 f1(), f2(), f3() 调用返回时, 所引用的变量i 变成了 3def count():    def f(j):        def g():            return j*j        return g    fs &#x3D; []    for i in range(1, 4):        fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f()    return fs            # 返回 1, 4, 9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">def inc():    x &#x3D; 0    def fn():        nonlocal x     # 没有 nonlocal 申明会报 UnboundLocalError，local variable &#39;x&#39; referenced before assignment        x &#x3D; x + 1        return x    return fnf &#x3D; inc()print(f()) # 1print(f()) # 2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-匿名函数"><a href="#3-2-匿名函数" class="headerlink" title="3.2 匿名函数"></a>3.2 匿名函数</h2><p><strong>匿名函数</strong>：关键字 <strong>lambda</strong> 表示匿名函数；只能有一个表达式，不用写 return ，返回值就是该表达式的结果；不需要显式地定义函数，直接传入匿名函数更方便</p><pre class="line-numbers language-none"><code class="language-none">lambda x: x * x# 等价于def f(x):    return x * x<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">f &#x3D; lambda x: x * x     # 匿名函数也是一个函数对象，可以把匿名函数赋值给一个变量，再利用变量来调用该print(f(5))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">def build(x, y):    return lambda: x * x + y * y    # 可以把匿名函数作为返回值返回print(build(1,2)())<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">请用匿名函数返回20以内的奇数L &#x3D; list(filter(lambda x: x % 2, range(1, 20)))print(L)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-偏函数"><a href="#3-3-偏函数" class="headerlink" title="3.3 偏函数"></a>3.3 偏函数</h2><p><strong>偏函数</strong>：设定参数的默认值，降低函数调用的难度</p><pre class="line-numbers language-none"><code class="language-none">print(int(&#39;12345&#39;))                 # int() 函数可以把字符串转换为整数, 默认按十进制转换(传入数据为十进制数)print(int(&#39;12345&#39;, base &#x3D; 8))       # 传入 base 参数，就可以做N进制的转换(规定传入数据为 N进制)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">import functoolsint2 &#x3D; functools.partial(int, base &#x3D; 2)print(int2(&#39;1000000&#39;))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none"># 创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数max2 &#x3D; functools.partial(max, 10)    # 会把10作为*args的一部分自动加到左边max2(5, 6, 7)# 相当于# args &#x3D; (10, 5, 6, 7)# max(*args)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-基础</title>
      <link href="/202107/0862556.html"/>
      <url>/202107/0862556.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Python使用 的相关基础知识</p><span id="more"></span><h1 id="1-保留关键字"><a href="#1-保留关键字" class="headerlink" title="1. 保留关键字"></a>1. 保留关键字</h1><p><strong>保留关键字</strong>：36个（Python 3.9），已经或者将要被赋予特定意义的单词，不能使用这些保留字作为标识符给变量、函数、类、模板以及其他对象命名</p><pre class="line-numbers language-none"><code class="language-none">查看关键字: 关键字在不停的完善，可能更高的版本会有修改import keywordprint(keyword.kwlist)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="1-1-控制语句"><a href="#1-1-控制语句" class="headerlink" title="1.1 控制语句"></a>1.1 控制语句</h2><p><strong>引用控制</strong>：import（导入文件、外部库、模块）、from<br><strong>循环结构</strong>：while、for、break、continue<br><strong>分支结构</strong>：if、elif、else<br><strong>异常控制</strong>：try、except、finally、raise（抛出异常）、assert（设置断言，用来辅助查看，用于调试）</p><h2 id="1-2-变量修饰符"><a href="#1-2-变量修饰符" class="headerlink" title="1.2 变量修饰符"></a>1.2 变量修饰符</h2><p>class：定义类<br>def：定义函数<br>lambda：匿名函数<br>return：定义返回值<br>global：申明全局作用域<br>nonlocal：申明外部嵌套函数内的变量</p><h2 id="1-3-逻辑判断"><a href="#1-3-逻辑判断" class="headerlink" title="1.3 逻辑判断"></a>1.3 逻辑判断</h2><p>True：布尔是<br>False：布尔非<br>and：逻辑与<br>not：逻辑非<br>or：逻辑或<br>is：身份运算符，比较两个对象的内存地址是否一致，也可用 is not；<strong>is 判断两个变量的内存地址是否一致，== 判断引用变量的值是否一致</strong><br>in：成员运算符，是否在某个范围内</p><h2 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h2><p>__peg_parser__<br>as：给模块、变量等起别名，方便使用<br>async<br>await<br>del：删除一个对象<br>None：空值<br>pass：表示占位符，保证程序代码的结构正确<br>with<br>yield：生成器返回申明</p><p><strong>注</strong>：没有数据类型关键字，在赋值时自动推导确定对应变量的数据类型，支持数值类型有：整数类型（int）、浮点数类型（float）、复数类型（complex）、字符串（没有char保留字）、集合（set）、列表（list）、字典（dict，也叫映射）；随时命名、随时赋值（=）、随时使用</p><h1 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h1><h2 id="2-1-算术运算符"><a href="#2-1-算术运算符" class="headerlink" title="2.1 算术运算符"></a>2.1 算术运算符</h2><p><strong>算术运算符</strong>：对数值数据的变量进行运算</p><table><thead><tr><th align="center">运算符</th><th align="center">实例</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td align="center">1 + 1，结果为2；可以处理两个字符串表示拼接字符串：’y’ + ‘es’，输出’yes’</td></tr><tr><td align="center">-</td><td align="center">减</td><td align="center">1 - 1，结果为0</td></tr><tr><td align="center">*</td><td align="center">乘</td><td align="center">1 * 1，结果为1；可以和字符串配合，表示输出整数次字符串：’s’ * 2，输出两个 ‘ss’</td></tr><tr><td align="center">/</td><td align="center">除</td><td align="center">1 / 1，结果为1</td></tr><tr><td align="center">//</td><td align="center">求模（整数商）</td><td align="center">1 // 1，结果为1</td></tr><tr><td align="center">%</td><td align="center">取余</td><td align="center">1 % 1，结果为0</td></tr><tr><td align="center">**</td><td align="center">幂</td><td align="center">1 ** 1，结果为1</td></tr></tbody></table><h2 id="2-2-比较运算符"><a href="#2-2-比较运算符" class="headerlink" title="2.2 比较运算符"></a>2.2 比较运算符</h2><p><strong>比较运算符</strong>：判断两数的大小关系</p><table><thead><tr><th align="center">运算符</th><th align="center">实例</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">==</td><td align="center">等于</td><td align="center">左右两边是否相等，是返回True</td></tr><tr><td align="center">!=</td><td align="center">不等于</td><td align="center">左右两边是否不等，是返回True；Python2可用 &lt;&gt; 表示不等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">左边是否大于右边，是返回True</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">左边是否小于右边，是返回True</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td><td align="center">左边是否大于等于右边，是返回True</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td><td align="center">左边是否小于等于右边，是返回True</td></tr></tbody></table><h2 id="2-3-逻辑运算符"><a href="#2-3-逻辑运算符" class="headerlink" title="2.3 逻辑运算符"></a>2.3 逻辑运算符</h2><p><strong>逻辑运算符</strong>：</p><ul><li><strong>and</strong>：当运算符两边的表达式的结果都为true时，整个运算结果才为true，只要有一边为false，则结果为false</li><li><strong>or</strong>：当运算符有一边为true时，整个运算结果为true</li><li><strong>not</strong>：取本来值的相反值</li></ul><h2 id="2-4-赋值运算符"><a href="#2-4-赋值运算符" class="headerlink" title="2.4 赋值运算符"></a>2.4 赋值运算符</h2><p><strong>赋值运算符</strong>：</p><table><thead><tr><th align="center">运算符</th><th align="center">实例</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">赋值</td><td align="center">c = a + b</td></tr><tr><td align="center">+=</td><td align="center">加赋值</td><td align="center">c += a；c = c + a；对于列表则是调用 extend 方法</td></tr><tr><td align="center">-=</td><td align="center">减赋值</td><td align="center">c -= a；c = c - a</td></tr><tr><td align="center">*=</td><td align="center">乘赋值</td><td align="center">c *= a；c = c * a</td></tr><tr><td align="center">/=</td><td align="center">除赋值</td><td align="center">c /= a；c = c / a</td></tr><tr><td align="center">//=</td><td align="center">求模赋值</td><td align="center">c //= a；c = c // a</td></tr><tr><td align="center">%=</td><td align="center">取余赋值</td><td align="center">c %= a；c = c % a</td></tr><tr><td align="center">**=</td><td align="center">幂赋值</td><td align="center">c **= a；c = c ** a</td></tr></tbody></table><p><strong>转义字符</strong>：特殊含义转义</p><pre class="line-numbers language-none"><code class="language-none">\\, \&#39;, \&quot; ：转义，输出 \, &#39;, &quot;\n：换行，显示 \n 需要写成 \\n，即进行转义\t：制表位\r：回车r&#39;&#39; 中包裹的字符不进行转义，print(r&#39;\\\t\\&#39;)，输出：\\\t\\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-输入输出"><a href="#3-输入输出" class="headerlink" title="3. 输入输出"></a>3. 输入输出</h1><ul><li>**input()<strong>：接收输入，</strong>input([输入提示])**，默认返回对应的字符串</li></ul><pre class="line-numbers language-none"><code class="language-none">str &#x3D; input(&#39;Please entry:&#39;)  # 用变量 str 接收来自键盘的输入num &#x3D; eval(input(&#39;Please entry:&#39;))   # 通过 eval() 将字符串行的数字转换为数值型，将字符串当成一个有效的表达式来求值，并返回计算结果，不建议使用，可以通过输入 __import__(&#39;os&#39;).system(&#39;终端命令&#39;)进行攻击：__import__(&#39;os&#39;).system(&#39;rm -rf&#39;)num &#x3D; int(input(&#39;Please entry:&#39;))    # 通过 int() 将字符串行的数字转换为整数型num &#x3D; float(input(&#39;Please entry:&#39;))  # 通过 float() 将字符串行的数字转换为浮点型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**print()<strong>：显示输出，</strong>print(打印内容 [, sep = ‘ ‘, end = ‘\n’])**，多个打印内容书写时用 , 隔开；打印时以 sep 隔开，默认为空格；以\n结束</li></ul><pre class="line-numbers language-none"><code class="language-none">print(&#39;hello&#39;, &#39;world&#39;)hello worldprint(100 + 200)  # 可计算结果300print(&#39;100 + 200 &#x3D;&#39;, 100 + 200)  # 100 + 200 &#x3D; 用 &#39;&#39; 包裹，表示字符串，而非表达式100 + 200 &#x3D; 300<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>格式化输出</strong>：</p><ol><li><p>占位符：<strong>print(“XXX 占位符 “%(value1,value2))</strong></p><pre class="line-numbers language-none"><code class="language-none">%s：字符串类型占位符%d：整数类型占位符（直接截取整数位，%04d可表示，数字宽为4位，不足用0进行左填充）%f：浮点型占位符%x：16进制数占位符print(&#39;Age: %d, Gender: %s, growth rate: %.2f %%&#39; % (25, &#39;男&#39;, 7.5))，% 后面的数据是一个元组tuple_info &#x3D; (25, &#39;男&#39;, 7.5)print(&#39;Age: %d, Gender: %s, growth rate: %.2f %%&#39; % tuple_info)Age: 25, Gender: 男, growth rate: 7.50 %输出内容中有 % 号时，需要用两个 %% 表示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>format：<strong>print(‘XXX {字符填充序号 : [填充字符] [对齐方式] [数据宽度] [千位分隔符] [保留小数位数] [数据类型]}’.format(value1,value2))</strong></p></li></ol><pre class="line-numbers language-none"><code class="language-none">字符填充序号：format() 里面的数据索引，从零开始填充字符：数据长度不够时的填充字符，默认用空格进行填充对齐方式：数据对齐方式，^, &lt;, &gt; 分别是居中、左对齐、右对齐数据宽度：数据的实际显示长度，用正整数表示，默认宽度为10，数据超过宽度则省略后宽度之后的数据千位分隔符：数据级每隔 1000 的分隔标识符保留小数位数：用 .+正整数表示，如 .4 表示保留 4位整数数据类型：d 表示整数，f 表示浮点数，s 表示字符串&gt;&gt;&gt; print(&#39;&#123;0:@&lt;20,.4f&#125;&#39;.format(123456789.987654321))123,456,789.9877@@@@显示百分比：print(&#39;&#123;0:-&lt;30,.4%&#125;&#39;.format(123456789.987654321))12,345,678,998.7654%----------科学计数法：print(&#39;&#123;0:-&lt;30,.4e&#125;&#39;.format(12345646577886789.987654321))1.2346e+16--------------------二进制：&#39;&#123;:b&#125;&#39;.format(11)十进制：&#39;&#123;:d&#125;&#39;.format(11)八进制：&#39;&#123;:o&#125;&#39;.format(11)普通十六进制：&#39;&#123;:x&#125;&#39;.format(11)小写十六进制带b：&#39;&#123;:#x&#125;&#39;.format(11)大写十六进制带B：&#39;&#123;:#X&#125;&#39;.format(11)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li>f-string：**var定义（换行）print(f’XXX {var_name[:format格式]}’)**，使用 f 开头申明，用前面申明的对应变量替换相同位置的占位符<pre class="line-numbers language-none"><code class="language-none">&gt;&gt;&gt; r &#x3D; 2.5&gt;&gt;&gt; s &#x3D; 3.14 * r ** 2&gt;&gt;&gt; print(f&#39;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;.&#39;)The area of a circle with radius 2.5 is 19.62.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h1><p><strong>标识符</strong>：程序员定义的变量名、函数名、类名等</p><p><strong>标识符命名规范</strong></p><blockquote><p>由字母、下划线、数字组成，首字符不能是数字，可以使用汉字但不推荐；不能和关键字同名<br>严格区分大小写，可以采用下<strong>划线命名</strong>（用下划线 _ 分割单词）、<strong>大驼峰</strong>（不同单词首字母大写）、<strong>小驼峰</strong>（第一个单词首字母小写，其他单词首字母大写）等命名法；可以使用保留关键字的大写形式命名，但不推荐<br>常用全部大写的变量名表示常量</p></blockquote><p><strong>注释</strong>：对某些代码进行标注说明，增强代码的可读性</p><ul><li>单行注释：# 注释内容</li><li>多行注释：’’’ 注释内容 ‘’’/“”” 注释内容 “””</li><li>文档注释：</li></ul><pre class="line-numbers language-none"><code class="language-none">class Person(object):    &quot;&quot;&quot;    Person类    &quot;&quot;&quot;    def __init__(self, name, weight):        &quot;&quot;&quot;        person类的初始化方法        :param name: 姓名        :param weight: 体重        &quot;&quot;&quot;        self.name &#x3D; name        self.weight &#x3D; weight# 输出注释文档if __name__ &#x3D;&#x3D; &quot;__main__&quot;:    import test            # 要与文件名保持一致    print(help(test))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>TODO注释：表明需要做的工作</li></ul><h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5. 参考资料"></a>5. 参考资料</h1><p><a href="https://docs.python.org/3.9/"><font face = "微软雅黑" color = 1E90FF size = 5>官方文档</font></a></p><p><a href="http://docs.python.org/3/library/functions.html"><font face = "微软雅黑" color = 1E90FF size = 5>Python3内置函数官方文档</font></a></p><p><strong>代码规范建议</strong>： <a href="https://www.python.org/dev/peps/pep-0008"><font face = "微软雅黑" color = 1E90FF size = 5>PEP 8</font></a> ；<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/"><font face = "微软雅黑" color = 1E90FF size = 5>PEP 8中文</font></a></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python-安装使用</title>
      <link href="/202107/073746.html"/>
      <url>/202107/073746.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Python的简介、安装过程和通识使用知识介绍</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p>创立者：Guido van Rossum，吉多，龟叔，1989年圣诞节期间编写，形成原型，于1991年诞生第一个 Python解释器，<a href="https://www.python.org/downloads"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></p><h2 id="1-1-Python解释器"><a href="#1-1-Python解释器" class="headerlink" title="1.1 Python解释器"></a>1.1 Python解释器</h2><p><strong>解释器</strong>：将高级语言转换为计算机能识别的机器语言的工具，转换的方式为<strong>解释</strong>（在每一次运行时进行转换）就称为解释器</p><p><strong>CPython</strong>：官方版本的解释器：CPython，用C语言开发，是使用最广的Python解释器；用 &gt;&gt;&gt; 作为提示符<br><strong>IPython</strong>：是基于CPython的一个交互式解释器，基于 BSD 开源；在交互方式上有所增强，但是执行Python代码的功能和CPython是完全一样；在终端输入 ipython 进入，用 In [序号]: 作为提示符；Out [序号]：输出返回值；<a href="http://ipython.org/"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a></p><blockquote><p>支持自动补全，自动缩进<br>支持 bash shell 命令；<strong>可通过 %command 在 jupyter 中运行 shell 命令</strong>；如 %pwd：显示当前目录；可通过变量接收命令的输出结果：result = %pwd</p></blockquote><ul><li><strong>魔法方法</strong><br><strong>%time</strong>：对单个语句的执行时间进行计时<br><strong>%timeit</strong>：对单个语句的重复执行进行计时，以获得更高的准确度<br><strong>%prun</strong>：利用分析器运行代码，需要安装<br><strong>%lprun</strong>：利用逐行分析器运行代码，需要安装<br><strong>%memit</strong>：测量单个语句的内存使用，需要安装<br><strong>%mprun</strong>：通过逐行的内存分析器运行代码，需要安装</li></ul><p><strong>PyPy</strong>：支持JIT即时编译，对Python代码进行动态编译，显著提高Python代码的执行速度；执行结果可能会与 CPython 有所不同，<br><strong>Jython</strong>：是运行在Java平台上的Python解释器，可以直接把Python代码编译成Java字节码执行<br><strong>IronPython</strong>：是运行在微软 .Net 平台上的Python解释器，可以直接把Python代码编译成 .Net 的字节码</p><h2 id="1-2-优缺点"><a href="#1-2-优缺点" class="headerlink" title="1.2 优缺点"></a>1.2 优缺点</h2><p><strong>优点</strong>：优雅、明确、简单、免费、开源；<strong>做一件事只用一种方法</strong></p><blockquote><p><strong>面向对象</strong>：一切皆对象，支持继承、重载、支持泛型设计<br><strong>强大标准库</strong>：提供系统管理、网络通信、文本处理、数据库接口、图形系统、XML处理等功能<br><strong>大量第三方模块</strong>：Python社区提供，覆盖 科学计算、人工智能、机器学习、Web开发、数据库接口、图形系统等<br><strong>可扩展性</strong>：可以编写 C 或 C++ 程序运行，提升运行效率或保密算法</p></blockquote><p><strong>缺点</strong></p><blockquote><p>执行效率慢<br>发布代码不能加密</p></blockquote><h2 id="1-3-环境"><a href="#1-3-环境" class="headerlink" title="1.3 环境"></a>1.3 环境</h2><h3 id="1-3-1-版本"><a href="#1-3-1-版本" class="headerlink" title="1.3.1 版本"></a>1.3.1 版本</h3><p><strong>Python 2.x</strong>：2010年推出最后一个版本 python 2.7</p><blockquote><p>默认不支持中文，解释器为 python；默认使用 ASCII 编码<br>支持长整型（long）；支持 &lt;&gt; 表示不等于；支持cmp函数（比较两个值的大小）</p></blockquote><p><strong>Python 3.x</strong>：2008年发布 python 3.0，没有考虑向下兼容</p><blockquote><p>默认支持中文，解释器为 python3；默认使用 UTF-8 编码<br>不支持长整型（long）；不支持 &lt;&gt; 表示不等于；不支持cmp函数（比较两个值的大小）</p></blockquote><h3 id="1-3-2-集成开发环境"><a href="#1-3-2-集成开发环境" class="headerlink" title="1.3.2 集成开发环境"></a>1.3.2 集成开发环境</h3><p><strong>集成开发环境</strong>：IDE，Integrated Development Environment，集成开发软件所需的所有工具，通常具备以下功能：</p><blockquote><p>图形用户界面<br>代码编辑器，支持自动补全、自动缩进、错误提示等<br>编译器或解释器，调试器（支持断点、单步执行等）</p></blockquote><ul><li><p><a href="https://qizhongyi.gitee.io/20210710/9972.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Anaconda</strong></font></a>：是一个开源的Python发行版本，包含了conda、Python等180多个科学包及其依赖项、大量科学包</p></li><li><p><a href="https://qizhongyi.gitee.io/20210711/18374.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>PyCharm</strong></font></a>：支持 Django 框架下的专业 Web 开发，可以在 Windows、Linux、macOS 下使用</p></li></ul><h2 id="1-4-应用"><a href="#1-4-应用" class="headerlink" title="1.4 应用"></a>1.4 应用</h2><p><strong>web应用开发</strong>：YouTube、Instagram、豆瓣</p><p><strong>网络爬虫</strong></p><p><strong>数据分析</strong></p><blockquote><p>支持产品<br>支持运营<br>支持集团管理层<br>负责行业研究</p></blockquote><p><strong>数据挖掘</strong></p><p><strong>机器学习</strong>：</p><p><strong>深度学习</strong>：NLP、计算机视觉</p><p><strong>推荐系统</strong></p><p><strong>系统网络运维</strong>：自动化运维</p><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><ol><li><p>下载地址：<a href="https://www.python.org/downloads"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a>，<a href="https://python123.io/download"><font face = "微软雅黑" color = 1E90FF size = 5>其他网址</font></a></p></li><li><p>选择合适的安装包</p></li></ol><h2 id="2-1-virtualenv"><a href="#2-1-virtualenv" class="headerlink" title="2.1 virtualenv"></a>2.1 virtualenv</h2><p><strong>virtualenv</strong>：为一个应用创建一套隔离的Python运行环境</p><ol><li><p>pip安装virtualenv：pip3 install virtualenv</p></li><li><p>创建目录：</p><pre class="line-numbers language-none"><code class="language-none">mkdir myprojectcd myproject&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>创建一个独立的Python运行环境，命名为venv：virtualenv –no-site-packages venv  ；把系统Python复制一份到virtualenv的环境</p></li><li><p>进入该环境：source venv/bin/activate  ；virtualenv会修改相关环境变量，让命令 python 和 pip 均指向当前 virtualenv环境</p></li><li><p>安装第三方包：pip install jinja2  ；用 pip 安装的包都被安装到 venv 这个环境下，系统Python环境不受任何影响</p></li><li><p>退出venv环境：deactivate</p></li></ol><h2 id="2-2-安装第三方模块"><a href="#2-2-安装第三方模块" class="headerlink" title="2.2 安装第三方模块"></a>2.2 安装第三方模块</h2><p><strong>pip安装</strong>：在Python中，安装第三方模块，通过包管理工具pip完成，<a href="https://pypi.org/"><font face = "微软雅黑" color = 1E90FF size = 5>第三方库网址</font></a></p><pre class="line-numbers language-none"><code class="language-none">pip install mod_namepip uninsatll mod_namepip list：列出当前系统已安装的第三方库pip show mod_namepip download mod_namepip search mod_namepip3 install --user mod_name：--user参数，设置只安装在当前的用户下，而不写入到系统目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改pip镜像源下载地址</strong></p><blockquote><p><strong>Windows</strong>：在用户主目录（C:\Users\user_name\AppData\Roaming）下新建pip文件夹，新建pip.ini文件：输入内容</p><blockquote><p>[global]<br>index-url=<a href="https://pypi.doubanio.com/simple">https://pypi.doubanio.com/simple</a></p><p>命令终端运行：pip config set global.index-url <a href="https://pypi.doubanio.com/simple">https://pypi.doubanio.com/simple</a></p></blockquote><p><strong>Linux</strong>：在用户主目录（cd /home/user_name）下新建.pip文件夹，新建pip.conf文件：输入内容</p><blockquote><p>[global]<br>index-url=<a href="https://pypi.doubanio.com/simple">https://pypi.doubanio.com/simple</a></p><p>将安装依赖项导出文件：pip freeze &gt; requirements.txt<br>安装依赖项安装：pip install -r requirements.txt</p></blockquote><p><strong>常见镜像源</strong>：</p><blockquote><p>阿里 <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>豆瓣 <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>清华 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中科大 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a></p></blockquote></blockquote><p><strong>Jupyter</strong>：是 Anaconda 自带的一个工具，是基于网页的用于交互计算的应用程序，用于全过程计算：开发、文档编写、运行代码和展示结果；<a href="https://jupyter.org/"><font face = "微软雅黑" color = 1E90FF size = 5>Jupyter官网</font></a>，Jupyter使用见 <a href="https://qizhongyi.gitee.io/202107/109972.html"><font face = "微软雅黑" color = 1E90FF size = 5>Anaconda-安装使用</font></a> 第三部分 Jupyter</p><pre class="line-numbers language-none"><code class="language-none">安装：pip install jupyter更新：pip install --upgrade jupyter启动：jupyter notebook<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA-常见问题</title>
      <link href="/202106/1710134.html"/>
      <url>/202106/1710134.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Java 实用工具-IDEA 的常见问题</p><span id="more"></span><h1 id="1-项目结构类"><a href="#1-项目结构类" class="headerlink" title="1. 项目结构类"></a>1. 项目结构类</h1><p><strong>问题1</strong>：cannot resolve symbol “xxxx”，无法解析某方法<br>原因：1. 方法名错误；2. 方法对应的jar未导入<br>解决：针对原因1，检查与定义的方法名是否一致，修改至一致即可；针对原因2，导入jar包（重点介绍）<br>步骤：先前往<a href="http://mvnrepository.com/artifact/"><font face = "微软雅黑" color = 1E90FF size = 5>官方网站</font></a>下载对应jar包（注意版本一致）；再将下载的jar导入项目<br><strong>Plan A</strong>：通过 Libraries 添加（推荐）</p><ol><li>打开 Project Structure<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Project_Structure.png" alt="IDEA_Project_Structure"></li><li>删除自动导入的包</li></ol><p><strong>Plan B</strong>：通过 Modules 添加（推荐）</p><ol><li>打开Project Structure<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Project_Structure.png" alt="IDEA_Project_Structure"></li><li>选择导入jar包类型<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Modules_Dependencies.png" alt="IDEA_Modules_Dependencies"></li><li>导入jar包<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Add_Jar.png" alt="IDEA_Add_Jar"></li></ol><p><strong>Plan C</strong>：直接复制：将硬盘上的jar包复制粘贴到项目的lib目录下，不适用于IDEA导入的eclipse项目</p><h1 id="2-外部接口类"><a href="#2-外部接口类" class="headerlink" title="2. 外部接口类"></a>2. 外部接口类</h1><p><strong>问题1</strong>：Error:(4, 21) java: 程序包javax.servlet不存在，项目配置中缺少软件包javax.servlet<br>解决：加入Tomcat<br>步骤：点击File-&gt;Project Structure-&gt;Modules;选择当前出错的项目（单击项目名）;选择JDK，点击右侧“+”号，选择“Library…”;选择Tomcat，点击Add Selected按钮，点击Apply按钮，点击OK按钮</p><p><strong>问题2</strong>：Error:(10, 37) java: 程序包org.apache.commons.fileupload不存在，项目配置中缺少软件包 org.apache.commons.fileupload<br>解决：手动下载org.apache.commons.fileupload并安装在Tomcat中<br>步骤：</p><ol><li>前往  <a href="http://commons.apache.org/proper/commons-fileupload/download_fileupload.cgi">http://commons.apache.org/proper/commons-fileupload/download_fileupload.cgi</a> 下载commons-fileupload-1.4-bin.zip文件，将解压得到的文件夹复制到Tomcat安装目录下(与bin目录同级)；</li><li>将包导入项目中：点击File-&gt;Project Structure-&gt;Libraries；点击右侧“+”号，选择“Java”；选择刚刚的解压文件夹，确认应用的项目，点击Apply按钮，点击OK按钮</li></ol><h1 id="3-项目文件类"><a href="#3-项目文件类" class="headerlink" title="3. 项目文件类"></a>3. 项目文件类</h1><p><strong>问题1</strong>：File is read-only，文件只允许读，<br>原因：文件设定或者被动被锁定<br>解决：</p><ol><li>通常编译好的黄色class文件设定为只读，只能编辑对应的找到蓝色java文件</li><li>依次点击：File -&gt; Make File Writable<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_File_RWX.png" alt="IDEA_File_RWX"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA-安装使用</title>
      <link href="/202106/1663138.html"/>
      <url>/202106/1663138.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Java实用工具-IDEA安装使用的相关知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>IDEA全称Intellij IDEA是JetBrains公司的产品，是Java的集成开发环境，支持只能代码助手、代码自动提示、重构、J2EE支持、Ant、JUnit、CVS整合、代码审查和超前的GUI设计，支持Java、Scala、Groovy等语言，支持主流的技术和框架<br><strong>优势</strong></p><ol><li>强大的代码整合功能（Git、Maven、Spring）</li><li>提示功能的快速、便捷、范围广(数据库表名、列名)</li><li>好用的快捷键和代码版本</li><li>精准搜索</li><li>实时保存</li></ol><h1 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2. 下载安装"></a>2. 下载安装</h1><ol><li><p><strong>卸载</strong>：安装前保证环境干净（卸载干净），初次安装无问题<br>通过控制面板进行卸载，不保留缓存和设置，卸载结束之后重启电脑</p></li><li><p><strong>下载</strong>：<a href="https://www.jetbrains.com/idea/download/other.html"><font face = "微软雅黑" color = 1E90FF size = 5>下载官网</font></a> ，选择合适的版本</p></li><li><p><strong>安装</strong>：<br>双击下载的exe文件，进入安装；点击下一步，选择安装路径，点击下一步；选择电脑对应的位数，选择.java，点击下一步；选择默认，点击Install，开始安装；安装结束，启动IDEA，跳过自行默认选择<br>安装目录介绍<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Program_Catalogue.png" alt="IDEA_Program_Catalogue"></p></li></ol><p>  启动目录介绍<br>  <img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Start_Auto_Catalogue.png" alt="IDEA_Start_Auto_Catalogue"></p><ol start="4"><li><strong>配置环境</strong><ul><li>虚拟机选项<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Vmoptions.png" alt="IDEA_Vmoptions"></li></ul></li><li><strong>启动</strong><br>运行IDEA安装目录的bin目录下的idea64.exe文件（32位的系统则运行idea32.exe，也可以在桌面创建快捷方式启动）</li></ol><p><strong>创建项目</strong>：点击Create New Project<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Start.png" alt="IDEA_Start"></p><p>下一步：选择创建的项目类型和所需版本的JDK</p><p><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Start_Choose_Project_Type.png" alt="IDEA_Start_Choose_Project_Type"></p><p>下一步：选择创建项目的方式：按照模板创建(勾选，点击Next)和自定已创建(不勾选，直接点击Next)</p><p><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Start_Create_Project_Type.png" alt="IDEA_Start_Create_Project_Type"></p><p>下一步：定义项目的名称和存放位置</p><p><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Start_Define_Project_Name.png" alt="IDEA_Start_Define_Project_Name"></p><p>Finish</p><p><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Start_Finish.png" alt="IDEA_Start_Finish"></p><p>.idea和project_name.ini文件是IDEA特定的文件</p><h1 id="3-配置使用"><a href="#3-配置使用" class="headerlink" title="3. 配置使用"></a>3. 配置使用</h1><h2 id="3-1-Module介绍"><a href="#3-1-Module介绍" class="headerlink" title="3.1 Module介绍"></a>3.1 Module介绍</h2><p>为适应分布式部署的需要，一个Project可以有多个Module组成，如：core Module、Web Module、plugin Module、solr Module等，彼此相互依赖<br><strong>新建</strong>：右键点击项目名，选择New -&gt; Module<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Module_Create.png" alt="IDEA_Module_Create"></p><p>下一步：选择创建的Module类型和所需版本的JDK</p><p><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Start_Choose_Project_Type.png" alt="IDEA_Start_Choose_Project_Type"></p><p>下一步：定义Module名称和存放目录</p><p><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Moudle_Define.png" alt="IDEA_Moudle_Define"></p><p>Finish：会在设置的位置出现对应的目录结构，进行编写<br><strong>删除</strong>：右键点击模块名module_name，选择Open Module Settings，选中要删除的module_name，点击上方的减号，再右键点击模块名module_name，选择Delete</p><h2 id="3-2-常用配置"><a href="#3-2-常用配置" class="headerlink" title="3.2 常用配置"></a>3.2 常用配置</h2><p>进入设置界面有三种方法：<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Use_Setting.png" alt="IDEA_Use_Setting"></p><p>设置页面介绍<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Use_Setting_Content.png" alt="IDEA_Use_Setting_Content"></p><h3 id="3-2-1-Appearance-amp-Behavior"><a href="#3-2-1-Appearance-amp-Behavior" class="headerlink" title="3.2.1 Appearance &amp; Behavior"></a>3.2.1 Appearance &amp; Behavior</h3><p><strong>Theme</strong><br><a href="http://www.riaway.com/"><font face = "微软雅黑" color = 1E90FF size = 5>下载官网</font></a><br>file -&gt; import Settings或者Settings -&gt; color scheme的scheme进行导入<br>找到下载目录，导入后重启</p><p><strong>取消更新</strong><br>依次点击 Appearance &amp; Behavior -&gt; System Settings -&gt; Update，取消勾选Automatically check update for</p><h3 id="3-2-2-Keymap"><a href="#3-2-2-Keymap" class="headerlink" title="3.2.2 Keymap"></a>3.2.2 Keymap</h3><p>IDEA和Eclipse有不同，可以进行搜索</p><h3 id="3-2-3-Version-Control-版本控制"><a href="#3-2-3-Version-Control-版本控制" class="headerlink" title="3.2.3 Version Control(版本控制)"></a>3.2.3 Version Control(版本控制)</h3><p>以 Git 为例</p><ol><li>安装 Git 客户端</li><li>依次点击 Settings -&gt; Version Control -&gt; Git</li><li>在右侧的Path to Git executable ：里面配置 Git的安装目录</li><li>依次点击 Settings -&gt; Version Control -&gt; GitHub，Auth Type 选择Password ，在右侧输入账号和密码，测试连接</li><li>依次点击 VCS -&gt; Checkout from Version Control -&gt; GitHub</li></ol><h3 id="3-2-4-Editor"><a href="#3-2-4-Editor" class="headerlink" title="3.2.4 Editor"></a>3.2.4 Editor</h3><p><strong>General</strong><br>Mouse</p><ul><li>Change font size with Ctrl + Mouse Wheel：通过鼠标滚轮改变字体大小<br>Auto Import </li><li>Insert imports on paste 选择all，勾选Add unambiguous imports on the fly和Optimize imports on the fly (for current project)：自动导入相关jar包<br>Appearance</li><li>show line numbers ：显示行号</li><li>show method separators：两个方法之间加入横线进行区分<br>Code Completion</li><li>Case sensitive completions 选择None：忽略大小写，进行提示<br>Editor tabs</li><li>show tabs in single row取消勾选：多行显示类文件<br>Postfix Completion：模板不可修改<br>Other</li><li>Show quick documentation on mouse move，设置时间，单位毫秒：鼠标放在类名上，会显示相关信息<br><strong>Font</strong><br>Font(字体) ：Consolas；Size(字体大小)： 16；Line spacing(行间距)：1.0<br><strong>Color Scheme</strong><br>Language Defaults -&gt; Comments -&gt; Block(多行)/Doc(文档)/Line(单行) Comment -&gt; Foreground：设置注释颜色<br>Color Scheme Font：设置编辑区字体<br>Console Font，勾选Use console font instead of the default：设置控制台字体<br><strong>Code Style</strong><br>Java -&gt; Imports -&gt; Class count to use  import with ‘*‘ ：设置import *的个数<br><strong>File and Code Templates</strong><br>Include -&gt; File Header ：添加文档注释<br><strong>File Encoding</strong><br>Global(系统)/Project(当前项目) Encoding：设置文件的编码信息<br><strong>Live Template</strong>：可以定制<br>psvm ：public static void main(String [] args){}<br>sout   ：System.out.println(“”);  soutp、soutm、soutv：最近的变量值、xxx.sout<br>fori     ：for(int i =0; ; i++)   iter、itar<br>list.for:list.fori、list.forr<br>ifn       :inn<br>prsf    ：private static final<br>psf      ：public static final;    psfi、psfs</li></ul><h3 id="3-2-5-Build、Execution、Deployment"><a href="#3-2-5-Build、Execution、Deployment" class="headerlink" title="3.2.5 Build、Execution、Deployment"></a>3.2.5 Build、Execution、Deployment</h3><p><strong>Build Tools</strong><br>配置Maven</p><blockquote><p>Maven是项目自动化构建工具，也可以进行依赖管理<br>Maven home dirtionary ：选择Maven本地安装目录<br>User Setting File ：settings.xml<br>Local repository：本地仓库</p><p>勾选 import Maven projects automatically<br>Automatically download 勾选 Source 和 Doucmentation：可以选择下载源码和官方文档<br>VM options ：-Xmx768m</p></blockquote><p><strong>Compiler</strong><br>Build project automatically：自动编译当前项目，建议勾选<br>Compiler independent modules in parallel：并行对多个模块进行编译，建议勾选</p><p><strong>Debugger</strong><br>Transport 勾选 Shared memory ，可以节省内存空间</p><h3 id="3-2-6-其他"><a href="#3-2-6-其他" class="headerlink" title="3.2.6 其他"></a>3.2.6 其他</h3><p><strong>注释模板</strong></p><ul><li><strong>类注释模板设置</strong>：IDEA –&gt; Settings… –&gt; Editor –&gt; File and Code Templates –&gt; Includes –&gt;File Header，在里面输入注释模板<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Annotation_Module_Class.png" alt="IDEA_Annotation_Module_Class"></li><li><strong>方法注释模板设置</strong>：IDEA –&gt; Settings… –&gt; Editor –&gt; Live Templates  –&gt; 点击+号  –&gt;Template Group…(添加模板组，随便取名)； 添加了模板组后再次点击+号，这次选择Live Template(添加注释模板）； Abbreviation: 该处填入* （此处一定要填写*,IDEA生成注释的默认方式是：/*+模板名+快捷键）<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/IDEA/IDEA_Annotation_Module_Function.png" alt="IDEA_Annotation_Module_Function"></li></ul><p><strong>省电模式</strong><br>File -&gt; Power Save Mode：关闭代码检查和代码提示的功能</p><p><strong>显示模式</strong><br>右键点击类名 -&gt; Split Vertically/Horizontally：横/竖分屏显示</p><p><strong>生成JavaDoc</strong><br>依次点击 Tools -&gt; Generate JavaDoc， 可以选择生成的范围和存储目录，保存格式设置为中文：zh_CN  ，Other command line arguments：-encoding UTF-8 -charset UTF-8</p><p><strong>清除缓存</strong><br>依次点击 File -&gt; Invalidate Caches / Restart</p><h2 id="3-3-配置Tomcat"><a href="#3-3-配置Tomcat" class="headerlink" title="3.3 配置Tomcat"></a>3.3 配置Tomcat</h2><p>运行JavaEE动态Web需要配置Tomcat项目</p><ol><li>依次点击 Run -&gt; Configuration</li><li>点击弹窗左上方的 + 号，选择 Tomcat -&gt; Local</li><li>进入配置页面，点击Server页面，给 Tomcat 命名，点击 Configure 指明Tomcat的安装路径</li><li>点击Deployment，进入部署页面，依次点击右侧 + 号 -&gt; Artifact ，选择需要部署的项目，在 Application context 指明部署应用的名称，点击Apply<br>结束时，先断开与服务器的连接，在执行关闭</li></ol><h2 id="3-4-连接数据库"><a href="#3-4-连接数据库" class="headerlink" title="3.4 连接数据库"></a>3.4 连接数据库</h2><ol><li>依次点击右侧的 Database -&gt; +号 -&gt; Data Source，选择数据库类型，进入连接配置页面</li><li>配置连接IP、端口、数据库、用户和密码，配置完成后可以点击 Test Connection，进行连接</li></ol><h2 id="3-5-断点调试"><a href="#3-5-断点调试" class="headerlink" title="3.5 断点调试"></a>3.5 断点调试</h2><p>step over：进入下一步，如果当前行断点是一个方法，则不进入当前方法体内<br>step into：进入下一步，如果当前行断点是一个方法，则进入当前方法体内<br>force step into：进入下一步，如果当前行断点是一个方法，则进入当前方法体内<br>step out：跳出<br>resume program：恢复程序运行，但如果该断点下面代码还有断点则停在下一个断点上<br>stop：停止<br>mute breakpoints：使所有断点失效<br>view breakpoints：查看所有断点<br>条件断点<br>查看值：Ctrl + U</p>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IDEA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven-安装使用</title>
      <link href="/202106/141824.html"/>
      <url>/202106/141824.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Maven的安装使用的相关知识</p><span id="more"></span><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><p>Maven是用来创建Java项目的工具<br>下载地址<br>将下载的内容解压(即安装)<br>配置环境变量</p><pre class="line-numbers language-none"><code class="language-none">MAVEN_HOME文件安装目录PATH加上%MAVEN_HOME%\bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>测试：cmd中输入mvn help:system<br>修改配置文件，安装目录下的conf目录下的settings.xml文件</p><blockquote><p>修改本地仓库(localRepository)：自定义一个Maven包的下载存放位置<br>镜像下载源：</p><pre><code>&lt;mirror&gt;    &lt;id&gt;alimaven&lt;/id&gt;    &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;    &lt;name&gt;aliyun maven&lt;/name    &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat-安装使用</title>
      <link href="/202106/133262.html"/>
      <url>/202106/133262.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Tomcat的安装使用的相关知识</p><span id="more"></span><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><p>下载安装 Tomcat 之前，需要电脑搭建好 Java 环境(安装JDK，配置了相关的环境变量)<br><a href="https://tomcat.apache.org/"><font face = "微软雅黑" color = 1E90FF size = 5>下载地址</font></a><br>安装</p><h2 id="1-1-Linux"><a href="#1-1-Linux" class="headerlink" title="1.1 Linux"></a>1.1 Linux</h2><ol><li>解压：tar -zxvf YUM_package_name</li><li>启动：进入Tomcat安装目录下的二进制执行文件目录（bin）下，执行./startup.sh<br>关闭：./shutdown.sh</li><li>测试：url localhost:8080，可以访问则安装成功</li><li>开放外网访问，需要打开防火墙，重启防火墙，重启Tomcat</li></ol><pre class="line-numbers language-none"><code class="language-none">vim &#x2F;etc&#x2F;sysconfig&#x2F;iptables加入-A INPUT -p tcp -m tcp --dport 8080 -j ACCEPTservice iptables restartservice iptables status，查看当前防火墙状态<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-Windows"><a href="#1-2-Windows" class="headerlink" title="1.2 Windows"></a>1.2 Windows</h2><ol><li><p>将下载的压缩包选择合适的位置解压即可</p></li><li><p>配置环境变量</p><pre class="line-numbers language-none"><code class="language-none">CATALINA_HOMEC:\Install\Tomcat\apache-tomcat-8.5.65TOMCAT_HOMEC:\Install\Tomcat\apache-tomcat-8.5.65PATH 里面加上：%CATALINA_HOME%\lib;%CATALINA_HOME%\bin;%TOMCAT_HOME%\bin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>启动</p><ul><li>直接双击 startup.bat 文件</li><li>cmd命令窗口输入：startup</li><li>cmd命令窗口输入：catalina run</li><li>关闭直接将弹出的 Java 黑窗关掉即可</li></ul></li><li><p>测试：浏览器输入：localhost:8080，可以出现界面则安装成功<br><img src="https://qizhongyi.gitee.io/images/Tools/Java/Tomcat_Start.png" alt="Tomcat_Start"></p></li></ol><h1 id="2-常见问题"><a href="#2-常见问题" class="headerlink" title="2. 常见问题"></a>2. 常见问题</h1><p><strong>问题1</strong>：若启动 Tomcat 时闪退，可在 startup.bat 文件最后加入 pause 保存退出，进行启动过程展示，定位问题</p><blockquote><p>环境变量配置问题：找对正确的路径，配置环境变量，CATALINA_HOME 和 TOMCAT_HOME 是解压安装的顶级目录(bin目录的上一级目录)，PATH 环境变量在 xxx_Home 的基础上加上 bin 目录<br>端口占用问题：修改 conf 目录下的 server.xml 文件，将 <Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /> 中port 处的端口值修改</p></blockquote><p><strong>问题2</strong>：Java 黑窗乱码问题</p><blockquote><p>解决：修改 conf 目录下的 logging.properties 文件，将里面 java.util.logging.ConsoleHandler.encoding 的属性值改为 GBK，默认为 UTF-8</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-常见包</title>
      <link href="/202106/1242385.html"/>
      <url>/202106/1242385.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Java常见包及其作用 的相关基础内容</p><span id="more"></span><h1 id="1-Servlet"><a href="#1-Servlet" class="headerlink" title="1. Servlet"></a>1. Servlet</h1><ul><li>作用：客户端发送请求至服务器；服务器启动并调用Servlet，Servlet根据客户端请求生成响应内容并将其传给服务器；服务器将响应返回客户端</li><li>生命周期：</li></ul><ul><li>Servlet 初始化后调用 init() 方法生成Servlet实例;</li><li>Servlet 调用 service() 方法来处理客户端的请求;</li><li>Servlet 在请求结束后，销毁前调用 destroy() 方法结束实例;</li><li>Servlet 最后由 JVM 的垃圾回收器进行垃圾回收。</li></ul><ul><li>init()：设计成只调用一次，在第一次创建 Servlet 时调用，后续每次用户请求时不再调用，init只简单地创建或加载一些数据，这些数据将被用于 Servlet 的整个生命周期<br>public void init() throws ServletException {<pre><code> // 初始化代码...</code></pre> }</li><li>service()：执行实际任务的主要方法，Servlet 容器（即 Web 服务器）调用 service() 方法来处理来自客户端（浏览器）的请求，并把格式化的响应数据写回给客户端。服务器接收到 Servlet 请求时，会产生一个新的线程并调用服务，service() 方法检查 HTTP请求类型（GET、POST、PUT、DELETE 等），并在适当的时候调用 doGet()、doPost()、doPut()，doDelete() 等方法。<br>public void service(ServletRequest request, ServletResponse response) throws ServletException, IOException{<pre><code> // 请求处理代码...</code></pre> }</li></ul><ul><li>GET请求来自于一个URL的正常请求，或者来自于一个未指定METHOD的HTML表单，由doGet()方法处理<br>public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<pre><code> // Servlet 代码</code></pre> }</li><li>POST请求来自于一个指定METHOD为POST的HTML表单，由doPost()方法处理<br>public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {<br>// Servlet 代码<br> }</li><li>destroy() 方法：只会在Servlet生命周期结束时被调用一次，destroy()方法可以让Servlet 关闭数据库连接、停止后台线程、把 Cookie 列表或点击计数器写入到磁盘，并执行其他类似的清理活动，调用 destroy() 方法后，servlet对象被标记为垃圾回收<br>public void destroy() {<br>// 终止化代码…<br> }</li></ul><h1 id="2-POI"><a href="#2-POI" class="headerlink" title="2. POI"></a>2. POI</h1><p>Apache POI是Apache软件基金会的开源项目，POI提供API给Java程序对MS Office文件实现读和写的功能。<br>导入：import org.apache.poi.classname.functionname<br>classname</p><ul><li>HSSF提供读写Microsoft Excel XLS格式档案的功能;</li><li>XSSF提供读写Microsoft Excel OOXML XLSX格式档案的功能;</li><li>HWPF提供读写Microsoft Word DOC格式档案的功能;</li><li>HSLF提供读写Microsoft PowerPoint格式档案的功能;</li><li>HDGF提供读Microsoft Visio格式档案的功能;</li><li>HPBF提供读Microsoft Publisher格式档案的功能;</li><li>HSMF提供读Microsoft Outlook格式档案的功能。<br>functionname</li><li>HSSFWorkbook：       Excel的文档对象</li><li>HSSFSheet：          Excel的表单</li><li>HSSFRow:             Excel的行</li><li>HSSFCell：           Excel的格子单元</li><li>HSSFFont：           Excel字体</li><li>HSSFDataFormat：     格子单元的日期格式</li><li>HSSFHeader：         Excel文档Sheet的页眉</li><li>HSSFFooter：         Excel文档Sheet的页脚</li><li>HSSFCellStyle：      格子单元样式</li><li>HSSFDateUtil：       日期</li><li>HSSFPrintSetup：     打印</li><li>HSSFErrorConstants： 错误信息表</li></ul><h1 id="3-util"><a href="#3-util" class="headerlink" title="3. util"></a>3. util</h1><ul><li>Scanner类来获取用户输入：Scanner scan = new Scanner(System.in);</li></ul>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-常见问题</title>
      <link href="/202106/1143502.html"/>
      <url>/202106/1143502.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍Java编程中的一些常见问题</p><span id="more"></span><ul><li>问题1. ‘==’和equals的区别</li></ul><blockquote><p>解释：==：当比较的对象是基本数据类型(int, string, double 等)时，比较两个对象所赋的值，当比较的对象是引用数据类型时，比较的是两个对象指向的地址；equals：不能用于比较基本数据类型，当比较对象是引用类型时，比较两个对象指向的地址<br>int a = 123;   int b = 123;     //基本数据类型在方法区中的常量池中一个常量只会对应一个地址，基本数据的包装类型也可以通过==判断。注：Integer的范围是[-128,127]，超出会是两个对象。<br>System.out.print(a == b);    //true</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot-常见问题</title>
      <link href="/202106/1018092.html"/>
      <url>/202106/1018092.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录SpringBoot中的常见问题</p><span id="more"></span><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><ul><li><p><strong>问题1</strong>：Web server failed to start. Port 8080 was already in use</p><blockquote><p>原因：端口占用<br>解决一：修改端口（修改配置文件：application.yml server :prot: = ）<br>解决二：关闭占用端口的进程（netstat -ano | findstr &lt;端口号&gt; / taskkill -PID &lt;进程号&gt; -F）</p></blockquote></li><li><p><strong>问题2</strong>：HikariPool-1 - Exception during pool initialization.</p><blockquote><p>原因：HikariPool-1 -池初始化期间异常<br>解决：加入&amp;&amp;serverTimezone=UTC</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM-基础</title>
      <link href="/202106/088268.html"/>
      <url>/202106/088268.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录-Java-SSM框架-的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><strong>SSM框架</strong>：Spring + SpringMVC + MyBaits</p><ul><li>Spring：是一个容器，类似于一个对象工厂，按要求标记  /注解的类都会被提前放入这个容器</li><li>SpringMVC：是一个控制器和视图分发器（给出回应）</li><li>MyBaits：JDBC的封装，本质是JDBC对数据库的操作：SQLSessionFactory(数据持久层)。根据用户写的实体类和隐射mapper文件之间的对应来获取到相应的SQL语句执行</li></ul><h1 id="2-各层介绍"><a href="#2-各层介绍" class="headerlink" title="2. 各层介绍"></a>2. 各层介绍</h1><ul><li>DAO（mapper、持久层）：主要做数据持久层工作，与数据库进行联络，设计DAO接口</li><li>Service（业务层）：实现具体任务，调用DAO层接口</li><li>Controller（控制层）：负责业务模块的流程控制</li><li>View（视图层）：负责前端页面展示</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> SSM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM-基础</title>
      <link href="/202106/0751874.html"/>
      <url>/202106/0751874.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍-Java-JVM虚拟机-的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Java Virtual Machine（JVM，Java虚拟机），Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），在多种平台上不需修改即可运行，实现跨平台</p><h1 id="2-内存模型（四个五个-）"><a href="#2-内存模型（四个五个-）" class="headerlink" title="2. 内存模型（四个五个 ）"></a>2. 内存模型（四个<del>五个</del> ）</h1><ul><li>程序计数器（Program Counter Register）：存储当前线程执行字节码的行号指示器，显示当前线程所执行字节码的行号（一个线程就有一个程序计数器）。如果程序执行Java方法，则计数器记录正在执行的虚拟机字节码指令地址；如果执行本地方法（native，由C语言编写完成），则计数器的值为Undefined。程序计数器只是记录当前指令地址，不存在内存溢出，因此，程序计数器是所有JVM内存区域中唯一一个没有定义OutOfMemoryError的区域</li><li>本地方法栈（Native Method Statck）：用来执行native方法。线程私有</li><li>虚拟机栈（JVM Stack）：存储局部变量表（包括基本数据类型，对象的引用，返回地址）、操作数栈、动态链接、方法出口等。线程的每个方法在执行时，创建一个栈帧（Statck Frame）入栈，当方法执行完成时，栈帧出栈。如果线程调用的栈深度大于虚拟机允许的最大深度，则抛出StatckOverFlowError（栈溢出）；不过多数Java虚拟机允许动态扩展虚拟机栈大小，所以线程可以一直申请栈，直到内存不足，抛出 OutOfMemoryError（内存溢出）。每个线程对应一个虚拟机栈（线程私有）</li><li>堆区（Heap）：存储对象实例。堆区由所有线程共享，虚拟机启动时创建，原则上所有的对象都在堆区上分配内存（也存在在栈上直接分配）。堆内存需要在逻辑上是连续的（物理上不需要），内存空间最大且可扩展（也可固定大小，主流都是可扩展），在执行垃圾回收之后，仍没有足够的内存分配，也不能再扩展，抛出OutOfMemoryError:Java heap space异常</li></ul><ul><li>VM Args:-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError    //-Xms = -Xmx,可避免堆自动扩展；-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出时dump出当前的内存堆转储快照</li></ul><ul><li>方法区（Method Area）：存储被虚拟机加载的类信息（即加载类时需要加载的信息，包括版本、field、方法、接口等信息）、final常量、静态变量、编译器即时编译的代码等。方法区由所有线程共享，在物理上不需要连续，可选固定大小或可扩展大小，还可以选择是否执行垃圾收集（一般不执行，<del>永生代：回收废弃常量和无用类</del> ），主要是针对常量池的内存回收和对已加载类的卸载，内存不足时抛出OutOfMemoryError:PermGen space异常。JDK1.8移除永久代，将方法区并入堆区，称为元空间</li></ul><ul><li>运行时常量池（Runtime Constant Pool）：是方法区的一部分，用于存储编译期就生成的字面常量、符号引用（编码时用字符串表示某个变量、接口的位置）、翻译出来的直接引用（根据符号引用翻译出来的地址，在类链接阶段完成翻译）</li></ul><h1 id="3-Garbage-Collection-GC，垃圾回收"><a href="#3-Garbage-Collection-GC，垃圾回收" class="headerlink" title="3. Garbage Collection(GC，垃圾回收)"></a>3. Garbage Collection(GC，垃圾回收)</h1><ul><li>程序计数器、虚拟机栈、本地方法栈与线程相关联，内存在类结构确定时即可确定，不需额外增加回收机制；堆区和方法区，内存在运行时才可以确定大小，需要垃圾回收机制处理</li></ul><h2 id="3-1-堆区（Heap）再分区"><a href="#3-1-堆区（Heap）再分区" class="headerlink" title="3.1 堆区（Heap）再分区"></a>3.1 堆区（Heap）再分区</h2><blockquote><p>新生代（Young Generation，细分为Eden区（Eden Region）和Survivor区（Form/To Survivor Region）和老生代（Old Generation）），两块Survivor在GC时会相互转化，循环利用</p><blockquote><p>Java虚拟机在进行垃圾回收时，将Eden和Form Survivor中存活着的对象一次性地复制到另一块To Survivor空间上，完全清理Eden区（防止出现内存碎片），经过一次或者多次 GC之后，存活下来的对象（通过对象年龄判断，初始值为1，每经过一次GC，对象年龄会加1，达到阈值后会进入老年区；如果Survivor空间中所有相同年龄对象大小的总和大于Survivor空间的一半，则年龄大于或等于该年龄的对象就可以进入老年代）会被移动到老年区；另外老生代中还存放着大对象（需要很多连续的内存的对象）和长期存活的对象。当 JVM内存不够时，会触发 Full GC，清理 JVM 老年区；当新生区不够时触发 YGC，先把存活的对象放到其中一个 Survice区，当Survivor空间不够用时，需要依赖其他老年代的内存进行分配担保。如果老生代的空间也被占满，当来自新生代的对象再次请求进入老生代时就会报OutOfMemory异常</p></blockquote></blockquote><h2 id="3-2-回收条件"><a href="#3-2-回收条件" class="headerlink" title="3.2 回收条件"></a>3.2 回收条件</h2><ul><li>1、该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>2、加载该类的ClassLoader已经被回收</li><li>3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li></ul><h2 id="3-3-回收算法"><a href="#3-3-回收算法" class="headerlink" title="3.3 回收算法"></a>3.3 回收算法</h2><blockquote><p>引用计数算法（Reference Counting）：给对象添加引用计数器，当被引用时，计数器值加1；当引用失效时，计数器值减1；计数器为0的对象不可能再被引用。无法判定相互循环引用（A引用B，B引用A）的情况</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-基础</title>
      <link href="/202106/0653309.html"/>
      <url>/202106/0653309.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Java基础语法 的相关基础知识</p><span id="more"></span><h1 id="1-保留关键字"><a href="#1-保留关键字" class="headerlink" title="1. 保留关键字"></a>1. 保留关键字</h1><p><strong>保留关键字</strong>：被Java语言赋予了特殊含义，用作专门用途的字符串(单词)，所有字母都小写</p><ul><li><p><strong>访问控制/权限控制</strong>：</p><ul><li>private：私有</li><li>protected：受保护的</li><li>public：公开</li></ul></li><li><p><strong>类、方法和变量修饰符</strong>：</p><ul><li>abstract</li><li>class</li><li>extends</li><li>final</li><li>implements</li><li>interface</li><li>native</li><li>new</li><li>static</li><li>strictfp</li><li>synchronized</li><li>transient</li><li>volatile</li></ul></li><li><p><strong>程序控制</strong>：</p><ul><li>if</li><li>else</li><li>do</li><li>while</li><li>for</li><li>switch</li><li>case</li><li>default</li><li>break：主要用在循环语句或者 switch 语句中，用来 跳出最里层的循环，并且继续执行该循环下面的语句</li><li>continue：用于任何循环控制结构中，用于让程序立刻跳转到下一次循环的迭代：在 for 循环中，continue 语句使程序立即跳转到更新语句；在 while 或者 do…while 循环中，程序立即跳转到布尔表达式的判断语句</li><li>return</li><li>instanceof：判断其左边对象是否为其右边类的实例，返回boolean类型的数据</li></ul></li><li><p><strong>错误处理</strong>：</p><ul><li>try</li><li>catch</li><li>throw</li><li>throws</li><li>finally</li></ul></li><li><p><strong>包相关</strong>：</p><ul><li>import：导入相关包（包括Java预定义的包和用户自定义的包）</li><li>package</li></ul></li><li><p><strong>基本类型/原始类型</strong>：</p><ul><li>boolean</li><li>byte</li><li>char</li><li>double</li><li>float</li><li>int</li><li>long</li><li>short</li><li>null</li><li>true</li><li>false</li></ul></li><li><p><strong>变量引用</strong>：</p><ul><li>super</li><li>this</li><li>void</li></ul></li><li><p><strong>保留字</strong>：现在未使用，以后的版本可能会作为关键字使用，命名时应尽量避免</p><ul><li>goto</li><li>const</li><li>byValue</li><li>cast</li><li>future</li><li>generic</li><li>inner</li><li>operator</li><li>outer</li><li>rest</li><li>var</li></ul></li></ul><h1 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h1><h2 id="2-1-基本数据类型"><a href="#2-1-基本数据类型" class="headerlink" title="2.1 基本数据类型"></a>2.1 基本数据类型</h2><p><strong>数值型</strong></p><ul><li><strong>整数</strong>：存放整数<ul><li>byte[1]：字节</li><li>short[2]：短整型</li><li>int[4]：整数型(默认)</li><li>long[8]：长整型，申明时需要加上“i”或者“L”</li></ul></li><li><strong>浮点数</strong>：存放小数，由符号位、指数位和尾数位构成，尾数位可能丢失，存在精度问题，有十进制计数法和科学计数法两种表现形式<ul><li>float[4]：单精度浮点数，申明时需要加上“f”或“F”</li><li>double[8]：双精度浮点数(默认)<br>不要使用运算结果为小数进行相等判断，通常采用两数之差的绝对值小于某个精度范围就认为相等</li></ul></li></ul><p><strong>字符串类型</strong>：char[2]，存放单个字符，可用ASCLL码/Unicode码输出字符，输出的字符用单引号包裹，双引号包裹的是字符串，char字符都有Unicode码对应的整数，可以参与运算</p><p><strong>布尔类型</strong> ：boolean[1]，存放ture，false，常用于逻辑运算，进行流程控制，<strong>不能用0或非0的整数代替true或false</strong></p><p><strong>数据类型转换</strong>：小容量数据类型可以自动转换为大容量类型<br><img src="https://qizhongyi.gitee.io/images/Java/Java_Type_Change.png" alt="Java_Type_Change"></p><p><strong>自动类型转换</strong>：存在多种类型的数据混合运算时，先自动转换为容量最大的数据类型</p><blockquote><p>byte、short和char不能自动进行类型转换，byte、short和char进行运算(包括单类型运算和多类型运算)时先自动转换为int进行计算<br>boolean 不参与数据类型转换<br>当把整数赋值给byte时，先判断整数是否在byte范围内，在进行类型判断进行赋值，如果是变量进行赋值，则先进行类型判断</p></blockquote><p><strong>强制类型转换</strong>：用强制类型转换符()包裹要转换成的数据类型，后面接上要转换的数据，可能引起数据精度丢失和数据溢出的问题</p><blockquote><p>强制类型转换符只针对最近的操作数有效，可以使用()提高运算优先级<br>char可以保存int值，不能保存int的变量，需要进行强制类型转换符</p></blockquote><p><strong>String类型转换</strong>：仅能转换整数字符串为基本数据，不能转换字符字符串为基本数据</p><blockquote><p>基本类型转换为String数据类型：只需要在基本数据类型后面加上’ + “” ‘即可<br>String类型转换为基本数据类型：需要用到基本数据类型包装类的parseXxx方法，String转换为char类型是使用charAt()方法取字符串的第一个字符给char</p></blockquote><h2 id="2-2-引用数据类型"><a href="#2-2-引用数据类型" class="headerlink" title="2.2 引用数据类型"></a>2.2 引用数据类型</h2><ul><li><strong>类</strong> class</li><li><strong>接口</strong> interface</li><li><strong>数组</strong></li></ul><h1 id="3-运算符"><a href="#3-运算符" class="headerlink" title="3. 运算符"></a>3. 运算符</h1><h2 id="3-1-算术运算符"><a href="#3-1-算术运算符" class="headerlink" title="3.1 算术运算符"></a>3.1 算术运算符</h2><p><strong>算术运算符</strong>：对数值数据的变量进行运算</p><table><thead><tr><th align="center">运算符</th><th align="center">运算</th><th align="center">范例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">正号</td><td align="center">+1</td><td align="center">1</td></tr><tr><td align="center">-</td><td align="center">负号</td><td align="center">-1</td><td align="center">-1</td></tr><tr><td align="center">+</td><td align="center">加</td><td align="center">1 + 1</td><td align="center">2</td></tr><tr><td align="center">-</td><td align="center">减</td><td align="center">1 - 1</td><td align="center">0</td></tr><tr><td align="center">*</td><td align="center">乘</td><td align="center">1 * 1</td><td align="center">1</td></tr><tr><td align="center">/</td><td align="center">除</td><td align="center">1 / 1</td><td align="center">1</td></tr><tr><td align="center">%</td><td align="center">取余</td><td align="center">1 % 1</td><td align="center">0</td></tr><tr><td align="center">++</td><td align="center">自增（在前）：先运算再赋值<br />自增（在后）：先赋值再运算</td><td align="center">a = 2; b = ++ a<br />a = 2; b = a ++</td><td align="center">a = 3; b = 3<br />a = 3; b = 2</td></tr><tr><td align="center">–</td><td align="center">自减（在前）：先运算再赋值<br />自减（在后）：先赋值再运算</td><td align="center">a = 2; b = – a<br />a = 2; b = a –</td><td align="center">a = 1; b = 1<br />a = 1; b = 2</td></tr></tbody></table><p>**+**：拼接，当左右两边数据类型均为数值型时，进行加法运算；若一边为字符串类型，进行拼接运算，运算顺序为从左到右<br>**/**：除，当除号两边均为int时，结果会舍弃小数部分，仅保留整数部分<br>**%**：取模，本质是：a % b = a - a / b * b<br>**++**：独立使用时，前++与后++完全一致，作为表达式使用：</p><pre class="line-numbers language-none"><code class="language-none">int i &#x3D; 1;i++;            &#x2F;&#x2F; 等价于：i &#x3D; i + 1;++i;            &#x2F;&#x2F; 等价于：i &#x3D; i + 1;int j &#x3D; ++i;    &#x2F;&#x2F; 等价于：i &#x3D; i + 1; j &#x3D; i;int j &#x3D; i++;    &#x2F;&#x2F; 等价于：j &#x3D; i; i &#x3D; i + 1;i &#x3D; i++;        &#x2F;&#x2F; 得i &#x3D; 1 ：(1)temp &#x3D; i; (2)i &#x3D; i + 1; (3)i &#x3D; tempi &#x3D; ++i;        &#x2F;&#x2F; 得i &#x3D; 2 ：(1)i &#x3D; i + 1; (2)temp &#x3D; i; (3)i &#x3D; temp注：--同理<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-关系运算符"><a href="#3-2-关系运算符" class="headerlink" title="3.2 关系运算符"></a>3.2 关系运算符</h2><p><strong>关系运算符</strong>：判断两数的大小关系，结果都是boolean类型；常用在 if 分支结构或 for / while 循环结构中，有关系运算符组成的表达式成为关系表达式</p><table><thead><tr><th align="center">运算符</th><th align="center">实例</th><th align="center">描述</th><th></th></tr></thead><tbody><tr><td align="center">==</td><td align="center">等于</td><td align="center">1 == 1</td><td>true</td></tr><tr><td align="center">!=</td><td align="center">不等于</td><td align="center">1 != 1</td><td>false</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td><td align="center">1 &gt; 1</td><td>false</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td><td align="center">1 &lt; 1</td><td>false</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td><td align="center">1 &gt;= 1</td><td>true</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td><td align="center">1 &lt;= 1</td><td>true</td></tr><tr><td align="center">instanceof</td><td align="center">检查是否为类的对象</td><td align="center">“A” instanceof String</td><td>true</td></tr></tbody></table><h2 id="3-3-逻辑运算符"><a href="#3-3-逻辑运算符" class="headerlink" title="3.3 逻辑运算符"></a>3.3 逻辑运算符</h2><p><strong>逻辑运算符</strong>：用于连接多个条件(关系表达式)，最终结果也是一个boolean值</p><table><thead><tr><th>a</th><th>b</th><th>a&amp;b</th><th>a&amp;&amp;b</th><th>a|b</th><th>a||b</th><th>!a</th><th>a^b</th></tr></thead><tbody><tr><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td>true</td><td>false</td><td>false</td></tr><tr><td>true</td><td>false</td><td>false</td><td>false</td><td>true</td><td>true</td><td>false</td><td>true</td></tr><tr><td>false</td><td>true</td><td>false</td><td>false</td><td>true</td><td>true</td><td>true</td><td>true</td></tr><tr><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>false</td><td>true</td><td>false</td></tr></tbody></table><ul><li>**逻辑与 &amp;**（and）：当运算符两边的表达式的结果都为true时，整个运算结果才为true，只要有一边为false，则结果为false<ul><li>&amp;：无论第一个判断条件是否成立，逻辑运算符前后两个条件都会进行判断</li></ul></li><li>**短路与 &amp;&amp;**（and）：当运算符两边的表达式的结果都为true时，整个运算结果才为true，只要有一方为false，则结果为false<ul><li>&amp;&amp;：第一个条件不成立，后面的条件均不进行判断，返回false，推荐使用，效率更高</li></ul></li><li>**逻辑或 |**（or）：当运算符有一边为true时，整个运算结果为true<ul><li>|：无论第一个判断条件是否成立，逻辑运算符前后两个条件都会进行判断</li></ul></li><li>**短路或 ||**（or）：当运算符有一边为true时，整个运算结果为true<ul><li>||：第一个条件成立，后面的条件均不进行判断，返回true，推荐使用，效率更高</li></ul></li><li>**逻辑非 !**（not）：取本来值的相反值</li><li><strong>逻辑异或 ^</strong>：符号两边不同时结果为true，否则为false</li></ul><h2 id="3-4-赋值运算符"><a href="#3-4-赋值运算符" class="headerlink" title="3.4 赋值运算符"></a>3.4 赋值运算符</h2><p><strong>赋值运算符</strong>：将数据赋值给变量，左边只能是变量，右边可以是常量、变量、表达式，进行复核赋值运算时会进行类型转换<br><strong>基本赋值运算符</strong>：=，例：int a = 10;<br><strong>复合赋值运算符</strong>：+=、-=、*=、/=、%=，例：a += b; 等价于 a = a + b;其他同理</p><h2 id="3-5-三元运算符"><a href="#3-5-三元运算符" class="headerlink" title="3.5 三元运算符"></a>3.5 三元运算符</h2><p>条件表达式 ？ 表达式1 : 表达式2；若条件表达式为true，则运行表达式1；若条件表达式为false，则运行表达式2。通常可以转换为if ··· else ··· 语句<br>当条件表达式为true时，不会执行表达式2；当条件表达式为false时，不会执行表达式1</p><h2 id="3-6-运算符优先级"><a href="#3-6-运算符优先级" class="headerlink" title="3.6 运算符优先级"></a>3.6 运算符优先级</h2><p>(), [], {}等 -&gt; 单目运算符 -&gt; 算术运算符 -&gt; 位移运算符 -&gt; 比较运算符 -&gt; 逻辑运算符 -&gt; 三元运算符 -&gt; 赋值运算符</p><table><thead><tr><th>优先级</th><th>运算方向</th><th>运算符</th></tr></thead><tbody><tr><td>高</td><td>L-&gt;R</td><td>()  []  {}</td></tr><tr><td></td><td>R-&gt;L</td><td>++   –   ~   !(data_type)：单目运算符，仅对一个数据进行计算</td></tr><tr><td></td><td>L-&gt;R</td><td>*  /  %  (算术运算)</td></tr><tr><td></td><td>L-&gt;R</td><td>+   -</td></tr><tr><td></td><td>L-&gt;R</td><td>&lt;&lt;   &gt;&gt;   &gt;&gt;&gt;  (位运算)</td></tr><tr><td></td><td>L-&gt;R</td><td>&lt;   &gt;   &lt;=   &gt;=   instanceof  (比较运算)</td></tr><tr><td></td><td>L-&gt;R</td><td>==   !=</td></tr><tr><td></td><td>L-&gt;R</td><td>&amp;  (逻辑运算)</td></tr><tr><td></td><td>L-&gt;R</td><td>^</td></tr><tr><td></td><td>L-&gt;R</td><td>|</td></tr><tr><td></td><td>L-&gt;R</td><td>&amp;&amp;</td></tr><tr><td></td><td>L-&gt;R</td><td>||</td></tr><tr><td></td><td>L-&gt;R</td><td>expr ? value : value (三元运算符)</td></tr><tr><td></td><td>R-&gt;L</td><td>=   *=   /=   %=</td></tr><tr><td></td><td>R-&gt;L</td><td>+=   -=   &lt;&lt;=   &gt;&gt;=</td></tr><tr><td>低</td><td>R-&gt;L</td><td>&gt;&gt;&gt;=   &amp;=   ^=</td></tr></tbody></table><h1 id="4-控制语句"><a href="#4-控制语句" class="headerlink" title="4. 控制语句"></a>4. 控制语句</h1><h2 id="4-1-循环语句"><a href="#4-1-循环语句" class="headerlink" title="4.1 循环语句"></a>4.1 循环语句</h2><ul><li><strong>for</strong>(初始化循环变量;  判断条件;  循环变量增幅){循环体}</li></ul><pre class="line-numbers language-none"><code class="language-none">for(int i &#x3D; 0; i &lt; n; i++)&#123;System.out.print(&quot;i&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>增强for循环：for(声明循环变量; 数组名称){语句}，主要用于数组</p><pre class="line-numbers language-none"><code class="language-none">String[] str&#x3D;&#123;&#39;xx&#39;,&#39;xxx&#39;&#125;for(String s:str)&#123;System.out.println(i);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>注意：增强for的目标不能是null（使用前先做非空判断），声明局部变量的类型必须和数组元素的类型匹配</p></blockquote><ul><li><strong>while</strong>(条件){语句}</li></ul><pre class="line-numbers language-none"><code class="language-none">while(条件)&#123;System.out.print(&quot;i&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>do</strong> {语句}while(条件);</li></ul><pre class="line-numbers language-none"><code class="language-none">do&#123;System.out.print(&quot;i&quot;);&#125;while(条件)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><blockquote><p>比较：与while相比，do…while 循环至少会执行一次；for的循环次数提前已知</p></blockquote><h2 id="4-2-分支语句"><a href="#4-2-分支语句" class="headerlink" title="4.2 分支语句"></a>4.2 分支语句</h2><ul><li><strong>if</strong>(条件){语句}[else if(条件){语句}else{语句}]</li></ul><pre class="line-numbers language-none"><code class="language-none">if()&#123;System.out.print(&quot;i&quot;);&#125;else if(条件)&#123;System.out.print(&quot;j&quot;);&#125;else&#123;System.out.print(&quot;k&quot;);&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>switch</strong>(变量) {case value:{语句;break;}[default:{语句}]}</li></ul><pre class="line-numbers language-none"><code class="language-none">switch(变量)&#123;case value1:&#123;System.out.print(&quot;i&quot;);continue;&#125;case value2:&#123;System.out.print(&quot;j&quot;);break;&#125;default:&#123;System.out.print(&quot;k&quot;);&#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>switch的类型可以是int，short，byte和char，不能处理long，String类型；匹配之前不会执行，若匹配无break，则后续会继续执行</p></blockquote><p>比较：switch使用了Binary Tree算法，运行效率优于if（除非是if-else的第一个条件就为true），if的使用更加灵活，条件更为多样；编译器编译switch时，不管有多少case，都直接跳转，不需逐个比较查询，与if不同；分支较多时，优先考虑switch</p><h1 id="5-I-O"><a href="#5-I-O" class="headerlink" title="5. I/O"></a>5. I/O</h1><h2 id="5-1-Input-输入"><a href="#5-1-Input-输入" class="headerlink" title="5.1 Input(输入)"></a>5.1 Input(输入)</h2><p>Scanner</p><ul><li>导包：import java.util.Scanner</li><li>输入：Scanner sc = new Scanner(System.in);</li></ul><h2 id="5-2-Output-输出"><a href="#5-2-Output-输出" class="headerlink" title="5.2 Output(输出)"></a>5.2 Output(输出)</h2><p>Java的输出方法是在java.long包里的System类中的方法，有print、println、printf三种</p><ul><li>System.out.print()；是一般的标准输出，输出的信息不会换行</li><li>System.out.println()；与print功能相似，输出的信息后会换行</li><li>System.out.printf()；继承了C语言的printf的一些特性，可以进行格式化输出<table><thead><tr><th align="center">符号</th><th>说明</th><th align="left">适用范围</th><th align="left">备注</th></tr></thead><tbody><tr><td align="center">%d</td><td>以十进制整数格式输出</td><td align="left">byte、short、int、long、Byte、Short、Integer、Long、BigInteger</td><td align="left">无</td></tr><tr><td align="center">%f</td><td>以十进制浮点数格式输出</td><td align="left">float、double、Float、Double、BigDecimal</td><td align="left">无</td></tr><tr><td align="center">%e或%E</td><td>以科学记号浮点数格式输出</td><td align="left">float、double、Float、Double、BigDecimal</td><td align="left">%e表示以小写字母e表示，%E表示以大写字母E表示</td></tr><tr><td align="center">%o</td><td>以八进制整数格式输出</td><td align="left">byte、short、int、long、Byte、Short、Integer、Long、BigInteger</td><td align="left">无</td></tr><tr><td align="center">%x或%X</td><td>以十六进制整数格式输出</td><td align="left">byte、short、int、long、Byte、Short、Integer、Long、BigInteger</td><td align="left">%x表示以小写字母x表示，%X表示以大写字母X表示</td></tr><tr><td align="center">%c或%C</td><td>以字符符号输出</td><td align="left">byte、short、char、Byte、Short、Integer、Charcater</td><td align="left">%c表示以小写字母表示，%X表示以大写字母表示</td></tr><tr><td align="center">%b或%B</td><td>输出boolean值</td><td align="left">boolean、非null值为true、null值为false</td><td align="left">%b表示输出结果会是true或false，%B表示输出结果会是TRUE或FALSE</td></tr><tr><td align="center">%h或%H</td><td>用Integer.toHexString (arg.hashCode())来得到输出结果</td><td align="left">-</td><td align="left">如果arg是null，则输出null，也常用于想得到十六进制格式输出</td></tr><tr><td align="center">%n</td><td>输出平台特定的换行符号</td><td align="left">-</td><td align="left">Windows下会置换为”\r\n”；Linux下会置换为’\n’；Mac OS下回置换为’\r’</td></tr></tbody></table></li></ul><h1 id="6-简单函数"><a href="#6-简单函数" class="headerlink" title="6.  简单函数"></a>6.  简单函数</h1><p><strong>进制转换函数</strong>：</p><pre class="line-numbers language-none"><code class="language-none">10进制的x转2进制:   Integer.toBinaryString(x);   # 返回一个二进制int型数据10进制的x转8进制:   Integer.toOctalString(x);    # 返回一个八进制int型数据10进制的x转16进制:  Integer.toHexString(x);      # 返回一个16进制int型数据10进制的x转n进制:   Integer.toString(x,n);       # 返回一个n进制int型数据n进制的x转10进制:   Integer.valueOf(x,n);        # 返回一个十进制int型数据；valueOf()：用于返回给定参数的原生Number对象值的静态方法，参数可以是原生数据类型, String等。该方法接收两个参数一个是需要转换字符串[，一个是转换基数(可选)]Number.valueOf(&quot;444&quot;&#x2F;444[,16]);     # 返回字符&quot;444&quot;&#x2F;数值444对应的十六进制Number(Integer&#x2F;Float&#x2F;Double&#x2F;String)型数据n进制的x转m进制(n-&gt;10-&gt;m)：（2进制的10001110转8进制）Integer.toOctalString(Integer.valueOf(10001110, 2));BigInteger.change(&quot;10001110&quot;, 2, 8);    # BigInteger.change(String number&#x2F;&quot;x&quot;, int from&#x2F;n, int to&#x2F;m);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>字符串相关函数</strong></p><ul><li>字符串截取：substring(start, stop);  (包头不包尾)</li></ul><p><strong>方法重载</strong>：方法名相同，可以改变参数类型、参数个数、参数顺序，仅改变参数名不构成方法重载，方法重载使用同一个方法名实现功能相同、主体不同的方法</p><h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h1><h2 id="7-1-转义字符"><a href="#7-1-转义字符" class="headerlink" title="7.1 转义字符"></a>7.1 转义字符</h2><pre class="line-numbers language-none"><code class="language-none">\t：制表位\n：换行\\：输出\\&quot;：输出&quot;，常用在在字符串里面输出&quot;\r：回车，光标会移动到最前面，重新开始输出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-安装使用</title>
      <link href="/202106/0530938.html"/>
      <url>/202106/0530938.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Java的发展历史、组成部分、安装下载、保留字和语言的特点</p><span id="more"></span><h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>进行JavaEE开发，所需要搭建的开发环境</p><ul><li>Java 语言的软件开发工具包：JDK，包含JAVA的运行环境（JVM+Java系统类库）和JAVA工具</li><li>Web服务器：常用Tomcat</li><li>代码编辑器：常用Eclipse、IDEA</li><li>数据库服务器：常用MySQL、Oracle</li></ul><h1 id="2-介绍"><a href="#2-介绍" class="headerlink" title="2. 介绍"></a>2. 介绍</h1><p>发展：1990年Sun公司启动绿色计划，希望在硬件设备上编程；1992年，James Gosling等人创建Oak（橡树）语言，1994年Gosling带着Java（更名）参加硅谷大会；1995年，发布第一个正式版本；2009年，甲骨文收购Sun；2011年，发布Java7；<a href="https://www.oracle.com/java/technologies/java-se-support-roadmap.html"><font face = "微软雅黑" color = 1E90FF size = 5>更多版本</font></a></p><ul><li>Java SE：Java Platform Standard Edition，标准版，各应用平台的基础，支持桌面级开发，提供了Java的核心API，也叫J2SE</li><li>Java EE：Java Platform Enterprise Edition，企业版，是企业环境下开发应用程序，支持Servlet、JSP等，也叫J2EE</li><li>Java ME：Java Platform Micro Edition，微型版，致力于移动设备（手机、PDA）和嵌入式设备开发，精简了Java API，加入了对移动端的支持，也叫J2ME</li></ul><h2 id="2-1-构成"><a href="#2-1-构成" class="headerlink" title="2.1 构成"></a>2.1 构成</h2><ol><li>Java程序设计语言</li><li>各平台Java虚拟机（JVM）</li><li>JavaAPI核心类库</li><li>辅助工具，javac（编译软件）、java、javadoc、javap</li></ol><ul><li>1+2+3+4=JDK：Java Development Kit，Java开发工具包，编程的最小环境</li><li>2+3=JRE：Java Runtime Environment，Java运行环境运，行的最小环境</li></ul><h2 id="2-2-特性"><a href="#2-2-特性" class="headerlink" title="2.2 特性"></a>2.2 特性</h2><ul><li>面向对象(oop)</li><li><strong>封装</strong></li><li><strong>继承</strong></li><li><strong>多态</strong></li><li>跨平台：通过JVM实现跨平台，Windows、Linux、Mac都有各自的JVM运行字节码文件（.class），一次编译全平台运行<br><img src="https://qizhongyi.gitee.io/images/Java/Java_KuaPingTai%E5%8E%9F%E7%90%86.png" alt="Java_KuaPingTai原理"></li><li>健壮性，由强制类型检查、自动回收垃圾、异常处理保证</li><li>自动回收垃圾（GC:Garbage Collection）<ul><li>通过引用计数法和根搜索算法（引用链：Reference Chain）判断是否为垃圾</li><li>通过“标记-清除”（Mark-Sweep）、“标记-整理”（Mark-Compact）和“复制算法”（Copying）<del>“分代收集”（Generational Collection）</del> 进行垃圾收集</li><li>通过GC收集器进行回收</li></ul></li><li>强制类型检查</li><li>解释型语言</li><li>取消指针</li></ul><h1 id="3-安装JDK"><a href="#3-安装JDK" class="headerlink" title="3. 安装JDK"></a>3. 安装JDK</h1><ol><li>卸载JDK，如果首次安装，则跳过</li><li><a href="https://www.oracle.com/java/technologies/javase-downloads.html"><font face = "微软雅黑" color = 1E90FF size = 5>官网下载</font></a></li><li>傻瓜安装，选择安装路径，持续下一步</li><li>配置环境变量：</li></ol><pre class="line-numbers language-none"><code class="language-none">Windows：依次打开我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量，新建JAVA_HOME：变量名为JAVA_HOME；变量值为Java的安装目录编辑PATH：加入%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin编辑CLASSPATH：加入%JAVA_HOME%\bin\dt.jar;%JAVA_HOME%\bin\tools.jarLinux：JAVA_HOME：Java的安装目录PATH：.&#x2F;JAVA_HOME&#x2F;lib;$JAVA_HOME&#x2F;jre&#x2F;lib:$PATHLinux需要注销用户，环境变量才能生效：在3运行级别下使用logout指令，在5运行级别下点击退出-注销-重新登陆<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li>测试：</li></ol><pre class="line-numbers language-none"><code class="language-none">java -versionjavac：编译java：执行注：javac将.java文件编译形成.class文件，java将.class文件里面的主类加载到JVM里面运行，当.java文件修改后，需要重新编译，在运行新生成的.class文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-注意事项"><a href="#4-注意事项" class="headerlink" title="4. 注意事项"></a>4. 注意事项</h1><h2 id="4-1-命名规范"><a href="#4-1-命名规范" class="headerlink" title="4.1 命名规范"></a>4.1 命名规范</h2><p>标识符：对各种变量、方法和类等命令是使用的字符序列，即自定义的名称<br>以字母、数字、下划线_和$(美元符号)组成，不能以数字开头，不能使用关键字和保留字，但可以包含，区分大小写，长度不限制，标识符不能包含空格</p><ul><li><strong>包名</strong>：多单词组成时所有字母都小写：xxx.yyy.zzz</li><li><strong>类名、接口名</strong>：多单词组成时，所有单词的首字母大写：XxxYyyZzz（大驼峰规则）</li><li><strong>变量名、方法名</strong>：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz（小驼峰规则，简称驼峰规则）</li><li><strong>常量名</strong>：所有字母都大写，多单词时每个单词用下划线连接：XXX_YYY_ZZZ</li></ul><h2 id="4-2-注释"><a href="#4-2-注释" class="headerlink" title="4.2 注释"></a>4.2 注释</h2><ul><li>单行注释：以’//‘开始，后面的内容为注释内容</li><li>多行注释：形如/* 内容 */，不允许多行注释嵌套多行注释</li><li>文档注释：生成一套以网页文件形式体现的该程序的说明文档，一般写在类里面，通常用于对方法和类进行注释</li></ul><pre class="line-numbers language-none"><code class="language-none">格式&#x2F;\*\*\* @javadoc标签\* @version...\*&#x2F;输出：javadoc -d 保存路径 -javadoc标签 源文件名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="5-编写规范"><a href="#5-编写规范" class="headerlink" title="5. 编写规范"></a>5. 编写规范</h1><ul><li>行宽不要超过80个字符</li><li>代码编写使用行尾风格(推荐)和次行风格</li></ul><h2 id="5-1-其他"><a href="#5-1-其他" class="headerlink" title="5.1 其他"></a>5.1 其他</h2><ul><li>Java源文件以.java为后缀，基本组成部分是类(class)，一个源文件里面只能有一个public主类，可以有多个其他类型的类；源文件的文件名必须与public修饰的主类的类名一致</li><li>Java源文件可以在非主类里面使用main()主方法psvm，同样使用类名进行调用</li><li>Java源文件编译后，每一个类都会生成一个对应的.class文件</li><li>Java应用程序的执行入口是main()方法，有固定的书写格式：</li></ul><pre class="line-numbers language-none"><code class="language-none">public static void main(String[] args)&#123;程序段&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>Java语言严格区分大小写，每条语句以分号’；’结束，包裹程序段的大括号成对出现</li></ul><h1 id="6-知识查阅"><a href="#6-知识查阅" class="headerlink" title="6. 知识查阅"></a>6. 知识查阅</h1><p><a href="https://www.matools.com/api/java8"><font face = "微软雅黑" color = 1E90FF size = 5>JDK8 API接口中文文档</font></a></p><h2 id="6-1-书籍"><a href="#6-1-书籍" class="headerlink" title="6.1 书籍"></a>6.1 书籍</h2><blockquote><p>Java编程思想<br>Java并发编程实战<br>深入理解Java虚拟机<br>函数式编程思维<br>TCP/IP详解<br>Spring MVC + MyBatis开发从入门到项目实战<br>Spring技术内幕（Ioc / AOP）</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive查询-优化</title>
      <link href="/202105/3014766.html"/>
      <url>/202105/3014766.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Hive-查询优化策略 的相关基础内容</p><span id="more"></span><h1 id="1-查询效率"><a href="#1-查询效率" class="headerlink" title="1. 查询效率"></a>1. 查询效率</h1><h2 id="1-1-影响因素"><a href="#1-1-影响因素" class="headerlink" title="1.1 影响因素"></a>1.1 影响因素</h2><p>MapReduce 任务的个数</p><h1 id="2-优化策略"><a href="#2-优化策略" class="headerlink" title="2. 优化策略"></a>2. 优化策略</h1><h2 id="2-1-裁剪"><a href="#2-1-裁剪" class="headerlink" title="2.1 裁剪"></a>2.1 裁剪</h2><ul><li>列裁剪：在查询时只读取需要的数据列</li><li>分区剪裁：只查询需要用到的分区/时间段内的数据</li></ul><h2 id="2-2-Sort-by-代替-Order-by"><a href="#2-2-Sort-by-代替-Order-by" class="headerlink" title="2.2 Sort by 代替 Order by"></a>2.2 Sort by 代替 Order by</h2><p>在Hive SQL 中 order by 用于将结果按照某一个字段进行全局排序，会导致 map 端的数据进入到一个 reduce 里面，在数据量大的时候计算时间较长；使用 sort by 会启动多个 reducer 进行计算，保证每个 reducer 内部有序，可结合使用 distribute by 控制 map 端分配到 reduce 的 key 值</p><pre class="line-numbers language-none"><code class="language-none">-- 未优化写法select a,b,cfrom table where xxxorder by alimit 10;-- 优化写法select a,b,cfrom tablewhere xxxdistribute by asort by alimit 10;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-Group-by"><a href="#2-3-Group-by" class="headerlink" title="2.3 Group by"></a>2.3 Group by</h2><p>默认 Map 阶段同一 key 值得数据发送给一个 reduce 进行处理，当一个 key 值的数据量过大时，所有的数据都在 reduce 阶段完成会造成数据倾斜，可以在 Map 端进行局部聚合，reduce 端进行整体汇总</p><pre class="line-numbers language-none"><code class="language-none">set hive.map.aggr&#x3D;true;  &#x2F;&#x2F; 设置在 map 端进行 group by，默认为trueset hive.groupby.mapaggr.checkinterval&#x3D;n;  &#x2F;&#x2F; 设置在 map 端进行聚合操作的条目数目set hive.groupby.skewindata&#x3D;true;  &#x2F;&#x2F; 设置有数据倾斜时，进行负载均衡，默认为false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>尽量用 group by 代替 distinct</p><pre class="line-numbers language-none"><code class="language-none">-- 原有写法SELECT distinct user_nameFROM user_tradeWHERE dt &gt; &#39;0&#39;;-- 优化写法SELECT user_nameFROM user_tradeWHERE dt &gt; &#39;0&#39;GROUP BY user_name;-- 在2019年购买后又退款的用户SELECT a.user_name  FROM (SELECT distinct user_name    FROM user_trade    WHERE year(dt) &#x3D; 2019) aJOIN(SELECT distinct user_name    FROM user_refund    WHERE year(dt) &#x3D; 2019) bon a.user_name &#x3D; b.user_name;-- 优化写法：SELECT a.user_name  FROM (SELECT user_name    FROM user_trade    WHERE year(dt) &#x3D; 2019    GROUP BY user_name) aJOIN (SELECT user_name    FROM user_refund    WHERE year(dt) &#x3D; 2019    GROUP BY user_name) bon a.user_name&#x3D;b.user_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-聚合"><a href="#2-4-聚合" class="headerlink" title="2.4 聚合"></a>2.4 聚合</h2><h3 id="2-4-1-Grouping-sets"><a href="#2-4-1-Grouping-sets" class="headerlink" title="2.4.1 Grouping sets"></a>2.4.1 Grouping sets</h3><p>在 group by 查询中，根据不同的维度组合进行聚合，等价于讲不同维度的 group by 结果进行 union all ，未 group by 的列组合显示为null</p><pre class="line-numbers language-none"><code class="language-none">-- 性别、城市、等级用户分布SELECT sex,city,level,count(user_id)FROM user_infoGROUP BY sex,city,levelGROUPING SETS (sex,city,level);-- 性别、性别&amp;城市的用户分布SELECT sex,       city,       count(user_id)FROM user_infoGROUP BY sex,city,levelGROUPING SETS (sex,(sex,city));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-2-cube"><a href="#2-4-2-cube" class="headerlink" title="2.4.2 cube"></a>2.4.2 cube</h3><p>根据 group by 维度的所有组合进行聚合</p><pre class="line-numbers language-none"><code class="language-none">-- 性别、城市、等级的各种组合的用户分布SELECT sex,       city,       level,       count(distinct user_id)FROM user_infoGROUP BY sex,city,levelGROUPING SETS (sex,city,level,(sex,city),(sex,level),(city,level),(sex,city,level));SELECT sex,       city,       level,       count(distinct user_id)FROM user_infoGROUP BY sex,city,levelwith cube;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-3-rollup"><a href="#2-4-3-rollup" class="headerlink" title="2.4.3 rollup"></a>2.4.3 rollup</h3><p>以最左侧的维度为主，进行层级聚合，是 cube 的子集(年度，季度，月份，天)</p><pre class="line-numbers language-none"><code class="language-none">select year(dt) as year, month(dt) as month,su(pay_ammount)from user_tradewhere dt &gt; &#39;0&#39;group by year(dt),month(dt)with rollup;   -- 按照年、年+月进行分组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-并行执行-union-all"><a href="#2-5-并行执行-union-all" class="headerlink" title="2.5 并行执行-union all"></a>2.5 并行执行-union all</h2><p>Hive 会将一个查询转化为一个或者多个阶段，包括：MapReduce 阶段、抽样阶段、合并阶段、Limit 阶段，或是其他 Hive 需要的阶段。Hive 默认一次只会执行一个阶段，特定的 job 可能包含众多阶段，这些阶段并非完全相互依赖，可通过并行执行提高效率，建议在系统资源空闲时使用</p><pre class="line-numbers language-none"><code class="language-none">set hive.exec.parallel&#x3D;true;  &#x2F;&#x2F; 开启并行执行<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-6-表连接"><a href="#2-6-表连接" class="headerlink" title="2.6 表连接"></a>2.6 表连接</h2><ol><li>小表在前，大表在后（满足业务逻辑的前提下），Hive 默认假定最后一张表为大表，先将其他表缓存，再扫描最后的表</li><li>使用相同的连接键，使用相同的连接主键只会产生一个 job</li><li>尽早过滤数据</li></ol><h2 id="2-7-Fetch抓取"><a href="#2-7-Fetch抓取" class="headerlink" title="2.7 Fetch抓取"></a>2.7 Fetch抓取</h2><pre class="line-numbers language-none"><code class="language-none">set hive.fecth.task.conversion&#x3D;none;   &#x2F;&#x2F; 设置所有的查询语句都会走 MapReduce 任务set hive.fecth.task.conversion&#x3D;more;   &#x2F;&#x2F; 设置所有的查询语句都不会走 MapReduce 任务<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-8-本地模式"><a href="#2-8-本地模式" class="headerlink" title="2.8 本地模式"></a>2.8 本地模式</h2><p>本地模式针对小数据集，任务触发时间可能会比任务执行时间长的情况</p><pre class="line-numbers language-none"><code class="language-none">set hive.exec.mode.local.auto&#x3D;true;  &#x2F;&#x2F; 开启本地模式set hive.exec.mode.local.auto&#x3D;false;  &#x2F;&#x2F; 关闭本地模式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-9-Map-join"><a href="#2-9-Map-join" class="headerlink" title="2.9 Map join"></a>2.9 Map join</h2><p>如果不指定 Map join 或者不符合 Map join 的条件，Hive 解析器会在 Reduce 阶段进行 join 操作，容易出现数据倾斜。可以通过 Map join 将小表加载到内存在 map 端进行 join，避免 reduce 操作</p><pre class="line-numbers language-none"><code class="language-none">set hive.auto.convert.join&#x3D;true;   &#x2F;&#x2F; 设置自动 Map joinset hive.mapjoin.smalltable.filesize&#x3D;n;  &#x2F;&#x2F; 设置小表阈值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-10-动态分区"><a href="#2-10-动态分区" class="headerlink" title="2.10 动态分区"></a>2.10 动态分区</h2><p>Hive 分区表插入数据时，提供了动态分区的功能：基于查询参数的位置推断分区的名称，从而建立分区。是通过第一个表的分区规则来对应第二个表的分区规则，将第一个表的所有分区拷贝到第二个表中，第二表在加载数据时，就不需要指定分区</p><pre class="line-numbers language-none"><code class="language-none">set hive.exec.dynamic.partition&#x3D;true;  &#x2F;&#x2F; 开启动态分区，默认为trueset hive.exec.dynamic.partition.mode&#x3D;nonstrict;  &#x2F;&#x2F; 开启非严格模式(允许所有的分区为动态分区)，默认为 strict 严格模式(必须指定至少一个分区为静态分区)set hive.exec.max.dynamic.partition&#x3D;n;  &#x2F;&#x2F; 设置最大分区个数set hive.exec.dynamic.partition.pernode&#x3D;n;  &#x2F;&#x2F; 设置每个执行 MR 节点上的最大分区个数set hive.exec.max.created.file&#x3D;n;  &#x2F;&#x2F; 整个 MR 任务中，最大创建 HDFS 文件的个数set hive.error.on.empty.partition&#x3D;false;  &#x2F;&#x2F; 设置产生空分区时，不抛出异常，一般设置为不抛出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-11-严格模式"><a href="#2-11-严格模式" class="headerlink" title="2.11 严格模式"></a>2.11 严格模式</h2><p>Hive 提供严格模式，防止用执行效率低下的查询</p><pre class="line-numbers language-none"><code class="language-none">set hive.mapred.mode&#x3D;strict&#x2F;nostrict<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>对于分区表：在where语句中必须含有分区字段作为过滤条件<br>对于 order by：必须使用 limit 语句进行分页<br>限制笛卡尔积查询</p></blockquote><h2 id="2-12-JVM重用"><a href="#2-12-JVM重用" class="headerlink" title="2.12 JVM重用"></a>2.12 JVM重用</h2><p>Hadoop 默认通过派生 JVM 执行 map 任务和 reduce 任务，JVM 的启用过程会造成较大的开销，可以设置 JVM 重用在用一个job中多次使用一个JVM实例</p><pre class="line-numbers language-none"><code class="language-none">set mapred.job.reuse.jvm.num.tasks&#x3D;n;  &#x2F;&#x2F; 开启 JVM 重用，n建议在10~20之间，需要结合具体业务场景需求<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="2-13-推测执行"><a href="#2-13-推测执行" class="headerlink" title="2.13 推测执行"></a>2.13 推测执行</h2><p>Hadoop 采用推测执行(Speculative Execution) 机制，根据一定的法则推测出执行效率较慢的任务，为该任务启动一个备份任务，与原始任务同时处理同一份数据，选用最先完成任务的结果作为最终结果</p><pre class="line-numbers language-none"><code class="language-none">set mapred.map.tasks.speculative.execution&#x3D;true;set mapred.reduce.tasks.speculative.execution&#x3D;true;set hive.mapred.reduce.tasks.speculative.execution&#x3D;true;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="2-14-其他"><a href="#2-14-其他" class="headerlink" title="2.14 其他"></a>2.14 其他</h2><p>避免使用笛卡尔积，Hive 只能用一个 reduce 完成笛卡尔积</p>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HBase基础-创建</title>
      <link href="/202105/2953988.html"/>
      <url>/202105/2953988.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 HBase基础-创建 的相关基础知识</p><span id="more"></span><p><strong>表名设计</strong>：汇总层标识＋数据域＋主维度＋时间维度，如： dws_trd_slr_dtr：表示汇总层交易数据，根据卖家（slr）主维度 +0点截至当日（dtr）进行统计汇总；所有主维度相同的数据都放在一张物理表中，避免表数量过多，难以维护；可以从表名上直观地看到存储的数据内容，方便排查问题<br><strong>rowkey设计</strong>：MD5 ＋主维度＋维度标识＋子维度1 ＋时间维度＋子维度2，如：卖家ID 的MD5 前四位＋卖家ID+ app + 一 级类目ID+ ddd ＋二级类目ID：D5 前四位作为 rowkey 的第一部分，可以把数据散列，服务器整体负载均衡，避免热点问题</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HBase </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive基础-函数</title>
      <link href="/202105/2860837.html"/>
      <url>/202105/2860837.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Hive-函数 的相关基础知识</p><span id="more"></span><h1 id="1-内置函数"><a href="#1-内置函数" class="headerlink" title="1. 内置函数"></a>1. 内置函数</h1><p>查看内置函数：show functions;<br>查看内置函数的用法：desc function [extended] fun_name;使用 extended 会更加详细，带有示例</p><h2 id="1-1-字符串函数"><a href="#1-1-字符串函数" class="headerlink" title="1.1 字符串函数"></a>1.1 字符串函数</h2><p><strong>concat</strong>：拼接字符串</p><pre class="line-numbers language-none"><code class="language-none">select concat(&#39;str1&#39;,&#39;str2&#39;[,str3]);直接拼接str1、str2[、str3]select concat_ws(&#39;&#39;,&#39;str1&#39;,&#39;str2&#39;[,str3]);将str1、str2[、str3]以  为分隔符进行拼接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="1-2-数据类型函数"><a href="#1-2-数据类型函数" class="headerlink" title="1.2 数据类型函数"></a>1.2 数据类型函数</h2><p><strong>cast</strong>：类型转换</p><pre class="line-numbers language-none"><code class="language-none">select cast(value as type);将 value 转化为 type 类型数据<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>get_json_object</strong>：解析 json 型数据</p><pre class="line-numbers language-none"><code class="language-none">select get_json_object(&#39;&#123;json 数据&#125;&#39;,&#39;$.json_key&#39;);例: select get_json_object(&#39;&#123;&#39;name&#39;:&#39;Tom&#39;,&#39;age&#39;:&#39;18&#39;&#125;&#39;,&#39;$.name&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="1-3-窗口函数"><a href="#1-3-窗口函数" class="headerlink" title="1.3 窗口函数"></a>1.3 窗口函数</h2><p>function_name([ col_name_list ])  over ( [partition by (col_name_list)]  [ordr by (col_name_list)] [rows between … and …])</p><blockquote><p>function_name : 计算类型<br>partition by : 分组字段<br>order by : 排序字段<br>rows between … and … : 计算的行数</p><blockquote><p>rows between unbounded preceding and current row：包括本行和之前所有的行<br>rows between current row and current unbounded follow：包括本行和之后所有的行<br>rows between 3 preceding and current row：包括本行和前3行<br>rows between 3 preceding and 1 following：包括本行前3行和本行之后1行（共5行）</p></blockquote></blockquote><h3 id="1-3-1-累计窗口函数"><a href="#1-3-1-累计窗口函数" class="headerlink" title="1.3.1 累计窗口函数"></a>1.3.1 累计窗口函数</h3><ul><li>sum(…) over( [partition by ()]  [ordr by ()] [rows between … and …] )</li><li>avg(…) over( [partition by ()]  [ordr by ()] [rows between … and …] )</li><li>max(…) over( [partition by ()]  [ordr by ()] [rows between … and …] )</li><li>min(…) over( [partition by ()]  [ordr by ()] [rows between … and …] )</li></ul><h3 id="1-3-2-分组排序窗口函数"><a href="#1-3-2-分组排序窗口函数" class="headerlink" title="1.3.2 分组排序窗口函数"></a>1.3.2 分组排序窗口函数</h3><ul><li>row_number() over( [partition by ()]  [ordr by ()]) ：1、2、3</li><li>rank() over( [partition by ()]  [ordr by ()])：1、1、3</li><li>dense_rank() over( [partition by ()]  [ordr by ()])：1、1、2</li><li>ntile(n) over( [partition by ()]  [ordr by ()]) : n 切片的个数</li></ul><h3 id="1-3-3-偏移分析窗口函数"><a href="#1-3-3-偏移分析窗口函数" class="headerlink" title="1.3.3 偏移分析窗口函数"></a>1.3.3 偏移分析窗口函数</h3><ul><li>lag(col_name_list, offset, defval) over( [partition by ()]  [ordr by ()]) : 之前 offset 行的数据</li><li>lead(col_name_list, offset, defval) over( [partition by ()]  [ordr by ()]) : 之后 offset 行的数据</li></ul><blockquote><p>offset : 偏移量</p><p>defval : 默认值，没有值时的默认值</p></blockquote><h2 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h2><p><strong>parse_url</strong>：解析 url 地址</p><pre class="line-numbers language-none"><code class="language-none">select parse_url(&#39;url 地址&#39;,&#39;参数&#39;);例select parse_url(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;HOST&#39;);select parse_url(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;PATH&#39;);select parse_url(&#39;https:&#x2F;&#x2F;www.baidu.com&#x2F;&#39;,&#39;QUERY&#39;[,key_name]);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>explode</strong>：将 map 集合中的每一个键值对或数组中的每一个元素都单独生成一行</p><h1 id="2-自定义函数"><a href="#2-自定义函数" class="headerlink" title="2. 自定义函数"></a>2. 自定义函数</h1><p>**UDF(user defined function)**：一进一出<br>继承 org.apache.hadoop.ql.execc.UDF 类，实现 evalute 函数，支持重载，必须拥有返回类型(返回值可以为 null ，返回类型不能为 viod )，推荐使用 Hive 数据类型</p><p>**UDAF(user defined aggregation function)**：多进一出<br>**UDTF(user defined generating function)**：一进多出</p>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive基础-库表数操作</title>
      <link href="/202105/2735020.html"/>
      <url>/202105/2735020.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Hive的基础知识-库表数操作</p><span id="more"></span><h1 id="1-HQL指令"><a href="#1-HQL指令" class="headerlink" title="1. HQL指令"></a>1. HQL指令</h1><h2 id="1-1-数据库"><a href="#1-1-数据库" class="headerlink" title="1.1 数据库"></a>1.1 数据库</h2><pre class="line-numbers language-none"><code class="language-none">create database [if exists] db_name(col_name1 type[,col_name2 type,col_name3 type...])[location catalogue][with dbproperties (&#39;owner&#39;&#x3D;&#39;owner_name&#39;,&#39;date&#39;&#x3D;&#39;创建时间‘&#39;)]; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>location：指明数据库在HDFS的存放位置，可通过hive-site.xml文件进行配置<br>with dbproperties()：使用键值对指明数据库的相关描述信息<br>describe database extended db_name：查看指定数据库的描述性信息<br>alter database db_name set dbproperties(‘key’=’value’)：修改键值对信息<br>desc database extended db_name：查看更多详情<br>drop database database [cascade]：删除数据库，若数据库里面有表，需要加入cascade参数<br>使用数据库：use db_name;</p></blockquote><h2 id="1-2-数据表"><a href="#1-2-数据表" class="headerlink" title="1.2 数据表"></a>1.2 数据表</h2><pre class="line-numbers language-none"><code class="language-none">create [external] table [if not exists] tb_name(col_name1 type [comment &#39;xxx&#39;][,col_name2 type,col_name3 type...])[comment &#39;xxx&#39;][partitioned by (col_name type [comment &#39;xxx&#39;])][clustered by (col_name type [comment &#39;xxx&#39;])][sorted by (col_name [asc|desc] ) into N buckets buckets][row format delimited fields terminated by &#39; &#39;][storted as ...][location &#39;catalogue&#39;];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>if not exists：在不存在的情况下创建表<br>external：指明创建外部表：外部表仅存储指向实际数据的路径，删除时仅删除元数据；内部表会移动数据到数据仓库指定的路径进行存储，删除时会删除元数据和数据文件<br>comment：表或字段的描述性信息，默认不能使用中文<br>partitioned by()：分区表的分区字段，每一个分区单独存在一个目录下<br>clustered by()：对于每一个表文件，Hive可以进一步组织成桶，进行更细粒度的范围划分<br>sorted by() into N buckets buckets：指明排序字段和排序方式<br>row format ：指明表数据文件的分隔符<br>storted as：指明数据表文件的数据存储类型</p><blockquote><p>SEQUENCEFILE：数据需要压缩，二进制文件<br>TEXTFILE：纯文本，默认<br>RCFILE<br>location：指明数据表存放位置</p></blockquote></blockquote><p><strong>内部表</strong><br>创建</p><pre class="line-numbers language-none"><code class="language-none">create table tb_name (col_name1 type [comment &#39;xxx&#39;][,col_name2 type,col_name3 type...])row format delimited fields terminated by &#39;\t&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>快速建内部表</p><blockquote><p>create table tb_name1 as select * from tb_name2：tb_name1 和 tb_name2 的表结构和数据都一致<br>create table tb_name1 like tb_name2：tb_name1 和 tb_name2 的表结构一致，但是tb_name1没有数据</p></blockquote><p>查询表信息：desc [formatted] tb_name; 加入 formatted 参数会更详细<br>删除表：drop table tb_name;</p><p><strong>外部表</strong><br>创建</p><pre class="line-numbers language-none"><code class="language-none">create external table tb_name (col_name1 type [comment &#39;xxx&#39;][,col_name2 type,col_name3 type...])row format delimited fields terminated by &#39;\t&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>加载数据</p><pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F; HDFS命令要求文件字段个数与对应的数据表结构一致，文件的内容分隔符与对应的数据表设置的分隔符一致hdfs dfs -mkdir [-p] catalogue_name;  &#x2F;&#x2F; 创建目录，-p表示级联创建文件夹hdfs dfs -put file_name catalogue;  &#x2F;&#x2F; 上传数据dfs -du -h catalogue&#x2F;file_name;  &#x2F;&#x2F; 查看表数据大小&#x2F;&#x2F; 本地加载load data [local] inpath &#39;catalogue&#39;[overwrite] into table tb_name;local：指明从本地加载数据(复制操作)，省略表示从HDFS上加载(剪切操作)inpath：本地文件的存放位置overwrite：覆盖加载数据&#x2F;&#x2F; 建立数据文件与表的映射关系msck repair table tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>每天将收集到的网站日志文件定期流入HDFS文本文件，在外部表（公共拥有的原始日志文件）的基础上进行大量的统计分析，各个部门用到的中间表、结果表使用内部表存储，数据通过SELECT 和 INSERT 进入内部表</p><p><strong>分区表</strong><br>将一个大的数据文件按照月、天进行分区，即进行切分成小文件，存放在不同的文件夹中，分区就相当于是把表中的数据按照不同的条件分成了不同的文件夹<br>创建</p><pre class="line-numbers language-none"><code class="language-none">create [external] table tb_name (col_name1 type [comment &#39;xxx&#39;][,col_name2 type,col_name3 type...])partitioned by(col_name1 type[,col_name2 type,col_name3 type...])row format delimited fields terminated by &#39;\t&#39;&#x2F;&#x2F; 可以创建多个分区字段，即创建多级目录&#x2F;&#x2F; 分区字段并不是实际数据，仅表示分区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>加载数据</p><pre class="line-numbers language-none"><code class="language-none">load data [local] inpath &#39;catalogue&#39;[overwrite] into table tb_name partition(col_name1&#x3D;&#39;value&#39;[,col_name2&#x3D;&#39;value&#39;,col_name3&#x3D;&#39;value&#39;]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询数据</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_name where col_name&#x3D;&#39;value1&#39; [union all select * from tb_name where col_name&#x3D;&#39;value2&#39;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查询分区：show partitions tb_name;<br>添加分区：alter table tb_name add partition(col_name=’value1’);<br>删除分区：alter table tb_name drop partition(col_name=’value1’);<br>查询分区：select col_name_list from tb_name where col_name_p = ‘value1’;</p><p><strong>分桶表</strong>：将数据文件按照指定的字段划分到多个文件当中，分桶就是MapReduce中的分区</p><ol><li>开启分桶配置</li></ol><pre class="line-numbers language-none"><code class="language-none">set hive.enforce.bucketing&#x3D;true;  &#x2F;&#x2F; 开启Hive的分桶功能，默认为falseset mapreduce.job.reduces&#x3D;3;  &#x2F;&#x2F; 设置Reduce的个数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="2"><li>创建分桶表</li></ol><pre class="line-numbers language-none"><code class="language-none">create [external] table tb_name_clu(col_name1 type [comment &#39;xxx&#39;][,col_name2 type,col_name3 type...])clustered by(col_name_clu) into N bucketsrow format delimited fields deminated by &#39;\t&#39;;col_name是表的实际字段N对应Reduce的个数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><p>加载数据<br>先创建同结构的普通表，向普通表加入数据，通过over write向分桶表加入数据</p><ul><li>创建同结构的普通表</li></ul><pre class="line-numbers language-none"><code class="language-none">create [external] table tb_name_com(col_name1 type [comment &#39;xxx&#39;][,col_name2 type,col_name3 type...])row format delimited fields deminated by &#39;\t&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>向普通表加入数据</li></ul><pre class="line-numbers language-none"><code class="language-none">load [local] data inpath &#39;catalogue&#39; into table tb_name_com;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>通过over write向分桶表加入数据</li></ul> <pre class="line-numbers language-none"><code class="language-none">insert overwrite table tb_name_clu select * from tb_name_com cluster by(col_name_clu)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><pre class="line-numbers language-none"><code class="language-none">查看表信息：desc tb_name;重命名：alter table tb_name_old rename to tb_name_new;增加列：alter table tb_name add columns (col_name type[,col_name type]);修改列名：alter table tb_name change col_name_old col_name_new data_type [Comment &#39;&#39;];删除表：drop table tb_name;快速建表：create tbale tb_name_new like tb_name_old;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-数据"><a href="#1-3-数据" class="headerlink" title="1.3 数据"></a>1.3 数据</h2><h3 id="1-3-1-数据类型"><a href="#1-3-1-数据类型" class="headerlink" title="1.3.1 数据类型"></a>1.3.1 数据类型</h3><h4 id="1-3-1-1-基本数据类型"><a href="#1-3-1-1-基本数据类型" class="headerlink" title="1.3.1.1 基本数据类型"></a>1.3.1.1 基本数据类型</h4><table><thead><tr><th><strong>数据类型</strong></th><th><strong>所占字节</strong></th><th><strong>存储大小</strong></th><th><strong>开始支持版本</strong></th></tr></thead><tbody><tr><td>TinyInt</td><td>1</td><td>-128~127</td><td>SQL</td></tr><tr><td>SmallInt</td><td>2</td><td>-32768~32767</td><td>块设备或本地文件系统</td></tr><tr><td>Int</td><td></td><td></td><td></td></tr></tbody></table><h4 id="1-3-1-2-复杂数据类型"><a href="#1-3-1-2-复杂数据类型" class="headerlink" title="1.3.1.2 复杂数据类型"></a>1.3.1.2 复杂数据类型</h4><table><thead><tr><th><strong>数据类型</strong></th><th><strong>描述</strong></th><th><strong>语法实例</strong></th></tr></thead><tbody><tr><td>Struct</td><td>与C语言的struct相同，通过’.’符号访问元素内容</td><td>Struct()</td></tr><tr><td>Map</td><td>是一组建-值对的元素集合，使用数据表示法可以访问数据</td><td>Map()</td></tr><tr><td>Array</td><td>是一组具有相同类型和名称的变量的集合</td><td>Array()</td></tr></tbody></table><h3 id="1-3-2-数据存储格式"><a href="#1-3-2-数据存储格式" class="headerlink" title="1.3.2 数据存储格式"></a>1.3.2 数据存储格式</h3><p>行式存储：相邻的是一条记录的不同字段，行查询效率高，列查询效率低，数据压缩效率低<br>列式存储：相邻的是不同记录的同一字段，行查询效率低，列查询效率高，数据压缩效率高<br>**TEXTFILE(行式存储)**：默认的存储格式，数据不进行压缩，空间开销大，可结合 Gzip、Bzip2 压缩算法使用<br>**SEQUENCEFILE(行式存储)**：<br>**ORC(列式存储)**：每个 ORC 数据文件由多个 stripe 组成，每个 stripe 250M</p><blockquote><p>indexData：某些列的索引数据<br>rowData：真正的数据内容<br>StripFooter：stripe 的元数据信息<br>加载数据时使用 insert into table 语句<br>stored as orc tblproperties(“orc.compress”=”none”); 指定数据存储方式为 ORC ， ORC 的压缩方式为 NONE(不进行压缩)</p></blockquote><p>**PARQUET(列式存储)**：parquet 文件以二进制方式存储，文件中包含真正数据和元数据，可自解析， parquet 文件内部是由多个行组组成，每一个行组(row group)由 mapreduce 任务进行处理，加载数据时使用 insert into table 语句</p><h3 id="1-3-3-压缩方式"><a href="#1-3-3-压缩方式" class="headerlink" title="1.3.3 压缩方式"></a>1.3.3 压缩方式</h3><p>查看 Hive 支持的数据压缩方式：在 Hive 的安装目录执行 bin/hadoop checknative<br><strong>Map阶段</strong></p><pre class="line-numbers language-none"><code class="language-none">set hive.exec.compress.intermediate&#x3D;true;  &#x2F;&#x2F; 开启 hive 中间传输数据压缩功能set mapreduce.map.output.compress&#x3D;true;  &#x2F;&#x2F; 开启 mapreduce 中 map 输出压缩功能，默认为falseset mapreduce.map.output.compress.codec&#x3D;org.apapche.hadoop.io.compress.SnappyCode;   &#x2F;&#x2F; 设置 mapreduce 中 map 输出压缩方式<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>Reduce阶段</strong></p><pre class="line-numbers language-none"><code class="language-none">set hive.exec.compress.output&#x3D;true;  &#x2F;&#x2F; 开启 hive 最终传输数据压缩功能set mapreduce.output.fileoutputformat.compress&#x3D;true;  &#x2F;&#x2F; 开启 mapreduce 最终传输数据压缩功能set mapreduce.output.fileoutputformat.compress.codec&#x3D;org.apapche.hadoop.io.compress.SnappyCodec;   &#x2F;&#x2F; 设置 mapreduce 最终数据输出压缩方式set mapreduce.output.fileoutputformat.compress.type&#x3D;block;   &#x2F;&#x2F; 设置 mapreduce 最终数据输出压缩为块压缩，默认为 record (记录压缩)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>建议选择 ORC、PARQUET 的数据存储格式、 snappy 的数据压缩方式</p><h3 id="1-3-4-查询"><a href="#1-3-4-查询" class="headerlink" title="1.3.4 查询"></a>1.3.4 查询</h3><h3 id="1-3-5-数据I-O"><a href="#1-3-5-数据I-O" class="headerlink" title="1.3.5 数据I/O"></a>1.3.5 数据I/O</h3><p><strong>导出</strong><br>insert overwrite local dictionary ‘catalogue’ select_expr</p><p>每一次 insert into 命令都会进行一次 MapReduce 任务，生成一个文件，应尽量减少单独插入语句，使</p>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive基础-查询</title>
      <link href="/202105/264720.html"/>
      <url>/202105/264720.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Hive-查询 的相关基础知识</p><span id="more"></span><h1 id="1-查询语法"><a href="#1-查询语法" class="headerlink" title="1. 查询语法"></a>1. 查询语法</h1><pre class="line-numbers language-none"><code class="language-none">select [all | distinct ] col_name[,col_name] from tb_name [where condition][group by col_name_list [having condition]][cluster by col_name_list | distribute by col_name_list][sort by | order by col_name_list][limit n];cluster by：通过hash散列分发算法根据指定的字段将数据分散到不同的 reducer 中，并进行排序distribute by：通过hash散列分发算法根据指定的字段将数据分散到不同的 reducer 中order by：对数据进行全局排序，只有一个 reducer ，当数据规模较大时，耗时较长sort by：不是全局排序，在数据进行 reducer 之前完成排序。使用 sort by 并设置 mapred.reduce.tasks&gt;1，仅能保证每个 reducer 的输出有序，不能保证全局有序如果 distribute by 和 sort by 是同一个字段时，cluster by &#x3D; distribute by + sort by<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-1-查询顺序"><a href="#1-1-查询顺序" class="headerlink" title="1.1 查询顺序"></a>1.1 查询顺序</h2><p>from -&gt; where -&gt; group by -&gt; having -&gt; select -&gt; order by -&gt; limit</p><h2 id="1-2-查询解释"><a href="#1-2-查询解释" class="headerlink" title="1.2 查询解释"></a>1.2 查询解释</h2><p><strong>where</strong></p><blockquote><p>A &lt;=&gt; B：若A、B都为Null，则返回True；任意一方结果部位Null，结果为Null，其他情况与’= ‘操作符结果一致<br>A rlike B：模糊查询，B为正则表达式，若A与B匹配，则返回True，%匹配任意多个字符，_匹配任意一个字符</p></blockquote><p><strong>sort by</strong>：局部排序，仅在Reduce内部进行局部排序</p><pre class="line-numbers language-none"><code class="language-none">set mapreduce.job.reduces&#x3D;3;  &#x2F;&#x2F; 设置 Reduce 的个数set mapreduce.job.reduces;    &#x2F;&#x2F; 查看 Reduce 的个数select * from tb_name sort by col_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>distribute by</strong>：类似于MR的 partition，进行分区，可结合sort by 使用，需要写在sort by 之前</p><pre class="line-numbers language-none"><code class="language-none">set mapreduce.job.reduces&#x3D;3;  &#x2F;&#x2F; 设置 Reduce 的个数;select * from tb_name distribute by col_name1 sort by col_name2;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>cluster by</strong>： distribute by 和 sort by 是同一个字段时，可用 cluster by 替换，只能使用默认的排序规则倒序，不能指定排序规则</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_name distribute by col_name1 sort by col_name1;select * from tb_name cluster by col_name1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>join</strong>：表连接时必须进行重命名</p><ul><li> inner join</li></ul><blockquote><p>on 后面使用的连接条件必须起到唯一键值的作用<br>inner 可以省略</p></blockquote><p><strong>union</strong>：</p><blockquote><p>字段名称必须一致<br>字段顺序必须一致<br>没有条件</p></blockquote><h1 id="2-操作"><a href="#2-操作" class="headerlink" title="2. 操作"></a>2. 操作</h1><h2 id="2-1-权限"><a href="#2-1-权限" class="headerlink" title="2.1 权限"></a>2.1 权限</h2><pre class="line-numbers language-none"><code class="language-none">set role admin;show grant on tb_name;grant select on tb_name to user user_name;revoke select on tb_name from user user_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-常见问题"><a href="#3-常见问题" class="headerlink" title="3. 常见问题"></a>3. 常见问题</h1><ol><li>没有对子查询的表进行重命名，按照思路顺序重命名</li><li>Hive 里面在 in 后面不能跟子查询</li></ol>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive-安装使用</title>
      <link href="/202105/246777.html"/>
      <url>/202105/246777.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Hive安装及使用 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><strong>Hive</strong> ：是基于 Hadoop 的数据仓库工具，将结构化的数据文件映射为一张数据库表，并提供类SQL（HQL，底层使用 MapReduce 实现）的功能，进行数据操作；本质是将 SQL 转化为 MapReduce 任务进行运算，底层由HDFS提供数据存储，可以认为 Hive 是一个将 SQL 转化为 MapReduce 任务的工具，通过Hive元数据(默认存储在derby 中，可以用其他的结构化数据进行存储)记录表与文件的对应关系、表字段与文件字段的对应关系</p><h2 id="1-1-分层架构"><a href="#1-1-分层架构" class="headerlink" title="1.1 分层架构"></a>1.1 分层架构</h2><p><img src="https://qizhongyi.gitee.io/images/Data/BigData/Hive/HQL_Run_Step.png" alt="HQL_Run_Step"><br><strong>用户接口</strong>：包括 CLI、JDBC/ODBC 和 WebGUI。CLI 是（Command Line Interface）是 shell 命令行，JDBC/ODBC 是 Hive 的 Java 实现，与传统数据库的 JDBC 相似，WebGUI 是通过浏览器进行访问 Hive<br><strong>元数据存储</strong>：通常 Hive 将元数据存储在关系型数据库 MySQL/Derby（默认）中，包括表名称、表字段和分区及其属性，表的属性（是否为外部表)和表所在目录等<br><strong>解析器</strong>：完成 HQL 语句的词法分析、语法分析、编译、优化和生成查询计划，查询计划存储到 HDFS 中，通过 MApReduce 调用执行</p><h2 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h2><ul><li><p>采用类 SQL 的语法操作数据，开发效率快</p></li><li><p>避免写 MapReduce 任务，降低开发人员的学习成本</p></li><li><p>较强的扩展功能</p></li></ul><h2 id="1-3-对比"><a href="#1-3-对比" class="headerlink" title="1.3 对比"></a>1.3 对比</h2><p>Hive与传统数据库都是用来做数据存储和数据分析，区别如下：</p><table><thead><tr><th></th><th>Hive</th><th>RDBMS</th></tr></thead><tbody><tr><td>查询语言</td><td>HQL</td><td>SQL</td></tr><tr><td>数据存储位置</td><td>HDFS</td><td>块设备或本地文件系统</td></tr><tr><td>数据更新</td><td>不建议</td><td>经常修改</td></tr><tr><td>索引</td><td>0.8以后加入位图索引</td><td>复杂的索引</td></tr><tr><td>数据规模</td><td>非常大</td><td>较小</td></tr><tr><td>执行引擎</td><td>MapReduce</td><td>自己的执行引擎</td></tr><tr><td>执行延迟</td><td>较高</td><td>低</td></tr><tr><td>可扩展性</td><td>很好</td><td>扩展性非常有限</td></tr></tbody></table><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><p>安装前一般安装关系型数据库存储 Hive 元数据</p><ol><li><a href="http://archive.apache.org/dist/hive"><font face = "微软雅黑" color = 1E90FF size = 5> 下载地址 </font></a>：选择合适的版本进行下载</li><li>上传安装包(rz -E)，解压：tar -zxvf 安装包名</li><li>修改配置文件：安装目录下的 conf 目录下的 hive-env.sh，默认仅有 hive-env.sh.template 模板文件，一般复制 hive-env.sh.template 文件改名为 hive-env.sh 修改 HADOOP_HOME=hadoop 的安装目录，HIVE_CONF_DIR=hive 的配置文件目录（即 hive-env.sh 文件所在的目录）</li><li>修改 hive-site.xml 文件</li><li>在安装目录下的lib目录放置所安装关系型数据库得驱动包</li><li>配置环境变量：vim /etc/profile，增加 HIVE_HOME=hive 的安装目录，PATH 加上 HIVE_HOME/bin：PATH=:$HIVE_HOME/bin:$PATH</li></ol><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><p>在 hive 得安装目录下执行：bin/hive，进入Hive终端（推荐）；也可以使用 bin/hive -e “HQL语句”，在命令行执行；也可以使用脚本进行</p><pre class="line-numbers language-none"><code class="language-none">bin.&#x2F;hive [-hiveconf x&#x3D;y] * [&lt;-i file_name&gt;] * [&lt;-f file_name&gt; | &lt;-e query-string&gt;] [-S]-hiveconf：设置 Hive 运行时的配置参数-i：从指定文件初始化 HQL-e：在命令行执行执行的 HQL-f：执行 HQL 脚本-v：输出执行的 HQL 语句到控制台-p：指定 Hive 服务器的端口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-1-参数配置"><a href="#3-1-参数配置" class="headerlink" title="3.1 参数配置"></a>3.1 参数配置</h2><p><strong>配置文件</strong><br>用户自定义配置文件：$HIVE_CONF_DIR/hive-site.xml<br>默认配置文件：$HIVE_CONF_DIR/hive-default.xml<br>配置了用户自定义的配置文件，就会覆盖默认的配置文件，Hive 也会读入 Hadoop 的配置， Hive 的配置也会覆盖 Hadoop 的配置<br><strong>命令行参数</strong>：在启动 Hive 时，可以在命令行添加 -hiveconf param=value 的方式来设定参数</p><pre class="line-numbers language-none"><code class="language-none">例： bin&#x2F;hive -hiveconf hive.root.logger&#x3D;INFO.console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>参数申明</strong>：在 HQL 中使用 SET 关键字进行设置，作用域是 Session 级(一次会话)</p><pre class="line-numbers language-none"><code class="language-none">例： set mapred.reduce.tasks&#x3D;100;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>优先级：参数申明 -&gt; 命令行参数 -&gt; 配置文件参数</p><h2 id="3-2-常用参数配置"><a href="#3-2-常用参数配置" class="headerlink" title="3.2 常用参数配置"></a>3.2 常用参数配置</h2><pre class="line-numbers language-none"><code class="language-none">#在命令行中显示当前数据库名set hive.cli.print.current.db&#x3D;true;# 查询出来的结果前显示字段名字set hive.cli.print.header&#x3D;true;set hive.resultset.use.unique.column.names&#x3D;false;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-知识查阅"><a href="#3-3-知识查阅" class="headerlink" title="3.3 知识查阅"></a>3.3 知识查阅</h2><p><a href="https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF"><font face = "微软雅黑" color = 1E90FF size = 5> 官方文档 </font></a></p>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据-基础</title>
      <link href="/202105/2361602.html"/>
      <url>/202105/2361602.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录大数据的相关概念和基础知识</p><span id="more"></span><h1 id="1-名词介绍"><a href="#1-名词介绍" class="headerlink" title="1. 名词介绍"></a>1. 名词介绍</h1><ul><li><strong>数据科学</strong>：将数据挖掘、统计分析和机器学习与数据集成整合，结合数据建模能力，构建数据模型、探索数据内容模式</li></ul><blockquote><p>条件</p><blockquote><p>丰富的数据源：具有能够展示隐藏在组织或客户行为中不可见模式<br>信息组织和分析：领会数据内容，结合数据集针对有意义模式进行假设和测试的技术<br>信息交付：针对数据运行模型和数学算法，进行可视化展示及其它方式输出，加强对行为的深入洞察</p></blockquote><p>过程</p><blockquote><p>定义大数据战略和业务需求：定义可衡量的、能够产生实际收益的需求<br>选择数据源：在当前数据资产库中识别短板并找到数据源以弥补短板<br>采集和提取数据资料：收集数据并加载使用它们<br>设定数据假设和方法：通过对数据进行剖析、可视化和挖掘来探索数据源，如定义模型算法的输入、种类或者模型假设和分析方法<br>集成和调整数据进行分析：模型的可行性取决于源数据的质量<br>使用数据模型探索数据：对集成的数据应用统计分析和机器学习算法进行验证、训练，并随着时间的推移演化模型<br>部署和监控：将产生有用信息的模型部署到生产环境中，持续监控它们的价值和有效性</p></blockquote></blockquote><ul><li><strong>大数据</strong>：5V特性</li></ul><blockquote><p>Volume ：数据量大，包括采集、存储和计算的量都非常大<br>Velocity： 数据增长速度快、处理速度快，时效性要求高<br>Variety： 数据种类（视频、音频、文本等）、来源多样化<br>Value ： 数据价值密度低<br>Veracity：数据真实性，数据质量</p></blockquote><ul><li><strong>数据湖</strong>：一种可以提取、存储、评估和分析不同类型和结构海量数据的环境，可供多种场景使用，可以作为 Hadoop 或其他数据存储系统、集群服务、数据转换、数据集成等数据处理工具的一种复合配置来实施</li></ul><blockquote><p>数据科学家可以挖掘和分析数据的环境<br>原始数据的集中存储区域，只需要进行少量的转换操作<br>数据仓库明细历史数据的内用存储区域<br>信息记录的在线归档<br>可通过自动化的模型识别提取流数据的环境</p></blockquote><ul><li><strong>基于服务的架构</strong>：Services-Based Architecture ，SBA，一种立即提供（如果不是完全准确或完整）数据的方法，使用相同的数据原来更新完整、准确的历史数据集</li></ul><blockquote><p>批处理层：数据湖为批处理层提供服务，包括近期和历史数据<br>加速层：只包括实时数据<br>服务层：提供链接批处理和加速层数据的接口</p></blockquote><ul><li><strong>机器学习</strong>：探索学习算法的构建和研究，是监督学习和无监督学习的结合</li></ul><blockquote><p><strong>无监督学习</strong>：数据挖掘，输入并不知道输出的数据，有关联、群集和维度降低三种类型，使用 Apriori、K-means、PCA算法等，无标签，进行聚类</p><blockquote><p>分类<br>聚类<br>回归分析<br>关联规则<br>特征分析<br>偏差分析<br>变化分析<br>Web 页文本挖掘</p><blockquote><p>剖析：尝试描述个人、群体或人群的典型行为，建立异常检测应用程序的行为规范，剖析结果是许多无监督学习组件的输入<br>数据缩减：在包含大数据集大部分重要信息的前提下，将大数据集转换为小数据集<br>关联：基于无监督学习找到交易数据之间的关联<br>聚类：基于数据元素共享特征，将他们合为不同的族<br>自组织映射：是聚类分析的神经网络算法，也被称为拓扑有序网络，旨在减少评估空间的维度</p></blockquote></blockquote><p><strong>监督学习</strong>：基于复杂的数学理论，从给定的训练数据集中学习函数，当出现新数据时，根据函数预测结果，要求包括输入和输出。方式分为回归和分类，算法有线性回归、Lonistic回归、CART、朴素贝叶斯、KNN等，有标签，进行分类，涉及统计学、组合学和运筹学等<br><strong>强化学习</strong>：基于目标实现，让机器不断测试，在环境中获得高分<br>数据集分为训练集、测试集和校验集：训练集用于拟合训练，测试集用于评估最终模型的泛化误差，校验集用于预测选择的误差，利用 K折（K-fold）验证避免过度拟合（将少量噪声数据具有的特性当做大部分数据的共性）</p></blockquote><ul><li><strong>语义分析</strong>：从大量非结构化或半结构化数据中检索并获得简洁的自动化方法，使用自然语言处理（NLP）分析短语或句子、语义察觉情绪，并揭示情绪的变化，以预测可能的情景</li></ul><h1 id="2-Hadoop生态圈"><a href="#2-Hadoop生态圈" class="headerlink" title="2. Hadoop生态圈"></a>2. Hadoop生态圈</h1><ol><li>Hadoop 是 Apacche 基金组织下的分布式系统基础框架，主要针对离线和大规模数据</li><li>核心组件有 HDFS、MapReduce、YARN、Hadoop 基础功能库<br><img src="https://qizhongyi.gitee.io/images/Data/BigData/Hadoop_ecosystem.png" alt="Hadoop_ecosystem"></li></ol><h2 id="2-1-HDFS"><a href="#2-1-HDFS" class="headerlink" title="2.1 HDFS"></a>2.1 HDFS</h2><p>块级别的分布式文件存储系统，HDFS 为了防止数据丢失，会自动对数据块进行备份，默认备份3份，一个数据块 128M</p><h2 id="2-2-MapReduce"><a href="#2-2-MapReduce" class="headerlink" title="2.2 MapReduce"></a>2.2 MapReduce</h2><p>MapReduce 是采用分而治之的思想设计的分布式计算框架，对一个复杂任务切分成若干个子任务（Map阶段），子任务会并行的在服务器上运行，最后汇总所有子任务的结果（Reduce阶段）</p><h2 id="2-3-YARN"><a href="#2-3-YARN" class="headerlink" title="2.3 YARN"></a>2.3 YARN</h2><p>进行资源调度</p><h2 id="3-4-Hive"><a href="#3-4-Hive" class="headerlink" title="3.4 Hive"></a>3.4 Hive</h2><p>基于 Hadoop 的开源数据仓库工具，用于处理海量结构化数据，将HDFS中结构化的数据文件映射成数据表<br>Hive 通过 HiveSQL 进行解析和转换，最终变成 mapreduce 任务，完成数据分析与处理<br>HiveSQL 遵循SQL标准</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据仓库-基础</title>
      <link href="/202105/2221246.html"/>
      <url>/202105/2221246.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据仓库使用 的相关基础知识</p><span id="more"></span><h1 id="1-数据仓库"><a href="#1-数据仓库" class="headerlink" title="1. 数据仓库"></a>1. 数据仓库</h1><p><strong>数据仓库</strong>：Data Warehouse，简写为DW或DWH，是一个面向主题的、集成的、稳定的、随时间变化的数据集合，是面向分析的集成化数据环境，通过形成分析报告和各类报表提供企业决策支持<br><strong>数仓元数据</strong>：监控数据仓库的数据状态，包括源数据系统到数据仓库的映射关系、数据仓库的逻辑结构、数据的转换规则、数据的更新规则、数据的导入历史记录以及装载周期等、数据项含义</p><h2 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h2><ul><li><strong>面向主题</strong>：主题是指用户使用数据仓库进行决策时所关心的重点问题</li><li><strong>集成</strong>：数据进入数据仓库之前，需要进行加工和集成，通过 ETL（抽取-extract、转换-transform、加载-load）操作，统一源数据中的不一致问题，如：同名异义、异名同义、单位不统一、字长不一致等</li><li><strong>稳定</strong>：保留一段时间内的历史数据，数据进入到数据仓库后极少更新或者不更新，一般仅执行查询操作，很少删除或更新，需要定期加载数据</li><li><strong>随时间变化</strong>：数据仓库关注历史数据，随着时间变化新增数据，删去超过存储时限的数据，具有时间维度</li></ul><h2 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h2><ul><li>清晰数据结构：每一个数据分层都有各自的作用域和职责，在使用时方便定位和理解</li><li>减少重复开发：规范数据分层，开发一些通用的中间层数据，减少重复计算</li><li>统一数据口径：通过数据分层，提供统一的数据出口，统一对外输出的数据口径</li><li>复杂问题简单化：将复杂的任务分解成多个步骤来完成，每一层只处理单一的步骤，易于实现，数据出现问题时，只需要修复有问题的数据，不用修复所有的数据</li><li>屏蔽原始数据的异常：不必改一次业务就需要重新接入数据</li></ul><h1 id="2-数据仓库架构"><a href="#2-数据仓库架构" class="headerlink" title="2. 数据仓库架构"></a>2. 数据仓库架构</h1><h2 id="2-1-分层"><a href="#2-1-分层" class="headerlink" title="2.1 分层"></a>2.1 分层</h2><ul><li>数据缓冲层（STG）：结构与源系统一致的增量数据，汇聚业务系统源数据，ETL过程的缓冲区，隔离数据与分析</li><li>操作数据存储层（ODS：Operational Data Store）：数据由源数据经过ETL操作后产生；结构与源系统一致的全量数据，对STG层数据进行聚合及数据清洗和标准化，数据粒度是最细，用于简化后续数据加工处理工作<ul><li>去噪（去除明显偏离正常水平的数据）</li><li>去重（去除重复数据）</li><li>提字段（提取数据挖掘需要的字段）</li></ul></li><li>数据明细层（DWD：Data Warehouse Detail）：明细层数据，面向数据进行数据域分类、整合、清洗，将相同主题的数据汇集起来，建立宽表，形成一套标准的化数据模型，提供一定的数据质量保证</li><li>数据服务层（DWS：Data Warehouse Service）：数据集市层数据，按照业务划分生成字段比较多的宽表，用于提供后续的业务查询，OLAP分析和数据分发等，该层的数据表会相对比较少，每张表字段较多</li><li>数据应用层（ADS：Application Data Store，也写作APP）：完全贴合前端业务应用，高度汇总，面向应用提供数据服务，进行数据分析和数据挖掘等</li><li>维表层（DIM：Dimension）：维表层主要包含高基数维度数据和低基数维度数据两部分数据，提供给用户使用<ul><li>高基数维度数据：一般是用户资料表、商品资料表类似的资料表，数据量可能是千万级或者上亿级别</li><li>低基数维度数据：一般是配置表，比如枚举值对应的中文含义，或者日期维表，数据量可能是个位数或者几千几万</li></ul></li></ul><p><img src="https://qizhongyi.gitee.io/images/Data/Data_warehouse_layered.png" alt="Data_warehouse_layered"></p><h2 id="2-2-模型"><a href="#2-2-模型" class="headerlink" title="2.2 模型"></a>2.2 模型</h2><p><strong>事实表</strong>：存储组织机构业务操作事件的实际数据或详细数据的数值化度量结果，每行数据是一个特定粒度级别的细节数据，同一张事实表保持相同的数据粒度，事实数据具有可加性和和连续性，具有多个外键与维度表主键关联，针对维度主键建立索引</p><ul><li>数据内容</li></ul><blockquote><p>可加性度量：可以按照与事实表关联的任意维度汇总<br>半可加性度量：可以与事实表关联的部分维度汇总，如差额<br>不可加性度量：如比率</p></blockquote><ul><li>分类</li></ul><blockquote><p>事实事实表：一行记录对应空间或时间上某点的度量事件<br>周期快照事实表：一行记录汇总了一段周期的度量事件，如天气预报<br>累计快照事实表：一行记录汇总事件开始到结束的全过程，如项目进度<br>无事实事实表：指没有度量事实（数值类型数据）但定义良好的事件记录，如上课记录<br>聚集事实表：对原子粒度的事实表进行简单的数字化上卷操作，提高查询性能<br>合并事实表：将来自多个过程的以相同粒度表示的事实合并为单一的事实表</p></blockquote><p><strong>维度表</strong>：与业务事件发生时相关的文本环境，用于描述“何人在何时何地为何如何处理何物”，存放具有独立属性和层次结构的数据，如时间、地点等；每个维度表都有单一主键列与事实表关联</p><p><strong>星型模型</strong>：由一张事实表关联多张维度表组成，形状类似星形<br><strong>雪花模型</strong>：由一张事实表关联多张多层级的维度表，形状类似雪花</p><p><strong>OLAP多维数据库</strong>：基于多维数据库实现的维度模型被称为联机分析处理（OLAP，On-Line Analytical Processing）<br><strong>OLAP常见操作</strong></p><ul><li>切片：多维数据立方体的子集，提取某一维度单独取值的数据</li><li>切块：多维数据立方体两个及以上维度的切片</li><li>钻取：在不同数据级别进行切换，从最概括（向上）到最详细（向下）</li><li>卷积：钻取的逆操作</li><li>旋转：更改报表或页面的展示维度</li></ul><p><strong>OLAP分类</strong></p><ul><li>关系型联机分析处理：ROLAP，通过关系型数据库的二维表使用多维技术支持 OLAP</li><li>多维矩阵型联机分析处理：MOLAP，通过专门的多维数据库支持 OLAP</li><li>混合型联机分析处理：HOLAP，是 ROLAP 和 MOLAP 的混合</li></ul><p>离线数仓：Hive</p><p>实时数仓：ClickHouse</p><p>分层、维度建模</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis-基础</title>
      <link href="/202105/2163107.html"/>
      <url>/202105/2163107.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Redis使用基础 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><strong>Redis</strong>：Remote Dictionary Server，远程字典服务；是一个开源的使用C语言编写、支持网络、可基于内存亦可持久化的数据结构存储系统，可用作 <strong>Key-Value数据库、缓存和消息中间件MQ</strong>；与 Memcached 类似，支持存储多种数据类型，包括 string ：字符串、list：链表、set：集合、zset：sorted set，有序集合 和 hash：哈希类型等；<strong>数据缓存在内存中</strong>，周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件进行持久化；支持高速缓存服务，由 <strong>单线程+多路I/O复用</strong>：Tornado-支持万级并发、Node.js实现，<a href="https://redis.io/"><font face = "微软雅黑" color = 1E90FF size = 5>英文官网</font></a>，<a href="http://redis.cn/"><font face = "微软雅黑" color = 1E90FF size = 5>中文官网</font></a></p><p><strong>应用场景</strong>：</p><ul><li>高速缓存服务：将用户经常访问的数据（热数据）从数据库搬到内存</li><li>实时排行榜</li><li>高时效数据，如手机验证码</li><li>发布订阅消息系统</li></ul><p><strong>数据保存方式</strong>：</p><ul><li>rdb：保存数据，redis-check-rdb –fix dump.rdb</li><li>aof：记录执行的命令，redis-check-aof –fix appendonly.aof</li></ul><h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2. 安装"></a>2. 安装</h1><h2 id="2-1-Linux安装"><a href="#2-1-Linux安装" class="headerlink" title="2.1 Linux安装"></a>2.1 Linux安装</h2><p>官方建议在 Linux 部署服务，本文仅介绍 Linux 安装</p><ol><li>访问 <a href="https://redis.io/"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a> 进行下载，如下图，点击后选择合适的版本；推荐下载稳定版<br> <img src="https://qizhongyi.gitee.io/images/Data/DataBase/Redis/Redis_Download.png" alt="Redis_Download">   可按如下图查看安装操作指引： <img src="https://qizhongyi.gitee.io/images/Data/DataBase/Redis/Redis_Install_Guide.png" alt="Redis_Install_Guide"></li><li>下载安装最新版的 gcc 编译器（c 语言的编译环境）</li></ol><pre class="line-numbers language-none"><code class="language-none">yum install centos-release-scl scl-utils-buildyum install -y devtoolset-8-toolchainscl enable devtoolset-8 bashyum install gcc-c++gcc --version   # 测试 gcc版本，gcc -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="3"><li><p>解压安装文件：</p><pre class="line-numbers language-none"><code class="language-none"># 先将下载 redis-6.2.7.tar.gz 放置于 &#x2F;opt目录1. cd &#x2F;opt  # 切换目录2. tar -zxvf redis-6.2.7.tar.gz  # 解压安装包3. cd redis-6.2.7  # 进入主目录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>编译：make ；如果没有准备好C语言编译环境，make 会报错—Jemalloc/jemalloc.h：没有那个文件，可执行 make clean 清除后再次进行 make 编译</p></li><li><p>安装：make install ；会默认安装在 <strong>/usr/local/bin</strong> 目录下，存在如下文件：</p><blockquote><p>redis-benchmark：压力性能测试工具<br>redis-check-aof：修复有问题的AOF文件，rdb和aof后面讲<br>redis-check-dump：修复有问题的dump.rdb文件<br>redis-sentinel：Redis集群使用<br>redis-server：Redis服务器启动命令<br>redis-cli：客户端，操作入口</p></blockquote></li><li><p>启动：</p><ul><li>前台启动：redis-server，不推荐；redis-server –prot 6379 –requirepass ‘password’ –appendonly yes &gt;redis.log &amp;；关闭窗口即停止服务</li><li>后台启动：默认前台启动，需要配置文件参数，修改为后台启动： daemonize yes（general模块 128行），修改配置文件需要先备份默认生成的配置文件：将 /opt/redis-6.2.7/redis.conf 拷贝至 /usr/local/bin/myconf 下（需要先创建） ：cp /opt/redis-6.2.7/redis.conf /usr/local/bin/myconf<ol start="3"><li>启动服务：主目录下运行（默认：/usr/local/bin）redis-server /myredis/redis.conf ；指定配置文件启动</li><li>连接使用：redis-cli -h ip -p 6379 ；默认没有密码，端口号为 6379</li><li>测试联通：ping ；返回 pong</li><li>读写测试：redis-benchmark</li><li>关闭连接：shutdown ；变成未连接状态</li><li>退出服务：exit</li></ol></li></ul></li></ol><h2 id="2-2-内容介绍"><a href="#2-2-内容介绍" class="headerlink" title="2.2 内容介绍"></a>2.2 内容介绍</h2><p><strong>redis-benchmark</strong>：安装自带的性能测试工具；使用 redis-benchmark 参数</p><pre class="line-numbers language-none"><code class="language-none">redis-benchmark -h localhost -p 6379 -c 100 -n 100000<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th align="left">选项</th><th align="left">描述</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left"><strong>-h</strong></td><td align="left">指定服务器主机名</td><td align="left">127.0.0.1</td></tr><tr><td align="left"><strong>-p</strong></td><td align="left">指定服务器端口</td><td align="left">6379</td></tr><tr><td align="left"><strong>-s</strong></td><td align="left">指定服务器 socket</td><td align="left"></td></tr><tr><td align="left"><strong>-c</strong></td><td align="left">指定并发连接数</td><td align="left">50</td></tr><tr><td align="left"><strong>-n</strong></td><td align="left">指定请求数</td><td align="left">10000</td></tr><tr><td align="left"><strong>-d</strong></td><td align="left">以字节的形式指定 SET/GET 值的数据大小</td><td align="left">3</td></tr><tr><td align="left"><strong>-k</strong></td><td align="left">1=keep alive 0=reconnect</td><td align="left">1</td></tr><tr><td align="left"><strong>-r</strong></td><td align="left">SET/GET/INCR 使用随机 key，SADD 使用随机值</td><td align="left"></td></tr><tr><td align="left"><strong>-P</strong></td><td align="left">通过管道传输 &lt;numreq&gt; 请求</td><td align="left">1</td></tr><tr><td align="left"><strong>-q</strong></td><td align="left">强制退出 redis；仅显示 query/sec 值</td><td align="left"></td></tr><tr><td align="left"><strong>–csv</strong></td><td align="left">以 CSV 格式输出</td><td align="left"></td></tr><tr><td align="left"><strong>-l（L 小写）</strong></td><td align="left">生成循环，永久执行测试</td><td align="left"></td></tr><tr><td align="left"><strong>-t</strong></td><td align="left">仅运行以逗号分隔的测试命令列表</td><td align="left"></td></tr><tr><td align="left"><strong>-I（i 大写）</strong></td><td align="left">Idle 模式；仅打开 N 个 idle 连接并等待</td><td align="left"></td></tr></tbody></table><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><p><a href="http://redisdoc.com/"><font face = "微软雅黑" color = 1E90FF size = 5>官网-命令参考文档</font></a>；<strong>命令不区分大小写</strong></p><h2 id="3-1-数据库"><a href="#3-1-数据库" class="headerlink" title="3.1 数据库"></a>3.1 数据库</h2><p><strong>数据库</strong>：默认16个数据库，初始默认使用0号库，所有库同样密码</p><pre class="line-numbers language-none"><code class="language-none">select dbid: 切换数据库，如：select 8dbsize:      查看当前数据库的key的数量flushdb:     清空当前库flushall:    清空全部库save:        立即保存数据bgsave:      后台保存数据auth password:登录，通过 config set requirepass &quot;xxx&quot; 设置密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-Key操作"><a href="#3-2-Key操作" class="headerlink" title="3.2 Key操作"></a>3.2 Key操作</h2><pre class="line-numbers language-none"><code class="language-none">keys *:            查看当前库所有key，查看指定库的所有键 keys *dbid，如 keys *1exists k_name:     判断k_name是否存在type k_name:       查看k_name的类型move k_name db_num:移动数据到指定数据库del k_name:        删除k_name对应的数据unlink k_name:     删除k_name对应的数据；仅将k_name从keyspace元数据中删除，实际删除后续异步进行expire k_name 10:  设置k_name的过期时间，默认单位为 s 秒ttl k_name:        查看k_name的剩余有效时间；-1表示永不过期，-2表示已过期type k_name:       查看k_name的数据类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><h3 id="3-3-1-字符串-String"><a href="#3-3-1-字符串-String" class="headerlink" title="3.3.1 字符串-String"></a>3.3.1 字符串-String</h3><p><strong>String</strong>：是 Redis 最基本的类型，一个 key 对应一个 value；二进制安全，可以包含任何数据，包括图片或序列化对象，value最多可以是 512M；底部数据结构为 <strong>简单动态字符串</strong>：SDS，Simple Dynamic String，可以修改的字符串，内部结构实现类似 Java 的 ArrayList，采用预分配冗余空间的方式来减少内存的频繁分配</p><p><strong>新建键值对</strong>：set k_name value [ex seconds|px millseconds|keeptll] [nx|xx]</p><ul><li>key，value：键值对的 key 和 value</li><li>ex seconds：k-v的超时秒数</li><li>px millseconds：k-v的超时毫秒数；与 ex互斥</li><li>nx：当数据库中key不存在时，将key-value添加数据库；如果 key值重复，则会覆盖之前的 value值</li><li>xx：当数据库中key存在时，将key-value添加数据库；与 nx互斥</li></ul><p><strong>获取键值对</strong>：</p><ul><li>获取指定键值对：get k_name，支持通配符 *</li><li>获取所有现有键：keys k_name，支持通配符 *</li></ul><p><strong>操作键值对</strong>：</p><pre class="line-numbers language-none"><code class="language-none">获取值长度：strlen k_name新增键值对，并指定过期时间：setex k_name seconds value新增键值对，不存在才会新建：setnx k_name value，只能设置 key 不存在的键值对，存在则不能新建，返回 0，表示新建失败批量新增：mset k_name_1 value_1 k_name_2 value_2 ... ，一次性创建多个键值对，不同键值对用空格隔开批量新增：msetnx k_name_1 value_1 k_name_2 value_2 ... ，一次性创建多个不存在的键值对批量获取：mget k_name_1 k_name_2 ... ，一次性获取多个键值对的值增加值：incr k_name，将 key 中储存的数字值增加1，只能对数字值操作；如果为空，新增值为1增加指定值：incrby k_name step，将 key 中储存的数字值增加 step减少值：decr k_name，将 key 中储存的数字值减少1，只能对数字值操作；如果为空，新增值为-1增加指定值：decrby k_name step，将 key 中储存的数字值减少 step追加修改值：append k_name value，将给定的 value 追加到原值的末尾；如果k_name不存在，则会新建覆盖修改值：setrange k_name start_num value，从 start_num开始将 value覆盖写入 k_name对应值取旧换新：getset k_name value，返回 k_name对应的旧值，并将对应值换成新的 value获取指定长度：getrange k_name start_num stop_num，获取 k_name对应 value指定长度的内容，包含开始结束位置，索引从 0 开始，最后位置可以用 -1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>原子操作</strong>：不会被线程调度机制打断的操作，操作同时成功或同时失败；从开始一直到运行结束，中间不会有任何 context switch：切换到另一个线程；如：incr、decr等</p><ul><li><strong>单线程</strong>：能够在单条指令中完成的操作都认为是原子操作，因为中断只能发生于指令之间</li><li><strong>多线程</strong>：不能被其它进程或线程打断的操作就叫原子操作</li></ul><pre class="line-numbers language-none"><code class="language-none">批量新增：mset k_name_1 value_1 k_name_2 value_2 ... ，一次性创建多个键值对，不同键值对用空格隔开批量新增：msetnx k_name_1 value_1 k_name_2 value_2 ... ，一次性创建多个不存在的键值对批量获取：mget k_name_1 k_name_2 ... ，一次性获取多个键值对的值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-2-列表-List"><a href="#3-3-2-列表-List" class="headerlink" title="3.3.2 列表-List"></a>3.3.2 列表-List</h3><p><strong>List</strong>：单键多值的数据结构，是string类型的有序集合，按照插入顺序排序；可以添加一个元素到列表的 头部/左边 或者 尾部/右边；底部数据结构为 <strong>双向链表</strong>，对两端的操作性能很高，通过索引下标的操作中间的节点性能较差</p><p><strong>新增键值对</strong>：lpush/rpush 从 左边/右边 插入一个或多个值</p><ul><li><p>lpush k_name value_1 value_2 … ；存储顺序与插入顺序相反</p></li><li><p>rpush k_name value_1 value_2 … ；存储顺序与插入顺序相同</p></li></ul><p><strong>获取键值对</strong>：lrange k_name start stop：返回 k_name 指定范围内的数据；lrange k_name 0 -1，返回 k_name 里面的所有数据</p><p><strong>操作键值对</strong>：</p><pre class="line-numbers language-none"><code class="language-none">lpop k_name：从左边移除第一个值，并返回移除的数据rpop k_name：从右边移除第一个值，并返回移除的数据lrem k_name num value：将 k_name中值为 value的数据删除 num个(从左往右开始删除)lindex k_name index_num：返回 k_name 在 index_name处(从左往右，从 0 开始)的值llen k_name：获取 k_name 的长度，拥有值的数量ltrim k_name start_idx stop_idx：截取 k_name中包含start_idx 到 stop_idx的值rpoplpush k_name_1 k_name_2：从 k_name_1 右边取出一个值，插入 k_name_2 左边lset k_name index_num value：将 k_name中 index_num位置处的值替换为 valuelinsert k_name before&#x2F;after value ins_value：在 k_name的 value位置之前&#x2F;后插入ins_value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-3-集合-Set"><a href="#3-3-3-集合-Set" class="headerlink" title="3.3.3 集合-Set"></a>3.3.3 集合-Set</h3><p><strong>Set</strong>：功能与list类似，是string类型的无序集合，会自动进行去重操作；底层是一个 value为null的 hash表，所以添加，删除，查找的复杂度都是O(1)；底层数据结构为 <strong>dict字典</strong>，用哈希表实现</p><p><strong>新建键值对</strong>：sadd k_name value_1 value_2 … </p><p><strong>读取键值对</strong>：smembers k_name：取出 k_name的所有值</p><pre class="line-numbers language-none"><code class="language-none">srem k_name value：移除 k_name 中的 valuesrem k_name value_1 value_2：删除 k_name中的 value_1 value_2spop k_name：随机从 k_name 移除一个值，返回移除的值smove k_name_1 k_name_2 value：将 k_name_1中的 value移动到 k_name_2srandmember k_name num：随机从 k_name中读取 num个数据sismember k_name value：判断 k_name中是否存在 value有1，没有0scard k_name：返回 k_name中的元素个数sinter k_name_1 k_name_2：取 k_name_1、k_name_2的交集(共有的元素)sunion k_name_1 k_name_2：取 k_name_1、k_name_2的并集(所有的元素)sdiff k_name_1 k_name_2：取 k_name_1、k_name_1的差集(k_name_1独有的元素)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-4-有序集合-Zset"><a href="#3-3-4-有序集合-Zset" class="headerlink" title="3.3.4 有序集合-Zset"></a>3.3.4 有序集合-Zset</h3><p><strong>Zset</strong>：sorted set，是一个没有重复元素的有序的字符串集合；按照每个元素的评分-score的高低顺序进行排序（由低到高）；集合的元素唯一，但评分可以重复</p><p><strong>新建键值对</strong>：zadd k_name score_1 value_1 score_2 value_2 … </p><p><strong>读取键值对</strong>：zrange k_name  start_num stop_num [withscores] ，按照 score由小到大的顺序取出 k_name的值，并显示 score</p><pre class="line-numbers language-none"><code class="language-none">zrem k_name value：删除 k_name的 valuezcard k_name：查看 k_name 的数据个数zcount k_name min_num max_num：统计 k_name中 score在区间内的元素个数zrangebyscore k_name min_num max_num [withscores] [limit offset count] ：读取 k_name的 score在 min_num~max_num 的元素；默认从小到大，-inf +inf：正负无穷zrevrangebyscore k_name max_num min_num [withscores] ：按照从大到小排列zrank k_name value：返回 k_name中的 value的排名，从 0 开始zincrby k_name num value：将 k_name中 value的 score增加 num<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-5-哈希表-Hash"><a href="#3-3-5-哈希表-Hash" class="headerlink" title="3.3.5 哈希表-Hash"></a>3.3.5 哈希表-Hash</h3><p><strong>Hash</strong>：是一个键值对集合，是 string类型的 field 和 value 的映射；例：用户ID为查找的key，存储的 value用户对象包含姓名，年龄，生日等信息</p><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/Redis/Hash_KV.png" alt="Hash_KV"></p><p><strong>新建键值对</strong>：</p><ul><li>hset k_name f_name f_value ex n，新建一个键值对，在指定n秒之后失效</li><li>hmset k_name f_name_1 f_value_1 f_name_2 f_value_2 … ex n，新建一个多重键值对</li></ul><p><strong>获取键值对</strong>：</p><ul><li>hget k_name f_name；获取指定一个键的值</li><li>hmget k_name f_name_1 f_name_2 … ；获取指定多个键的值</li><li>hgetall k_name；获取所有的键和值</li></ul><pre class="line-numbers language-none"><code class="language-none">hsetnx k_name f_name value：将 hash集合指定不存在的 f_name设置为 value；如果存在，则设置失败hdel k_name f_name：删除指定的字段，对应的值自动删除hincrby k_name f_name value：将 hash集合指定 f_name增加 valuehdecrby k_name f_name value：将 hash集合指定 f_name减少 valuehlen k_name：获取 k_name中的数据个数（field的个数）hkeys k_name：查看 hash集合的所有 fieldhvals k_name：查看 hash集合的所有 valuehexists k_name f_name：判断哈希表 key中，给定 field域是否存在<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-6-地理信息-Geospatial"><a href="#3-3-6-地理信息-Geospatial" class="headerlink" title="3.3.6 地理信息-Geospatial"></a>3.3.6 地理信息-Geospatial</h3><p><strong>Geospatial</strong>：Geo-Geographic，地理信息；是元素的2维坐标，对应地图上的经纬度，提供经纬度设置，查询，范围查询，距离查询，经纬度Hash等常见操作；<strong>底层是 Zset 实现</strong></p><p><strong>新建键值对</strong>：geoadd k_name val_longitude val_latitude loc_name [ val_longitude_2 val_latitude_2 loc_name_2]；可同时加入多个，成功后返回成功插入的个数</p><p><strong>获取键值对</strong>：geopos k_name loc_name ；可同时获取多个</p><p><strong>操作键值对</strong>：</p><pre class="line-numbers language-none"><code class="language-none">geodist k_name name_1 name_2 [m&#x2F;km&#x2F;ft-英尺&#x2F;mi-英里] [WITHCOORD] [WITHDIST] [WITHHASH] [ASC|DESC]：计算直线距离，单位默认为 m米- WITHDIST：在返回位置对象的同时，将位置对象与中心之间的距离也一并返回，距离的单位和用户给定的范围单位保持一致- WITHCOORD：将位置对象的经度和维度也一并返回- WITHHASH：以 52 位有符号整数的形式，返回位置对象经过原始 geohash 编码的有序集合分值；主要用于底层应用或者调试- ASC|DESC：从近到远返回位置对象元素 | 从远到近返回位置对象元素georadius k_name val_longitude val_latitude radius m&#x2F;km&#x2F;ft&#x2F;mi：获取给定经纬度在指定半径内的数据geohash：返回一个或多个位置对象的 Geohash表示（11个字符）georadiusbymember k_name loc_name radius m&#x2F;km&#x2F;ft&#x2F;mi：以给定的位置对象为中心，返回与其距离不超过给定最大距离的所有位置对象<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-7-位图-Bitmaps"><a href="#3-3-7-位图-Bitmaps" class="headerlink" title="3.3.7 位图-Bitmaps"></a>3.3.7 位图-Bitmaps</h3><p><strong>Bitmaps</strong>：本身不是一种数据类型，本身就是字符串：key-value，可以对字符串的位进行操作；合理地使用操作位能够有效地提高内存使用率和开发效率；可以把 Bitmaps想象成一个以位为单位的数组，数组的下标在Bitmaps中叫做 <strong>偏移量</strong></p><p><strong>新增Bitmaps键值对</strong>：<strong>setbit k_name offset value</strong> ；假设现在有20个用户，userid=1， 6， 11， 15， 19 的用户访问了网站， 那么当前 Bitmaps初始化结果如下图：</p><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/Redis/Bitmaps_init.png" alt="Bitmaps_init"></p><p>对应初始化语句为：分别对每一个偏移量进行设置</p><pre class="line-numbers language-none"><code class="language-none">setbit user_id_0001 1 1setbit user_id_0001 6 1setbit user_id_0001 11 1setbit user_id_0001 15 1setbit user_id_0001 19 1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>读取Bitmaps键值对</strong>：<strong>get k_name:k_value offset</strong></p><pre class="line-numbers language-none"><code class="language-none">getbit user_id_0001 1  # 返回 1， 1,6,11,15,19，返回值都为1，其余为0getbit user_id_0001 2  # 返回 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">bircount k_name [start end]：统计字符串指定范围内被设置为1的 bit数量bitop and&#x2F;or&#x2F;not&#x2F;xor unique:new_k_name unique:old_k_name_1 unique:old_k_name_2 ；返回 old_k_name_1、old_k_name_2相同偏移量处修改的数量；and-交集、or-并集、not-非、xor-异或例：bitop and unique:user_0001_2 unique:user_id_0001 user_id_0002：两天都访问过的用户数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>set和Bitmaps存储一天活跃用户对比</strong>：假设网站有1亿用户， 每天独立访问的用户有5千万</p><table><thead><tr><th>数据类型</th><th>每个用户id占用空间</th><th>需要存储的用户量</th><th>全部内存量</th></tr></thead><tbody><tr><td>set</td><td>64位</td><td>50000000</td><td>64位*50000000 = 400MB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><p><strong>set和Bitmaps存储独立用户空间对比</strong>：假设网站有1亿用户， 每天独立访问的用户有5千万</p><table><thead><tr><th>数据类型</th><th>一天</th><th>一个月</th><th>一年</th></tr></thead><tbody><tr><td>set</td><td>400MB</td><td>12GB</td><td>144GB</td></tr><tr><td>Bitmaps</td><td>12.5MB</td><td>375MB</td><td>4.5GB</td></tr></tbody></table><p><strong>set和Bitmaps存储一天活跃用户对比</strong>：独立用户比较少</p><table><thead><tr><th>数据类型</th><th>每个用户id占用空间</th><th>需要存储的用户量</th><th>全部内存量</th></tr></thead><tbody><tr><td>set</td><td>64位</td><td>100000</td><td>64位*100000 = 800KB</td></tr><tr><td>Bitmaps</td><td>1位</td><td>100000000</td><td>1位*100000000 = 12.5MB</td></tr></tbody></table><h3 id="3-3-8-基数-Hyperloglog"><a href="#3-3-8-基数-Hyperloglog" class="headerlink" title="3.3.8 基数-Hyperloglog"></a>3.3.8 基数-Hyperloglog</h3><p><strong>基数</strong>：集合中不重复元素个数称为基数</p><p><strong>Hyperloglog</strong>：是用来做基数统计的算法，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且很小；每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数， <strong>Hyperloglog 只会根据输入元素来计算基数，不会储存输入元素本身</strong></p><p><strong>新建Hyperloglog键值对</strong>：pfadd k_name value_1 value_2 …</p><p><strong>操作Hyperloglog键值对</strong>：</p><pre class="line-numbers language-none"><code class="language-none">pfcount k_name ：返回基数pfmerge new_k_name old_k_name_1 old_k_name_2 ：将多个集合合并到一个新集合中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-4-发布订阅"><a href="#3-4-发布订阅" class="headerlink" title="3.4 发布订阅"></a>3.4 发布订阅</h2><p><strong>发布订阅</strong>：发布订阅 (pub/sub) 是 Redis的一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息，Redis 客户端可以订阅任意数量的频道</p><pre class="line-numbers language-none"><code class="language-none">1. 打开一个客户端订阅 channel1：subscribe channel_name；2. 打开另一个客户端，给channel1发布消息hello：publish channel_name hello3. 打开第一个客户端可以看到发送的消息注：发布的消息没有持久化<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-新特性"><a href="#4-新特性" class="headerlink" title="4. 新特性"></a>4. 新特性</h1><h2 id="4-1-ACL"><a href="#4-1-ACL" class="headerlink" title="4.1 ACL"></a>4.1 ACL</h2><p><strong>ACL</strong>：Access Control List，访问控制列表；允许根据可以执行的命令和可以访问的键来限制连接；可进行更细粒度的权限控制 ：（1）接入权限：用户名和密码；（2）可以执行的命令；（3）可以操作的 KEY</p><pre class="line-numbers language-none"><code class="language-none">acl list：展现用户权限列表acl whoami：命令查看当前用户acl cat：查看添加权限指令类别；acl cat string：可以查看类型下具体命令<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>类型</th><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>启动用户</td><td>on</td><td>激活某用户账号</td></tr><tr><td>禁用用户</td><td>off</td><td>禁用某用户账号（已验证的连接仍然可以工作）；如果默认用户被标记为off，则新连接将在未进行身份验证的情况下启动，并要求用户使用AUTH选项发送AUTH或HELLO，以便以某种方式进行身份验证</td></tr><tr><td>权限添加</td><td>+&lt;command&gt;</td><td>将指令添加到用户可以调用的指令列表中</td></tr><tr><td>权限删除</td><td>-&lt;command&gt;</td><td>从用户可执行指令列表移除指令</td></tr><tr><td></td><td>+@&lt;category&gt;</td><td>添加该类别中用户要调用的所有指令，有效类别为@admin、@set、@sortedset…等，通过调用ACL CAT命令查看完整列表；特殊类别@all表示所有命令，包括当前存在于服务器中的命令，以及将来将通过模块加载的命令</td></tr><tr><td></td><td>-@&lt;actegory&gt;</td><td>从用户可调用指令中移除类别</td></tr><tr><td></td><td>allcommands</td><td>+@all的别名</td></tr><tr><td></td><td>nocommand</td><td>-@all的别名</td></tr><tr><td>可操作键的添加或删除</td><td>~&lt;pattern&gt;</td><td>添加可作为用户可操作的键的模式；如~*允许所有的键</td></tr></tbody></table><h2 id="4-2-IO多线程"><a href="#4-2-IO多线程" class="headerlink" title="4.2 IO多线程"></a>4.2 IO多线程</h2><p><strong>IO多线程</strong>：指客户端交互部分的网络IO交互处理模块多线程，而非执行命令多线程；多线程部分只是用来处理网络数据的读写和协议解析，Redis执行命令依然是单线程</p><h2 id="4-3-其他"><a href="#4-3-其他" class="headerlink" title="4.3 其他"></a>4.3 其他</h2><ul><li>支持 Cluster</li><li>RESP3新的 Redis 通信协议：优化服务端与客户端之间通信</li><li>Client side caching客户端缓存：基于 RESP3 协议实现的客户端缓存功能</li><li>Proxy集群代理模式：让 Cluster 拥有像单实例一样的接入方式，降低使用cluster的门槛</li><li>Modules API</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL基础-指令</title>
      <link href="/202105/2017570.html"/>
      <url>/202105/2017570.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录PostgreSQL的基础知识-常用</p><span id="more"></span><h1 id="1-库表数操作"><a href="#1-库表数操作" class="headerlink" title="1. 库表数操作"></a>1. 库表数操作</h1><h2 id="1-1-库操作"><a href="#1-1-库操作" class="headerlink" title="1.1 库操作"></a>1.1 库操作</h2><pre class="line-numbers language-none"><code class="language-none">create database db_name;  -- 创建数据库create database db_name with owner &#x3D; user_name encoding &#x3D; &#39;utf-8&#39;;drop database db_name;  -- 删除数据库alter database old_db_name rename to new_db_name;  -- 重命名数据库alter database db_name connection limit conn_num;  -- 修改最大连接数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-2-表操作"><a href="#1-2-表操作" class="headerlink" title="1.2 表操作"></a>1.2 表操作</h2><p><strong>创建</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-- 创建普通表create table tb_name(id int,name varchar(20),sex bool);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-- 创建分区表create table tb_name(col_name data_type[,col_name data_type])[distribute by hash(col_name)]     -- 设置分布列[partition by range(col_name)(     -- 创建分区partition p_name values less than(value)[,partition p_name values less than(value)])];-- 快速建表select * from tb_name partition (pt) where condition;create table tb_name (like tb_name_module including all);create table tb_name (like tb_name_module) distribute by hash(col_name);alter table tb_name_old rename to tb_name_new;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改列定义</strong>：</p><pre class="line-numbers language-none"><code class="language-none">-- 修改表alter table old_tb_name rename to new_tb_name;  -- 重命名表drop table if exists tb_name;  -- 删除数据表，不会报错-- 修改字段alter table tb_name rename col_name_old to col_name_new;   -- 字段重命名alter table tb_name alter column col_name type data_type;  -- 修改字段数据类型alter table tb_name add col_name data_type;   -- 新增字段alter table tb_name drop col_name data_type;  -- 删除字段comment on column&#x2F;table is &#39;description&#39;;     -- 新增字段注释<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>新增约束</strong>：包括主键约束、外键约束、非空约束、唯一约束、默认值约束等</p><pre class="line-numbers language-none"><code class="language-none">-- 主键约束：唯一标识一条记录，提高数据检索效率create table tb_anme(    col_name d_type(length) primary key,  -- 在定义表的时候直接在列定义时指明；);create table tb_anme(    col_name d_type(length),    primary key (col_name),  -- 在完成表定义时，在小括号内部指明主键列);例：create table tb_anme(    user_id char(9) primary key  -- 最后一个字段前不需要加逗号,);create table tb_anme(    user_id char(9),    user_name varchar(30),    PRIMARY KEY(user_id, user_name)  -- 定义组合主键，（id， name） 组合构成主键);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-- 外键约束：外键 col_name 必须是其他表的主键；保证数据的完成性，提高数据检索效率create table tb_anme(    col_name foreign key references tb_name (col_name),);create table tb_anme(    CONSTRAINT cons_name foreign key(col_name) references tb_name (col_name) [on delete set null],  -- 其余的列定义约束都有上述两种增加方式);注：not null：非空约束unique：唯一性约束，可以为空default：默认值约束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-3-数操作"><a href="#1-3-数操作" class="headerlink" title="1.3 数操作"></a>1.3 数操作</h2><p><strong>插入数据</strong>：</p><pre class="line-numbers language-none"><code class="language-none">insert into tb_name values (d_value_list);  -- 数据顺序与字段顺序一致，多条数据可直接用逗号分隔insert into tb_name (col_name_list) values (d_value_list);insert into tb_name select_query;insert into tb_name (col_name_list) select_query;  -- 字段列表要一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>更新数据</strong>：</p><pre class="line-numbers language-none"><code class="language-none">update tb_name set col_name &#x3D; value where condition;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>删除数据</strong>：</p><pre class="line-numbers language-none"><code class="language-none">delete from tb_name where condition;delete from tb_name;  -- 不加条件则会清空表truncate table tb_name;  -- 先 drop，再重新创建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th></th><th>Delete</th><th>Truncate</th></tr></thead><tbody><tr><td>执行速度</td><td>慢</td><td>快</td></tr><tr><td>可指定条件</td><td>可以，where condition</td><td>不可以</td></tr><tr><td>语句分类</td><td>DML</td><td>DDL</td></tr><tr><td>回滚事务</td><td>可以</td><td>不可以</td></tr><tr><td>操作日志</td><td>记录</td><td>不记录</td></tr></tbody></table><h1 id="2-查询"><a href="#2-查询" class="headerlink" title="2. 查询"></a>2. 查询</h1><h2 id="2-1-语法"><a href="#2-1-语法" class="headerlink" title="2.1 语法"></a>2.1 语法</h2><pre class="line-numbers language-none"><code class="language-none">-- 书写规范select repeat_options select_expr   -- 指定查询的字段列表以及是否去重from tb_name                        -- 可以通过 as 关键字对表进行重命名，便于书写[join tb_name on join_condition]    -- 指定表关联方式where where_condition               -- 进行数据筛选group by col_name_list              -- 进行数据分组having having_condition         -- 对分组后的数据进行筛选order by col_name_list desc         -- 进行数据排序limit a[,b]                         -- 进行数据分页，指定数据的展示条数允许子句 clause&#x2F;子查询 subquery可以对查询结果进行集合操作：交、并、差 ： union&#x2F;intersect&#x2F;except<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>语句执行顺序</strong>：from -&gt; on -&gt; join -&gt; where -&gt; group by -&gt; 聚合函数 -&gt; having -&gt; select -&gt; distinct -&gt; order by -&gt; union -&gt; limit</p><pre class="line-numbers language-none"><code class="language-none">select products.prod_name from crashcourse.products; select * from products; select prod_name from products where prod_price &#x3D; 2.5; select prod_name from products where prod_price between 2.5 and 3.0;select prod_name from products where vend_id &#x3D; 1001 and&#x2F;&amp;&amp; prod_price not in (2.5, 3.0);select prod_name from products where prod_name like &#39;_ABc%&#39;;select prod_name from products order by prod_price desc nulls first&#x2F;last;-- 检索 products表中的 prod_name，结果按照 prod_price进行降序排列，如果存在null，则排在最前&#x2F;后面select prod_name from products limit 5 offset 10;-- 检索 products表中的 prod_name，从第11条开始显示5条记录select * from products a left join vendors b on a.vend_id &#x3D; b.vend_id;select * from employees awhere not exists (    select emp_no from dept_emp b    where a.emp_no &#x3D; b.emp_no);-- 查找 employees 表中 emp_no 不出现在 dept_emp 表中的所有信息seelct prod_name, (select prod_id||&#39;@@&#39;||prod_name from products) from products;  -- ||进行字段拼接select vend_id, prod_id, prod_price from products where prod_price &lt;&#x3D; 5union [all]select vend_id, prod_id, prod_price from products where vend_id in (1001,1002);-- union：去掉重复记录，执行速度慢-- union all：保留重复记录，执行速度快<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-2-函数"><a href="#2-2-函数" class="headerlink" title="2.2 函数"></a>2.2 函数</h2><h3 id="2-2-1-数值函数"><a href="#2-2-1-数值函数" class="headerlink" title="2.2.1 数值函数"></a>2.2.1 数值函数</h3><pre class="line-numbers language-none"><code class="language-none">MIN(col_name)     -- 返回指定列的最大值，只能计算一列，多列使用多个MAX(col_name)     -- 返回指定列的最小值，只能计算一列，多列使用多个SUM(col_name)     -- 返回指定列的总和，只能计算一列，多列使用多个AVG(col_name)     -- 返回指定列的均值，只能计算一列，多列使用多个COUNT(col_name)   -- 统计指定列中不为null值的数据条数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-2-字符串函数"><a href="#2-2-2-字符串函数" class="headerlink" title="2.2.2 字符串函数"></a>2.2.2 字符串函数</h3><pre class="line-numbers language-none"><code class="language-none">LENGTH(str)                            -- 获取字符串str长度CONCAT(str1,str2[,… ])                 -- 将str1、str2…顺序拼接起来LTRIM(str)                             --去除前端的空格RTRIM(str)                             --去除后端的空格TRIM(str)                              --去除左右两边的空格REPLACE(str, search_str, replace_str)  -- 在str中用replace_str替换search_strSUBSTRING(str, position [,length])     -- 从 str 的 position 开始（支持负索引），向右取 length 个字符，substr(&#39;string&#39;,start[,offset])select to_char(data, format);select string_agg(&#39;string&#39;,&#39;string&#39;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-3-日期时间函数"><a href="#2-2-3-日期时间函数" class="headerlink" title="2.2.3 日期时间函数"></a>2.2.3 日期时间函数</h3><pre class="line-numbers language-none"><code class="language-none">NOW()                          -- 获取当前日期时间current_time                   -- 获取当前时间current_date                   -- 获取当前日期extract(t_type from col_name)  -- 获取日期函数，t_type可以取 year、month、day等to_date(data, format)to_timestamp(data, format)text_timestamp(str)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-2-4-窗口函数"><a href="#2-2-4-窗口函数" class="headerlink" title="2.2.4 窗口函数"></a>2.2.4 窗口函数</h3><pre class="line-numbers language-none"><code class="language-none">select count(1) from (select *,row_number() over (partition by col_name [order by col_name]) as col_name_new from tb_name) where col_name_new &#x3D; 1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="2-2-5-自定义函数"><a href="#2-2-5-自定义函数" class="headerlink" title="2.2.5 自定义函数"></a>2.2.5 自定义函数</h3><pre class="line-numbers language-none"><code class="language-none">create function func_name(d_type_list)  -- 声明创建函数，定义函数名称和传入参数类型returns d_type               -- 返回值的数据类型    as sql_lst               -- sql_lst为定义函数体，定义的参数通过 $1、$2... 的方式调用，1, 2 为参数的顺序    language sql             -- 用以实现函数的语言名称returns null on null input;  -- 定义常数为 null时的返回值select func_name(value);     -- 调用函数-- casecreate or replace function concat_def(integer, vaechar, date) returns varchar  -- 存在则覆盖    as &#39;select $1||$2||$3&#39;    language sqlreturns null on null input;drop function func_name(d_type_list);  -- 删除函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-维护"><a href="#3-维护" class="headerlink" title="3. 维护"></a>3. 维护</h1><h2 id="3-1-索引"><a href="#3-1-索引" class="headerlink" title="3.1 索引"></a>3.1 索引</h2><p><strong>分类</strong>：</p><ul><li><p><strong>B-Tree索引</strong>：适合处理能够按顺序存储的数据，默认索引类型</p></li><li><p><strong>Hash索引</strong>：处理简单的等于比较</p></li><li><p><strong>GiST索引</strong>：一种索引架构，扩展索引的方式</p></li><li><p><strong>GIN索引</strong>：反转索引，处理包含多个值的键</p></li></ul><pre class="line-numbers language-none"><code class="language-none">create index idx_name on tb_name(col_name_list);drop index idx_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>优点</strong>：</p><ul><li>提高数据的检索效率</li><li>加速表之间的连接</li></ul><p><strong>缺点</strong>：</p><ul><li>创建和维护索引需要耗费时间</li><li>占用磁盘空间</li></ul><pre class="line-numbers language-none"><code class="language-none">select * from pg_indexes where schemmaname &#x3D; &#39;shc_name&#39; and tablename &#x3D; &#39;tb_name&#39;;create index idx_name on tb_name useing btree(col_name);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-2-视图"><a href="#3-2-视图" class="headerlink" title="3.2 视图"></a>3.2 视图</h2><pre class="line-numbers language-none"><code class="language-none">create view v_name as select_query;drop view v_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-其他"><a href="#3-其他" class="headerlink" title="3. 其他"></a>3. 其他</h2><h3 id="3-1-查看"><a href="#3-1-查看" class="headerlink" title="3..1 查看"></a>3..1 查看</h3><pre class="line-numbers language-none"><code class="language-none">-- 查看表结构select lower(pg_catalog.pg_namespace.nspname) as schema_name,   pg_catalog.pg_class.relname as table_name,   ttt.description as table_comment,   pg_catalog.pg_attribute.attname as fields_name,   pg_catalog.pg_attribute.attnum as fields_num,   pg_catalog.pg_type.typname,   format_type(pg_catalog.pg_attribute.atttypid,pg_catalog.pg_attribute.atttypmod) as type,   pg_catalog.pg_description.description as fields_commentfrom pg_catalog.pg_attribute inner join pg_catalog.pg_class on pg_catalog.pg_attribute.attrelid &#x3D; pg_catalog.pg_class.oid inner join pg_catalog.pg_type  on pg_catalog.pg_attribute.atttypid &#x3D; pg_catalog.pg_type.oid left outer join pg_catalog.pg_attrdef on pg_catalog.pg_attrdef.adrelid &#x3D; pg_catalog.pg_class.oid and pg_catalog.pg_attrdef.adnum &#x3D; pg_catalog.pg_attribute.attnum left outer join pg_catalog.pg_description on pg_catalog.pg_description.objoid &#x3D; pg_catalog.pg_class.oid and pg_catalog.pg_description.objsubid &#x3D; pg_catalog.pg_attribute.attnum inner join pg_catalog.pg_namespace on pg_catalog.pg_class.relnamespace &#x3D; pg_catalog.pg_namespace.oid left join (select objoid,description from pg_catalog.pg_description where  objsubid &#x3D; &#39;0&#39;) ttt on ttt.objoid &#x3D; pg_catalog.pg_class.oidwhere pg_catalog.pg_attribute.attnum &gt; 0  and attisdropped &lt;&gt; &#39;t&#39;  and lower(pg_catalog.pg_namespace.nspname) &#x3D; lower(&#39;schema_name&#39;)  and lower(pg_catalog.pg_class.relname) &#x3D; lower(&#39;table_name&#39;)order by schema_name,table_name,pg_catalog.pg_attribute.attnum;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-- 查看表信息select * from pg_tables where tablename &#x3D; &#39;tb_name&#39;;select * from etl.v_cjpt_sjbcqfs where sjb_wlmc &#x3D; &#39;&#39;;select * from pg_partition;select * from pg_class;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-2-权限操作"><a href="#3-2-权限操作" class="headerlink" title="3..2 权限操作"></a>3..2 权限操作</h3><pre class="line-numbers language-none"><code class="language-none">-- 权限show grant on table tb_name;grant select on tb_name to user_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="3-3-回收空间"><a href="#3-3-回收空间" class="headerlink" title="3..3 回收空间"></a>3..3 回收空间</h3><p><strong>回收空间</strong>：PostgreSQL采用MVCC（多版本并发控制）进行处理，随着时间的推移，数据文件中积累的 dead tuples 会越来越多，需要及时清理</p><pre class="line-numbers language-none"><code class="language-none">select pg_size_pretty(pg_relation_size(tb_name)), pg_size_pretty(pg_total_relation_size(tb_name));vacuum [full] table_name;    &#x2F;&#x2F; 回收dead表空间analyze [verbose] table tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>vacuum</strong>：</p><ul><li>清除dead tuples指向的index tuples：先顺序扫描目标表，并构建一个dead tuples 组成的 list 链表，存储在 maintenance_work_mem 缓存中。然后根据 dead tuples list 移除 dead tuples 指向的 index；</li><li>移除dead tuples，更新VM和FSM：对dead tuples 做移除标记后，重新排列剩余的元组以进行碎片化整理，然后更新目标表的 VM（可见性映射文件）和 FSM（空闲空间映射文件）；</li><li>更新统计信息和相关系统表：更新目标表的统计信息（以适应最新的查询优化）和相关系统表</li></ul><p><strong>vacuum full</strong>：</p><ul><li>先对目标表创建一个 AccessExclusiveLock ，不允许外界再进行访问（为后面拷贝做准备），然后创建一个表结构和目标表相同的新表；</li><li>扫描目标表，把表中的 live tuples 拷贝到新表中；</li><li>删除目标表，在新表上，重新创建索引，更新VM， FSM以及统计信息，相关系统表等</li></ul><p><strong>区别</strong>：vacuum：只是把表中的 dead tuples 进行删除标记，并没有真正物理删除；vacuum 过程中，可以正常访问数据表；vacuum full：物理删除表中的 dead tuples，释放空间给操作系统；vacuum full 过程中，表被锁定，不允许访问。一般采用 vacuum 而不采用 vacuum full，vacuum full 尽管可以保持表的最小尺寸，但是对持续增长的表意义不大，而且 vacuum 在执行效率上也比 vacuum full 好</p>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL进阶-查询优化</title>
      <link href="/202105/188210.html"/>
      <url>/202105/188210.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 MySQL进阶-查询优化策略 的相关基础知识</p><span id="more"></span><h1 id="1-查询效率"><a href="#1-查询效率" class="headerlink" title="1. 查询效率"></a>1. 查询效率</h1><h2 id="1-1-影响因素"><a href="#1-1-影响因素" class="headerlink" title="1.1 影响因素"></a>1.1 影响因素</h2><p><strong>执行时间长，等待时间长</strong></p><ul><li>服务器硬件设备性能：发生在数据装入内存或从磁盘上读取数据；可通过 top、free、iostat、vmstat 查看系统性能</li><li>磁盘IO数：磁头移动到指定磁道的时间花费，发生在装入数据远大于内存容量</li><li>参数配置不合理</li><li>数据量的多少</li><li>SQL效率慢</li><li>索引失效</li><li>太多 join 关联查询</li></ul><h2 id="1-2-外部表现"><a href="#1-2-外部表现" class="headerlink" title="1.2 外部表现"></a>1.2 外部表现</h2><ul><li>大量请求阻塞</li><li>SQL操作变慢</li><li>存储出现问题</li></ul><h1 id="2-性能分析"><a href="#2-性能分析" class="headerlink" title="2. 性能分析"></a>2. 性能分析</h1><h2 id="2-1-MySQL-Query-Optimizer"><a href="#2-1-MySQL-Query-Optimizer" class="headerlink" title="2.1 MySQL Query Optimizer"></a>2.1 MySQL Query Optimizer</h2><p><strong>MySQL Query Optimizer</strong>：专职负责 select语句 的优化器模块，通过分析系统中收集到的统计信息，为客户端请求的 Query 提供自认为最优的执行计划</p><ol><li>将从命令解析器解析过滤的 select语句 的常量表达式换算成常量，处理常量表达式的预算（Optimizer仅接收命令解析器模块过滤的 select语句）；</li><li>对 select语句 中的查询条件进行简化和转换，如去掉无用或显而易见的条件、结构调整等；</li><li>分析 select语句 中的 Hint信息，判断显示 Hint信息 能否完全确定 select语句 的执行计划；如果不能或没有 Hint信息，则会读取所涉及对象的统计信息，根据 select语句 进行相应的计算分析，然后得出最后的执行计划</li></ol><h2 id="2-2-执行计划"><a href="#2-2-执行计划" class="headerlink" title="2.2 执行计划"></a>2.2 执行计划</h2><p><strong>执行计划</strong>：explain SQL_list，在查询语句之前加上 explain 关键字可以模拟优化器执行SQL语句，显示出执行信息，包括 <strong>表的读取顺序、数据读取操作的操作类型、可以使用和实际使用的索引、表之间的引用、被优化器查询记录数</strong>；用于分析SQL语句的性能，只是在正常的SQL语句之前加上 explain 关键字，仅用于数据的增删改查类型的SQL，不涉及数据库、数据表和数据列的相关操作</p><table><thead><tr><th align="left">指标名称</th><th align="left">指标含义</th><th align="left">指标取值及含义</th></tr></thead><tbody><tr><td align="left">id</td><td align="left">select子句或表的读取操作顺序</td><td align="left">1、2、3…<br />id值相同，从上往下顺序执行；id值不同，id值大优先查询(先查内层-子查询，再查外层)</td></tr><tr><td align="left">select_type</td><td align="left">当前SQL语句的查询类型</td><td align="left"><strong>SIMPLE</strong>：不包含子查询、union等<br /><strong>PRIMARY</strong>：包含子查询SQL中的 主查询（最外层），俗称鸡蛋壳<br /><strong>SUBQUERY</strong>：包含子查询SQL中的子查询（非最外层）<br /><strong>DERIVED</strong>：from列表中包含的子查询被标记为 derived（衍生查询），MySQL递归执行并将结果存放在临时表中<br /><strong>UNION</strong>：union 之后出现的 select<br /><strong>UNION RESULT</strong>：对 union合并结果 进行的 select</td></tr><tr><td align="left">table</td><td align="left">执行的表名</td><td align="left">tb_name</td></tr><tr><td align="left">partitions</td><td align="left">使用到的分区</td><td align="left">partitions_list</td></tr><tr><td align="left">type</td><td align="left">访问类型判断</td><td align="left"><strong>system</strong>：表只有一行记录（等于系统表），是 const类型的特例；实际一般不会出现<br /><strong>const</strong>：通过索引一次性找到；一般用于比较 primary key 、unique索引，只匹配一条数据，可以很快将主键至于 where列表中，MySQL可以将查询转换成一个常量<br /><strong>eq_ref</strong>：通过唯一性索引扫描，对于每一个索引值，表中只有一条记录匹配；常用于主键或唯一索引扫描<br /><strong>ref</strong>：通过非唯一性索引扫描，对于每一个索引值，表中有多条记录匹配<br /><strong>range</strong>：只检索给定范围的行，使用索引选择行，key显示使用的索引列；一般出现在 where语句 中存在 between、&lt;、&gt;、in 等<br /><strong>index</strong>：全索引扫描，只遍历索引树，从索引中读取数据<br /><strong>ALL</strong>：全表查询，从磁盘读取数据<br /><strong>查询效率从上到下，依次递减</strong>；一般操作中至少需要达到 <strong>range级别</strong></td></tr><tr><td align="left">possible_keys</td><td align="left">显示可能应用在这张表中的索引</td><td align="left">idx_name_list、null表示没有</td></tr><tr><td align="left">key</td><td align="left">实际上使用到的索引</td><td align="left">idx_name_list、null表示没有或索引失效；如果使用了 <strong>覆盖索引</strong>（查询的字段与复合索引的字段一致，不必读取表中的数据行，直接根据索引 “指针” 定位数据），则该索引进出现在 key列表中</td></tr><tr><td align="left">key_len</td><td align="left">索引中使用的字节数</td><td align="left">正整数，通过该列计算查询中使用的索引长度，保证精度的前提下，长度越短越好</td></tr><tr><td align="left">ref</td><td align="left">显示索引的哪一列被使用</td><td align="left">表名用于查找索引的列</td></tr><tr><td align="left">rows</td><td align="left">查询的行数</td><td align="left">正整数，根据表统计信息和索引选用情况，估算出找到指定记录所需读取的行数，越小越好</td></tr><tr><td align="left">filtered</td><td align="left">返回的结果行占需要读到的行的百分比</td><td align="left">0、1、2…100</td></tr><tr><td align="left">extra</td><td align="left">包含不适合在其他列显示但是很重要的额外信息</td><td align="left"><strong>using index</strong>：使用到了索引<br />using where：使用了where条件<br />using join buffer：使用了连接缓存<br />impossible where：where子句 的值总是 false，不能用来获取元组<br />select tables optimized away：在没有 group by子句的情况时，基于索引优化 min/max操作或者count(*)操作<br />distinct：在找到第一个匹配的元组后即停止<br /><strong>using filrsort</strong>（九死一生）：无法利用索引完成的排序操作（称为”文件排序”），数据使用一个外部索引进行排序<br /><strong>using temporary</strong>（十死无生）：对查询结果排序时使用临时表保存中间结果，常见于 group by 和 order by</td></tr></tbody></table><h2 id="2-3-Show-Profile"><a href="#2-3-Show-Profile" class="headerlink" title="2.3 Show Profile"></a>2.3 Show Profile</h2><p><strong>Show Profile</strong>：MySQL提供可以用来分析当前绘画中SQL语句执行的资源消耗情况，可以用于SQL调优的测量，<a href="https://dev.mysql.com/doc/refman/5.7/en/show-profile.html"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a>，默认关闭，并保存最近15次测运行结果</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;profiling&#39;;  -- 查看是否具备功能set profiling &#x3D; on;  -- 开启 profilingshow profiles;  -- 查看SQL运行列表，包括SQL语句的 query_id、持续时间和SQL语句内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查看系统消耗</strong>：</p><ul><li>all：显示所有的系统消耗信息</li><li>block io：显示I/O相关的开销</li><li>context switches：显示上下文切换的开销</li><li>cpu：显示cpu的开销</li><li>ipc：显示发送和接收的开销信息</li><li>memory：显示内存的开销信息</li><li>page faults：显示页面错误的开销信息</li><li>source：显示和 source_function、source_file、source_line 相关的开销信息</li><li>swaps：显示次数交换相关的开销信息</li></ul><pre class="line-numbers language-none"><code class="language-none">show profile cpu, block io for query query_id;  -- 查看系统响应，存在以下内容，SQL效率不高-- converting heap to MyISAM：查询结果太大-- create tmp table：创建临时表-- copying to tmp table on disk：江北村的临时表复制到磁盘-- locked：表锁定<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-问题定位"><a href="#2-4-问题定位" class="headerlink" title="2.4 问题定位"></a>2.4 问题定位</h2><p><strong>系统状态</strong></p><pre class="line-numbers language-none"><code class="language-none">show status ： 显示状态信息（扩展 show status like &#39;xxx&#39;, show global status like &#39;%slow%&#39;）show variables ： 显示系统变量（扩展 show variables like &#39;xxx&#39;）show innodb status ： 显示InnoDB存储引擎的状态show processlist ： 查看当前 SQL 执行，包括执行状态、是否锁表等mysqladmin variables -u username -p password ： 显示系统变量mysqladmin extended-status -u username -p password ： 显示状态信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>开启慢SQL记录</strong>：在配置文件 my.cnf 或 my.ini 中在[mysqld]一行下面加入配置参数</p><pre class="line-numbers language-none"><code class="language-none">slow_query_log &#x3D; on     # 开启慢查询日志，slow_query_log &#x3D; 1long_query_time &#x3D; 2     # 规定语句执行查过两秒就会记录，最好在5秒以内log-slow-queries&#x3D;&#x2F;data&#x2F;mysqldata&#x2F;slow-query.log       # 规定慢查询日志文件存放位置，slow_query_log_file &#x3D; &#x2F;path&#x2F;to&#x2F;log<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>连接数</strong>：connections</p><pre class="line-numbers language-none"><code class="language-none">show variables like &#39;max_connections&#39;; show global status like ‘Max_used_connections’;Max_used_connections &#x2F; max_connections * 100% ≈ 85%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>索引丢失率</strong>：key_buffer_size，Key_read_requests，Key_reads，key_cache_miss_rate</p><pre class="line-numbers language-none"><code class="language-none">show variables like ‘key_buffer_size’;   # 查看索引缓存大小show global status like &#39;Key_read_requests&#39;;     # 查看索引请求数show global status like &#39;Key_reads&#39;;     # 查看索引未命中数key_cache_miss_rate &#x3D; Key_reads &#x2F; Key_read_requests * 100%  # 索引丢失率，在0.1%以下较好(每1000个请求有一个直接读硬盘)，如果key_cache_miss_rate在0.01%以下的话，key_buffer_size分配的过多，可以适当减少。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>临时表创建</strong>：Created_tmp_disk_tables ，Created_tmp_tables ，max_heap_table_size </p><pre class="line-numbers language-none"><code class="language-none">show global status like &#39;Created_tmp_disk_tables&#39;; # 查看在磁盘上创建临时表数量show global status like &#39;Created_tmp_tables&#39;;      # 查看创建临时表数量show global status like &#39;Created_tmp_files&#39;;       # 查看创建临时文件数Created_tmp_disk_tables &#x2F; Created_tmp_tables * 100% &lt;&#x3D; 25% show variables where Variable_name in (&#39;tmp_table_size&#39;, &#39;max_heap_table_size&#39;); max_heap_table_size  # 内存临时表大小，规定值以下的临时表才能全部放内存tmp_table_size       # 临时表大小，超过 max_heap_table_size 但在规定值以下创建磁盘临时表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>打开表情况</strong>：Open_tables，Opened_tables，table_cache</p><pre class="line-numbers language-none"><code class="language-none">show global status like &#39;open%tables%&#39;; show variables like &#39;table_cache&#39;; 如果Opened_tables数量过大，说明配置中table_cache(5.1.3之后叫做table_open_cache)值可能太小Open_tables &#x2F; Opened_tables * 100% &gt;&#x3D; 85%Open_tables &#x2F; table_cache * 100% &lt;&#x3D; 95%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>进程使用情况</strong>：Threads_created ，thread_cache_size，当客户端断开之后，服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁</p><pre class="line-numbers language-none"><code class="language-none">show global status like &#39;Threads_created&#39;;show variables like &#39;thread_cache_size&#39;; 如果 Threads_created值过大，表明MySQL服务器一直在创建线程，比较耗资源，可以适当增加配置文件中thread_cache_size值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查询缓存</strong>：qcache、query_cache</p><pre class="line-numbers language-none"><code class="language-none">show global status like &#39;qcache%&#39;; show variables like &#39;query_cache%&#39;; 查询缓存碎片率 &#x3D; Qcache_free_blocks &#x2F; Qcache_total_blocks * 100%；查询缓存碎片率超过20%，可以用FLUSH QUERY CACHE整理缓存碎片，如果查询都是小数据量的话可以减小query_cache_min_res_unit查询缓存利用率 &#x3D; (query_cache_size - Qcache_free_memory) &#x2F; query_cache_size * 100%；查询缓存利用率在25%以下的话说明query_cache_size设置的过大，可适当减小；查询缓存利用率在80%以上且Qcache_lowmem_prunes &gt; 50 说明 query_cache_size 可能有点小，或者是碎片太多查询缓存命中率 &#x3D; (Qcache_hits - Qcache_inserts) &#x2F; Qcache_hits * 100%；命中率较差，可能写操作比较频繁，而且可能有些碎片<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>查询排序</strong>：Sort_buffer_size ，Sort_merge_passes </p><pre class="line-numbers language-none"><code class="language-none">show global status like &#39;Sort_merge_passes&#39;; show variables like &#39;Sort_buffer_size&#39;; 如果 Sort_buffer_size 的大小不够把所有的记录都读到内存中，MySQL 就会把每次在内存中排序的结果存到临时文件中，等 MySQL 找到所有记录之后，再把临时文件中的记录做一次排序；这次排序就会增加 Sort_merge_passes；实际上，MySQL 会用另一个临时文件来存再次排序的结果，通常 Sort_merge_passes 增加的数值是建临时文件数的两倍<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>文件打开数</strong>：open_files、open_files_limit</p><pre class="line-numbers language-none"><code class="language-none">show global status like &#39;open_files&#39;;show variables like &#39;open_files_limit&#39;;比较合适的设置：Open_files &#x2F; open_files_limit * 100% &lt;&#x3D; 75%<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>表锁情况</strong>：Table_locks_immediate ，Table_locks_waited </p><pre class="line-numbers language-none"><code class="language-none">show global status like &#39;table_locks%&#39;;Table_locks_immediate：表示立即释放表锁数Table_locks_waited：表示需要等待的表锁数如果Table_locks_immediate &#x2F; Table_locks_waited &gt; 5000，最好采用InnoDB引擎<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>表扫描情况</strong>：Handler_read_rnd_next，Com_select、read_buffer_size</p><pre class="line-numbers language-none"><code class="language-none">show global status like &#39;Handler_read_rnd_next&#39;;  # 显示查询直接操作的数据文件数量show global status like &#39;com_select&#39;; # 调出服务器完成的查询请求次数表扫描率 &#x3D; Handler_read_rnd_next &#x2F; Com_select：如果表扫描率超过4000，说明进行了太多表扫描，很有可能索引没有建好，可以适当增加 read_buffer_size 值，但最好不要超过8MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-优化策略"><a href="#3-优化策略" class="headerlink" title="3. 优化策略"></a>3. 优化策略</h1><h2 id="3-1-SQL层面-SQL优化"><a href="#3-1-SQL层面-SQL优化" class="headerlink" title="3.1 SQL层面-SQL优化"></a>3.1 SQL层面-SQL优化</h2><p><strong>尽量避免全表扫描和笛卡尔积</strong>；优先优化内层循环；不要用 select *，只查询所需要的字段</p><p><strong>join优化</strong>：</p><ul><li>使用 join 代替 子查询；尽可能减少 join语句 的循环总数，数据量较小的表为主表，关联数据量较大的副表，可在附表上建立索引，<strong>小表驱动大表</strong></li><li>无法保证副表 join字段被索引且内存资源充足的前提下，可以增加 join buffer 的大小</li></ul><p><strong>where优化</strong>：</p><ul><li>where 子句中，表连接写在最前面，可以过滤掉大量数据的条件写在最右边，having写在最后面，条件匹配从右向左依次进行</li><li>尽量避免在 where 子句中进行 null判断 和表达式操作，会导致放弃使用索引进行全表扫描</li><li>避免在索引列上进行计算和 使用null判断(is [not] null)，会导致放弃使用索引进行全表扫描</li><li>通配符（like）和正则表达式匹配会尝试匹配表中所有行，应尽量避免使用</li><li>使用 exists 替代 in；[not] in -&gt; [not] exists</li></ul><p><strong>group by优化</strong>：分组之前先进行排序</p><ul><li>使用索引列进行分组，且遵循最佳左前缀法则</li><li>增大 sort_buffer_size参数 和 max_length_for_sort_data参数的设置</li><li>优先在 where条件下进行数据限定，再通过 having进行数据限定</li></ul><p><strong>order by优化</strong>：<strong>尽量使用 index 索引排序，避免使用 Using filesort 文件排序</strong>（会创建临时表存储数据，再进行排序），即尽量使用创建索引的字段进行排序（B+Tree索引创建完成后默认已经排好序，不需要再通过数据表进行排序），当排序字段与索引字段不匹配时会采用 filesort排序方式</p><ul><li><p>查询字段避免使用 select *，严格限定查询的字段</p></li><li><p>使用索引列进行排序，且遵循最佳左前缀法则；where使用索引的最左前缀定义为常量，order by会使用索引，例：index a_b_c, where a = const order by b, c</p></li><li><p>排序字段的顺序与创建复合索引的顺序一致，且所有的排序字段排序方式一致，即全为增或全为减</p></li><li><p>增大 sort_buffer_size参数的设置：双路排序算法、单路排序算法提高参数都会增加效率</p></li><li><p>增大 max_length_for_sort_data参数的设置：select查询字段大小的总和小于 max_length_for_sort_data，且排序字段不是 text、blob等类型时，会采用单路算法，否则还是会用多路算法；提高参数，会增加用单路排序算法的概率；<strong>如果 max_length_for_sort_data设得太高，会增加数据量超出 sort_buffer_size的概率</strong></p><p><strong>Using filesort 文件排序实现算法</strong>：</p><ul><li><strong>双路排序</strong>：MySQL4.1之前使用双路排序，两次扫描磁盘，最终得到数据：从表中读取行指针和 order by列并进行排序，然后扫描已经排好序的列表，按照列表的数据重新从列表中读取数据输出；<strong>从磁盘读取排序字段，在 buffer中进行排序，再从磁盘获取其他字段</strong></li><li><strong>单路排序</strong>：从磁盘读取需要查询的所有列，按照 order by列 在 buffer中进行排序，然后扫描排序后的列表进行输出；避免了第二次读取数据，并且把随机IO变成顺序IO；但把每一行都保存在内存中会消耗更多的空间，可能会因为 sort_buffer的容量小于读取的数据量，导致创建临时表，多路合并，造成多次I/O，会导致性能下降，甚至低于 双路排序算法</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">select distinct t1.a from t1,t2 where t1.a &#x3D; t2.a;select t1.a from t1,t2 where t1.a &#x3D; t2.a group by t1.a order by t1.a;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>distinct 替换为 group by，并结合 order by 使用</li><li>用 union 代替手动创建的临时表</li></ul><h2 id="3-2-表结构层面"><a href="#3-2-表结构层面" class="headerlink" title="3.2 表结构层面"></a>3.2 表结构层面</h2><h3 id="3-2-1-表结构层面-索引"><a href="#3-2-1-表结构层面-索引" class="headerlink" title="3.2.1 表结构层面-索引"></a>3.2.1 表结构层面-索引</h3><p><strong>索引</strong>：是帮助数据库高效获取数据的数据结构，是数据库优化中最常用也是最重要的手段之一，数据量越大，索引查询效率提高越明显，更多内容可以查看<a href="https://qizhongyi.gitee.io/202109/1525719.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>MySQL进阶-索引</strong></font></a></p><p><strong>优点</strong>：</p><ul><li>提高数据检索的效率，降低数据库的 I/O成本</li><li>提高数据排序的效率，降低CPU的消耗</li></ul><p><strong>缺点</strong>：</p><ul><li>索引也是一张表，里面存储主键和索引字段，并指向实体记录；会占用额外的存储空间</li><li>对表进行增删改时，索引也会动态维护数据更新后的索引信息，包括主键、索引字段和指向信息等，降低了数据的维护速度</li><li>需要根据实际业务情况，不断更新重建最合适的索引</li><li>在最频繁使用以缩小查询范围、频繁使用需要排序的字段上建立索引；不宜在很少在查询中涉及或者重复值比较多的列或者数据类型是文本的字段上建立索引</li></ul><h3 id="3-2-2-表结构层面-数据类型"><a href="#3-2-2-表结构层面-数据类型" class="headerlink" title="3.2.2 表结构层面-数据类型"></a>3.2.2 表结构层面-数据类型</h3><ul><li><p>选取最实用的字段属性，如省份、性别最好用 enum 枚举类型</p></li><li><p>尽可能减少字段宽度</p></li><li><p>尽量把字段设置成 not null</p><blockquote><p>字段类型优先级：int -&gt; date、time - &gt; enum、char -&gt; varchar -&gt; blob、text；优先考虑数字类型，其次是日期或者二进制类型，最后是字符串，同级别数据类型优先选择占用空间小的数据类型</p></blockquote></li></ul><h3 id="3-2-3-表结构层面-表冗余"><a href="#3-2-3-表结构层面-表冗余" class="headerlink" title="3.2.3 表结构层面-表冗余"></a>3.2.3 表结构层面-表冗余</h3><p>将需要关联查询的数据冗余保存到需要关联的表内</p><h3 id="3-2-4-表结构层面-创建分区表"><a href="#3-2-4-表结构层面-创建分区表" class="headerlink" title="3.2.4 表结构层面-创建分区表"></a>3.2.4 表结构层面-创建分区表</h3><ul><li>创建条件：数据量巨大<h3 id="3-2-5-表结构层面-锁机制"><a href="#3-2-5-表结构层面-锁机制" class="headerlink" title="3.2.5 表结构层面-锁机制"></a>3.2.5 表结构层面-锁机制</h3>适用外键，优化锁定表；锁定表，优化事务处理</li><li>读写分离</li><li>分段加锁</li><li>减少锁持有时间</li><li>多个线程尽量以相同顺序获取资源<blockquote><p>不能将锁的粒度过于细化，否则会出现线程加锁和释放的次数过多，从而降低效率</p></blockquote></li></ul><h2 id="3-3-数据库配置"><a href="#3-3-数据库配置" class="headerlink" title="3.3 数据库配置"></a>3.3 数据库配置</h2><h3 id="3-3-1-数据库配置-集群"><a href="#3-3-1-数据库配置-集群" class="headerlink" title="3.3.1 数据库配置-集群"></a>3.3.1 数据库配置-集群</h3><h3 id="3-3-2-数据库配置-主从复制"><a href="#3-3-2-数据库配置-主从复制" class="headerlink" title="3.3.2 数据库配置-主从复制"></a>3.3.2 数据库配置-主从复制</h3><h4 id="3-3-2-1-介绍"><a href="#3-3-2-1-介绍" class="headerlink" title="3.3.2.1 介绍"></a>3.3.2.1 介绍</h4><p><strong>主从复制基本原理</strong>：slave 从 master 读取 binlog 进行数据同步</p><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/Master_Slave_Replication.png" alt="Master_Slave_Replication"></p><p><strong>主从复制过程</strong>：</p><ol><li>Master 将数据改变记录到二进制日志：Binary Log；记录过程叫做二进制日志事件：Binary Log Events；</li><li>Slave 将 Master 的 Binary Log Events 拷贝到它的中继日志：Replay Log；</li><li>Slave 重做中继日志中的事件，将改变应用到自己的数据库中；MySQL复制是异步且串行化的</li></ol><p><strong>主从复制基本原则</strong>：</p><ul><li>每个 Master 可以有多个 Salve，每个 Slave 只有一个 Master</li><li>每个 Slave 只能有一个唯一的服务器ID</li></ul><h4 id="3-3-2-2-操作"><a href="#3-3-2-2-操作" class="headerlink" title="3.3.2.2 操作"></a>3.3.2.2 操作</h4><p><strong>主从复制前置要求</strong>：</p><ol><li>MySQL版本一致，且后台以服务运行</li><li>多台MySQL服务器必须在同一网段，保证网络通畅</li></ol><p><strong>主从复制配置</strong>：在配置文件中完成配置，配置完成后需要重启MySQL服务器</p><ul><li>Master</li></ul><pre class="line-numbers language-none"><code class="language-none">[mysqld]server-id&#x3D;1              # 主服务器的唯一ID，必须log-bin&#x3D;&#x2F;path&#x2F;mysql-bin  # 开启二进制日志，默认会生成 mysql-bin.000001, mysql-bin.000002...序列文件，必须log-err&#x3D;&#x2F;path&#x2F;mysql-err  # 启用错误日志，默认会生成 mysql-err.err 错误日志文件basedir&#x3D;&quot;&#x2F;path&#x2F;&quot;         # 配置MySQL的根目录，basedir&#x3D;&quot;C:&#x2F;Program Files&#x2F;MySQL&#x2F;MySQL Server 8.0&#x2F;&quot;tmpdir&#x3D;&quot;&#x2F;path&#x2F;&quot;          # 配置MySQL的临时目录，可与根目录相同datadir&#x3D;&quot;&#x2F;path&#x2F;&quot;         # 配置数据目录，默认为 &#x2F;根目录&#x2F;data&#x2F;，即C:&#x2F;Program Files&#x2F;MySQL&#x2F;MySQL Server 8.0&#x2F;data&#x2F;read-only&#x3D;0              # 表示主机可读可写binlog-ignore-db&#x3D;db_name # 设置不进行复制的数据库binlog-do-db&#x3D;db_name     # 设置需要进行复制的数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Slave</li></ul><pre class="line-numbers language-none"><code class="language-none">[mysqld]server-id&#x3D;2              # 从服务器的唯一ID，必须log-bin&#x3D;&#x2F;path&#x2F;mysql-bin  # 开启二进制日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>主从连接</strong>：</p><ul><li>主机创建账户并授权</li></ul><pre class="line-numbers language-none"><code class="language-none">GRANT REPLICATION SLAVE ON *.* TO &#39;zhangsan&#39;@&#39;slave_ip&#39; IDENTIFIED BY &#39;123456&#39;;FLUSH PRIVILEGES;    -- 刷新权限show master status;  -- 查看最新的 File 和 Position并记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>从机配置需要复制的主机</li></ul><pre class="line-numbers language-none"><code class="language-none">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;master_ip&#39;,MASTER_USER&#x3D;&#39;zhangsan&#39;,MASTER_PASSWORD&#x3D;&#39;123456&#39;,MASTER_LOG_FILE&#x3D;&#39;mysql-bin.File_num&#39;,MASTER_LOG_POS&#x3D;Position_num;start slave;   -- 开启 Slave从机的复制；stop slave，关闭从机的复制show slave status\G  -- Slave_IO_Running 和 Slave_SQL_Running 同时为Yes，主从复制配置成功，否则失败<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-3-3-数据库配置-读写分离"><a href="#3-3-3-数据库配置-读写分离" class="headerlink" title="3.3.3 数据库配置-读写分离"></a>3.3.3 数据库配置-读写分离</h3><h3 id="3-3-4-数据库配置-使用缓存"><a href="#3-3-4-数据库配置-使用缓存" class="headerlink" title="3.3.4 数据库配置-使用缓存"></a>3.3.4 数据库配置-使用缓存</h3><h3 id="3-3-5-数据库配置-分库分表"><a href="#3-3-5-数据库配置-分库分表" class="headerlink" title="3.3.5 数据库配置-分库分表"></a>3.3.5 数据库配置-分库分表</h3><p><strong>使用场景</strong>：单表数据超过500万或者表容量超过2G，推荐进行分库分表，如果预计三年后的数据量达不到级别，不要在创建时就分库分表；有 <strong>垂直切分</strong>（按照业务切分，表结构可能不同）和 <strong>水平切分</strong>（表结构相同，按照主键ID、时间等进行分表）两种</p><h4 id="3-3-5-1-名词介绍"><a href="#3-3-5-1-名词介绍" class="headerlink" title="3.3.5.1 名词介绍"></a>3.3.5.1 名词介绍</h4><blockquote><p>逻辑表：逻辑上存储数据的表<br>真实表：实际存储数据的表<br>广播表：所有的库里面存储相同的数据<br>绑定表<br>分片键：进行分库分表的数据列<br>分片算法：将数据表以分片键进行分库分表的规则</p><blockquote><p>随机：random<br>范围：range<br>hash（取模）：一致性hash<br>数据节点</p></blockquote></blockquote><h4 id="3-3-5-2-问题-跨库关联查询"><a href="#3-3-5-2-问题-跨库关联查询" class="headerlink" title="3.3.5.2 问题-跨库关联查询"></a>3.3.5.2 问题-跨库关联查询</h4><blockquote><p>字段冗余：把需要关联的字段放入主表<br>数据抽象：通过ETL将数据进行汇合聚集，形成新表<br>全局表：在每一个数据库都存放关键基础数据<br>应用层组装：将需要的基础数据查出，通过应用程序计算组装</p></blockquote><h2 id="3-4-硬件与操作系统"><a href="#3-4-硬件与操作系统" class="headerlink" title="3.4 硬件与操作系统"></a>3.4 硬件与操作系统</h2>]]></content>
      
      
      <categories>
          
          <category> 进阶 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-常见问题</title>
      <link href="/202105/1728498.html"/>
      <url>/202105/1728498.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录MySQL使用中的常见问题</p><span id="more"></span><h1 id="1-账户连接类"><a href="#1-账户连接类" class="headerlink" title="1. 账户连接类"></a>1. 账户连接类</h1><p><strong>问题1</strong>：忘记root密码：（Windows）</p><ol><li>关闭MySQL服务；</li><li>在cmd中切换至mysql\bin目录；</li><li>mysqld –skip-grant-tables，回车；</li><li>重新打开一个命令行窗口，切换至mysql\bin目录；</li><li>输入mysql，回车，即可登录；</li><li>修改root密码（update修改user表）：</li><li>mysql&gt; use mysql; //切换数据库</li><li>mysql&gt; update user set password=password(‘123’) where user=’root’ and host=’localhost’; </li><li>mysql&gt; update mysql.user set authentication_string=password(‘123’) where user=’root’ ;mysql 5.7的数据库没有password字段,而是authentication_string字段</li><li>mysql&gt; flush privileges; //刷新权限</li></ol><p><strong>问题2</strong>：1130-Host ‘xxx’ is not allowed to connect to this MySQL server</p><ul><li>原因：无远程权限</li><li>解决：赋予远程权限：update user set host =’%’where user =’root’;刷新权限：flush privileges;</li><li>确认：select Host,User from mysql.user; 保证root对应的Host为%，表示任何主机都可以访问</li></ul><p><strong>问题3</strong>：ERROR 1044 (42000): Access denied for user ‘‘@’localhost’ to database ‘mysql’</p><ul><li>原因：‘‘@’localhost’，登录为匿名账户</li><li>解决：<ul><li>Linux：<ul><li>关闭MySQL：service mysqld stop</li><li>屏蔽权限：mysqld_safe –skip-grant-table；屏幕出现Starting demo from …..</li></ul></li><li>Windows：<br>  关闭MySQL： net stop mysql<br>  屏蔽权限：mysqld –skip-grant-table；屏幕出现Starting demo from …..<br>  新开一个终端登录：mysql -u root mysql，直接Enter进入<br>  重设密码：UPDATE user SET Password=PASSWORD(‘newpassword’) where USER=’root’;<br>  刷新权限：FLUSH PRIVILEGES; </li></ul></li></ul><p><strong>问题4</strong>：ERROR 1364 (HY000): Field ‘ssl_cipher’ doesn’t have a default value insert into mysql.user(Host,User,Password) values(“host”,”username”,password(“password”));</p><ul><li>原因：mysql中创建用户时，默认配置严格模式，禁止通过insert的方式直接修改mysql库中的user表进行添加新 - 用户</li><li>解决：create user ‘username‘@’host’ identified by ‘password’;（不推荐）</li><li>修改配置文件： 将sql-mode的STRICT_TRANS_TABLES参数删除，再重启服务，再次添加用户</li></ul><h1 id="2-查询操作类"><a href="#2-查询操作类" class="headerlink" title="2. 查询操作类"></a>2. 查询操作类</h1><p><strong>问题1</strong>：1093 - You can’t specify target table ‘XXX’ for update in FROM clause</p><ul><li>原因：在同一语句中，不能先select出同一表中的某些值，再update这个表</li></ul><h1 id="3-指令介绍类"><a href="#3-指令介绍类" class="headerlink" title="3. 指令介绍类"></a>3. 指令介绍类</h1><p><strong>问题1</strong>：Like 和 Regexp 的区别</p><ul><li>like 不使用通配符时，进行等值匹配，如 name like ‘张三’ 等价于 name = ‘张三’；regexp不使用特殊字符匹配时，进行模糊匹配，如 name regexp ‘张三’ 等价于 name like ‘%张三%’；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-查询</title>
      <link href="/202105/1646703.html"/>
      <url>/202105/1646703.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录MySQL查询基础语法的相关内容，包括查询结构和查询顺序等</p><span id="more"></span><h1 id="1-查询语法"><a href="#1-查询语法" class="headerlink" title="1. 查询语法"></a>1. 查询语法</h1><pre class="line-numbers language-none"><code class="language-none">-- 书写规范select repeat_options select_expr   -- 指定查询的字段列表以及是否去重from tb_name                        -- 可以通过 as 关键字对表进行重命名，便于书写[join tb_name on join_condition]    -- 指定表关联方式where where_condition               -- 进行数据筛选group by col_name_list              -- 进行数据分组having having_condition         -- 对分组后的数据进行筛选order by col_name_list desc         -- 进行数据排序limit a[,b]                         -- 进行数据分页，指定数据的展示条数允许子句 clause&#x2F;子查询 subquery可以对查询结果进行集合操作：交、并、差 ： union&#x2F;intersect&#x2F;except<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="1-1-语法结构"><a href="#1-1-语法结构" class="headerlink" title="1.1 语法结构"></a>1.1 语法结构</h2><ul><li><strong>repeat_options</strong>：面对重复值的选项，有 <strong>all 和 distinct</strong> 两个选项，all：展示全部内容，包括重复值；distinct 去除重复值的所有内容；默认返回的数据不进行去重，多列视为一个元组，整体进行去重</li><li><strong>select_expr</strong>：查询列可以是一个列名或表达式，多列之间使用逗号分割；AS(可省略，建议保留)为每一个列指明一个别名，可用于group by，having或 order by子句中，允许通配符 all 或 *；不建议使用<pre class="line-numbers language-none"><code class="language-none">select 1+2    -- 可以使用表达式<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><strong>from</strong>：可以是tb_name或者db_name.tb_name，多表使用逗号分割。AS(可省略，建议保留)为表名起别名。可以不存在表名，使用 dual 作为伪表名，来保证 sql 语法的兼容性（有些服务器要求必须有表名）</li><li><strong>where</strong>：用于检索数据（先判断每条记录是否符合条件，符合则可以获取当前记录信息，否则不能获取；条件可由多个条件组合完成（and/or），比较运算产生的结果为1(TRUE)、0 (FALSE)或 NULL）</li><li><strong>group by</strong>：根据一个或多个列对结果集进行分组（[GROUP BY {col_name | expr | position} [ASC | DESC], … [WITH ROLLUP]]，分组后，每组内显示一条记录，分组后查询其他字段就只是组内第一条记录的信息，不能准确表示组内所有数据信息，可利用分组字段进行排序显示结果，可以使用多个字段进行分组，每个字段可以设置排序规则，可以使用with rollup 进行组内聚合计算，与聚合函数一起使用，用于统计组内的信息）</li><li><strong>having</strong>：对分组结果（group by）进行再次过滤，语法结构与where相似，但having可以使用字段别名（where负责先获得结果，如果需要在结果中再次处理，则使用having再次执行过滤操作，WHERE关键字无法与合计函数一起使用）</li><li><strong>order by</strong>：对一列或者多个列对结果进行排序（[ORDER BY {col_name | expr | position}  [ASC | DESC] , …]如果存在多个排序字段，在前一个不能比较出结果后，后边的才起作用，指明升序（asc：ascending）还是降序（desc：descending））</li><li><strong>limit</strong>：用于限制被SELECT语句返回的行数（[LIMIT {[offset,] row_count | row_count OFFSET offset}]，从offset索引位置开始获取row_count条记录）</li></ul><h2 id="1-2-执行顺序"><a href="#1-2-执行顺序" class="headerlink" title="1.2 执行顺序"></a>1.2 执行顺序</h2><h3 id="1-2-1-系统执行顺序"><a href="#1-2-1-系统执行顺序" class="headerlink" title="1.2.1 系统执行顺序"></a>1.2.1 系统执行顺序</h3><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/Data_Select_Order.png" alt="Data_Select_Order"></p><p>MySQL可以分为Server层和存储引擎层<br>Server层：连接器、查询缓存区、解析器、优化器、执行器，支持客户端与存储引擎层进行交互<br>存储引擎层：负责数据的存储和提取，架构是插件式</p><ol><li><strong>连接器</strong>：客户端通过连接器连接上数据库服务端，由连接器负责建立、维持和管理连接，获取权限</li><li><strong>缓存区</strong>：查询缓存空间，若有结果，则返回结果；否则进行下一步</li><li><strong>解析器</strong>：解析器解析SQL语句，形成解析树：<ul><li>先进行<strong>词法分析</strong>：将SQL语句切割成多个字符串，并对字符串进行含义识别，例：select name, age from user where id = ‘xxx’; 会被切割成：select，name，age，from，user，where，id，=，’xxx’这样的9个字符串，识别：select 为查询语句，user为表名</li><li>再进行<strong>语法分析</strong>：判断输入的SQL语句是否符合MySQL的SQL语法规则，形成解析树</li></ul></li><li><strong>预处理器</strong>：预处理器进行预处理：判断表名是否存在、用户权限是否足够等，形成新的解析树</li><li><strong>优化器</strong>：优化器进行优化：根据解析树形成执行计，选择最优的执行计划执行<ul><li>当有多个索引时，决定使用的索引</li><li>当进行多表关联时，决定关联顺序</li></ul></li><li><strong>执行器</strong>：根据表的引擎定义，存储引擎提供的查询接口，将磁盘中的数据加载到存储引擎的内存中(Buffer Pool)，获取数据，返回结果</li></ol><h3 id="1-2-2-语句执行顺序"><a href="#1-2-2-语句执行顺序" class="headerlink" title="1.2.2 语句执行顺序"></a>1.2.2 语句执行顺序</h3><p><strong>语句执行顺序</strong>：from -&gt; on -&gt; join -&gt; where -&gt; group by -&gt; 聚合函数 -&gt; having -&gt; select -&gt; distinct -&gt; order by -&gt; union -&gt; limit</p><pre class="line-numbers language-none"><code class="language-none">from:     对查询指定的表计算笛卡尔积；执行顺序为从后往前、从右到左；数据量较大的表尽量放在后面on:       按照 join_condition 过滤数据join:     关联外部表获取数据where:    按照 where_condition 过滤数据；执行顺序为自下而上、从右到左；将能过滤掉最大数量记录的条件写在WHERE字句的最右group by: 进行分组；执行顺序从右往左，在运行GROUP BY使用WHERE将不需要的记录过滤掉聚合函数（count-计数；sum-求和；avg-求平均；max-最大值；min-最小值）having:   按照 having_condition 过滤数据select:   选择指定列distinct: 进行去重order by: 按照 order_condition 过滤数据；执行顺序从左到右，消耗资源union:    将两个查询的结果拼接到一起limit:    取出指定数量的记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-简单样例"><a href="#2-简单样例" class="headerlink" title="2. 简单样例"></a>2. 简单样例</h1><h2 id="2-1-列限定"><a href="#2-1-列限定" class="headerlink" title="2.1 列限定"></a>2.1 列限定</h2><p><strong>检索单列</strong></p><pre class="line-numbers language-none"><code class="language-none">select prod_name from products;-- 检索 products 表中 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>检索多列</strong></p><pre class="line-numbers language-none"><code class="language-none">select prod_id, prod_name  from products;-- 检索 products 表中  prod_id、prod_name 列下的数据，多列之间用（,）分隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>检索所有列</strong></p><pre class="line-numbers language-none"><code class="language-none">select * from products; -- 查询 products 表中所有数据，采用通配符星号（*）表示，也可以将所有字段全部 列举额出来；除非特殊需求，一般不建议查询所有列；可以检索出列名未知的列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>完全限定列名</strong></p><pre class="line-numbers language-none"><code class="language-none">select products.prod_name from crashcourse.products; -- 检索 products 表中 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-2-去重"><a href="#2-2-去重" class="headerlink" title="2.2 去重"></a>2.2 去重</h2><p><strong>去重检索</strong></p><pre class="line-numbers language-none"><code class="language-none">select distinct prod_name from products;-- 检索 products 表中 prod_name 列下的数据，去重展示；默认返回的数据不进行去重<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-3-条件过滤"><a href="#2-3-条件过滤" class="headerlink" title="2.3 条件过滤"></a>2.3 条件过滤</h2><p><strong>过滤数据</strong>：根据指定的搜索条件检索所需数据，字符串类型需要引号进行限定，数值类型不需要</p><ol><li><strong>算术运算符</strong>：=/&lt;/&gt;/!=</li></ol><pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_price &#x3D; 2.5; -- 检索 products 表中 prod_price 等于 2.5 时 prod_name 列下的数据select prod_name from products where prod_price &lt; 2.5; -- 检索 products 表中 prod_price 小于 2.5 时 prod_name 列下的数据select prod_name from products where prod_price &lt;&#x3D; 2.5;-- 检索 products 表中 prod_price 小于或等于 2.5 时 prod_name 列下的数据select prod_name from products where prod_price &lt;&gt; 2.5;-- 检索 products 表中 prod_price 不等于 2.5 时 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li><p><strong>逻辑操作符</strong>：多条件过滤，将上文的多重过滤条件进行逻辑组合，支持 AND/&amp;&amp; 操作符和 OR/|| 操作符</p><ul><li>AND操作符：也可以用 &amp;&amp; 表示，只有前后的条件都满足才能匹配</li></ul> <pre class="line-numbers language-none"><code class="language-none">select prod_name from products where vend_id &#x3D; 1001 and&#x2F;&amp;&amp; prod_price not in (2.5, 3.0);-- 检索 products 表中 vend_id &#x3D; 1001 并且prod_price 不等于 2.5 且不等于 3.0 时 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>OR操作符：也可以用 || 表示，前后条件满足一个即可匹配</li></ul> <pre class="line-numbers language-none"><code class="language-none">select prod_name from products where vend_id &#x3D; 1001 or&#x2F;|| prod_price not in (2.5, 3.0);-- 检索 products 表中 vend_id &#x3D; 1001 或者（prod_price 不等于 2.5 且不等于 3.0 ）时 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>XOR操作符：异或，两个条件都满足，则结果为 0；两个条件只满足一个，则结果为 1</li></ul> <pre class="line-numbers language-none"><code class="language-none">select prod_name from products where vend_id &#x3D; 1001 xor prod_price not in (2.5, 3.0);-- 检索 products 表中仅满足 vend_id &#x3D; 1001 、 prod_price 不等于 2.5 且不等于 3.0 其中一个条件的 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>AND 操作符的优先级高于 OR 操作符，在处理 OR 操作符前，优先处理 AND 操作符；可使用 <strong>圆括号</strong> 明确地分组相应的操作符，提高对应运算的优先级</p></blockquote></li><li><p><strong>空值检查</strong>：一个列不包含值时，称其为包含空值NULL</p></li></ol><pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_price IS NULL; select prod_name from products where ISNULL( prod_price);-- 检索 products 表中 prod_price 为空（无值，no value）时 prod_name 列下的数据select prod_name from products where prod_price IS NOT NULL; -- 检索 products 表中 prod_price 不为空时 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li><strong>LIKE通配符</strong>：用来匹配值的一部分的特殊字符，支持百分号（%）通配符和下划线（_）通配符；% 匹配任意个字符，包括0个；_ 只能匹配一个字符，代表该位置有且仅有一个字符，通配符可用于匹配字符的任意位置，根据需要进行选择，如 A%c、A%、%c 等；且此时是区分大小写的，ABC 和 ABc 是不同的数据，上文只能匹配 ABc，无法匹配 ABC；尽量不使用通配符，查询效率较低</li></ol><pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_name like &#39;%ABc%&#39;;-- 检索 products 表中 prod_name 带有 ABc 的 prod_name 列下的数据select prod_name from products where prod_name like &#39;_ABc_&#39;;-- 检索 products 表中 prod_name 带有 ABc 且长度为5的 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="5"><li><p><strong>集合运算符</strong></p><ul><li>范围限定：BETWEEN min AND max：闭区间（大于等于，小于等于：min &lt;= expr &lt;= max）<pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_price between 2.5 and 3.0; -- 检索 products 表中 prod_price 大于等于 2.5 并且 小于或等于 3.0 时 prod_name 列下的数据结果包括指定的开始值和结束值，不同类型的数据库结果对边界值会有差别；相对于操作符，级别效率更高，但边界值不灵活<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><strong>IN操作符</strong>：存在集合内的元素，指定条件范围，范围中的每个条件都可以进行匹配合法值的由逗号分隔的清单，全都括在圆括号中<pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_price in (2.5, 3.0); -- 检索 products 表中 prod_price 等于 2.5 或3.0 时 prod_name 列下的数据select prod_name from products where prod_price not in (2.5, 3.0); -- 检索 products 表中 prod_price 不等于 2.5 且不等于 3.0 时 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>Any操作符：任意一个</li></ul> <pre class="line-numbers language-none"><code class="language-none">&#x3D; any(数据集合) 相当于in&lt; any(数据集合) 小于最大值&gt; any(数据集合) 大于最小值!&#x3D;any(数据集合) 只要与集合内的一个元素不相等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>All操作符：所有</li></ul> <pre class="line-numbers language-none"><code class="language-none">&#x3D; all(数据集合) 等于集合内的所有元素&lt; all(数据集合) 小于最小值&gt; all(数据集合) 大于最大值!&#x3D;all(数据集合) 相当于not in<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>Some操作符：一些，语法上与any一致，not some() 等价于 !=any()</li><li><strong>Exists操作符</strong>：存在，返回一个布尔类型的结果；将外表主查询的数据放入 exists子查询 中进行逐条遍历验证操作，根据验证的 bool结果判断返回外表主查询中满足条件的结果</li></ul> <pre class="line-numbers language-none"><code class="language-none">select * from tb_a where key in (select key from tb_b);select * from tb_a where exists (select 1 from tb_b where tb_b.key &#x3D; tb_a.key);-- in 与 exists 的区别：in 先查询 tb_b，在查询 tb_a；exists 先查询 tb_a，在查询 tb_b；当 tb_a 的数据集小于 tb_b 时，用 exists 优于 in；当 tb_b 的数据集必须小于 tb_a 时，用 in 优于 exists<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>NOT操作符</strong>：否定它之后所跟的任何条件，包括集合运算、空值检查、Like通配符等</p></li></ol><pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_price IS NOT NULL;-- 检索 products 表中 prod_price 不为空时 prod_name 列下的数据select prod_name from products where prod_price not in (2.5, 3.0);-- 检索 products 表中 prod_price 不等于 2.5 且不等于 3.0 时 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="7"><li><p><strong>正则表达式</strong>：用来匹配文本的特殊的串（字符集合），使用 REGEXP 关键字进行申明</p> <pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_name regexp &#39;ABc&#39;;-- 检索 products 表中 prod_name 带有 ABc 的 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>进行OR匹配：搜索两个串其中的一个，用“|”连接</li></ul> <pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_name regexp &#39;ABc|ABC&#39;;-- 检索 products 表中 prod_name 带有 ABc 或 ABC 的 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>匹配字符集：自定义匹配字符集，用[]包裹，可用[^]进行否定</li></ul> <pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_name regexp &#39;[ABCc]&#39;;-- 检索 products 表中 prod_name 带有 ABCc其中之一的 prod_name 列下的数据select prod_name from products where prod_name regexp &#39;[^ABCc]&#39;;-- 检索 products 表中 prod_name 不带有 ABCc其中任意之一的 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>匹配范围：用集合来定义要匹配的一个或多个字符，如 0-9表示 0123456789，a-z表示所有小写字母，A-Z表示所有大写字母；也可以是一部分范围，如1-5，a-d等</li></ul> <pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_name regexp &#39;[0-9a-zA-Z]&#39;;-- 检索 products 表中 prod_name 存在数字或大小写字母的 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">[:alnum:]</td><td align="center">任意字母和数字（同[a-zA-Z0-9]）</td></tr><tr><td align="center">[:alpha:]</td><td align="center">任意字符（同[a-zA-Z]）</td></tr><tr><td align="center">[:blank:]</td><td align="center">空格和制表（同[\t]）</td></tr><tr><td align="center">[:cntrl:]</td><td align="center">ASCII控制字符（ASCII 0到31和127）</td></tr><tr><td align="center">[:digit:]</td><td align="center">任意数字（同[0-9]）</td></tr><tr><td align="center">[:graph:]</td><td align="center">与[:print:]相同，但不包括空格</td></tr><tr><td align="center">[:lower:]</td><td align="center">任意小写字母（同[a-z]）</td></tr><tr><td align="center">[:print:]</td><td align="center">任意可打印字符</td></tr><tr><td align="center">[:punct:]</td><td align="center">既不在[:alnum:]又不在[:cntrl:]中的任意字符</td></tr><tr><td align="center">[:space:]</td><td align="center">包括空格在内的任意空白字符（同[\f\n\r\t\v]）</td></tr><tr><td align="center">[:upper:]</td><td align="center">任意大写字母（同[A-Z]）</td></tr><tr><td align="center">[:xdigit:]</td><td align="center">任意十六进制数字（同[a-fA-F0-9]）</td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><ul><li>匹配特殊字符：转义特殊符号的字符，用\进行转义</li></ul> <pre class="line-numbers language-none"><code class="language-none">select prod_name from products where prod_name regexp &#39;\\.&#39;;-- 检索 products 表中 prod_name 带有.的 prod_name 列下的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><table><thead><tr><th align="center">元字符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">\\f</td><td align="center">换页</td></tr><tr><td align="center">\\n</td><td align="center">换行</td></tr><tr><td align="center">\\r</td><td align="center">回车</td></tr><tr><td align="center">\\t</td><td align="center">制表</td></tr><tr><td align="center">\\v</td><td align="center">纵向制表</td></tr></tbody></table></li></ol><h2 id="2-4-分组"><a href="#2-4-分组" class="headerlink" title="2.4 分组"></a>2.4 分组</h2><p><strong>分组数据</strong>：将数据按照 col_name_list分组，进行分类汇总；分组之前必先进行排序，如果顺序错误会导致临时表产生</p><p><strong>过滤分组</strong>：通过 having 子句对分组结果进行筛选，用法与where相似；WHERE排除的行不包括在分组中</p><pre class="line-numbers language-none"><code class="language-none">select col_name from tb_name group by col_name_list having condition;-- 将数据按照 col_name_list 进行分组，按照 condition 过滤分组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>注意事项</strong></p><ul><li>分组字段遵循最佳左前缀</li><li>WHERE 执行顺序高于 HAVING，应该提前在 where处尽量筛选出最少的数据</li></ul><p>GROUP BY子句可以包含任意数目的列<br>数据在最后规定的分组上进行汇总<br>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式，不能是聚集函数<br>除聚集计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出<br>如果分组列中具有NULL值，则NULL将作为一个分组返回<br>GROUP BY子句必须出现在WHERE子句之后，ORDER BY子句之前</p><h2 id="2-5-排序"><a href="#2-5-排序" class="headerlink" title="2.5 排序"></a>2.5 排序</h2><p><strong>排序数据</strong>：根据指定列的数据按照一定大小进行排序，<strong>asc升序排序</strong>（从A到Z）或者 <strong>desc 降序排序</strong>（从Z到A），默认为升序；多个排序列也是通过逗号，分隔，优先级按照列名的前后顺序；可以为每个排序字段进行顺序指定；按照数据库的比较规则进行排序，一般默认 a 和 A 大小相同；MySQL实现排序有两种方式：index 索引排序和Using filesort 文件排序；<strong>尽量使用 index 索引排序，避免使用 Using filesort 文件排序</strong>（会创建临时表存储数据，再进行排序）</p><p><strong>Using filesort 文件排序实现</strong>：</p><ul><li><strong>双路排序</strong>：MySQL4.1之前使用双路排序，两次扫描磁盘，最终得到数据：从表中读取行指针和 order by列并进行排序，然后扫描已经排好序的列表，按照列表的数据重新从列表中读取数据输出；<strong>从磁盘读取排序字段，在 buffer中进行排序，再从磁盘获取其他字段</strong></li><li><strong>单路排序</strong>：从磁盘读取需要查询的所有列，按照 order by列 在 buffer中进行排序，然后扫描排序后的列表进行输出；避免了第二次读取数据，并且把随机IO变成顺序IO；但把每一行都保存在内存中会消耗更多的空间，可能会因为 sort_buffer的容量小于读取的数据量，导致创建临时表，多路合并，造成多次I/O，会导致性能下降，甚至低于 双路排序算法</li></ul><pre class="line-numbers language-none"><code class="language-none">select prod_name from products order by prod_name asc &#x2F; desc;-- 检索 products 表中 prod_name 列下的数据select prod_price from products order by prod_price [asc]&#x2F;desc limit 1  -- 查找某列最值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-6-分页"><a href="#2-6-分页" class="headerlink" title="2.6 分页"></a>2.6 分页</h2><p><strong>限制结果</strong>：也叫分页</p><pre class="line-numbers language-none"><code class="language-none">select prod_name from products limit 5; -- 检索 products 表中 prod_name 列下的数据，仅展示5行select prod_name from products limit 5,10; -- 检索 products 表中 prod_name 列下的数据，从第5行开始展示10行，即5~14行；第一行的索引值为0，即 limit 5 &#x3D; limit 0,5 &#x3D; limit 5 offset 0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-横向连接-JOIN"><a href="#3-横向连接-JOIN" class="headerlink" title="3. 横向连接-JOIN"></a>3. 横向连接-JOIN</h1><p><strong>横向连接</strong>：关联多张表进行查询；没有条件就是笛卡尔积，先进行连接，再判断是否保留，一般大表在左，小表在右；连接表的数量没有限制</p><pre class="line-numbers language-none"><code class="language-none">select vend_name, prod_name, prod_pricefrom vendors, productswhere vendors.vend_id &#x3D; products.vend_idorder by vend_name,prod_nametb_left join tb_right 连接条件inner&#x2F;outer&#x2F;natural&#x2F;cross&#x2F;Left&#x2F;right join where&#x2F;on&#x2F;using() tb_left.Column &#x3D; tb_right.Column；一定要给出连接条件，否则两表进行一一配对，返回结果形成笛卡尔积，浪费资源<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>内连接</strong>：左右两边的数据都存在才能进行连接（内连接），内连接可以省略连接条件：左表的所有数据都要与右表的所有数据进行连接/笛卡尔积连接（M &gt; &gt; N），可以使用 cross join 替代 inner join，默认是 inner join（可省写为join）</li></ul><pre class="line-numbers language-none"><code class="language-none">select vend_name, prod_name, prod_pricefrom vendors inner join productson vendors.vend_id &#x3D; products.vend_id-- 返回 vend_id 同时存在于 vendors 和 products 两张表的数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>外连接</strong>：如果存在左右两边不能匹配的数据，也会进行连接，此时匹配不上的记录用null值填充字段，Mysql暂时不支持全外连接。外连接不能使用where条件，不能省略连接条件</p><ul><li>左外连接：<strong>left [outer] join</strong> ，保留左表的数据</li><li>右外连接：<strong>right [outer] join</strong> ，保留右表的数据</li><li>全外连接：<strong>full outer join</strong>，两边的数据都保留，<strong>MySQL不支持全外连接</strong>，可通过 left join union right join 实现</li></ul></li></ul><pre class="line-numbers language-none"><code class="language-none">select vend_name, prod_name, prod_pricefrom vendors left&#x2F;right&#x2F;full [outer] join productson vendors.vend_id &#x3D; products.vend_idleft：返回 vend_id 存在于 vendors 表中的数据，不能匹配的数据置空right：返回 vend_id 存在于 products 表中的数据，不能匹配的数据置空full：返回 vend_id 存在于 vendors 和 products 两张表中数据的交集，不能匹配的数据置空outer 关键字可以省略，连接条件由 on 给出<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>自连接</strong>：左表与右表为同一张表，通过定义别名进行区分</li></ul><pre class="line-numbers language-none"><code class="language-none">select p1.prod_id,p2.prod_namefrom products as p1, products as p2where p1.vend_id &#x3D; p2.vend_id and p2.prod_id &#x3D; &#39;DTNTR&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>自然连接</strong>：natural left/right join，mysql自动判断连接条件，通过多表的相同字段自动进行连接，且每个表只返回一次；支持内自然连接和外自然连接，重复列只出现一次</p><ul><li><p><strong>条件过滤</strong>：</p><ul><li>where：对一一配对好的结果进行过滤，可使用条件表达式</li><li>on：连接条件，过滤无效连接，可使用条件表达式，进行连接两表的字段名可以不一致</li><li>using：连接条件，去掉结果中的重复字段，并放置在列前，要求进行连接两表的字段名一致</li></ul></li><li><p>内连接可以使用 where、on 和 using 进行条件筛选，外连接只可以使用 using 和 on 进行条件筛选</p></li></ul></li></ul><p><strong>左右两表公有</strong>：</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_a inner join tb_b on a.key &#x3D; b.key;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>仅包含左表</strong>：左表独有的记录右表对应的字段填充为空</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_a left [outer] join tb_b on a.key &#x3D; b.key;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>仅包含右表</strong>：右表独有的记录左表对应的字段填充为空，<strong>右外连接都可以转换成左外连接</strong></p><pre class="line-numbers language-none"><code class="language-none">select * from tb_a right [outer] join tb_b on a.key &#x3D; b.key;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>仅包含左表独有</strong>：左右两表公有的记录不显示</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_a left [outer] join tb_b on a.key &#x3D; b.key where b.key is null;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>仅包含右表独有</strong>：左右两表公有的记录不显示</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_a right [outer] join tb_b on a.key &#x3D; b.key where a.key is null;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>左右两表所有</strong>：全外连接，</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_a left join tb_b on a.key &#x3D; b.keyunion select * from tb_a right join tb_b on a.key &#x3D; b.key;-- select * from tb_a full outer join tb_b on a.key &#x3D; b.key;  -- MySQL 不支持<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>左右两表各自独有</strong>：</p><pre class="line-numbers language-none"><code class="language-none">select * from tb_a left join tb_b on a.key &#x3D; b.key where b.key is nullunion select * from tb_a right join tb_b on a.key &#x3D; b.key  where a.key is null;-- select * from tb_a full outer join tb_b on a.key &#x3D; b.key where a.key is null or b.key is null;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-纵向连接-UNION"><a href="#4-纵向连接-UNION" class="headerlink" title="4. 纵向连接-UNION"></a>4. 纵向连接-UNION</h1><p><strong>纵向连接</strong>：UNION 用于把来自许多 SELECT 语句的结果组合到一个结果集合中</p><pre class="line-numbers language-none"><code class="language-none">select vend_id, prod_id, prod_pricefrom productswhere prod_price &lt;&#x3D; 5union [all]select vend_id, prod_id, prod_pricefrom productswhere vend_id in (1001,1002);-- union：去掉重复记录，执行速度慢-- union all：保留重复记录，执行速度快<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意</strong>：</p><blockquote><p>要求查询结果的字段数要求一致，字段类型也应一致<br>数据列是根据列的顺序进行匹配，而不是根据列名称；在第一个SELECT语句中被使用的列名称被用于结果的列名称<br>默认使用 DISTINCT 去除重复行，可通过 ALL 关键字申明保留<br>如要对 union 的结果作为整体进行排序或 limit，需要对单个地SELECT语句加圆括号限定范围，在联合后的结果增加 order by 或 limit；order by引用的数据列来自最后一个select<br>分别排序，再联合，则需要用括号将各select语句括起来，且order by只能在limit 出现时才有效</p></blockquote><h1 id="5-子查询-subquery"><a href="#5-子查询-subquery" class="headerlink" title="5. 子查询-subquery"></a>5. 子查询-subquery</h1><p><strong>子查询</strong>：指的是一个查询语句被其他语句包裹，子查询和外部查询可以是任意表，不要求是同表；子查询总是从内向外处理；子查询可以迭代多次</p><pre class="line-numbers language-none"><code class="language-none">select * from (select_result) where condition in (select_result);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="5-1-分类"><a href="#5-1-分类" class="headerlink" title="5.1 分类"></a>5.1 分类</h2><p><strong>返回值分类</strong></p><ul><li>返回一个标量（单一值）：<strong>标量子查询</strong>，non_subquery_operand comparison_operator (subquery)，获得一个值后进行关系运算符进行运算（=  &gt;  &lt;  &gt;=  &lt;=  &lt;&gt;）</li><li>返回一行多列：<strong>行子查询</strong>，在使用时用括号构建对应字段，用运算符进行运算，(字段1，字段2) = （select 字段1，字段2 from 表 limit 1）</li><li>返回多行一列：<strong>列子查询</strong>，进行集合运算（in），operand IN|NOT IN/ANY/SOME (subquery)</li><li>返回一张表/多行多列：<strong>表子查询</strong>，通常用于from里，需要起别名，（字段1，字段2） = （select 字段1， 字段2 from 表 ）</li></ul><p><strong>出现位置分类</strong></p><ul><li><strong>Where型子查询</strong>：where 比较规则 (subquery);</li></ul><pre class="line-numbers language-none"><code class="language-none">select * from employees awhere not exists (    select emp_no from dept_emp b    where a.emp_no &#x3D; b.emp_no);-- 查找 employees 表中 emp_no 不出现在 dept_emp 表中的所有信息<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>from型子查询</strong>：from (subquery) as tmp_table;（必须要有[AS] name ，因为FROM子句中的每个表必须有一个名称）</li></ul><p><strong>注意</strong>：</p><ul><li>子查询必须位于小括号中</li><li>子查询外部语句可以是：SELECT, INSERT, UPDATE, DELETE, SET 或 DO</li><li>不能在子查询时修改</li></ul><h1 id="6-校对规则"><a href="#6-校对规则" class="headerlink" title="6. 校对规则"></a>6. 校对规则</h1><p><strong>校对规则</strong>：比较数据的大小关系，进行排序操作；如果参与比较的数据类型不同，则会发生类型转换<br><strong>显示校对规则</strong></p><pre class="line-numbers language-none"><code class="language-none">show collation;   -- 显示所有可用的校对，以及它们适用的字符集；区分大小写由_cs表示，不区分大小写由_ci表示show variables like &#39;character%&#39;;  -- 显示字符集show variables like &#39;collation%&#39;;  -- 显示排序规则<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>设定字符集</strong></p><pre class="line-numbers language-none"><code class="language-none">create table tb_name(...)default character set hebrew collate hebrew_general_ci;可针对列设置字符集create table tb_name(...col_name varchar(10) character set latinl collate latinl_general_ci)default character set hebrew collate hebrew_general_ci;临时设置比较规则，COLLATE 还可以用于 GROUP BY、HAVING、聚集函数、别名等select user_id from user_info order by first_name collate latinl_general_ci desc;可以使用 Cast() 或 Convert() 函数实现串在字符集之间转换<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-库表数操作</title>
      <link href="/202105/1542888.html"/>
      <url>/202105/1542888.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍MySQL的基础-数据库表、数据相关操作的基础知识</p><span id="more"></span><h1 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1. 数据库"></a>1. 数据库</h1><p><strong>创建数据库</strong>：create database [if not exists] db_name [数据库选项];</p><blockquote><p>db_name：可以使用任意字符的组合，纯数字，特殊字符，mysql需要用反引号作为限定符标识，可以使用中文(不建议使用)；见名知意，推荐使用下划线命名法<br>数据库选择可以设定数据库字符集(character set utf8)和校对集(collate utf8_general_ci)等<br>创建成功，会在mysql的data目录下形成一个以数据库名为名称的目录，里面有一个db.opt文件，用于存储数据库的库选项信息</p></blockquote><p><strong>删除数据库</strong>：drop database [if exists] db_name; 删除一个数据库时，同时删除该数据库相关的目录及其目录内容</p><p><strong>修改数据库</strong>：alter database db_name [修改指令(数据库信息的修改)];</p><pre class="line-numbers language-none"><code class="language-none">例： alter database db_name character set gbk;数据库改名：数据库不支持 rename 操作；1. 新建数据库，插入源数据库数据；2. 创建一个新数据库，将表都移动到新数据库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>选择数据库：use db_name;</p><pre class="line-numbers language-none"><code class="language-none">show databases [like ‘xxx’];  -- 列出所有数据库show create database db_name  -- 查看创建数据库的DDLshow tables;  -- 列出默认数据库的所有表show tables from db_name;  -- 列出指定数据库的所有表<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h1 id="2-数据表"><a href="#2-数据表" class="headerlink" title="2. 数据表"></a>2. 数据表</h1><h2 id="2-1-创建"><a href="#2-1-创建" class="headerlink" title="2.1 创建"></a>2.1 创建</h2><p><strong>创建数据表</strong>：创建一个表，会在数据目录创建对应的文件保存表信息；tb_name 命名规范与 db_name 相同，可使用逻辑前缀或后缀进行区分</p><pre class="line-numbers language-none"><code class="language-none">create table [if not exists] tb_name(列定义) [表选项(引擎:engine|type,字符集:charset set,校对集:collate)]  [注释(comment)];create table if not exists tb_user_info( user_id int NOT NULL AUTO_INCREMENT,  -- 设置自增长user_name char(20) NOT NULL,user_sex boolean DEFAULT 1,           -- 设置默认值，即默认值约束user_address varchar(100),user_Email char(30) unique            -- 设置唯一值约束PRIMARY KEY(user_id),                 -- 申明主键FULLTEXT(user_address)                -- 申明全文本索引)ENGINE &#x3D; InnoDB DEFAULT CHARSET&#x3D;utf8mb4 ROW_FORMAT&#x3D;DYNAMIC COMMENT &#x3D; &#39;客户信息表&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-1-1-表选项"><a href="#2-1-1-表选项" class="headerlink" title="2.1.1 表选项"></a>2.1.1 表选项</h3><p><strong>引擎类型</strong>：ENGINE ，也叫表类型，指的是数据表的存储机制，索引方案等配套相关功能；具体管理和处理数据的内部引擎，引擎在内部处理 SQL请求；MySQL 具有多种引擎，都隐藏在MySQL服务器内，为不同的任务选择正确的引擎以获得良好的功能和灵活性</p><p><strong>选择表的存储引擎的标准</strong></p><ul><li>是否需要事务支持</li><li>是否支持外键</li><li>并发量的要求</li><li>错误恢复的处理</li><li>是否支持某些具体功能</li></ul><h3 id="2-1-2-列定义"><a href="#2-1-2-列定义" class="headerlink" title="2.1.2 列定义"></a>2.1.2 列定义</h3><p><strong>设置主键</strong>：PRIMARY KEY，数据唯一且不为空，支持多列组合主键，多列用逗号‘，’分隔；唯一标识一条记录，提高数据检索效率</p><pre class="line-numbers language-none"><code class="language-none">create table tb_anme(    col_name d_type(length) primary key,  -- 在定义表的时候直接在列定义时指明；);create table tb_anme(    col_name d_type(length),    primary key (col_name),  -- 在完成表定义时，在小括号内部指明主键列);例：create table tb_anme(    user_id char(9) primary key  -- 最后一个字段前不需要加逗号,);create table tb_anme(    user_id char(9),    user_name varchar(30),    PRIMARY KEY(user_id, user_name)  -- 定义组合主键，（id， name） 组合构成主键);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>设置外键</strong>：FOREIGN KEY，关联其他表的主键，不能跨引擎使用，col_name 必须是其他表的主键；保证数据的完成性，提高数据检索效率</p><pre class="line-numbers language-none"><code class="language-none">create table tb_anme(    col_name foreign key references tb_name (col_name),);create table tb_anme(    CONSTRAINT cons_name foreign key(col_name) references tb_name (col_name) [on delete set null],  -- 其余的列定义约束都有上述两种增加方式);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>**唯一约束(unique)**：该列的所有数据都唯一</p><pre class="line-numbers language-none"><code class="language-none">col_name uniqueuser_id char(9) unique<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>指定默认值</strong>：DEFAULT，性别在未给出数据的情况下使用 1-男性；不允许使用函数作为默认值，只支持常量</p><pre class="line-numbers language-none"><code class="language-none">col_name default value,sex bool default 1,<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>**空值约束(NOT NULL)**：表示没有值，什么都没有，与任何数据不同；如果一个列不允许为空，但是在赋值时，没有为该字段赋值，则会报错；使用 is null or is not null来判断，不能直接比较=/&gt;null</p><pre class="line-numbers language-none"><code class="language-none">col_name [not null]user_id char(9) not null, 表名 user_id 不允许为空，省略 not null 表明该列可以为空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>设置自增长</strong>：AUTO_INCREMENT，每当增加一行时该列自动增长，每个表只允许一个AUTO_INCREMENT 列，且必须被索引；可通过 last_insert_id() 函数获得最后一个```</p><pre class="line-numbers language-none"><code class="language-none">col_name AUTO_INCREMENT valueuser_id char(5) AUTO_INCREMENT &#39;00001&#39;, user_id 列从 00001 开始，每增加一行，数据自动加一<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="2-1-2-1-修改列定义"><a href="#2-1-2-1-修改列定义" class="headerlink" title="2.1.2.1 修改列定义"></a>2.1.2.1 修改列定义</h4><p><strong>增加约束</strong>：对数据列添加相关的约束条件，满足数据使用需求；都支持在表定义的时候添加，也支持表定义后单独添加</p><pre class="line-numbers language-none"><code class="language-none">alter table tb_name add constraint constraint_name constraint_type (column_name) [on delete&#x2F;update cascade(级联操作)&#x2F;restrict(不允许操作)&#x2F;set null];alter table test add constraint unique_constraint unique unique (id,name); 在test表的(id,name)组合增加唯一性约束，省略约束名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**主键约束(Primary Key)**：表中的一个或多个字段，唯一标识一条记录的字段集合，只能有一个主键；尽量不使用真实实体的属性，利用一个或多个与实体不相关的字段，作为唯一标识，主键不能为空，不能重复，看成一个唯一索引</li></ul><pre class="line-numbers language-none"><code class="language-none">alter table test add constraint P_Key primary Key (id);删除主键:alter table tb_name drop primary key; 主键字段原则上在插入后，不应该修改，但是语法支持，要求修改后的值不能与已有值冲突<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>**外键约束(Foreign Key)**：如果A表的一个字段指向B表的主键，则此字段就为A表的外键。用于表示表之间的关系：存在外键的表，称之为从表(子表)，外键指向的表，称之为主表(父表)，一个表可以有外键，可以重复、可以为空；保持数据一致性，参照完整性，主要目的是控制存储在外键表(从表)中的数据；只有innodb存储引擎支持外键，其他引擎不支持</li></ul><pre class="line-numbers language-none"><code class="language-none">alter table tb_name_p add [foreign_key_name] foreign key (col_name) references tb_name_s(col_name);ALTER TABLE audit ADD FOREIGN KEY (EMP_no) REFERENCES employees_test (ID); 在 audit 表的 EMP_no 字段上添加外键约束，引用 employees_test 表的ID字段，省略外键名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>**唯一约束(unique)**：该列的所有数据都唯一</p><pre class="line-numbers language-none"><code class="language-none">alter table tb_name add constraint unique_name unique(col_name);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>**自动增长约束(auto_increment)**：column_name auto_increment，整型，必须建立在索引之上，通常定义在主索引(主键)字段上；通常自动增长是从1开始递增，可以通过修改表属性，更改初始值</p></li></ul><pre class="line-numbers language-none"><code class="language-none">alter table tb_name auto_increment value; 可重复设置，新增数据从最大值开始增长，可以手动插入数据(可重复插入，可更新)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p><strong>级联操作约束</strong>：主表改变时，从表的反应</p><pre class="line-numbers language-none"><code class="language-none">1. cascade ：关联操作，从表进行相应操作：主表数据更新(主键值更新)，从表也更新(外键值更新)；主表记录删除，从表相关记录也删除。2. set null：设为null，不在指向任何主表记录，主表数据被更新(主键值更新)，从表的外键被设置为null3. restrict：拒绝，拒绝主表的相关操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>检查约束(CHECK)</strong></p></li><li><p>**默认值约束(DEFAULT)**：为列指定一个默认值，当该字段不存在值时启用；默认值必须是常数，不能是函数或表达式；如果该列可以为空，则默认值为null；blob，text数据列不能有默认值；时间戳类型，可以设置一个特殊的默认值 CURRENT_TIMESTAMP；在当列不存在或者传递的值为null时，使用当前的时间戳</p></li><li><p>**空值约束(NOT NULL)**：表示没有值，什么都没有。与任何数据不同。如果一个列不允许为空，但是在赋值时，没有为该字段赋值，则会报错。使用 is null or is not null来判断，不能直接比较=/&gt;null</p></li><li><p><strong>注释</strong>：进行字段描述</p><pre class="line-numbers language-none"><code class="language-none">column_name comment ‘description’;comment on column tb_name. column_name is ‘description’;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>其他</strong>：MySQL回味每一条记录加上三个属性：trx_id(事务ID)、roll_point(回滚指针，存储历史版本数据的地址)、row_id(行号)</p><h3 id="2-1-3-快速创建"><a href="#2-1-3-快速创建" class="headerlink" title="2.1.3 快速创建"></a>2.1.3 快速创建</h3><pre class="line-numbers language-none"><code class="language-none">create table [if not exists] tb_name like old_tb_name;create table [if not exists] tb_name select 结果集;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h2 id="2-2-修改"><a href="#2-2-修改" class="headerlink" title="2.2 修改"></a>2.2 修改</h2><p><strong>删除表</strong>：表名不存在无法删除，可同时删除多个表，表名之间用逗号分割，没有确认，不能撤销</p><pre class="line-numbers language-none"><code class="language-none">drop table [if exists] tb_name [CASCADE]; <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>重命名</strong>：可同时重命名多个表，表名之间用逗号分割；剪切复制，可以跨库操作</p><pre class="line-numbers language-none"><code class="language-none">rename table old_tb_name to new_tb_name[, old_tb_name to new_tb_name];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>更新表</strong>：更新表定义，即表结构</p><pre class="line-numbers language-none"><code class="language-none">增加：alter table tb_name add 列定义 after col_name|first（第一列）删除：alter table tb_name drop col_name;修改：alter table tb_name modify 列定义; -- 修改数据类型重命名：alter table tb_name charge old_col_name new_col_name 列定义;修改表选项：alter table tb_name 新表选项;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-3-查看"><a href="#2-3-查看" class="headerlink" title="2.3 查看"></a>2.3 查看</h2><pre class="line-numbers language-none"><code class="language-none">查看所有表：show tables [like &#39;_&#x2F;%xxx&#39;];查看表的DDL：show create table tb_name;查看表的描述性信息：show table status from db_name;描述表：describe&#x2F;desc tb_name;查看列信息：show columns from tb_name;查看索引信息：show index from tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-视图"><a href="#2-4-视图" class="headerlink" title="2.4 视图"></a>2.4 视图</h2><p><strong>视图</strong>：是一个虚拟表，视图不保存数据，通过完成相应的SQL语句得到相应数据，视图的内容可以来自当前或其它数据库的一个或多个表，或者其它视图；视图常用来缩减业务逻辑，保存复杂逻辑，通常只对视图只进行简单逻辑操作</p><p><strong>优点</strong>：</p><ul><li>视图保存查询的快照，可以简化查询操作，使复杂的查询易于理解和使用</li><li>可以隐藏数据，提高数据的安全性，将用户的访问权限限制在列上，用户能以多种角度看待同一张数据表</li><li>重用SQL语句，简化复杂的SQL操作</li><li>重新格式化检索出的数据，满足使用数据的需要</li><li>过滤掉不需要的数据</li><li>为数据库提供一定程度的逻辑独立性</li></ul><p><strong>规则</strong>：</p><ul><li>视图名必须唯一，且不能与表重名；可以在查询时重命名列名作为视图的列名</li><li>创建视图的数目没有限制</li><li>视图可以嵌套，即可从视图中检索创建新视图</li><li>视图不能索引，也不能有关联的触发器或默认值</li><li>视图可以和表一起关联查询使用</li><li>创建视图中拥有 where 子句，基于视图的查询也拥有 where 子句，二者将会自动组合过滤</li><li><strong>可以进行插入、更新、删除，最终还是操作基表，即时生效</strong>，如果 MySQL 不能正确地确定被更新的基数据，则不允许更新，包括插入和删除</li><li>视图定义中有 分组（使用GROUP BY和HAVING）、联结、子查询、并、聚集函数（Min()、Count()、Sum()等）、DISTINCT、导出（计算）列等不能进行更新操作</li></ul><h3 id="2-4-1-操作"><a href="#2-4-1-操作" class="headerlink" title="2.4.1 操作"></a>2.4.1 操作</h3><p><strong>创建视图</strong></p><pre class="line-numbers language-none"><code class="language-none">create [OR REPLACE] [ALGORITHM &#x3D; &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] view view_name as (select result);create view actor_name_view as select first_name first_name_v,last_name last_name_v from actor; 对 actor 表创建仅有first_name、last_name 两列，且视图字段名为 first_name_v、last_name_v 的actor_name_view 视图<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>删除视图</strong></p><pre class="line-numbers language-none"><code class="language-none">Drop view [if exists] view_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>修改视图</strong>：通过 algorithm 指定视图执行算法：</p><ul><li>Merge 合并，每当执行时，将视图的sql语句于外部操作语句混合在一起，最终执行</li><li>Temptable：临时表：每当执行时，将创建视图的sql语句生成一个临时表，之后对临时表进行操作，undefine进行创建</li></ul><pre class="line-numbers language-none"><code class="language-none">Alter view view_name as new_select_result;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>查看结构</strong></p><pre class="line-numbers language-none"><code class="language-none">SHOW CREATE VIEW view_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-数据"><a href="#3-数据" class="headerlink" title="3. 数据"></a>3. 数据</h1><h2 id="3-1-导入"><a href="#3-1-导入" class="headerlink" title="3.1 导入"></a>3.1 导入</h2><ol><li>在登录mysql的情况下：source  文件路径/文件名</li><li>在不登录的情况下：mysql -u 用户名 -p 密码 库名 &lt; 备份文件</li><li><strong>导入</strong>：</li></ol><pre class="line-numbers language-none"><code class="language-none">Load data infile ‘f_name’   -- 数据文件[REPLACE | IGNORE]     -- 主键冲突： Ignore(忽略) | REPLACE(替换)INTO TABLE tb_name     -- 目标表[FIELDS [TERMINATED BY &#39;string&#39;] [[OPTIONALLY] ENCLOSED BY &#39;char&#39;] [ESCAPED BY &#39;char&#39;]] -- 字段切割：fields terminated by &#39;\t&#39; enclosed by &#39;&#39; escaped by &#39;\\&#39;[LINES [STARTING BY &#39;string&#39;] [TERMINATED BY &#39;string&#39;]]   -- 记录行切割：lines terminated by &#39;\n&#39; starting by &#39;&#39;[IGNORE N LINES]   -- 跳过n行数据按照指定数据格式导入(默认)：字段使用逗号分割，而使用引号包裹<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-2-导出-备份"><a href="#3-2-导出-备份" class="headerlink" title="3.2 导出/备份"></a>3.2 导出/备份</h2><p><strong>命令行实用程序</strong>：mysqldump</p><ul><li>导出一张表：mysqldump -u用户名 -p密码 库名 表名 &gt; 文件保存路径/文件名</li><li>导出多张表：mysqldump -u用户名 -p密码 库名 表名1 表名2 表名3 &gt; 文件保存路径/文件名</li><li>导出所有表：mysqldump -u用户名 -p密码 库名 &gt; 文件保存路径/文件名</li><li>导出一个库：mysqldump -u用户名 -p密码 -B 库名 &gt; 文件保存路径/文件名</li><li>使用-w指明备份条件</li></ul><p><strong>MySQL语句</strong>：BACKUP TABLE 或 SELECT INTO OUTFILE，导出查询结果到文件；<br><strong>SELECT INTO OUTFILE</strong>：自动创建文件，但不能重写已有文件，默认采用换行符区分记录，制表符区分字段；支持配置字段分隔符、包裹符和转义符；配置行(记录)结束符和起始符，常使用逗号分割字段，引号包裹；导出的数据文件可以使用 LOAD DATA INFILE 语句载入到某个数据表内；支持 INTO dumpfile，作用与 outfile 一致，不做任何换行和转义处理导出结果到文件；常用来保存二进制数据；数据可以用 RESTORE TABLE 复原</p><pre class="line-numbers language-none"><code class="language-none">select * INTO outfile ‘文件地址&#x2F;文件名’   -- 目标文件fields(字段) terminated by ‘，’ starting by ‘aaa’ enclosed by  ‘bbb’ escaped by &#39;\\&#39;    -- 字段切割lines(记录) terminated by ‘\n’   -- 记录行切割from tb_name;   -- 源数据表每一行为一条数据，每个字段之间使用水平制表符分隔<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-插入"><a href="#3-3-插入" class="headerlink" title="3.3 插入"></a>3.3 插入</h2><pre class="line-numbers language-none"><code class="language-none">INSERT [LOW_PRIORITY] INTO tb_name (col_name_list) values (data_list) [on duplicat key update col_name &#x3D; data[,col_name&#x3D; data]]  (没有set); LOW_PRIORITY：降低 INSERT 语句的优先级Into：可以省略(不建议)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>INSERT INTO tb_name values (data_list);<br>不明确指定列名，语句高度依赖于表中列的定义次序，并不安全，应该尽量避免使用</li><li>INSERT INTO tb_name (col_name_list) values (data_list);<br>将位置相同的数据和字段一一对应，必须对每个列出的列给出一个值；即使表的结构改变，语句仍能正确工作</li><li><strong>INSERT INTO tb_name (col_name_list) values (), (), ();</strong><br>通过记录构造符，一次性插入多个值；批量插入时推荐，效率优于一条一条单独插入</li><li>INSERT INTO tb_name SELECT …;<br>将查询结果作为数据插入，要求结果的列名、数据类型与目标表一致，蠕虫复制</li><li>INSERT INTO tb_name set field=value,…;<br>使用set语法</li><li>INSERT INTO tb_name values (field_value, 10+10, now());<br>使用表达式</li><li>INSERT INTO tb_name values (field_value, default);<br>使用特殊值 default</li><li>INSERT IGNORE INTO tb_name (col_name_list) values (data_list);<br>出现主键冲突时忽略冲突记录不插入，插入其他不冲突的记录</li><li>INSERT INTO tb_name (col_name_list) values (data_list) on duplicate key update col_name = data, …;<br>指定在插入的值出现主键(或唯一索引)冲突时，更新其他非主键列的信息</li></ul><h2 id="3-4-删除"><a href="#3-4-删除" class="headerlink" title="3.4 删除"></a>3.4 删除</h2><pre class="line-numbers language-none"><code class="language-none">delete from tb_name [WHERE where_condition] [ORDER BY ...] [LIMIT N];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>支持多表删除：Delete from tb_name_1,tb_name_2 using 表连接条件</p></li><li><p>TRUNCATE [TABLE] tb_name; 清空数据，删除重建表</p></li><li><p>区别：</p><ol><li>truncate是删除表再创建空表，delete是逐条删除</li><li>truncate会重置 auto_increment 的值，delete不会</li><li>truncate不返回删除条数，delete会返回</li></ol></li></ul><h2 id="3-5-修改"><a href="#3-5-修改" class="headerlink" title="3.5 修改"></a>3.5 修改</h2><pre class="line-numbers language-none"><code class="language-none">update [LOW_PRIORITY] [IGNORE] tb_name set col_name &#x3D; data [WHERE where_condition] [ORDER BY ...] [LIMIT N];IGNORE：忽略插入过程中的错误，继续更新；正常出现错误就会把错误发生前更新的所有行恢复到原来的值支持更新多列，用逗号分隔多表更新：Update [LOW_PRIORITY]  [IGNORE] t1 join t2 on t1.x&#x3D;t2.x where cond;多表更新时ORDER BY和LIMIT不能被使用；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>替换</strong>： REPLACE INTO tb_name values (data_list);  存在更新，不存在插入。但如果表中的一个旧记录与一个用于PRIMARY KEY或一个UNIQUE索引的新记录具有相同的值，则在新记录被插入之前，旧记录被删除(替换原有记录)</li><li><strong>数据更改操作流程</strong>：数据产生变更时，会先在内存更改数据，当在特定时期再写入磁盘(频繁的I/O操作会降低性能)<br><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/Data_Change_Order.png" alt="Data_Change_Order"></li></ul><p><strong>脏页</strong>：指的是存储引擎内存中的数据与磁盘中的数据不一致，进行数据更改操作(增删改)时，会先写预写日志(WAL)，再更改内存中的数据，最后在合适时机进行脏页落盘</p><ol><li>将数据加载到Buffer Pool中</li><li>生成修改操作的redo log日志，写入redo log Buffer 缓冲(为降低I/O操作，提高效率)<ul><li>写日志的效率优于写数据的日志，所以先写日志，再写数据</li><li>redo log Buffer缓冲，采用 force log at commit 保证 redo log Buffer 在MySQL服务器宕机时将数据写入磁盘，force log at commit要求事务提交，立即刷新redo log Buffer，可通过 innodb_flush_log_at_trx_commit 参数进行设置，有效值：0-立即更新磁盘数据，1-每秒提交一次，默认，2</li></ul></li><li>当redo log Buffer 缓冲在指定的时间将缓冲区的 redo log 写入磁盘上的 id_logfile文件中</li><li>当磁盘上的 id_logfile文件写满时，会触发checkpoint机制，将Buffer Pool里的数据写入磁盘，清空id_logfile文件，循环使用</li><li>当Buffer Pool缓冲满时，也会触发checkpoint机制(控制脏页何时落盘)，将Buffer Pool里的数据写入磁盘<ul><li>保证脏页落盘，使用Double Write(双写日志) ：MySQL数据页的大小是16k，而操作系统的磁盘块大小是4k，需要四次写入，双写日志保证数据页数据更改失败时能够保证数据一致</li><li>Double Write由两部分组成：Double Write Buffer(大小2M)和物理磁盘上共享表空间连续的128个页，大小也为2M。</li><li>对缓冲区的脏页进行刷新时，先通过memcpy()函数将脏页先复制到内存中的double write buffer区域，分两次(每次1M)顺序写入共享空间的磁盘文件上，然后调用fsync()函数，同步磁盘，避免操作系统缓冲带来的问题。完成double write 页的写入后，再将double write buffer区域的页写入各个表空间文件</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-函数</title>
      <link href="/202105/1418874.html"/>
      <url>/202105/1418874.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 MySQL-函数 的相关基础知识</p><span id="more"></span><h1 id="1-聚合函数"><a href="#1-聚合函数" class="headerlink" title="1. 聚合函数"></a>1. 聚合函数</h1><ul><li><strong>统计数目</strong>：COUNT(col_name)，确定表中行的数目或符合特定条件的行的数目，</li></ul><pre class="line-numbers language-none"><code class="language-none">COUNT(col_name)：统计指定列中不为 null值的数据条数，默认不去重，可通过 distinct 进行去重 COUNT(distinct col_name)COUNT(*)：对表中行的数目进行计数，包括空值NULLCOUNT(1)：返回所有的记录<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>统计计算</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">MIN(col_name)     -- 返回指定列的最大值，只能计算一列，多列使用多个MAX(col_name)     -- 返回指定列的最小值，只能计算一列，多列使用多个SUM(col_name)     -- 返回指定列的总和，只能计算一列，多列使用多个AVG(col_name)     -- 返回指定列的均值，只能计算一列，多列使用多个<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>组内连接：GROUP_CONCAT(expr) </p><blockquote><p>聚合函数通常与group by一起使用，用于统计组内的信息；单独使用，则将所有行看成一组，不统计null值</p></blockquote></li></ul><h1 id="2-数学函数"><a href="#2-数学函数" class="headerlink" title="2. 数学函数"></a>2. 数学函数</h1><pre class="line-numbers language-none"><code class="language-none">Abs(X)           -- 绝对值，例：abs(-10.9) &#x3D; 10Ceil(X)          -- 向上取整，例：ceil(10.1) &#x3D; 11Cos()            -- 获取一个角度的余弦值Exp()            -- 返回一个数的指数值Floor(X)         -- 向下取整，例：floor (10.1) &#x3D; 10Format(X,D)      -- 格式化千分位数值，例：format(1234567.456, 2) &#x3D; 1,234,567.46Mod(M,N)         -- 求余 M%N &#x2F; M MOD N，例：10%3&#x3D;1Pow(M,N)         -- 乘方 M^NRand(X)          -- 随机数Pi()             -- 获得圆周率Round(X)         -- 四舍五入去整Sin()            -- 返回一个角度的正弦值Sqrt(X)          -- 算术平方根Tan()            -- 返回一个角度的正切值TRUNCATE(X,D)    -- 截取D位小数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="3-字符串函数"><a href="#3-字符串函数" class="headerlink" title="3. 字符串函数"></a>3. 字符串函数</h1><h2 id="3-1-获取信息"><a href="#3-1-获取信息" class="headerlink" title="3.1 获取信息"></a>3.1 获取信息</h2><ul><li>**CHARSE(str)**：返回字串字符集</li><li>**CHAR_LENGTH(str)/LENGTH(str)**：获取字符串str长度</li></ul><pre class="line-numbers language-none"><code class="language-none">CHAR_LENGTH(str)：（汉字、数字、字母都是一个字符），例：select CHAR_LENGTH(&#39;10,A,B,张&#39;);  -- 8select CHAR_LENGTH(&#39;10,A,B&#39;);  -- 6select CHAR_LENGTH(100);   -- 3LENGTH(str)：获取str长度（字符数，一个汉字算三个字符，字母算一个字符，几位数字算几个字符），例：select LENGTH(&#39;10,A,B,张&#39;);  -- 10select LENGTH(&#39;10,A,B&#39;);  -- 6select LENGTH(100);   -- 3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p>**INSTR(str, substring)**：从头寻找 str 中第一个 substring 出现的位置</p></li><li><p>**LOCATE(substring, str [,start_position])**：从 str 的 start_position 位置寻找第一个 substring 出现的位置<br><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/Position_Introduction.png" alt="Position_Introduction"></p><blockquote><p>position：指定子串的起始位置，position可以是正整数、负整数和零；position为正整数，按照字符顺序编号从指定位置截取到字符串末尾；position为负整数，按照字符逆序编号从指定位置截取到字符串末尾；position为零，返回一个空字符串</p></blockquote></li><li><p>**Soundex(str)**：返回字符串的Soundex值，即文本串转换为描述其语音表示的字母数字模式的算法值</p></li><li><p>**STRCMP(str1, str2)**：比较两字串大小：str1大，返回1；str2小，返回-1；二者一样大，返回0</p></li></ul><h2 id="3-2-拼接截取"><a href="#3-2-拼接截取" class="headerlink" title="3.2 拼接截取"></a>3.2 拼接截取</h2><ul><li>**CONCAT(str1,str2[,… ])**：拼接字串，将str1、str2…顺序拼接起来，可以列名将字段值进行顺序拼接</li></ul><pre class="line-numbers language-none"><code class="language-none">CONCAT(id,&quot;@@&quot;,name)，将id、@@和name里面的数据顺序拼接起来<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**GROUP_CONCAT( [DISTINCT] col_name  [Order BY col_name_list  ASC/DESC] [Separator ‘分隔符’] )**：将col_name字段的数据按照col_name_list进行排序，以分隔符进行区分，默认分隔符为逗号</li></ul><pre class="line-numbers language-none"><code class="language-none">select group_concat(emp_no) as employees from dept_emp group by dept_no;将dept_emp表按照dept_no进行分组，将同一个dept_no的emp_no字段里的数据拼接起来，以逗号分隔，将所得的字段重命名为employees<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>长度填充</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">LPAD(str, length, substr)：在 str 左边重复用 substr 填充直到字符串长度为 lengthRPAD(str, length, substr)：在 str 右边重复用 substr 填充直到字符串长度为 length<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>截取字符串</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">LEFT(str, length)：从 str 中的左边开始起取 length个字符RIGHT(str, length)：从 str 中的右边开始起取 length个字符SUBSTRING(str, position [,length])：从 str 的 position 开始（支持负索引），向右取 length 个字符，省略长度则全取出来-- SUBSTRING(&quot;QWERTYUIOP&quot;, -10, 4)：从 str 的 -10处向右取 4个字符<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-字符串修改"><a href="#3-3-字符串修改" class="headerlink" title="3.3 字符串修改"></a>3.3 字符串修改</h2><ul><li>**REPLACE(str, search_str, replace_str)**：在str中用replace_str替换search_str</li></ul><pre class="line-numbers language-none"><code class="language-none">select replace(&quot;10,A,B&quot;, &quot;,&quot;, &quot;&quot;);  -- 将字符串10,A,B里面的,替换为空——删除10,A,B里面的,<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><strong>去除空格</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">LTRIM(str)：去除前端的空格RTRIM(str)：去除后端的空格TRIM(str)： 去除左右两边的空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><strong>大小写切换</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">LCASE(&#39;str&#39;)：转换为小写Lower(&#39;str&#39;)：转换为小写Upper(&#39;str&#39;)：转换为大写UCASE(&#39;str&#39;)：转换为大写<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>**REPEAT(str, n)**：将 str 重复n次输出</li></ul><h1 id="4-时间日期函数"><a href="#4-时间日期函数" class="headerlink" title="4. 时间日期函数"></a>4. 时间日期函数</h1><p><strong>时间日期</strong>：推荐使用4位年进行存储，支持2位年，00-69为2000-2069，70-99为1970-1999</p><h2 id="4-1-时间获取"><a href="#4-1-时间获取" class="headerlink" title="4.1 时间获取"></a>4.1 时间获取</h2><ul><li>获取当前日期时间：NOW()/current_timestamp()，获取的是当前语句执行的时间，转换后的时间</li><li>获取当前日期时间：sysdate()，获取的是sysdate()函数执行的时间，转换后的时间</li><li>获得unix时间戳：Unix_timestamp()，时间戳</li><li>从时间戳获得时间：From_unixtime()，将时间戳转换为常用时间格式YYYY-MM-DD hh:mm:ss</li><li>获取当前日期：CURDATE()/Current_date()，使用：SELECT CURDATE(); 默认返回格式为YYYY-MM-DD</li><li>获取当前时间：CURTIME()/current_time()，使用：SELECT CURTIME(); 默认返回格式为hh:mm:ss</li><li>获取年份部分：Year(‘YYYY-MM-DD hh:mm:ss’)</li><li>获取月份部分：Month(‘YYYY-MM-DD hh:mm:ss’)</li><li>获取天部分：Day(‘YYYY-MM-DD hh:mm:ss’)</li><li>获取日期部分：Date(‘YYYY-MM-DD hh:mm:ss’)</li><li>获取时间部分：Time(‘YYYY-MM-DD hh:mm:ss’)</li><li>获取小时部分：Hour(‘YYYY-MM-DD hh:mm:ss’)</li><li>获取分钟部分：Minute(‘YYYY-MM-DD hh:mm:ss’)</li><li>获取秒钟部分：Second(‘YYYY-MM-DD hh:mm:ss’)</li><li>返回日期对应的星期几：DayOfWeek(‘YYYY-MM-DD hh:mm:ss’)</li></ul><table><thead><tr><th>Unit单位记法</th><th>单位描述</th></tr></thead><tbody><tr><td>FRAC_Second</td><td>毫秒</td></tr><tr><td>Second</td><td>秒</td></tr><tr><td>Minute</td><td>分钟</td></tr><tr><td>Hour</td><td>小时</td></tr><tr><td>Day</td><td>天</td></tr><tr><td>Week</td><td>星期</td></tr><tr><td>Month</td><td>月</td></tr><tr><td>Quarter、</td><td>季度</td></tr><tr><td>Year</td><td>年</td></tr></tbody></table><ul><li>返回日期/时间的某一部分：EXTRACT(unit FROM date), 使用：SELECT XTRACT(unit FROM date);</li></ul><h2 id="4-2-时间计算"><a href="#4-2-时间计算" class="headerlink" title="4.2 时间计算"></a>4.2 时间计算</h2><ul><li>**TIMESTAMPDIFF(unit,datetime1,datetime2)**：计算 datetime2 - datetime1在unit单位下的时间间隔</li><li>**DATEDIFF(datetime1,datetime2)**：计算 datetime1 - datetime2 相隔的天数</li><li>**DATE_ADD(datetime, INTERVAL number unit)**：计算 datetime 加上 number个unit单位的时间间隔</li><li>**DATE_SUB(datetime, INTERVAL number unit)**：计算 datetime 减去 number个unit单位的时间间隔</li><li>**to_days(‘YYYY-MM-DD hh:mm:ss’)**：返回从0000年（公元1年）到指定日期的总天数</li></ul><h2 id="4-3-时间操作"><a href="#4-3-时间操作" class="headerlink" title="4.3 时间操作"></a>4.3 时间操作</h2><ul><li>**sleep(num)**：沉睡指定时间，默认单位是秒</li><li><strong>日期格式化</strong>：date_format(&lt; data(‘YYYY-MM-DD hh:mm:ss’) &gt;,&lt; format(‘%D %y %a %d %m %b %j’) &gt;)，将 data 按照 format 的格式输出</li></ul><h1 id="5-流程控制函数"><a href="#5-流程控制函数" class="headerlink" title="5. 流程控制函数"></a>5. 流程控制函数</h1><h2 id="5-1-分支语句"><a href="#5-1-分支语句" class="headerlink" title="5.1 分支语句"></a>5.1 分支语句</h2><ul><li><strong>IF语句</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">IF search_condition THEN statement_list[ELSEIF search_condition THEN statement_list] ...[ELSE statement_list]END IF;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><strong>CASE语句</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">CASE case_valueWHEN when_value THEN statement_list[WHEN when_value THEN statement_list]...[ELSE statement_list]END as col_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-2-循环语句"><a href="#5-2-循环语句" class="headerlink" title="5.2 循环语句"></a>5.2 循环语句</h2><pre class="line-numbers language-none"><code class="language-none">While[begin_label_name:] WHILE search_condition DOstatement_listEND WHILE [begin_label_name];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>提前终止 while循环，则需要使用标签；标签需要成对出现。</li><li>退出整个循环 leave(break)</li><li>退出当前循环 iterate(continue)</li><li>通过退出的标签决定退出哪个循环</li></ul><h1 id="6-窗口函数"><a href="#6-窗口函数" class="headerlink" title="6. 窗口函数"></a>6. 窗口函数</h1><p>也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理</p><h2 id="6-1-聚合窗口"><a href="#6-1-聚合窗口" class="headerlink" title="6.1 聚合窗口"></a>6.1 聚合窗口</h2><p>select *, <strong>sum</strong>()    OVER ([PARTITION BY col_name] ORDER BY col_name 排序规则) from tb_name;</p><p>select *, <strong>avg</strong>()      OVER ([PARTITION BY col_name] ORDER BY col_name 排序规则) from tb_name;</p><p>select *, <strong>count</strong>()  OVER ([PARTITION BY col_name] ORDER BY col_name 排序规则) from tb_name;</p><p>select *, <strong>max</strong>()     OVER ([PARTITION BY col_name] ORDER BY col_name 排序规则) from tb_name;</p><p>select *, <strong>min</strong>()      OVER ([PARTITION BY col_name] ORDER BY col_name 排序规则) from tb_name;</p><p>在不改变源数据的基础上，在每一列最后增加一列，数据为对应的聚合值</p><h2 id="6-2-排序窗口"><a href="#6-2-排序窗口" class="headerlink" title="6.2 排序窗口"></a>6.2 排序窗口</h2><ul><li>**DENSE_RANK()**：生成连续序号，出现相同排名时，不跳过相同排名号，例：1，2，2，3</li></ul><pre class="line-numbers language-none"><code class="language-none">select *, DENSE_RANK() OVER (PARTITION BY col_name ORDER BY col_name 排序规则) as drank_num from tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**RANK()**：如果有并列名次的行，会占用下一名次的位置，但相同名词一致，例：1，2，2，4</li></ul><pre class="line-numbers language-none"><code class="language-none">select *, RANK() OVER (PARTITION BY col_name ORDER BY col_name 排序规则) as rank_num from tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**ROW_NUMBER()**：不考虑并列名次的情况，顺序排列，例：1，2，3，4<br>聚合函数可以作为窗口函数，用法类似，在聚合函数参数位置填入需要计算的列名</li></ul><pre class="line-numbers language-none"><code class="language-none">select *, ROW_NUMBER() OVER (PARTITION BY col_name ORDER BY col_name 排序规则) as row_num from tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>**NTILE(num)**：按 col_name 分组平均分成 num组</li></ul><pre class="line-numbers language-none"><code class="language-none">select *, NTILE(num) OVER (PARTITION BY col_name ORDER BY col_name 排序规则) as NTILE_num from tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="6-3-其他"><a href="#6-3-其他" class="headerlink" title="6.3 其他"></a>6.3 其他</h2><p>用于同列中相邻行的数据计算操作</p><ul><li><strong>lag</strong>(col_name, num) over ()：用于统计函数向上第 num行的值；末行会为空</li><li><strong>lead</strong>(col_name, num) over ()：用于统计函数向下第 num行的值；首行会为空</li></ul><pre class="line-numbers language-none"><code class="language-none">select *, lag(col_name, 1) OVER (PARTITION BY col_name ORDER BY col_name 排序规则) from tb_name;    # 读取相同列上一行的数据置于本行新增列中，便于数据计算select *, lag(col_name, 1) OVER (PARTITION BY col_name ORDER BY col_name 排序规则) from tb_name;    # 读取相同列下一行的数据置于本行新增列中，便于数据计算<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li><strong>first_value</strong>(col_name) over ()：取分组内排序后，截止到当前行的第一个值</li><li><strong>last_value</strong>(col_name) over ()：取分组内排序后，截止到当前行的最后一个值</li></ul><pre class="line-numbers language-none"><code class="language-none">select *, first_value(col_name, 1) OVER (PARTITION BY col_name ORDER BY col_name desc)rows between unbounded preceding and current row         -- 取当前行与之前行的数据进行比较；向上不限，向下当前行；支持数字；窗口函数的默认统计范围from tb_name;select *, last_value(col_name, 1) OVER (PARTITION BY col_name ORDER BY col_name desc)rows between unbounded preceding and unbounded following -- 取之前前行与之后行的数据进行比较；向上不限，向下不限；支持数字from tb_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7. 其他函数"></a>7. 其他函数</h1><ul><li>**LOAD_FILE(file_name)**：从文件读取内容</li><li>**ifnull(value_1,value_2)**：如果数据为null，将数据设为value_2；如果数据不为null，将数据设为value_1</li><li>cast(values as type)：将value转换为指定的类型type</li><li>convert(values, type)：将value转换为指定的类型type<ul><li>有符号整数 : SIGNED、无符号整数 : UNSIGNED</li><li>浮点数 : DECIMAL、字符型 : CHAR()，可带参数</li><li>日期 : DATE、时间 : TIME、日期时间型 : DATETIME</li><li>二进制，同带binary前缀的效果 : BINARY</li></ul></li><li>md5()：获取md5的hash值</li><li>default()：指定默认值</li><li>INTERVAL(N,N1,N2,N3,…)：返回指定位置</li><li>LEAST(value1,value2,…)：返回最小值</li><li>GREATEST(value1,value2,…)：返回最大值</li><li>COALESCE(value,…)：找到第一个非零的值</li></ul><h1 id="8-SQL编程"><a href="#8-SQL编程" class="headerlink" title="8. SQL编程"></a>8. SQL编程</h1><p><strong>SQL编程</strong>：将多条SQL组合到一起完成相应的业务逻辑</p><h2 id="8-1-语句块"><a href="#8-1-语句块" class="headerlink" title="8.1 语句块"></a>8.1 语句块</h2><p><strong>语句块</strong>：以begin开始，end结束，Delimiter修改命令结束符，使用\G作为语句结束符，进行格式化输出，以\g，\G作为结束符</p><pre class="line-numbers language-none"><code class="language-none">Delimiter aaBeginSQL_listEndaadelimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="8-2-变量"><a href="#8-2-变量" class="headerlink" title="8.2 变量"></a>8.2 变量</h2><p><strong>变量</strong>：允许用户自己定义变量，即为用户变量（用户自定义变量）</p><ul><li>定义变量<ul><li>Set @var = value;</li><li>Select @v1:=id, @v2=name from tb_name limit 1：使用select into语句为变量初始化并赋值。要求select语句只能返回一行多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</li><li>select - from tb_name where @var:=30：通过select执行表达式完成变量初始化并赋值。</li><li>为了避免=被当作关系运算符看待，使用赋值运算符:=代替。（set语句可以使用= 和 :=）。</li><li>避免用户自定义的变量与系统标识符（通常是字段名）重复，用户自定义变量在变量名前使用@作为开始符号。</li><li>变量被定义后，在整个会话周期都有效（登录到退出），会话结束（连接结束），释放变量，全局可用</li></ul></li><li>使用declare定义函数内变量，参数位置局部变量<ul><li>Declare I int default 0;</li></ul></li><li>局部变量声明：<ul><li>DECLARE var_name[,…] type [DEFAULT value] </li><li>需要给变量提供一个默认值（DEFAULT子句），值可以被指定为一个表达式。如果没有DEFAULT子句，初始值为NULL</li></ul></li><li>使用：语序使用 set 和 select into语句为变量赋值。</li><li>注意在函数内是可以使用全局变量（用户自定义的变量的）</li></ul><h2 id="8-3-创建"><a href="#8-3-创建" class="headerlink" title="8.3 创建"></a>8.3 创建</h2><p><strong>创建函数</strong>：<br><strong>Create function function_name (参数列表：paramter_list) returns 返回值类型(返回值长度)</strong><br><strong>函数体：SQL_list</strong></p><ul><li>function_name：函数名，唯一标识函数，不能与已有的关键字冲突，可以使用db_name.funciton_name指明当前函数的所属数据库，否则为当前数据库</li><li>paramter_list：参数部分，由参数名和参数类型组成</li><li>返回值类类型：一定要有return返回值</li><li>函数体：由多条可用的mysql语句组成，包括流程控制、变量声明等语句构成；多条语句应该使用begin end语句块包含</li></ul><p>删除函数：Drop function if exists function_name;</p><p>查看函数：</p><pre class="line-numbers language-none"><code class="language-none">Show function status like &#39;partten&#39;;Show create function function_name;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改函数：Alter function function_name 函数选项</p><p><strong>调用函数</strong>：select function_name(paramter_list);</p><pre class="line-numbers language-none"><code class="language-none">-- 例：随机生成学生名字drop function if exists sname;delimiter $$create function sname () returns char(2)begindeclare first_name char(16) default &#39;赵钱孙李周吴郑王冯陈褚卫蒋沈韩杨&#39;;declare last_name char(10) default &#39;军勇鹏朗皓俊刚轩峰昊&#39;;declare full_name char(2);set full_name &#x3D; concat(substring(first_name, floor(rand()- 16+1), 1), substring(last_name, floor(rand()- 10+1), 1));return full_name;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-- 例：随机生成字符串delimiter $$create function ran_string(n int) returns varchar(255)begindeclare chars_str varchar(100) default &#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#39;;declare return_str varchar(255) default &#39;&#39;;declare i int default 0;while i &lt; n doset return_str &#x3D; concat(return_str,substring(chars_str,floor(1+rand()*52),1));set i&#x3D;i+1;end while;return return_str;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">-- 例：随机生成数字delimiter $$create function rand_num() returns int(5)begindeclare i int default 0;set i&#x3D;floor(100+rand()*10);return i;end $$delimiter ;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础-数据类型</title>
      <link href="/202105/1341093.html"/>
      <url>/202105/1341093.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 MySQL的-数据类型 的相关基础知识</p><span id="more"></span><h1 id="1-数值型"><a href="#1-数值型" class="headerlink" title="1. 数值型"></a>1. 数值型</h1><p><strong>整数</strong>：tinyint，smallint，mediumint，int/integer，bigint，column+0可以展示整数值，依次为1，2，3，4，8个字节整数</p><pre class="line-numbers language-none"><code class="language-none">TINYINT[(M)]  [UNSIGNED]  [ZEROFILL]M，表示显示宽度，不限制数值的范围，配合 zerofill ：前导零填充使用，在小于显示宽度的位数前增加0；zerofill 默认为 unsigned：表示无符号，只表示正数布尔类型 bool，就是 tinyint(1)的别名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>小数</strong>：</p><ul><li><strong>浮点型</strong>：小数点可以浮动（float：六到七位，double：十六位左右）<pre class="line-numbers language-none"><code class="language-none">单精度：FLOAT[(M,D)]  [UNSIGNED]  [ZEROFILL]双精度：DOUBLE[(M,D)]  [UNSIGNED]  [ZEROFILL]M表示总位数，D表示小数位数，可控制保存范围；省略M,D会根据计算机硬件进行处理；单精度：M大约为7；双精度：M大约为15Float(10,2) unsigned zerofill：总长10位，整数8位，小数2位，支持科学记数法，存储范围是 -99999999.99 到 99999999.99；长度不够左边补零，不表示正负<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><strong>定点型</strong>：可以存储比 bigint 还大的整型，能存储精确的小数，可以理解成用字符串进行处理，效率低于 float、double<pre class="line-numbers language-none"><code class="language-none">DECIMAL[(M[,D])]  [UNSIGNED]  [ZEROFILL]M表示总位数，D表示小数位数，可控制保存范围；M，D省略，默认为10,0；可以使用unsigned，但不会影响范围decimal(10,0) unsigned zerofill：总长10位，整数10位，存储范围是 -9999999999 到 9999999999，数据不会丢失，四舍五入截断；长度不够左边补零，不表示正负<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><table><thead><tr><th>类型</th><th>占用字节数</th><th>最小值(有符号/无符号)</th><th>最大值(有符号/无符号)</th></tr></thead><tbody><tr><td>tinyint</td><td>1</td><td>-128 / 0</td><td>127 / 255</td></tr><tr><td>smallint</td><td>2</td><td>-32768 / 0</td><td>32767 / 65535</td></tr><tr><td>mediumint</td><td>3</td><td>-8388608 / 0</td><td>8388607 / 16777215</td></tr><tr><td>int / intege</td><td>4</td><td>-2147483648 / 0</td><td>2147483647 / 4294967295</td></tr><tr><td>bigint</td><td>8</td><td>-9223372036854775808 / 0</td><td>9223372036854775807 / <br>1844674407709551615</td></tr><tr><td>float</td><td>4</td><td>-3.402823466 * E^38</td><td>-3.402823466 * E^38</td></tr><tr><td>double</td><td>8</td><td>-1.7976931348623157 * E^38</td><td>1.7976931348623157 * E^38</td></tr><tr><td>decimal</td><td>8</td><td>2-(65个9)</td><td>65个9</td></tr></tbody></table></li></ul><h1 id="2-时间日期"><a href="#2-时间日期" class="headerlink" title="2. 时间日期"></a>2. 时间日期</h1><p><strong>Datatime</strong>：以YYYY-MM-DD HH:MM:SS格式存储日期时间，精确到秒，占用8个字节，datatime 类型与时区无关；存储范围 1000-01-01 00:00:00 - 9999-12-31 23:59:59，可以区分任意分隔符的日期时间，不建议</p><p><strong>Date</strong>：日期（年月日），datetime 的 date 部分，占用3个字节，存储年月日，可利用日期时间函数计算天数差；</p><p><strong>Time</strong>：时间，可以是 datetime 的 time 部分，必须使用: 进行分隔，表示为 HH:II:SS；也可以是两个时间的间隔，表示为 D HH:II:SS，可以使用其他标点符号作为分隔符，甚至不用</p><p><strong>year</strong>：存储范围 1901 - 2155，一个字节</p><p><strong>month</strong>：月</p><p><strong>day</strong>：日期（某一月的具体天）</p><p><strong>Timestamp</strong>：以时间戳格式存储，存储为整型数值，占用4个字节，范围是1970-01-01 00:00:00 - 2038-1-19，表现为日期时间型，显示依赖指定的时区，加 0 显示时间戳类型，支持0000-00-00 00:00:00：逻辑整年；默认在第一列的数据修改时自动修改对应行的timestamp列的数据</p><blockquote><p>DATETIME，DATE，TIMESTAMP 在保存数据时，会对数据格式的合法性进行验证，不验证日期时间的合法性；年月日时分秒的分隔符可以是任意的标点，甚至可以不使用，常用的是-和: ；可以使用2位的年，表示范围：1970-2069<br>TIMESTAMP：时间戳，年份是一个范围，在一定范围内的数均表示同一年</p></blockquote><table><thead><tr><th>类型</th><th>占用字节数</th><th>最小值(有符号/无符号)</th><th>最大值(有符号/无符号)</th></tr></thead><tbody><tr><td>datetime</td><td>8</td><td>1001-01-01 00:00:00</td><td>9999-12-31 23:59:59</td></tr><tr><td>timestamp</td><td>4</td><td>1970-01-01 00:00:00</td><td>2038-01-19 03:14:07</td></tr><tr><td>date</td><td>3</td><td>1001-01-01</td><td>9999-12-31</td></tr><tr><td>time</td><td>3</td><td>-838:59:59</td><td>838:59:59</td></tr><tr><td>year</td><td>1</td><td>1901</td><td>2155</td></tr></tbody></table><h1 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h1><p>**char(m)**：定长，限定长度，保存时如果字符串长度不够，则后边补足空字符串，超出设置的长度时，内容会被截断，效率快；但浪费空间</p><p>**varchar(m)**：变长，最大长度，用一个字节保存字符串总长度，小于255采用一个字节保存，否则采用二个字节保存，超出设置的长度时，内容会被截断，空间利用高；但查询效率慢</p><blockquote><p>CHAR 和 VARCHAR 类型声明的长度表示想要保存的最大字符数<br>一条记录的总长度是 65535 ；所有字段的总长度不能超过该值；unicode 最大存储 21845*3 个字符，gbk 最大存储 32767*2 个字符，65533(not null)可以创建，varchar 当类型数据超过255个字符时，需要两个字节表示长度，记录需要额外的字节保存当前字段的 null 值，记录的所有字段都不是 null 时，这个字节才可以省略</p></blockquote><p><strong>text</strong>：65535个字符可以用来全部表示数据，不用指定字符长度</p><p><strong>blob</strong>：查询时会使用临时表，导致严重的性能开销，尽量避免使用 text 和 blob</p><p><strong>enum</strong>：枚举类型 enum(‘value1’,’value2’,…)；内部保存的是整型，允许使用下标方式标识，1标识第一个元素，逐个递增，允许 null 和空字符串（下标为0）下标方式，可以使用在检索中；</p><pre class="line-numbers language-none"><code class="language-none">gender enum(&#39;female’, ’male’)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>set</strong>：集合类型/不定向选择Set(‘value1’,’value2’,…)，表示可以选择可用值的0个或多个组合，用每个数据的状态（0/1）保存，占用8个字节，展示64个状态</p><pre class="line-numbers language-none"><code class="language-none">hobby set(‘read’, ’sport’, ’cook’)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><table><thead><tr><th>类型</th><th>最大长度</th><th>备注</th></tr></thead><tbody><tr><td>char</td><td>255</td><td>定长字符串；char(m)，m指定字符数</td></tr><tr><td>varchar</td><td>65535，需要1-2个位置保存字符串信息，同时由于一条记录的限制，最大有效存储为 65532</td><td>变长字符串；字符编码不同，字符数不同：GBK &lt;= 32767，UTF-8 &lt;= 21845</td></tr><tr><td>tinytext、text、mediuntext、longtext</td><td>L + n；L为最大长度<br>2^8 + 1, 2^16 + 2, 2^24 + 3, 2^32 + 4</td><td>定义时，通常不制定长度，可以自己计算</td></tr><tr><td>enum</td><td>1、2…；枚举选项量（65535）</td><td>内部存储为整型，属性取值只能是枚举类型中的一个</td></tr><tr><td>set</td><td>1、2…；元素数量（64）</td><td></td></tr><tr><td>binary、varbinary、blob</td><td>binary-char；varbinary-varchar，blob-text；作类比</td><td>二进制数据，字节非字符</td></tr></tbody></table><h1 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h1><h2 id="4-1-其他数据类型"><a href="#4-1-其他数据类型" class="headerlink" title="4.1 其他数据类型"></a>4.1 其他数据类型</h2><p>二进制：blob，binary，varbinary，用于保存一个二进制文件内容，如图片等<br>实型：real<br>用户指定：numeric<br>字符型大对象：clob</p><h2 id="4-2-数据类型选择"><a href="#4-2-数据类型选择" class="headerlink" title="4.2 数据类型选择"></a>4.2 数据类型选择</h2><ul><li>尽量精确，占用的空间少</li><li>考虑相关应用语言的处理</li><li>考虑移植兼容性</li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL-安装使用</title>
      <link href="/202105/1248742.html"/>
      <url>/202105/1248742.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍 MySQL的安装、卸载和简单使用 的相关基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>MySQL</strong>：是由瑞典的MySQL AB公司开发的，目前是Oracle(甲骨文)公司的一个<strong>关系型数据库产品</strong>(2008年MySQL AB被Sun公司收购、2009年Sun公司又被Oracle收购)，是一种关联数据库管理系统，将数据存储在不同的表中<br>MySQL是世界上流行的基于C/S(客户端/服务器端；服务器端：存储和管理数据库的；客户端：发出操作请求的程序)框架的开源的数据库系统；使用 <strong>标准的 SQL数据语言</strong> 管理数据<br>MySQL采用的是C/S架构，需要安装mysqld服务器，mysql客户端，data/数据存储，此外还要配置MySQL服务器占用的资源，使用的连接数，字符集，root用户密码等</p><h2 id="1-1-特点"><a href="#1-1-特点" class="headerlink" title="1.1 特点"></a>1.1 特点</h2><p><strong>成本低</strong>：MySQL代码是开放源的，一般可以免费使用或修改<br><strong>性能高</strong>：MySQL代码执行效率非常快<br><strong>可信赖</strong>：许多厉害的公司、站点在使用和维护MySQL<br><strong>操作易</strong>：MySQL很容易安装和使用</p><h1 id="2-安装卸载"><a href="#2-安装卸载" class="headerlink" title="2. 安装卸载"></a>2. 安装卸载</h1><p><a href="https://dev.mysql.com/downloads/mysql/"><font face = "微软雅黑" color = 1E90FF size = 5>下载官网</font></a><br><strong>完全干净</strong>：安装之前确保MySQL相关文件完全清除（第一次安装无此问题），解压下载好的文件至想要安装的目录下(尽量无中文)，检查服务、文件夹和注册表等是否删除完成，环境变量（可以保留）</p><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><h3 id="2-1-1-Windows"><a href="#2-1-1-Windows" class="headerlink" title="2.1.1 Windows"></a>2.1.1 Windows</h3><ol><li>初始化data文件：在bin目录下运行：mysqld –initialize-insecure –user=mysql</li><li>安装MySQL：mysqld -install； 安装完毕，运行配置向导（详细配置：开发环境，服务器环境，独立服务器：占用最多的资源；多功能：支持事务和非事务，支持事务，不支持事务；innodb表空间地址；OLAP，OLTP，手动设置连接数量；网络端口，严格模式；设定字符集；Windows服务名：不允许同名，环境变量；用户登录；运行配置）</li><li>启动服务：net start MySQL</li><li>登录MySQL：mysql -u root -p<br>因为之前没设置密码，所以直接回车即可</li><li>设置root用户密码：ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘password’;</li><li>刷新权限：flush privileges;</li><li>退出(exit/quit;)重新登陆即可</li><li>配置环境变量：<ul><li>MYSQL_HOME：安装根目录（bin的上一级目录）</li></ul></li><li>测试<ol><li>查看变量：show variable like ‘character_set%’;（%对应任意个数的字符，_  对应一个字符）</li><li>查看版本：select version();</li></ol></li></ol><h3 id="2-1-2-Linux"><a href="#2-1-2-Linux" class="headerlink" title="2.1.2 Linux"></a>2.1.2 Linux</h3><ol><li><p>安装之前先查看是否安装mysql：rpm -qa | grep -i mysql，若有则进入2，若没有则进入3</p></li><li><p>卸载mysql，rpm -e mysql-libs，如提示会破坏依赖，则强制删除：rpm -e –nodeps mysql-libs</p></li><li><p>安装：</p><ul><li>安装编译代码包gcc：yum -y install make gcc-c++ cmake bison-devel ncurses-devel</li><li>下载安装包</li><li>解压安装包：tar -zxvf YUM_package_name</li><li>进入解压目录：cd YUM_package_name</li><li>编译：<pre class="line-numbers language-none"><code class="language-none">cmake -DCMAKE_INSTALL_PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql-DMYSQL_DATADIR&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data -DSYSCONFDIR&#x3D;&#x2F;etc-DWITH_MYISAM_STORAGE_ENGINE&#x3D;1 -DWITH_INNOBASE_STORAGE_ENGINE&#x3D;1-DWITH_MEMORY_STORAGE_ENGINE&#x3D;1 -DWITH_READLINE&#x3D;1-DMYSQL_UNIX_ADDR&#x3D;&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;mysql.sock -DMYSQL_TCP_PORT&#x3D;3306-DENABLED_LOCAL_INFILE&#x3D;1 -DWITH_PARTITION_STORAGE_ENGINE&#x3D;1-DEXTRA_CHARSETS&#x3D;all -DDEFAULT_CHARSET&#x3D;utf8-DDEFAULT_COLLATION&#x3D;utf8_general_ci<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>安装：make &amp;&amp; make install，时间较长，大概30分钟</li></ul></li><li><p>测试：</p> <pre class="line-numbers language-none"><code class="language-none">注：正常安装完成后，Linux会自动创建 mysql 的用户和用户组查看用户列表：cat &#x2F;etc&#x2F;passwd|grep mysql查看用户列表：cat &#x2F;etc&#x2F;group|grep mysql查看版本：mysqladmin --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>配置：</p><ul><li>添加用户和用户组</li></ul> <pre class="line-numbers language-none"><code class="language-none">创建组：groupadd mysql创建用户：useradd -g mysql mysql修改&#x2F;usr&#x2F;local&#x2F;mysql权限：chown -R mysql:mysql &#x2F;usr&#x2F;local&#x2F;mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>初始化配置</li></ul> <pre class="line-numbers language-none"><code class="language-none">cd &#x2F;usr&#x2F;local&#x2F;mysql   进入安装目录scripts&#x2F;mysql_install_db --basedir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql --datadir&#x3D;&#x2F;usr&#x2F;local&#x2F;mysql&#x2F;data --user&#x3D;mysql，配置数据库和数据表存储位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>启动：在/usr/local/mysql/下运行</p><blockquote><p>注：启动mysql服务时，会按照/etc/my.cnf——“$basedir/my.cnf”搜索mysql的配置文件，新版MySQL的默认位置是：/usr/local/mysql/my.cnf。为防止干扰可将/etc/的文件名修改：mv /etc/my.cnf /etc/my.cnf.bak</p><ul><li>复制mysql服务到init.d目录下：cp support-files/mysql.server /etc/init.d/mysql</li><li>设置mysql服务开机自启动：chkconfig mysql on</li><li>启动mysql：service mysql start</li></ul><p>设置开机自启动：chkconfig mysql on ；查看是否设置成功：chkconfig –list|grep mysql  或者 ntsysv 开机自启动的服务前面的中括号内会有 * 星号标识</p></blockquote></li><li><p>登录：./mysql -u root -p，回车即可进入，默认密码为空</p></li><li><p>设置密码：MySQL 默认安装完成会创建一个无密码的 root 用户，为保证数据安全，需要设置密码</p><ul><li>SQL语法：set PASSWORD = PASSWORD(‘pwd’); 需进入MySQL进行</li><li>Linux语法：/user/bin/mysqladmin -u root password pwd; 可以直接在Linux命令行执行</li></ul></li><li><p>退出：exit;</p></li><li><p>重新登陆：./mysql -u root -p，此时需要登陆密码，密码为之前设置的 pwd</p></li></ol><h2 id="2-2-卸载"><a href="#2-2-卸载" class="headerlink" title="2.2 卸载"></a>2.2 卸载</h2><ul><li>暂停服务:管理员运行cmd：net stop MySQL，再进行删除</li><li>控制面板下卸载MySQL，删除ProgramData下的MySQL数据文件</li><li>删除注册表：win + r下输入regedit，进入注册表，进行删除</li></ul><pre class="line-numbers language-none"><code class="language-none">HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\services\eventlog\Application\MySQLHKEY_LOCAL_MACHINE\SYSTEM\ControlSet002\services\eventlog\Application\MySQL（可能没有） HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\EventLog\Application<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-3-安装介绍"><a href="#2-3-安装介绍" class="headerlink" title="2.3 安装介绍"></a>2.3 安装介绍</h2><table><thead><tr><th>路径</th><th>解释</th><th>备注</th></tr></thead><tbody><tr><td>/var/lib/mysql/</td><td>mysql数据库文件的存放路径</td><td>/var/lib/mysql/atguigu.cloud.pid</td></tr><tr><td>/user/share/mysql</td><td>配置文件目录</td><td>mysql.server 命令及配置文件</td></tr><tr><td>/user/bin</td><td>mysql命令目录</td><td>mysqladmin mysqldump等命令</td></tr><tr><td>/etc/init.d/mysql</td><td>启停脚本目录</td><td>/etc/init.d/mysql stop也可以关闭mysql服务</td></tr></tbody></table><h1 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h1><h2 id="3-1-连接启动"><a href="#3-1-连接启动" class="headerlink" title="3.1 连接启动"></a>3.1 连接启动</h2><ul><li><p>连接前要先开启服务</p><pre class="line-numbers language-none"><code class="language-none">开启服务：net start MySQL; (net start service_name);关闭服务：net stop MySQL;重启服务：net restart MySQL;cmd下操作：配置环境变量，可以在任意路径下运行；没配置环境变量，需要在安装路径下的bin目录下运行，下文全是，服务名默认是 MySQL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>登录</p></li></ul><pre class="line-numbers language-none"><code class="language-none">mysql [-h host_ip -P port] -u user_name -p [passwaord]主机：运行 MySQL 服务器的主机名地址，如果连接到本地MySQL服务器，为localhost 或 127.0.0.1端口：默认端口 3306，用默认可省略；修改端口后，需要指定用户名：一个合法的用户名密码：用户的登陆密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>测试</li></ul><pre class="line-numbers language-none"><code class="language-none">输出数据库列表：show databases;  -- 包含MySQL内部使用的数据库，如mysql、information_schema切换数据库：use database_name;输出数据表列表：show tables;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>断开连接：exit; /quit; /q;</li></ul><h2 id="3-2-简单查看"><a href="#3-2-简单查看" class="headerlink" title="3.2 简单查看"></a>3.2 简单查看</h2><pre class="line-numbers language-none"><code class="language-none">查看所有的数据库：show databases [like ‘xxx’];查看创建数据库的DDL：show create database db_name;查看当前数据库的所有表：show tables [like ‘xxx’];查看创建数据表的DDL：show create table tb_name;查看指定数据库的所有表：show tables from db_name;查看指定数据表的属性列：show columns from tb_name;查看广泛的服务器状态信息：show status;查看授予用户（所有用户或特定用户）的安全权限：show grants；查看服务器错误或警告消息：show errors &#x2F; warnings;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-3-设定字符集"><a href="#3-3-设定字符集" class="headerlink" title="3.3 设定字符集"></a>3.3 设定字符集</h2><pre class="line-numbers language-none"><code class="language-none">-- 显示字符集show variables like &#39;character%&#39;;  -- 默认字符集是latin1show variables like &#39;%char%&#39;;-- 修改字符集1. 配置文件修改：仅对修改后创建的数据库有效，对修改前创建的数据库无效[client]default-character-set &#x3D; utf8[mysqld]character_set_server &#x3D; utf8character_set_client &#x3D; utf8collation-server &#x3D; utf8_general_ci[mysql]no-auto-researchdefault-character-set &#x3D; utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-4-远程连接"><a href="#3-4-远程连接" class="headerlink" title="3.4 远程连接"></a>3.4 远程连接</h2><pre class="line-numbers language-none"><code class="language-none">grant all privileges on dbname.tbname to &#39;username&#39;@&#39;loginip&#39; identified by &#39;password&#39; with grant option;all privileges：表示所有权限（insert、delete、update、select、create、drop、alter等）dbname：表示数据库名，\* 表示所有数据库tbname：表示数据表名，\* 表示所有数据表username：表示用户名loginip：表示允许远程IP地址，% 表示所有IP地址password：表示登录密码，为空表示不需要密码登录with grant option：表示允许级联授权设置好了之后需要刷新权限：flush privileges;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-知识查阅"><a href="#4-知识查阅" class="headerlink" title="4. 知识查阅"></a>4. 知识查阅</h1><h2 id="4-1-网站资讯"><a href="#4-1-网站资讯" class="headerlink" title="4.1 网站资讯"></a>4.1 网站资讯</h2><p><strong>官方网站</strong>：<a href="https://www.mysql.com/"><font face = "微软雅黑" color = 1E90FF size = 5>英文</font></a>、<a href="https://www.mysql.com/cn/"><font face = "微软雅黑" color = 1E90FF size = 5>中文</font></a>、<a href="https://dev.mysql.com/doc/"><font face = "微软雅黑" color = 1E90FF size = 5>官方文档</font></a></p><p>进入官网 -&gt; 点击 Document / 文档 -&gt; 按下如所示，点击右下角，可以得到不同版本的接口文档说明</p><p><img src="https://qizhongyi.gitee.io/images/Data/DataBase/MySQL/Reference_Guide.png" alt="Reference_Guide"></p><p><strong>社区网站</strong>：<a href="http://mysqlserverteam.com/"><font face = "微软雅黑" color = 1E90FF size = 5>开发团队</font></a>、<a href="https://community.oracle.com/"><font face = "微软雅黑" color = 1E90FF size = 5>Oracle社区</font></a></p><h2 id="4-2-教程"><a href="#4-2-教程" class="headerlink" title="4.2 教程"></a>4.2 教程</h2><p><a href="https://www.w3cschool.cn/mysql/"><font face = "微软雅黑" color = 1E90FF size = 5>w3cschool</font></a><br><a href="https://www.runoob.com/mysql/mysql-tutorial.html"><font face = "微软雅黑" color = 1E90FF size = 5>菜鸟</font></a></p><h2 id="4-3-书籍"><a href="#4-3-书籍" class="headerlink" title="4.3 书籍"></a>4.3 书籍</h2><p>《MySQL必知必会》：比较经典，入门，<a href="http://forta.com/books/0672327120/"><font face = "微软雅黑" color = 1E90FF size = 5>配套网站</font></a><br>《高性能MySQL》：进阶<br>《高可用MySQL》：进阶<br>《MySQL技术内幕（第5版）》：进阶<br>《MySQL技术内幕：InnoDB存储引擎》：进阶</p>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库-基础</title>
      <link href="/202105/1047364.html"/>
      <url>/202105/1047364.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 数据库基本原理 的相关基础知识</p><span id="more"></span><h1 id="1-数据库系统"><a href="#1-数据库系统" class="headerlink" title="1. 数据库系统"></a>1. 数据库系统</h1><p><strong>数据库系统</strong>(DBS：Database System)：数据库系统 = 数据库管理系统 + 数据库 + 管理员；数据库系统包括数据、硬件、软件(基础软件：操作系统，数据库管理系统)和人员(用户、管理员)<br><strong>数据库管理系统</strong>(DBMS：Database Management System)：数据库管理软件</p><ul><li>基于共享文件系统的DBMS：通常用于桌面用途，不用于高端或更关键的应用，如Microsoft Access、FileMaker等</li><li>基于客户机—服务器的DBMS：服务器部分负责所有数据访问和处理，客户机将服务器处理好的数据返回给用户，服务器与数据打交道，客户机与客户打交道</li></ul><p><strong>数据库</strong>(DataBase)：存储数据的容器或集合；按照数据结构来组织管理数据的仓库，对大量数据进行高效的管理，是数据库管理系统所管理和操作的数据的容器；分为 <strong>关系型数据库</strong> 和 <strong>非关系型数据库</strong>，详情见下文 1.1.1 和1.1.2</p><p><strong>管理员</strong>(DBA：Database Administrator)：操作和管理数据及数据库管理软件的人</p><h2 id="1-1-发展"><a href="#1-1-发展" class="headerlink" title="1.1 发展"></a>1.1 发展</h2><p>1960s：文件系统</p><ul><li>缺点：不一致、费时、完整性、安全问题</li></ul><p>数据库系统</p><ul><li>层次型数据库(IBM)：最古老的数据库类型，数据被组织成具有强制父子关系的树形结构，父与子是一对多关系</li><li>网络型数据库</li><li>关系型数据库：是建立在关系模型(二维表)上的数据库系统，要求数据记录具有相同的关系结构，基于几何理论和关系代数，常见的数据库类型有  SQL Server、MySQL、Oracle、PostgreSQL、DB2等</li><li>面向对象</li><li>非关系数据库：是建立在非关系模型上的数据库系统，有列式数据库、空间数据库、键值对数据库等；常见的数据库类型有MongoDB、ElasticSearch、Redis等</li></ul><p>知识型数据库</p><h3 id="1-1-1-关系型数据库"><a href="#1-1-1-关系型数据库" class="headerlink" title="1.1.1 关系型数据库"></a>1.1.1 关系型数据库</h3><p><strong>关系型数据库</strong>：RDBS， Relational DataBase System；是建立在关系模型(二维表)上的数据库系统，要求数据记录具有相同的关系结构，基于几何理论和关系代数；常见的数据库类型有  SQL Server、MySQL、Oracle、PostgreSQL、DB2等</p><ul><li>数据结构可以规定：同类数据，结构一致，二维表；</li><li>数据间的关系可以设置：日常生活中的实体和实体的属性保存到数据中</li></ul><h3 id="1-1-2-非关系型数据库"><a href="#1-1-2-非关系型数据库" class="headerlink" title="1.1.2 非关系型数据库"></a>1.1.2 非关系型数据库</h3><p><strong>非关系型数据库</strong>：NoSQL: Not Only SQL；是建立在非关系模型上的数据库系统，不依赖业务逻辑方式存储；常见的数据库类型有MongoDB、ElasticSearch、Redis等；<strong>不遵循SQL语法、不支持ACID、性能优于SQL</strong>；常用于数据高并发的读写、海量数据的读写和数据高扩展</p><ul><li><strong>键值对数据库</strong>：也叫 <strong>Key-Value数据库</strong><ul><li><strong>Redis</strong>：Remote Dictionary Server，远程字典服务；是一个开源的使用C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库；与 Memcached 类似，支持存储多种数据类型，包括 string ：字符串、list：链表、set：集合、zset：sorted set，有序集合 和 hash：哈希类型等；数据缓存在内存中，周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件进行持久化；支持高速缓存服务，由 <strong>单线程+多路I/O复用</strong>：Tornado-支持万级并发、Node.js实现，<a href="https://redis.io/"><font face = "微软雅黑" color = 1E90FF size = 5>英文官网</font></a>，<a href="http://redis.cn/"><font face = "微软雅黑" color = 1E90FF size = 5>中文官网</font></a>，更多内容查看 <a href="https://qizhongyi.gitee.io/202105/2163107.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Redis-基础</strong></font></a></li></ul></li><li><strong>列式数据库</strong>：某列数据仅有唯一值，压缩冗余数据，常用于商务智能<ul><li>HBase</li></ul></li><li><strong>文档数据库</strong>：<ul><li>MongoDB：数据存储格式是一种类似于 json的 bson格式，支持二进制数据和大型对象</li><li>ElasticSearch：</li></ul></li><li><strong>图数据库</strong>：存储节点之间的关系，如朋友圈网络、推荐系统<ul><li>Neo4j：开源的NoSQL图数据库，使用 Scala 和 Java 开发，与2007年发布；使用属性图模型（Property graph model）进行图数据存储、查询（使用 Cypher 语言进行查询）和处理，<a href="https://neo4j.com/"><font face = "微软雅黑" color = 1E90FF size = 5>英文官网</font></a>，更多内容查看 <a href="https://qizhongyi.gitee.io/202210/142374.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Neo4j-基础</strong></font></a></li></ul></li></ul><h2 id="1-2-模式"><a href="#1-2-模式" class="headerlink" title="1.2 模式"></a>1.2 模式</h2><p><strong>外模式</strong>：子模式/用户模式，用户层，用户使用的局部数据的逻辑结构和特征</p><p><strong>模式</strong>：概念模式/逻辑模式，概念层，存储全体数据的逻辑结构和特征</p><p><strong>内模式</strong>：存储模式，物理层，数据的物理结构和存储方式的描述</p><h2 id="1-3-数据库连接方式"><a href="#1-3-数据库连接方式" class="headerlink" title="1.3 数据库连接方式"></a>1.3 数据库连接方式</h2><p><strong>ODBC</strong>：Open Database Connectivity，开放数据库连接</p><p><strong>JDBC</strong>：Java Database Connectivity，Java数据库连接</p><p><strong>ADO.NET</strong>：.NET框架中用于和数据库交互的类库</p><p><strong>PDO</strong>：PHP Data Object，PHP语言访问数据库技术</p><h1 id="2-SQL"><a href="#2-SQL" class="headerlink" title="2. SQL"></a>2. SQL</h1><p><strong>SQL</strong>：Structured Quary Language，结构化查询语言；用来管理数据的语言，专门用来与数据库通信；SQL语句默认以英文分号; 进行分隔，SQL语句不区分大小写，推荐对所有SQL关键字使用大写对所有列和表名使用小写</p><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p><strong>发展</strong></p><ol><li>1972：System R项目中提出Sequel</li><li>结构化的查询语言：标准86、92、99、03</li></ol><p><strong>分类</strong></p><ul><li><strong>DDL</strong>：Data Definition Language，数据定义语言；进行建库建表等操作，关键字有 create、drop、alter</li><li><strong>DML</strong>：Data Manipulation Language，数据操作语言；进行数据更新操作，关键字有 insert、delete、update</li><li><strong>DQL</strong>：Data Query Language，数据查询语言；进行数据检索，关键字有 select</li><li><strong>DCL</strong>：DataBase Control Language，数据库控制语言；进行安全管理、事务管理等，关键字有 grant、revoke、commit、rollback</li></ul><p><strong>优点</strong></p><ul><li>SQL不是某个特定数据库供应商专有的语言，所有重要的 DBMS 都支持 SQL</li><li>SQL简单易学，语句全都是由描述性很强的英语单词组成，且数量较少</li><li>SQL是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作</li></ul><h2 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h2><ol><li>给数据库、数据表、数据列命名时尽量使用全小写</li><li>作为筛选条件的字符串是否区分大小写，由校对规则确定</li><li>用前缀区分数据库对象：（表：tb）、（视图：v）、（索引：idx）、（函数：fun）、（触发器：tri）</li><li>批量插入操作要比多次插入更高效</li><li>执行表连接时，一般把小表放后面，大表放前面；执行where条件筛选时，一般把能过滤数据最多的条件放到最后面，把滤数据最少的条件放到最前面（数据库驱动引擎是右驱动：右边向左边链接）</li></ol><h1 id="3-关系型数据库"><a href="#3-关系型数据库" class="headerlink" title="3. 关系型数据库"></a>3. 关系型数据库</h1><p><strong>关系型数据库</strong>：RDBS: Relational DataBase System</p><h2 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h2><ul><li>**模式(Schema)**：是数据库的数据库对象的一个子集，用来将包含敏感数据的对象和普通用户分离</li><li>**表(Table)**：用于存放数据，是某种特定类型数据的结构化清单，数据表由数据行和数据列构成</li><li>**列(Column)/字段(Field)**： 表中的一个字段，多个列水平拼接成一个数据表，可以规定数据的存储类型(规范数据的存储)</li><li>**数据类型(Datatype)**：所容许的数据的类型，限制（或容许）该列中存储的数据</li><li>**行(Row)**：用于记录数据，多行竖直拼接成一个数据表，一行数据也称一条记录(Record)</li><li>**键(Key)**：唯一标识实体实例的一个或多个属性的集合<ul><li>单一键：唯一识别实体实例的是一个属性</li><li>组合键：唯一识别实体实例的是一组属性</li></ul></li><li>**主键(Primary Key)**：数据的“身份证”，用于唯一确定一条记录<ul><li>任意两行都不具有相同的主键值；</li><li>每个行都必须具有一个主键值(主键列不允许为空) </li></ul></li><li>**外键(Foreign key)**：一个实体的属性依赖于另一个实体的主键</li><li>**域(Domain)**：属性的可能取值范围，属性不应该含有域以外的值</li><li>**关系(Relational)**：关系模型</li><li><strong>数据库抽象</strong>：用来调用数据库函数的通用应用接口，如ODBCC、JDBC等</li></ul><h2 id="3-2-关系模型"><a href="#3-2-关系模型" class="headerlink" title="3.2 关系模型"></a>3.2 关系模型</h2><p><strong>关系模型</strong>：Entity-Relatonship 模型，E-R模型</p><h3 id="3-2-1-实体"><a href="#3-2-1-实体" class="headerlink" title="3.2.1 实体"></a>3.2.1 实体</h3><p><strong>实体</strong>：是区别于其他事物的一个事物，一个对象，由属性取值唯一确定，用表存储：属性取值具有原子性，元组无序</p><ul><li>单一属性</li><li>组合属性：姓/名</li><li>单值属性</li><li>多值属性：电话号码</li><li>派生属性：通过属性间的运算可获得</li></ul><h3 id="3-2-2-关系"><a href="#3-2-2-关系" class="headerlink" title="3.2.2 关系"></a>3.2.2 关系</h3><p><strong>关系</strong>：实体与实体之间存在的关联关系</p><p><strong>按元数分类</strong>：涉及实体数量称为元数</p><ul><li><strong>一元关系</strong>：也称递归关系，或自我引用关系，一对多描述层级关系，如课程需要先导课，虚线表示；多对多描述网络或图表，实线表示</li><li><strong>二元关系</strong>：最常见</li><li><strong>三元关系</strong>：涉及三个实体，基于事实建模，学生可以再特定时期选择一门特定课程</li></ul><p><strong>按关联关系分类</strong></p><ul><li><strong>一对一</strong>：一对一/一对一，两个实体表存在相同的主键字段，垂直分割（常用/不常用）；</li><li><strong>一对多</strong>：一对多/一对一，一个实体对应多个其他实体，在n端实体增加字段，指向对应实体</li><li><strong>多对多</strong>：一对多/一对多，多个实体对应多个实体，利用中间表保存实体间的对应关系，映射成两个一对多关系，关系表指向实体表</li></ul><h4 id="3-2-2-1-关系代数"><a href="#3-2-2-1-关系代数" class="headerlink" title="3.2.2.1 关系代数"></a>3.2.2.1 关系代数</h4><p><strong>选择</strong>：select</p><p><strong>投影</strong>：project：消除重复行</p><p><strong>并</strong>：union：列数相同，域相同，消除重复行</p><p><strong>差</strong>：set difference</p><p><strong>笛卡尔积</strong>：cartesian product，又叫直积，两集合内数据所有可能的排列组合；两个二维表的没有条件的内连接（交叉连结：cross join）就是笛卡尔积</p><p><strong>重命名</strong>：rename</p><p><strong>交</strong>：保留两表相同的部分</p><p><strong>自然连接</strong>：连接具有相同属性的两表，属性是两表属性不重复的集合，保留取值相同的元组</p><p><strong>外连接</strong>：</p><ul><li>左外连接：共有属性列以左表为准拼接两表，允许右表属性缺失</li><li>右外连接：共有属性列以右表为准拼接两表，允许左表属性缺失</li><li>全连接：共有属性列由两表集合为准，允许缺失</li></ul><p><strong>除</strong>：连接具有相同属性的两表，属性是两表的差，保留元组的对应属性的取值完全包含另外一张表</p><h3 id="3-2-3-设计原则"><a href="#3-2-3-设计原则" class="headerlink" title="3.2.3 设计原则"></a>3.2.3 设计原则</h3><ul><li>属性不能有关系</li><li>一个实体不能作为另一个实体的属性：弱实体</li><li>联系可以有标识符</li><li>实体联系可以作为实体</li><li>先构建实体/关系，后添加属性</li></ul><h2 id="3-3-数据库构建原则"><a href="#3-3-数据库构建原则" class="headerlink" title="3.3 数据库构建原则"></a>3.3 数据库构建原则</h2><p>数据库构建应遵循<strong>PRISM原则</strong>：</p><ol><li><strong>性能和易用性</strong>（Performance of Ease of Use）：确保用户可以快速、轻松的访问数据，提高应用程序和数据的业务价值</li><li><strong>可重用性</strong>（Reusability）：确保数据库结构在适当情况下可以被多个应用重复使用</li><li><strong>完整性</strong>（Integrity）：数据完整的表述业务含义和、价值和有效状态，且能监测并报告数据的完整性约束违规事件</li><li><strong>安全性</strong>（Security）：始终及时向授权用户提供真实准确的数据，且满足利益相关方的隐私要求</li><li><strong>可维护性</strong>（Maintainability）：确保创建、存储、维护、使用数据的成本不超过其对组织的价值</li></ol><h2 id="3-4-键-码"><a href="#3-4-键-码" class="headerlink" title="3.4 键/码"></a>3.4 键/码</h2><p><strong>超码</strong>：可以唯一确定一个元组，最小的超码为候选码；主码从候选码中挑选；<strong>外码</strong>：连接到另一个表的的主码</p><pre class="line-numbers language-none"><code class="language-none">column_name data_type primary key auto_increment;&#x2F;&#x2F; 自增长：属性为整型，属性有索引，可以设置初始值primary key (column_name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-5-完整性约束"><a href="#3-5-完整性约束" class="headerlink" title="3.5 完整性约束"></a>3.5 完整性约束</h2><ul><li><strong>实体完整性</strong>：每个实体都是独一无二的，没有冗余，且主码不为空</li><li><strong>参照完整性</strong>：外码必须匹配主码，外键约束</li><li><strong>域完整性</strong>：也叫数据完整性，存储的数据都是有效的，数据列的取值在域内（数据类型、数据长度、默认值约束、非空约束、检查约束）</li><li><strong>用户定义完整性</strong>：用户自定义的完整性约束，不同的关系数据库系统根据应用环境不同，需要一些特殊的约束条件，反映某一具体应用必须满足的语义需求</li></ul><h3 id="3-5-1-列属性约束"><a href="#3-5-1-列属性约束" class="headerlink" title="3.5.1 列属性约束"></a>3.5.1 列属性约束</h3><p><strong>列属性约束</strong>：保证表的结构和数据的正确性和稳定性</p><ul><li>唯一性和主键约束(UNIQUE,Primary Key)：表中的一个或多个字段，用于惟一地标识表中的某一条记录，要求主键的值不能重复。</li><li>外键约束(Foreign Key)</li><li>检查约束(CHECK)</li><li>空值约束(NOT NULL)：表示没有值，什么都没有。与任何数据不同。如果一个列不允许为空，但是在赋值时，没有为该字段赋值，则会报错。使用 is null or is not null来判断，不能直接比较=/&gt;null</li><li>默认值约束(DEFAULT)：为列指定一个默认，当该字段不存在值时，会被启用。默认值必须为一个常数，不能为一个函数或一个表达式。如果该列可以为空，则默认值为null。有些列是不能有默认值的：Blob，text。时间戳类型，可以设置一个特殊的默认值 CURRENT_TIMESTAMP。在当列不存在或者传递的值为null时，使用当前的时间戳。</li></ul><h1 id="4-逻辑设计"><a href="#4-逻辑设计" class="headerlink" title="4. 逻辑设计"></a>4. 逻辑设计</h1><ul><li>任务：E-R图转换成关系表</li><li>组合属性由组合值代替</li><li>派生属性省略</li><li>多值属性另外生成一张关系表</li><li>保留单值属性</li><li>一对多/多对一：对多方的属性加入一方的主码</li><li>多对多关系：保留实体的主码和自身属性</li><li>弱实体转换为关系要增加依附实体的主码</li></ul><h1 id="5-函数依赖"><a href="#5-函数依赖" class="headerlink" title="5. 函数依赖"></a>5. 函数依赖</h1><p><strong>函数依赖</strong>：A-&gt;B</p><h2 id="5-1-阿姆斯特朗公理"><a href="#5-1-阿姆斯特朗公理" class="headerlink" title="5.1 阿姆斯特朗公理"></a>5.1 阿姆斯特朗公理</h2><p><strong>包含规则</strong>：Y属于X，则X可以推出Y（X、Y是R的属性组）</p><p><strong>传递规则</strong>：X决定Y且Y决定Z，则X决定Z</p><p><strong>增广规则</strong>：X决定Y，则XZ决定YZ</p><p><strong>推1合并规则</strong>：X决定Y，X决定Z，则X决定YZ</p><p><strong>推2分解规则</strong>：X决定YZ，则X决定Y，X决定Z</p><h2 id="5-2-闭包"><a href="#5-2-闭包" class="headerlink" title="5.2 闭包"></a>5.2 闭包</h2><p><strong>函数依赖集闭包</strong>：由函数依赖集F所能推出的所有函数依赖的集合称为F的闭包</p><p><strong>属性集闭包</strong>：属性集a在函数依赖集F下所能推出的所有属性的集合称为a的闭包</p><h2 id="5-3-正则覆盖"><a href="#5-3-正则覆盖" class="headerlink" title="5.3 正则覆盖"></a>5.3 正则覆盖</h2><p>覆盖：函数依赖集F包含函数依赖集G，则F覆盖G</p><p>等价：F可覆盖G，G可覆盖F，则F、G等价</p><p>最小函数依赖集</p><ul><li>分解函数依赖集右侧，化解为单属性</li><li>去除函数依赖集左侧的冗余属性：尝试去除属性集的某一属性</li><li>去掉多余的函数依赖（可由其他函数依赖推到而出）</li><li>函数依赖集C与F等价，没有函数依赖有多余的属性，函数依赖左部不重复，则C是F的正则覆盖</li></ul><h2 id="5-4-范式"><a href="#5-4-范式" class="headerlink" title="5.4 范式"></a>5.4 范式</h2><p><strong>范式</strong>：NF，Normal Form，数据库设计范式，表示设计关系型数据库需要满足某种级别的一些规则和要求。分为1NF，2NF，3NF，BCNF，4NF，5NF，6NF，要求是从低到高逐渐递增。关系型数据库必须满足1NF，通常达到3NF就可以满足要求</p><ul><li><strong>1NF</strong>：要求数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性</li><li><strong>2NF</strong>：在满足1NF的基础上，要求表中的每条记录必须被唯一的区分，实体属性应该完全依赖于主关键字。而不能是对主关键字形成部分函数依赖。常采用单关键字主键满足要求，即为每一条记录一个字段用于表示其主键</li><li><strong>3NF</strong>：在满足第二范式的基础上，要求不能出现传递依赖，任何字段不能由其他字段派生出来，即不能出现属性依赖于非主属性。通过将传递依赖的数据单独建立二维表，保存数据解决</li><li><strong>BCNF</strong>：解决较差的复合侯选建</li><li><strong>4NF</strong>：将三元关系都分解成二元关系</li><li><strong>5NF</strong>：将实体内部依赖关系分解成二元关系<h3 id="5-4-1-优缺点"><a href="#5-4-1-优缺点" class="headerlink" title="5.4.1 优缺点"></a>5.4.1 优缺点</h3>可以尽量减少冗余，使得更新快，体积少<br>对于查询需要进行多表关联，减少写效率，增加读效率，更难进行索引优化<blockquote><p>采用反范式化（降低表的范式），可以减少表关联，更好进行索引优化；但会存储较多的冗余数据，数据修改成本较高</p></blockquote></li></ul><h1 id="6-事务"><a href="#6-事务" class="headerlink" title="6. 事务"></a>6. 事务</h1><p><strong>事务</strong>：是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败</p><h2 id="6-1-ACID特性"><a href="#6-1-ACID特性" class="headerlink" title="6.1 ACID特性"></a>6.1 ACID特性</h2><p><strong>A（atomicity）原子性</strong>：事务是一个不可分割的工作单位，要么不做，要么全做</p><p><strong>C（consistency）一致性</strong>：事务执行结果正确，事务前后数据的状态必须保持一致</p><p><strong>I（isolation）隔离性</strong>：多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离</p><p><strong>D（durability）持久性</strong>：事务完成后，结果直到下一次修改前，永久保存<br>redo log 在数据库崩溃时恢复数据，保证数据的一致性和持久性<br>undo log 用于对事务回滚时进行撤销，也用于隔离性的多版本控制</p><h2 id="6-2-实现"><a href="#6-2-实现" class="headerlink" title="6.2 实现"></a>6.2 实现</h2><ul><li>要求是事务支持的表类型</li><li>执行一组相关的操作前开启事务(Start transaction)</li><li>整组操作完成后，都成功，则提交(Commit)，如果存在失败，选择回滚(Rollback)，则会回到事务开始的备份点<ul><li>自动提交：autocommit=0|1</li></ul></li></ul><h2 id="6-3-状态"><a href="#6-3-状态" class="headerlink" title="6.3 状态"></a>6.3 状态</h2><ul><li>活动状态：active，开始执行</li><li>部分提交状态：partially committed，指令执行结束</li><li>失败状态：failed，不能正常执行</li><li>终止状态：aborted，失败回滚，恢复成初始状态</li><li>提交状态：committed，结果提交给数据库之后</li><li>终结状态：Terminated，终止态或提交态</li></ul><h2 id="6-4-隔离级别"><a href="#6-4-隔离级别" class="headerlink" title="6.4 隔离级别"></a>6.4 隔离级别</h2><p>RU：读未提交，产生脏读<br>RC：读已提交，产生不可重复读<br>RR：可重复读，产生脏读<br>Serializable：序列化，不存在事务并发问题，为读写都加锁，效率不高</p><h2 id="6-5-并发控制"><a href="#6-5-并发控制" class="headerlink" title="6.5 并发控制"></a>6.5 并发控制</h2><h3 id="6-5-1-并发冲突类型"><a href="#6-5-1-并发冲突类型" class="headerlink" title="6.5.1 并发冲突类型"></a>6.5.1 并发冲突类型</h3><ul><li>写写冲突：丢失修改，同时更新</li><li>读写冲突：不可重复读(A会话两次查询，查询的结果记录数一致，记录内容不一致)，B会话在两次查询之间发生 update 语句</li><li>写读冲突：读脏数据(A会话读到B会话未提交的数据)，回滚<br>幻读：A会话两次查询，查询的结果记录数不一致，B会话在两次查询之间发生 insert 或 delete 语句</li></ul><h3 id="6-5-2-锁机制"><a href="#6-5-2-锁机制" class="headerlink" title="6.5.2 锁机制"></a>6.5.2 锁机制</h3><ul><li>排它锁：其他事务不可进行读写操作</li><li>共享锁：所有事物可读，不可写</li><li>死锁：互相等待；饿死：持续等待</li><li>两阶段封锁协议：增长阶段：只允许增加锁，不允许释放；消减阶段：只允许释放，不允许增加锁</li></ul><h1 id="7-字符集"><a href="#7-字符集" class="headerlink" title="7. 字符集"></a>7. 字符集</h1><p>字符集是一套字符与字符编码的集合，常用字符集见 <a href="https://qizhongyi.gitee.io/202104/1016033.html"><font face = "微软雅黑" color = 1E90FF size = 5>程序设计-通识</font></a> 的字符编码部分</p><pre class="line-numbers language-none"><code class="language-none">Show character set; 可以获得支持的所有字符集character set gbk collate gbk_chinese_ci;设置字符集，也可在配置文件中修改 - character_set_database：默认数据库字符集（数据） - character_set_sever：默认mysql服务器字符集 - character_set_system：标识符的字符集（库名，表名）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>校对规则：当前字符集内，字符之间的比较关系。每一套字符集都有一套相应的校对规则/按照ASCLL码表大小比较规则（ci不区分大小写，cs区分大小写，bin二进制下区分，一般认为不区分），查看字符集：Show collation like ‘xxx’;</p><h1 id="8-其他"><a href="#8-其他" class="headerlink" title="8. 其他"></a>8. 其他</h1><h2 id="8-1-数据库领域图灵奖获得者"><a href="#8-1-数据库领域图灵奖获得者" class="headerlink" title="8.1 数据库领域图灵奖获得者"></a>8.1 数据库领域图灵奖获得者</h2><p>查尔斯·巴赫曼：网状数据库管理系统IDS<br>埃德加·科德：关系型数据库<br>詹姆斯·格雷：事务处理技术<br>迈克尔·斯通布雷克：底层概念实践，数据库产品</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell-常见操作指令</title>
      <link href="/202104/1316490.html"/>
      <url>/202104/1316490.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Shell-编程 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>Shell是一个命令行解释器，为用户提供一个项Linux内核发送请求以便运行程序的界面系统级程序，用户可以用Shell来启动、挂起、停止和编写程序<br><img src="https://qizhongyi.gitee.io/images/System/Linux/Shell_Principle.png" alt="Shell_Principle"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>Shell脚本以#!/bin/bash开始，告诉系统使用bash进行解析</li><li>脚本需要可执行权限</li><li>Shell脚本的文件后缀一般是.sh，可以为其他后缀</li></ul><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><h2 id="2-1-运行"><a href="#2-1-运行" class="headerlink" title="2.1 运行"></a>2.1 运行</h2><ul><li>拥有可执行权限：可使用绝对路径和相对路径进行运行</li></ul><blockquote><p>./file_name<br>/root/…/file_name</p></blockquote><ul><li>没有可执行权限：可使用sh解释器强制运行，不推荐</li></ul><blockquote><p>sh ./file_name<br>sh /root/…/file_name</p></blockquote><h2 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h2><p>Linux Shell中的变量分为系统变量和用户自定义变量<br><strong>系统变量</strong>：系统已经定义好的变量，可以直接使用</p><blockquote><p>查看所有系统变量：set</p></blockquote><p><strong>用户自定义变量</strong>：用户定义变量，仅对当前脚本有效<br><strong>定义</strong></p><pre class="line-numbers language-none"><code class="language-none">普通变量：variable_name&#x3D;value，等号两端不要有空格静态变量：readonly variable_name&#x3D;value，静态变量不能注销 unset<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><p>定义规则</p><ul><li>变量可由字母、数字、下划线组成，不能以数字开头</li><li>定义变量时等号两端不要有空格</li><li>变量名一般为大写</li></ul></blockquote><p><strong>赋值</strong>：将命令的返回值赋值给变量</p><blockquote><ol><li>variable_name=`ls -al`，反引号括起命令，运行ls -al，并将结果复制给A</li><li>variable_name=$(ls -al)，$()美元符号和小括号括起命令，运行ls -al，并将结果复制给A，推荐</li></ol></blockquote><p><strong>引用</strong>：$variable_name，在变量前加$表示引用变量<br><strong>注销</strong>：unset variable_name<br><strong>设置环境变量并引用</strong></p><blockquote><ol><li>export variable_name=value，将shell变量输出给环境变量</li><li>source 配置文件，让修改后的配置文件立即生效</li><li>echo $variable_name，查询环境变量的值<br>输出环境变量，需要刷新，才能引用</li></ol></blockquote><p><strong>设置位置参数</strong>：获取到命令行的参数信息（传参）</p><blockquote><p>$n：n为整数，$0表示命令本身，$1-$9表示第一到就个参数，十个以上用大括号包含，例${10}<br>$*：代表命令行中的所有参数，看成一个整体<br>$@：代表命令行中的所有参数，每个参数单独对待<br>$#：代表命令中的参数个数</p></blockquote><p><strong>预定义变量</strong>：shell设计者事先定义好的变量，可以直接在shell就脚本中使用</p><blockquote><p>$$：获取当前进程号（PID）<br>$!：后台运行最后一个进程的进程号（PID）<br>$?：返回最后一次执行命令的状态，0为正常，其他为不正常</p></blockquote><h2 id="2-3-运算符"><a href="#2-3-运算符" class="headerlink" title="2.3 运算符"></a>2.3 运算符</h2><ol><li>$((运算表达式))或$[运算表达式]（推荐）</li><li>expr m +，-，*，/，% n：加、减、乘、除、取余，可嵌套使用，也可计算中间值</li></ol><pre class="line-numbers language-none"><code class="language-none">RESULT&#x3D;$(((2 * 3) + 4))RESULT&#x3D;$[(2 * 3) + 4]    # 推荐# 嵌套使用RESULT&#x3D;expr expr 2 \* 3  + 4# 计算中间值TEMP&#x3D;&#96;expr 2 \* 5&#96;RESULT1&#x3D;&#96;expr $TEMP + 4&#96;注：使用expr时，需要用反引号包裹，运算符两边需要加上空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-4-流程控制"><a href="#2-4-流程控制" class="headerlink" title="2.4 流程控制"></a>2.4 流程控制</h2><h3 id="2-4-1-条件判断—CONDITION"><a href="#2-4-1-条件判断—CONDITION" class="headerlink" title="2.4.1 条件判断—CONDITION"></a>2.4.1 条件判断—CONDITION</h3><p>[ 条件 ]，条件两端有空格，非空为true，可使用$?判断（0为true，&gt;1为false）<br><strong>两个整数比较</strong></p><blockquote><p>=：字符串比较<br>-lt：小于<br>-le：小于等于<br>-eq：等于<br>-gt：大于<br>-ge：大于等于<br>-ne：不等于</p></blockquote><p><strong>按照文件权限进行判断</strong></p><blockquote><p>-r：拥有可读权限<br>-w：拥有可写权限<br>-x：拥有可执行权限</p></blockquote><p><strong>按照文件类型进行比较</strong></p><blockquote><p>-f：文件存在且是一个常规文件<br>-e：文件存在<br>-d：文件存在并且是一个目录</p></blockquote><h3 id="2-4-2-if分支"><a href="#2-4-2-if分支" class="headerlink" title="2.4.2 if分支"></a>2.4.2 if分支</h3><pre class="line-numbers language-none"><code class="language-none">if conditionthen程序段[elif conditonthen程序段]fi<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-3-case分支"><a href="#2-4-3-case分支" class="headerlink" title="2.4.3 case分支"></a>2.4.3 case分支</h3><pre class="line-numbers language-none"><code class="language-none">case variable_name in&quot;value1&quot;)程序段;;&quot;value2&quot;)程序段;;*)程序段;;esac<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-4-for循环"><a href="#2-4-4-for循环" class="headerlink" title="2.4.4 for循环"></a>2.4.4 for循环</h3><pre class="line-numbers language-none"><code class="language-none">for variable_name value1 value2 value3...do程序段done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-none"><code class="language-none">for ((初始值;循环控制条件;变量变化))do程序段done<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-5-while循环"><a href="#2-4-5-while循环" class="headerlink" title="2.4.5 while循环"></a>2.4.5 while循环</h3><pre class="line-numbers language-none"><code class="language-none">while [condition]do程序段done注：while于中括号之间要有空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-5-I-O操作"><a href="#2-5-I-O操作" class="headerlink" title="2.5 I/O操作"></a>2.5 I/O操作</h2><ul><li><strong>read读取控制台输入</strong>：read 选项 参数</li></ul><blockquote><p>-p：指定读取值的提示符<br>-t：指定读取的访问时间（秒）<br>参数为读取数据的变量名</p><pre class="line-numbers language-none"><code class="language-none">read -t 5 -p &quot;请输入一个整数：&quot; NUMecho &quot;输入的值是：$NUM&quot;5秒内在控制台输入一个整数，用NUM存储，并打印到控制台窗口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></blockquote><ul><li><p><strong>读取命令行输入</strong>：获取到的内容为设置位置参数：$n、$*、$@、$#</p></li><li><p><strong>echo输出</strong>：输出关键字为echo，输出的内容由双引号包裹，用$引用变量</p></li></ul><h2 id="2-6-函数"><a href="#2-6-函数" class="headerlink" title="2.6 函数"></a>2.6 函数</h2><ul><li><strong>系统函数</strong>：shell编程里自带的函数</li></ul><ol><li>basename：返回完整路径最后/的部分，常用来获取文件名<br>basename [string]  [suffix]，若指定suffix后缀，则返回string里的文件名，不保留文件类型；若省略，则返回string里的文件名和文件类型</li><li>dirname：返回完整路径最后/的前面部分，常用来获取文件目录<br>dirname [string]<br><img src="https://qizhongyi.gitee.io/images/System/Linux/System_Function_01.png" alt="System_Function_01"></li></ol><ul><li><strong>用户自定义函数</strong>：由用户根据实际业务需求定制的函数</li></ul><pre class="line-numbers language-none"><code class="language-none">[function] function_name()&#123;程序段[返回值]&#125;注：不需要配置形参，调用时直接使用函数名，后面接上实际参数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">例：function Sum()&#123;        SUM&#x3D;$[$A+$B]        echo &quot;$A与$B的和是：$SUM&quot;&#125;read -p &quot;请输入X：&quot; Aread -p &quot;请输入Y：&quot; BSum $A $B注：命令行输入两个数，计算这两个数的和<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-7-其他"><a href="#2-7-其他" class="headerlink" title="2.7 其他"></a>2.7 其他</h2><ul><li><strong>注释</strong></li></ul><pre class="line-numbers language-none"><code class="language-none">单行注释：#内容多行注释:&lt;&lt;!内容!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-基础</title>
      <link href="/202104/1256685.html"/>
      <url>/202104/1256685.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Linux操作系统使用的相关基础知识</p><span id="more"></span><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h1><p><strong>Linux内核版</strong>：内核(kernel)，试运行硬件设备的核心程序</p><p><strong>Linux发行版</strong>：包含内核组件，Ubuntun、CentOS、Redhat等</p><h1 id="2-VMware安装CentOS"><a href="#2-VMware安装CentOS" class="headerlink" title="2. VＭware安装CentOS"></a>2. VＭware安装CentOS</h1><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><ul><li> 下载：<a href="https://www.centos.org/download/"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a>，选择DVD ISO</li><li> 安装：打开VMware，新建虚拟机，自定义安装CentOS</li></ul><ol><li><p><strong>安装虚拟机</strong>：</p><ol><li>创建虚拟机：</li><li>选择兼容版本,默认即可,点击下一步;</li><li>选择稍后安装操作系统,点击下一步;</li><li>选择需要安装的操作系统：Linux 版本:安装的版本,点击下一步;</li><li>命名虚拟机,选择安装位置,点击下一步;</li><li>配置处理器,选择处理器,默认,也可根据自身需要修改,点击下一步;</li><li>配置虚拟机内存,最少628M,不多于自身主机内存的一半,点击下一步;</li><li>配置网络,选择使用网络地址转换(Nat),点击下一步;</li><li>配置I/O,默认(LSI Logic).点击下一步;</li><li>配置磁盘类型,默认(SCSI),点击下一步;</li><li>选择磁盘,选择创建新的磁盘空间;点击下一步;</li><li>指定磁盘大小,默认20G,可根据自身需要修改,点击下一步;</li><li>指定磁盘文件,默认选择,点击下一步;</li><li>配置硬件,默认即可,可根据自身需要选择,点击下一步;</li><li>点击完成.</li></ol></li><li><p><strong>安装CentOS</strong>：</p><ol start="16"><li>安装CentOS：</li><li>右键单击创建的虚拟机,进入设置;</li><li>选择CD/DVD,选择使用ISO映像文件,浏览找到ISO文件目录,打开ISO文件,点击确认;</li><li>开启虚拟机,进行安装;</li><li>选择Install CentOS,Enter;</li><li>选择系统语言,点击继续;</li><li>设置时间日期,地区选Asia,时区选上海,点击完成;</li><li>软件选择,选择最小化安装,点击完成;</li><li>安装目标位置,选择自动配置分区,点击完成;</li><li>点击开始安装;</li><li>设置root密码,点击完成;</li><li>结束后重启,进入系统后,使用root登录.</li></ol></li></ol><h2 id="2-2-配置网络"><a href="#2-2-配置网络" class="headerlink" title="2.2 配置网络"></a>2.2 配置网络</h2><ul><li><p>测试网络: ping <a href="http://www.baidu.com/">www.baidu.com</a>;</p></li><li><p>输入: ip addr,查看网络配置文件，一般为/etc/sysconfig/network-scripts/###fcfg-ens33;</p></li><li><p>修改网络配置文件:vi /etc/sysconfig/network-scripts/# ###fcfg-ens33,修改”ONBOOT=yes”，保存退出;</p></li><li><p>关闭防火墙</p><pre class="line-numbers language-none"><code class="language-none">systemctl stop firewalld    # 临时关闭防火墙，service iptables stopsystemctl disable firewalld # 禁止开机启动<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>重启网络服务</p><pre class="line-numbers language-none"><code class="language-none">service network restart隔天打开若无法连接，可以查看虚拟机相关服务是否打开<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><h3 id="2-2-1-网络连接模式"><a href="#2-2-1-网络连接模式" class="headerlink" title="2.2.1 网络连接模式"></a>2.2.1 网络连接模式</h3><ul><li><p><strong>桥连接模式</strong>：虚拟机IP与本机在同一个网端，通讯通畅，但是会出现IP冲突的危险</p></li><li><p><strong>NAT连接模式</strong>：网络地址转换方式，Linux可以访问外网，不会出现IP冲突<br><img src="https://qizhongyi.gitee.io/images/System/Linux/NAT_Net_Model.png" alt="NAT_Net_Model"></p><p><strong>配置自动获取IP：</strong></p><ol><li>系统 -&gt; 首选项 -&gt; 网络连接 -&gt; 编辑 -&gt; 勾选自动连接</li><li>自动获取ip的ip地址会改变</li><li>指定固定IP</li><li>修改/etc/sysconfig/network-scripts/ifcfg-eth0 ；配置完成后需要重启网络：service network restart 或重启机器：reboot<pre class="line-numbers language-none"><code class="language-none">ONBOOT &#x3D; yes               -- 启用BOOTPROTO &#x3D; static         -- 指定以静态方式获取IPIPADDR &#x3D; xxx.xxx.xxx.xxx   -- 指定IPGATEWAY &#x3D; xxx.xxx.xxx.xxx  -- 网关DNS1 &#x3D; xxx.xxx.xxx.xxx     -- DNS和网管保持一致即可# IPADDR、GATEWAY、DNS1的前面三段必须保持一致<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol></li><li><p><strong>独立连接模式</strong>：Linux独立一个网络IP</p></li><li><p>测试：ping <a href="http://www.baidu.com/">www.baidu.com</a></p></li></ul><h1 id="3-关机"><a href="#3-关机" class="headerlink" title="3. 关机"></a>3. 关机</h1><p>关机重启前应该将内存的数据同步到磁盘上</p><ul><li>shutdown [选项] [时间]<pre class="line-numbers language-none"><code class="language-none">shutdown -h now；立即关机shutdown -h 1：一分钟后关机，不输入时间，默认一分钟shutdown -r now：立即重启shutdown -c ：取消关机或重启操作<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>halt：立即关机</li><li>rebot：重启系统</li><li>sync：将内存的数据同步到磁盘上</li><li>logout：退出远程，图形界面运行无效</li></ul><h1 id="4-目录结构"><a href="#4-目录结构" class="headerlink" title="4. 目录结构"></a>4. 目录结构</h1><p>Linux采用基层是的树状目录结构，在Linux世界里，万物皆是文件，包括鼠标、键盘等<br><strong>root</strong>：根目录，对顶级目录，系统管理员的主目录<br><strong>/bin</strong>：二进制指令文件目录；主要用于主体应用<br><strong>/boot</strong>：存放启动Linux的核心文件，包括连接文件和镜像文件<br><strong>/dev</strong>：设备管理目录，将硬件以文件形式存放<br><strong>/etc</strong>：系统管理需要的配置文件和子目录<br><strong>/home</strong>：普通用户的目录，Linux里每一个用户都有各自的 目录<br><strong>/lib</strong>：系统开机所需最基本的动态链接共享库，类似于Window里面的DDL文件<br><strong>/proc</strong>：是一个虚拟目录，是系统内存的映射，存放系统信息<br><strong>/opt</strong>：安装软件管理目录<br><strong>/sbin</strong>：系统管理员专用的二进制指令文件目录，主要用于系统管理<br><strong>/srv</strong>：service的缩写，存放服务启动之后需要提取的数据<br><strong>/sys</strong>：存放2.6内核新出的文件系统ysfs<br><strong>/tmp</strong>：存放临时文件<br><strong>/usr</strong>：用户应用程序和文件的存放路径；/user/bin：后期安装的软件；/user/sbin 超级用户的一些管理程序<br><strong>/var</strong>：日志文件，存放不停变化的文件</p><h2 id="4-1-分区"><a href="#4-1-分区" class="headerlink" title="4.1 分区"></a>4.1 分区</h2><h3 id="4-2-分区方式"><a href="#4-2-分区方式" class="headerlink" title="4.2 分区方式"></a>4.2 分区方式</h3><p><strong>mbr分区</strong></p><blockquote><p>最多支持四个主分区<br>系统只能安装在主分区<br>扩展分区腰斩一个主分区<br>MBR最大支持2TB，拥有最好的兼容性</p></blockquote><p><strong>gtp分区</strong></p><blockquote><p>支持无限个主分区（受系统限制，Windows 最多支持128个分区）<br>最大支持18EB的大容量<br>Windows7 64位之后支持 gtp</p></blockquote><h3 id="4-3-管理"><a href="#4-3-管理" class="headerlink" title="4.3 管理"></a>4.3 管理</h3><blockquote><p>挂载：mount<br>卸载：umont</p></blockquote><h3 id="4-4-硬盘"><a href="#4-4-硬盘" class="headerlink" title="4.4 硬盘"></a>4.4 硬盘</h3><p><strong>分类</strong>：<br><strong>IDE硬盘</strong>：并口，用hdxn进行标识，hd表示IDE硬盘，x代表盘号（a：基本盘、b：基本从属盘、c：辅助主盘、d：辅助从属盘），n表示分区数：1-4表示主分区或扩展分区，5以上是逻辑分区<br><strong>SCSI硬盘</strong>：串口，用sdxn进行标识，sd表示SCSI硬盘，x代表盘号（a：基本盘、b：基本从属盘、c：辅助主盘、d：辅助从属盘），n表示分区数：1-4表示主分区或扩展分区，5以上是逻辑分区</p><pre class="line-numbers language-none"><code class="language-none">查看硬盘分区挂载情况：lsblk -f返回分区情况、分区类型、UUID（40位字符串的唯一标识）、挂载目录查看分区大小：lsblk<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-5-实践"><a href="#4-5-实践" class="headerlink" title="4.5 实践"></a>4.5 实践</h3><ol><li>新增硬盘</li><li>重启服务器</li><li>创建分区<pre class="line-numbers language-none"><code class="language-none">操作：fdisk &#x2F;dev&#x2F;sdb Enter输入n           Enter输入p           Enter连续两次默认选择  Enter输入w           Enter<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><p><strong>命令</strong></p><blockquote><p>m：显示命令列表<br>p：显示磁盘分区<br>n：新增分区<br>d：删除分区<br>w：写入并保存退出</p></blockquote><ol start="4"><li><p>格式化：mkfs -t ext4    /dev/sdb1（ext4为文件类型，/dev/sdb1为分区地址和分区名称）</p></li><li><p>挂载：mount /dev/sdb1 /home/newdisk（mount 设备名称  挂载目录，将/dev/sdb1挂载到/home/newdisk下）</p><blockquote><p>卸载：umont 设备名称/挂载目录，例：mount /dev/sdb1      mount /home/newdisk，取消挂载/dev/sdb1</p></blockquote></li><li><p>设置自动挂载（永久挂载）：vim /etc/fstab 输入挂载信息，保存退出，执行mount -a，即刻生效</p></li></ol><h1 id="5-文件"><a href="#5-文件" class="headerlink" title="5. 文件"></a>5. 文件</h1><p>Linux系统里面，万物皆是文件，包括鼠标、键盘等外部设备都用文件形式进行保存管理，每一个 Linux 用户最多可以开启1024个进程，每个进程最多可以打开2048个文件</p><h2 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1 介绍"></a>5.1 介绍</h2><blockquote><p>所有者：文件的创建者<br>所在组：文件的所在组，一般是创建者的所在组<br>其他组：除去所在组的其他全部组</p></blockquote><h2 id="5-2-管理"><a href="#5-2-管理" class="headerlink" title="5.2 管理"></a>5.2 管理</h2><blockquote><p>新建文件：touch file_name<br>删除文件：rm file_name<br>修改所有者：chown user_name file_name；将file_name的所有者改为user_name</p></blockquote><pre class="line-numbers language-none"><code class="language-none">同时修改所有者和所在组：chown user_name:group_name file_name，将file_name的所有者改为user_name、所在组改为group_name级联修改：chown -R user_name dictionary_name，将dictionary_name目录下的所有文件的所有者改为user_name修改所有组：chgrp group_name file_name，将file_name的所在组改为group_name级联修改：chgrp -R group_name dictionary_name，将dictionary_name目录下的所有文件的所在组改为group_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>查看文件信息：ls -ahl；以列表形式将所有文件以方便用户查看的形式返回，会显示文件类型、文件权限、所有者、所在组、最新更新时间、文件大小的信息</p></blockquote><p><img src="https://qizhongyi.gitee.io/images/System/Linux/File_Info.png" alt="File_Info"></p><h1 id="6-用户管理"><a href="#6-用户管理" class="headerlink" title="6. 用户管理"></a>6. 用户管理</h1><p>Linux是一个多用户多任务的操作系统，任何一个用户必须使用合法的账号才能登入系统，每一个用户账号至少属于一个用户组，存储在/home目录下；用户信息位于 /etc/passwd 文件中；用户组信息位于 /etc/group 文件中</p><ul><li><p><strong>用户组</strong>：类似于角色，对有共性的多个用户进行统一的管理</p><blockquote><p>添加：groupadd group_name<br>删除：groupdel group_name<br>查看：cat /etc/group<br>修改：chgrp -R group_name file_name/dir_name；-R 进行递归修改</p></blockquote></li><li><p><strong>用户</strong>：登入系统进行操作的人员</p><blockquote><p><strong>添加</strong>：useradd [-m -g gorup_name]  &gt; user_name； -m 自动创建家目录， -g 指定所属组，不指定所属组时，会自动创建与用户名同名的用户组，也可以指定目录：useradd -d 路径 user_name<br><strong>设定密码</strong>：passwd user_name，回车输入密码；输入密码后才能登陆<br><strong>删除</strong>：userdel user_name，会保留用户组，如果需要删除用户组，使用：userdel -r user_name，一般保留用户组<br><strong>修改用户登陆的初始目录</strong>：useradd -d directory_name user_name</p><p><strong>查询</strong>：id user_name，返回uid（用户ID号），gid（所在用户组的ID号）和用户组名<br><strong>查看当前用户</strong>：whoami/who am i；who 查看当前登录的所有用户和登录信息<br><strong>修改用户组</strong>：usermod -g gorup_name user_name，修改用户的主组（创建用户时指定的组信息）；usermod -G gorup_name user_name，增加用户的附加组；usermod -s /bin/bash user_name；修改用户登录 Shell（默认为 dash）</p><p><strong>超级用户</strong>：root 进行系统维护和管理，能够访问所有资源；以上操作都需要通过 root 用户操作<br><strong>切换登录用户</strong>：su [-] user_name，su 切换至另一个用户，带有 - 表示同时切换到对应用户的家目录，不指定用户名，切换至 root（不安全）exit：撤销切换指令，高权限用户切换到低权限用户不需要输入密码；sudo 使用另一个用户执行，默认为 root</p></blockquote></li><li><p><strong>配置文件</strong></p><blockquote><p><strong>组配置文件</strong>：/etc/group，数据格式：user_name:password:uid:gid:注释行描述:主目录：登录shell<br><strong>用户配置文件</strong>：/etc/passwd，数据格式：groupname:password:gid:userList(会隐藏起来，不可见)<br><strong>口令文件</strong>：/etc/shadow，加密文件，存放密码信息，删除用户时不会删除相关记录</p></blockquote></li></ul><h1 id="7-权限管理"><a href="#7-权限管理" class="headerlink" title="7. 权限管理"></a>7. 权限管理</h1><h2 id="7-1-介绍"><a href="#7-1-介绍" class="headerlink" title="7.1 介绍"></a>7.1 介绍</h2><p><strong>作用于文件</strong></p><blockquote><p>r：可读，可查看<br>w：可以修改文件，如想要删除文件，需要拥有对文件所在目录的w权限<br>x：可以被执行</p></blockquote><p><strong>作用于目录</strong></p><blockquote><p>r：可读，可进入目录查看<br>w：可在目录内新建、删除、重命名文件或目录<br>x：可进入该目录</p></blockquote><h2 id="7-2-管理"><a href="#7-2-管理" class="headerlink" title="7.2 管理"></a>7.2 管理</h2><blockquote><p>修改权限：chmod（u：所有者、g：所有组、o：其他组、a：所有人）<br>+、-、=进行权限变更</p><blockquote><p>chmod u=rwx,g=rw,o=r file_name，设置file_name所有者的权限为读、写、执行，所在组的权限为读、写，其他人的权限为读<br>chmod o+x file_name，给file_name的所在组增加执行权限<br>通过数字进行权限变更，权限可用数字表示：r=4、w=2、x=1<br>chmod 764 file_name，设置file_name所有者的权限为读、写、执行，所在组的权限为读、写，其他人的权限为读（7=4+2+1；6=4+2；5=4+1；4=4；3=2+1；2=2；1=1；0：无权限）</p></blockquote></blockquote><h1 id="8-Linux软件安装方式"><a href="#8-Linux软件安装方式" class="headerlink" title="8. Linux软件安装方式"></a>8. Linux软件安装方式</h1><h2 id="8-1-rpm"><a href="#8-1-rpm" class="headerlink" title="8.1 rpm"></a>8.1 rpm</h2><p><strong>rpm</strong>（RedHat Package Manager），用于互联网下载包的打包和安装工具，类似于Windows的setup.exe程序<br><strong>查看</strong></p><pre class="line-numbers language-none"><code class="language-none">查看全部：rpm -qa查看指定条件过滤：rpm -qa | grep -i RPM_packake_name查看软件包是否安装：rpm -q RPM_packake_name查看软件包信息：rpm -qi RPM_packake_name查询安装软件包的文件及存放目录：rpm -ql RPM_packake_name查询指定文件所属软件包：rpm -qf RPM_file_name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://qizhongyi.gitee.io/images/System/Linux/RPM_Info.png" alt="RPM_Info" style="zoom:200%;" /><p><strong>管理</strong></p><ul><li><p><strong>安装</strong>：rpm [选项] RPM_packake_name，例：rpm -ivh MySQL…</p><blockquote><p>-i：install，安装<br>-v：verbose，提示<br>-h：hash，显示进度条<br>U盘安装：先挂载CentOS的iso文件，在/media/CentOS/下找到到需要安装的软件rpm包，拷贝到/opt/目录下，在/opt/目录下，执行rpm -ivh RPM_packake_name，安装完成</p></blockquote></li><li><p><strong>删除</strong>：rpm -e RPM_packake_name</p><blockquote><p>删除时如果报错：removing these packages would break dependencies …表示会破坏这个包的相关依赖，可采用rpm -e –nodeps RPM_packake_name进行强制删除，一般不采用，会导致依赖于该软件包的程序无法使用</p></blockquote></li></ul><h2 id="8-2-yum"><a href="#8-2-yum" class="headerlink" title="8.2 yum"></a>8.2 yum</h2><p><strong>yum</strong>，是Shell前端软件包管理器，基于rpm包管理器，能顾从指定的服务器自动下载RPM包并安装，可以自动处理依赖关系，一次性安装所有以来的软件包，使用yum时需要保证网络通畅，默认安装最新版本</p><p><strong>查看</strong></p><pre class="line-numbers language-none"><code class="language-none">查看全部：yum list installed查看指定条件过滤：yum list installed | grep name<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>管理</strong></p><blockquote><p>安装：yum install 软件名</p></blockquote><h2 id="8-3-deb"><a href="#8-3-deb" class="headerlink" title="8.3 deb"></a>8.3 deb</h2><p><strong>deb</strong></p><p><strong>查看</strong></p><pre class="line-numbers language-none"><code class="language-none">dpkg -l(查看全部)dpkg-l|grep name(查看特定)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="8-4-apt"><a href="#8-4-apt" class="headerlink" title="8.4 apt"></a>8.4 apt</h2><p><strong>apt</strong>：Advanced Packaging Tool，是一个安装包管理管理工具，常用于 Ubuntu 中，用于软件包的安装、删除和管理，在 /etc/apt/source.list 中制定了官方的软件仓库地址（通常在美国）；当执行 install 时，安装相应的包，下载并更新，写入 source.list 文件；当执行 update 时，程序分析 source.list 文件是否有对应的 Packages/Sources/lelease 列表文件，如果有就下载，存入 /var/lib/apt/lists/ 目录中<br><strong>修改镜像源</strong></p><blockquote><ol><li>使用前将美国的软件库地址改为清华的软件仓库镜像源：<a href="https://mirrors.tuna.tsinghua.edu.cn/">https://mirrors.tuna.tsinghua.edu.cn/</a><br><img src="https://qizhongyi.gitee.io/images/System/Linux/Ubuntu_apt_source.png" alt="Ubuntu_apt_source"></li><li>更新源：sudo apt-get update</li></ol></blockquote><p><strong>管理</strong></p><blockquote><p>更新源：apt-get update<br>搜索：apt-cache search package_name<br>获取包信息：apt-cache show package_name，包括说明、大小、版本等<br>查看包依赖：apt-cache rdepends package_name<br><strong>安装</strong>：apt-get install package_name<br>修复安装：apt-get -f install package_name<br>重装：apt-get install package_name –reinstall<br><strong>升级</strong>：apt-get upgrade package_name<br><strong>删除</strong>：apt-get remove package_name<br>安装编译环境：apt-get build_dep package_name<br>下载源码：apt-get source package_name<br>删除包和配置文件：apt-get remove package_name –purge<br>升级系统：apt-get dist_upgrade package_name<br>若提示权限不够，可在指令前面加上sudo或者切换到root目录下运行</p></blockquote><pre class="line-numbers language-none"><code class="language-none">例：安装sshd服务安装：sudo apt-get install openssh-server，默认安装服务器端和客户端启动服务：service sshd start本机测试：netstat -anp | moreWindows测试：telnet ip portLinux测试：ssh user_name@ip，退出用exit 或 logout<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="9-文本编辑器"><a href="#9-文本编辑器" class="headerlink" title="9. 文本编辑器"></a>9. 文本编辑器</h1><p><strong>vi/vim（vi的增强版）</strong>：文本编辑器，不能低字体、段落进行排版，不支持鼠标，只使用命令</p><h2 id="9-1-工作模式"><a href="#9-1-工作模式" class="headerlink" title="9.1 工作模式"></a>9.1 工作模式</h2><p><strong>正常模式</strong>：一般模式，使用vi/vim打开即可进入的默认模式，使用上下左右移动光标，使用删除字符和删除整行（dd），进行定位、翻页、复制、粘贴等操作修改文件，不可进行输入；vi/vim f_name ：f_name 进入 vi/vim 的正常模式<br><strong>插入模式</strong>：编辑模式，在正常模式下按 i、insert 进入编辑模式，可进行正常输入修改<br><strong>命令行模式</strong>：在正常模式下，输入“：或者/”进入命令行模式，输入命令，完成读取、存盘、退出、显示行号等操作</p><ul><li><strong>模式切换</strong>：vi/vim打开进入正常模式：正常模式下，按 i 或 insert 进入编辑模式，在里面完成代码编写工作；按 Esc 退回一般模式，输入: 进入命令行模式，进入命令行模式，会在文件最下方出现一个英文冒号，在冒号后输入命令；在命令行模式下，输入 wq (保存修改并退出)、q (未修改退出)、:q! (不保存修改退出) vi/vim 文本编辑</li></ul><h2 id="9-2-常见命令"><a href="#9-2-常见命令" class="headerlink" title="9.2 常见命令"></a>9.2 常见命令</h2><p><strong>进入 vi/vim</strong>：直接进入正常模式</p><pre class="line-numbers language-none"><code class="language-none">vi&#x2F;vim f_name          # 进入上一次退出时光标所在的位置vi&#x2F;vim f_name +[num]   # 进入 num行的位置；省略 num，则光标定位到最后一行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>移动光标</strong>：常用于正常模式下</p><ul><li>前往首行：gg；前往尾行：G</li><li>前往指定行：先输入对应行号（此时页面没有任何显示），再输入 gg 或 G；也可以进入命令行模式，先输入对应行号，然后按回车</li><li>单词移动：w，移动至单词末尾</li><li>向上翻页：Crtl + b(back)；向下翻页：Crtl + f(forward)</li><li>屏幕顶部：H(head)；屏幕中部：M(middle)；屏幕底部：L(low)；保持屏幕不动，光标进行移动</li><li>段落移动：{ 上移一级，} 下移一级</li><li>括号移动：% 可以在相邻的两个() 之间快速移动光标</li><li>标记移动：先添加标记，在移动至标记位置：1. 添加标记 mx （m：mark，x：标记字符，只能是一个大小写英文字符），添加完标记没有任何提示；2. 移动至标记处 ‘x（’：英文状态下的单引号，x：定义的标记字符）</li></ul><p><strong>选择文本</strong>：进入可视模式，可查看选中的代码；在可视模式下，可与移动光标命令连用</p><p>可视模式： v ，小写v，光标选择的全部内容</p><p>可视行模式： V，大写V，光标选择内容的全部行</p><p>可视块模式： Ctrl + v，垂直方向选中文本</p><p><strong>编辑命令</strong>：常用于正常模式下</p><ul><li><strong>删除</strong>：删除选中的文本</li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">cut</td><td align="center">删除光标选中的文字；先输入删除字符数，再按 x，可一次性删除多个字符</td></tr><tr><td align="center">d移动命令</td><td align="center">delete</td><td align="center">删除移动命令对应的内容，先输入d，再输入移动命令，如：d2gg，删除当前行之后的两行</td></tr><tr><td align="center">dd</td><td align="center">delete</td><td align="center">删除当前行；先输入删除行数，再按 dd，可一次性删除多行</td></tr><tr><td align="center">D</td><td align="center">delete</td><td align="center">删除至行尾</td></tr></tbody></table><ul><li>撤销： u(undo)，撤销上次命令，可一直回撤至文件刚打开时的初始状态</li><li>重做： Ctrl + r(redo)，恢复撤销的命令</li><li><strong>复制粘贴</strong></li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">y移动命令</td><td align="center">copy</td><td align="center">复制移动命令对应的内容，先输入y，再输入移动命令，如：y2gg，复制当前行之后的两行</td></tr><tr><td align="center">yy</td><td align="center">copy</td><td align="center">复制当前行；先输入复制行数，再按 dd，可一次性复制多行</td></tr><tr><td align="center">p</td><td align="center">paste</td><td align="center">粘贴；先输入粘贴次数，再按 p，可一次性粘贴多次</td></tr></tbody></table><ul><li>替换</li></ul><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">replace</td><td align="center">替换当前字符</td></tr><tr><td align="center">R</td><td align="center">replace</td><td align="center">复制当前行；先输入复制行数，再按 dd，可一次性复制多行</td></tr></tbody></table><ul><li>设置缩进</li></ul><table><thead><tr><th align="center">命令</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&gt;&gt;</td><td align="center">向右增加缩进，可视模式下，一个 &gt; 就行</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">向左减少缩进，可视模式下，一个 &lt; 就行</td></tr></tbody></table><ul><li><p>查找字符串：/find_str，按n查找下一个，按N查找上一个；* 向上查找光标所在单词所在位置，# 向下查找光标所在单词所在位置；执行查找后，对应字符串一直会高亮显示，可通过查找不存在的内容取消高亮</p></li><li><p>替换字符串： 替换命令包括前面的英文冒号 : </p><blockquote><p>全局替换 :%s/old_str/new_str/g<br>区域替换 :s/old_str/new_str/g，先选中范围，再输入替换命令<br>确认替换 :%s/old_str/new_str/gc，先输入替换命令，再输入替换选项</p><blockquote><p>y-yes：替换，光标移动至下一个<br>n-no：不替换，光标移动至下一个<br>a-all：全部替换<br>q-quit：退出替换<br>l-last：仅替换最后一个，并将光标移动至第一行<br>^E：向下滚屏<br>^Y：向上滚屏</p></blockquote></blockquote></li></ul><p><strong>插入模式命令</strong></p><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">i</td><td align="center">insert</td><td align="center">在当前字符前插入文本；先输入重复次数 num ，再按 i，再输入添加的内容，最后按 ESC，可一次性添加 num次输入的内容</td></tr><tr><td align="center">I</td><td align="center">insert</td><td align="center">在光标所在行首插入文本</td></tr><tr><td align="center">a</td><td align="center">append</td><td align="center">在当前字符后添加文本</td></tr><tr><td align="center">A</td><td align="center">append</td><td align="center">在光标所在行尾添加文本</td></tr><tr><td align="center">o</td><td align="center"></td><td align="center">在当前行下方插入空行，并将光标移动到添加行的行首</td></tr><tr><td align="center">O</td><td align="center"></td><td align="center">在当前行上方插入空行，并将光标移动到添加行的行首</td></tr></tbody></table><p><strong>命令行模式命令</strong></p><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">write</td><td align="center">保存；w f_name 将当前文件的内容写入到 f_name 文件中，不会切换至文件</td></tr><tr><td align="center">q</td><td align="center">quit</td><td align="center">退出；如果文件发生修改未保存，则无法退出</td></tr><tr><td align="center">q!</td><td align="center">quit</td><td align="center">强制退出；文件发生修改未保存时，不保存，强制退出</td></tr><tr><td align="center">wq</td><td align="center">write &amp; quit</td><td align="center">保存文件修改并退出</td></tr><tr><td align="center">x</td><td align="center"></td><td align="center">保存文件修改并退出</td></tr><tr><td align="center">set nu/nonu</td><td align="center"></td><td align="center">设置行号/取消行号</td></tr><tr><td align="center">e f_name</td><td align="center">edit</td><td align="center">切换至 f_name 进行编辑；当前文件修改未保存，无法使用；e . 可以浏览当前目录下的文件列表</td></tr><tr><td align="center">n f_name</td><td align="center">new</td><td align="center">新建名为 f_name 的文件</td></tr><tr><td align="center">sp f_name</td><td align="center">splite</td><td align="center">横向增加分屏；传入 f_name ，则会在新增的屏幕穿窗口新建并打开对应文件</td></tr><tr><td align="center">vsp f_name</td><td align="center">vertical splite</td><td align="center">纵向增加分屏；传入 f_name ，则会在新增的屏幕穿窗口新建并打开对应文件</td></tr></tbody></table><p><strong>分屏命令</strong>：可以同时编辑和查看多个文件，操作窗口都需要先按 Ctrl + w</p><table><thead><tr><th align="center">命令</th><th align="center">英文</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">w</td><td align="center">window</td><td align="center">切换到下一个窗口</td></tr><tr><td align="center">r</td><td align="center">reverse</td><td align="center">交换窗口内容</td></tr><tr><td align="center">c</td><td align="center">close</td><td align="center">关闭当前窗口，但不能关闭最后一个窗口</td></tr><tr><td align="center">q</td><td align="center">quit</td><td align="center">退出当前窗口，如果是最后一个窗口，则关闭 vi</td></tr><tr><td align="center">o</td><td align="center">other</td><td align="center">关闭其他窗口</td></tr></tbody></table><p><strong>快捷键</strong></p><p>重复上一次命令： . 英文点号</p><h2 id="9-3-使用"><a href="#9-3-使用" class="headerlink" title="9.3 使用"></a>9.3 使用</h2><ol><li><strong>删除交换文件</strong>：交换文件(.swp)是通过vi修改文件后，未保存时强制关闭终端命令窗口自动生成的隐藏文件，需要删除后才能继续编辑； vi f_name ，在弹出页面输入英文 d，会恢复到最近一次保存的状态</li></ol><h1 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h1><ul><li><p><strong>连通Windows和Linux</strong><br>安装vmtool</p><pre class="line-numbers language-none"><code class="language-none">export JAVA_HOME&#x3D;&#x2F;usr&#x2F;java&#x2F;jdkexport PATH&#x3D;$JAVA_HOME&#x2F;bin:$PATHexport CLASSPATH&#x3D;.:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:JAVA_HOME&#x2F;lib&#x2F;tools.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li><p><strong>改变终端窗口字体</strong>：放大：ctrl + shift + = ; 缩小：ctrl + -c</p></li><li><p><strong>which</strong>：查看执行命令的所在位置</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-常见问题</title>
      <link href="/202104/1214543.html"/>
      <url>/202104/1214543.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Linux使用中的常见问题</p><span id="more"></span><h1 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h1><p><strong>问题1</strong>：使用service ssh restart 命令时出现Failed to restart ssh.service: Unit not found.</p><blockquote><p>原因：servicecentos6里面的命令，在centos7需要用systemctl<br>解决：使用systemctl restart sshd命令</p></blockquote><p><strong>问题2</strong>：找回root密码</p><blockquote><p>解决：进入到单用户模式，修改root密码，进入单用户模式，不需要输入密码就可以登录到root用户<br>步骤：开机-&gt;在引导时输入回车键Enter-&gt;在出现的界面输入e-&gt;进入一个界面，选择kernel，再输入e-&gt;进入一个界面，输入 空格+1，再按Enter键-&gt;回到kernel界面，输入b，启动进入单用户模式，使用passwd修改密码</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常见问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux-常见指令</title>
      <link href="/202104/1256121.html"/>
      <url>/202104/1256121.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Linux操作系统的常见操作指令</p><span id="more"></span><p><strong>命令格式</strong>：command [-option] [parmeter]</p><h1 id="1-指定运行级别"><a href="#1-指定运行级别" class="headerlink" title="1. 指定运行级别"></a>1. 指定运行级别</h1><p>Init 运行级别</p><blockquote><ul><li>0：关机</li><li>1：单用户（找回丢失密码）</li><li>2：多用户无网络服务</li><li>3：多用户有网络服务，常用</li><li>4：保留的运行级别</li><li>5：图形界面</li><li>6：重启<br>* 配置文件：/etc/inittab的 id:5:initdefault</li><li>init 0/1/2/3/5/6<br><img src="https://qizhongyi.gitee.io/images/System/Linux/Init_Process.png" alt="Init_Process"></li></ul></blockquote><h1 id="2-帮助指令"><a href="#2-帮助指令" class="headerlink" title="2. 帮助指令"></a>2. 帮助指令</h1><ul><li>man 指令，获得帮助信息（the on-line reference manuals）</li></ul><blockquote><p>例：man ls</p></blockquote><ul><li>help 指令，获得shell内置命令的帮助信息</li></ul><blockquote><p>例：help cd,  cd –help 皆可</p></blockquote><h1 id="3-文件目录"><a href="#3-文件目录" class="headerlink" title="3. 文件目录"></a>3. 文件目录</h1><ul><li><strong>pwd</strong>：显示当前目录的绝对路径</li></ul><blockquote><p>例：pwd</p></blockquote><ul><li><strong>ls</strong> [选项]  [目录或文件]：显示指定目录下的文件和目录（list directory contents），默认为当前目录</li></ul><blockquote><p>选项：</p><blockquote><p>-a：显示当前目录下的所有文件和目录，包括隐藏内容，隐藏文件以 . 开头<br>-l：以列表形式显示文件详细信息信息<br>-h：配合 -l 以人性化的方式显示文件大小</p><blockquote><p>例：ls -al  ：以列表形式显示当前目录下包括隐藏内容的所有文件和目录<br>例：ls -l -h  ；ls -lh ；ls -hl ；不关注顺序</p></blockquote></blockquote><p>通配符：</p><blockquote><p>*：匹配任意多个字符，例：ls 1*  显示以 1 开头的文件<br>?：匹配任意一个字符，例：ls 1?.txt 显示以 1 开头且文件名长度为 2 的 txt 文件<br>[]：匹配字符组，例：ls [1-9].txt 显示文件名为 1-9 的 txt 文件，ls [1, d, _].txt</p></blockquote></blockquote><ul><li><strong>cd</strong> [选项]：切换目录（change dictionary）</li></ul><blockquote><p>例：cd .. ：返回上一级目录<br>例：cd . ：切换至当前目录<br>例：cd ~：返回当前用户的home目录/主目录，也可以使用：cd ；后面不跟内容<br>例：cd -：在最近两次工作目录间切换<br>例：cd 路径 ：前往指定目录，可用绝对路径(cd /home/xxx)和相对路径(cd ./xxx)</p></blockquote><ul><li><strong>mkdir</strong> [选项] 目录名：创建目录（make directories）</li></ul><blockquote><p>选项：-p，创建多级目录，默认一次只能创建一级目录</p><blockquote><p>例：mkdir -p /home/animal/dog ：在home目录下创建animal，再在animal下创建dog，若之前有animal目录则不需要-p选项</p></blockquote></blockquote><ul><li><strong>rmdir</strong> [选项] 目录名：删除空目录（remove empty directories）</li></ul><blockquote><p>若要删除非空目录，应使用：rm -r 目录名</p></blockquote><ul><li><strong>touch</strong> 文件名：创建空文件，可一次创建多个文件；如果文件已存在，就修改文件的末次修改时间</li></ul><blockquote><p>例：touch hello.txt helloword.txt<br>例：touch /home/user/xxx.txt  ；允许级联创建</p></blockquote><ul><li><p><strong>rm</strong> [选项] 目录名或文件名：删除文件或目录（remove），默认有删除提示；删除后不能恢复；可以使用通配符</p><blockquote><p>选项：</p><blockquote><p>-r：递归删除整个文件夹<br>-f：强制删除不提示<br>-rf：强制递归删除整个文件夹不提示（慎用！！！）</p><blockquote><p>例：rm -r * 删除当前文件夹内的所有文件和目录</p></blockquote></blockquote></blockquote></li><li><p><strong>tree</strong> [选项] 目录名：以树状图列出文件目录结构；省略则输出当前文件夹的目录结构</p><blockquote><p>选项：</p><blockquote><p>-d 只显示目录</p><blockquote><p> 例：tree -d ~，显示根目录下的目录树</p></blockquote></blockquote></blockquote></li><li><p><strong>cp</strong> [选项] source(数据源) dest(目标位置)：复制文件到指定目录（copy）</p><blockquote><p>选项：</p><blockquote><p>-r 递归复制整个文件夹<br>-i 覆盖文件前给予提示</p><blockquote><p>例：cp -r test1/ test2/：将test1整个复制到test2里面</p></blockquote></blockquote><p><strong>SCP</strong>：远程CP，-P 指定端口</p></blockquote></li><li><p><strong>mv</strong> 移动或重命名文件或目录（move）</p><blockquote><p>移动</p><blockquote><p>文件：mv file_name dictionary_name<br>文件夹：mv dictionary_name dictionary_name</p></blockquote><p>重命名</p><blockquote><p>文件：mv old_file_name new_file_name（如果存在同名，会覆盖；支持 -i 覆盖文件前给予提示）<br>文件夹：mv old_dictionary_name new_dictionary_name</p></blockquote></blockquote></li><li><p><strong>cat</strong> [选项] 目录名：以只读的方式打开文件；将文件一次性全部显示，适用于文件内容较少的文件</p></li></ul><blockquote><p>选项</p><blockquote><p>-n：显示行号，包含空行<br>-b：显示行号，不包含空行</p></blockquote></blockquote><ul><li><strong>more</strong> [选项(-dflpcsu)]  [-num]  [+linenum | +/pattern] 文件名：以全屏的方式按页显示文件内容，加载完全部内容，再进行显示，按空格键进行翻页</li></ul><blockquote><p>选项</p><blockquote><ul><li>-d：提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声</li><li>-l：取消遇见特殊字符，默认是将^L(表单提要)视为特殊字符，在包含表单提要的任何行之后暂停，使用-l会避免上述情况</li><li>-f：计算行数时，以实际上的行数，而非自动换行过后的行数(有些单行字数太长的会被扩展为两行或两行以上)</li><li>-p：不以卷动的方式显示每一页，而是先清除萤幕后再显示内容</li><li>-c：跟 -p 相似，不同的是先显示内容再清除其他旧资料</li><li>-s：当遇到有连续两行以上的空白行，就代换为一行的空白行</li><li>-u：不显示下引号 (根据环境变数 TERM 指定的 terminal 而有所不同)</li><li>-num：设置一次显示的行数</li><li>+linenum：开始显示的行号</li><li>+/pattern：在每个文档显示前搜寻该字串(pattern)，然后从该字串之后开始显示</li></ul></blockquote><p>快捷键</p><blockquote><ul><li>空格键：向下翻页</li><li>Enter：下翻一行</li><li>q：退出more指令</li><li>Ctrl + F：向下滚动一屏</li><li>Ctrl + B：向上滚动一屏</li><li>=：显示当前行号</li><li>:f：输出文件名和当前行号</li></ul></blockquote></blockquote><ul><li><strong>less</strong> [选项] 文件名：功能同more，支持各种显示终端，根据显示需要动态加载内容，对显示大型文件有较高的效率</li></ul><blockquote><p>快捷键</p><blockquote><ul><li>空格键/PageDown：向下翻页</li><li>PageUp：向上翻页</li><li>Enter：下翻一行<br>/字符串：向下查找字符串内容：n-向下查找；N-向上查找<br>?字符串：向上查找字符串内容：n-向上查找；N-向下查找</li><li>q：退出less指令</li></ul></blockquote></blockquote><ul><li><strong>head</strong> [-n] 文件名：显示文件开头部分内容，默认显示10行，n为正整数</li><li><strong>tail</strong> [选项] 文件名：显示文件结尾部分内容，默认显示10行</li></ul><blockquote><p>-n：设置显示的文件内容行数，n为正整数<br>-f：实时监控文件的更新情况</p></blockquote><ul><li><strong>ln -s</strong> [原文件或目录]  [连接名]：软连接，符号链接，类似于Windows的快捷方式，存放连接其他文件的路径；使用绝对路径，-s 表示建立软连接，省略表示建立硬链接（删除源文件，硬链接仍可以访问）</li><li><strong>history</strong> [n]：查看已经执行过的指令，也可以执行历史指令，n为正整数，显示最近执行的n条指令，使用 !n，可以执行历史编号为n的指令</li></ul><h1 id="4-时间日期"><a href="#4-时间日期" class="headerlink" title="4. 时间日期"></a>4. 时间日期</h1><ul><li><strong>date</strong> [选项]  [+ 显示格式]：显示当前时间，注意date与+之间有一个空格</li></ul><blockquote><p>显示格式：</p><blockquote><p>%Y：显示当前年份<br>%m：显示当前月份<br>%w：显示当前星期<br>%d：显示当前日期<br>%Y%%d%H%M%S：显示当前年月日时分秒，可以在中间加入分隔符，date ‘+%Y年%m月%d日 %H:%M:%S’，需要用引号包裹<br>选项<br>-s：设定当前系统时间：date -s ‘yyyy-mm-dd HH:MM:ss’</p></blockquote></blockquote><ul><li><strong>cal</strong> [时间]：默认显示当前月的日历，时间为年份，加上时间显示指定年份一整年的日历；cal -y</li></ul><h1 id="5-搜索查找"><a href="#5-搜索查找" class="headerlink" title="5. 搜索查找"></a>5. 搜索查找</h1><ul><li><strong>find</strong> [范围]  [选项]：从指定目录下递归遍历各个子目录，将满足条件的内容显示在终端</li></ul><blockquote><p>选项：</p><blockquote><p>-name ：按照文件名进行查找，例：find / -name *1.txt，查找文件名以 1 结尾的 txt 文件<br>-user：按照文件拥有者进行查找<br>-size [+/-]Size：按照文件大小进行查找，+表示大于，-表示小于，不写表示等于Size，Size表示文件大小，100k、20M</p></blockquote></blockquote><ul><li><strong>locate</strong> 文件名称：根据locate数据库快速定位文件路径，locate存储系统中所有文件名称及路径，需要及时更新，第一次执行前，需要使用updatedb指令创建locate数据库</li><li><strong>grep</strong> [选项] 查找内容 源文件：过滤查找，管道符 | ，表示将前一个命令的处理结果输出传递给后面的指令处理</li></ul><blockquote><p>选项：</p><blockquote><p>-n：显示行号<br>-i：忽略大小写<br>-v：返回不包含指定内容的行，包含空行</p><blockquote><p>例：grep -niv abc file_name ；返回 file_name 内包含 abc 的行，显示行号，同时忽略大小写</p></blockquote></blockquote><p>模式查找：也成为正则表达式，可配合选项进行操作</p><blockquote><p>^a：查找以 a 开头的行<br>a$：查找以 a 结束的行</p><blockquote><p>例：grep -n ^a file_name</p></blockquote></blockquote></blockquote><h1 id="6-打包压缩"><a href="#6-打包压缩" class="headerlink" title="6. 打包压缩"></a>6. 打包压缩</h1><ul><li><strong>tar</strong> [选项]  文件名：打包指令，不进行压缩，打包文件为 .tar 后缀</li></ul><blockquote><p>选项：</p><blockquote><p>-c：创建打包文件，生成档案文件<br>-f：指定档案文件名称，必须放在最后<br>-v：列出打包或解包的详细过程，显示进度<br>-x：解开打包文件<br>-z：调用 gzip ，实现压缩和解压缩命令；打包压缩文件为 .tar.gz 后缀（用tar进行打包，gzip进行压缩）</p><p>-j：调用 bzip2 ，实现压缩和解压缩命令；打包压缩文件为 .tar.bz2 后缀</p><blockquote><p>例：tar -cvf 1_tar.tar 1* ，将当前目录下的以 1 开头的文件打包为1_tar.tar；解包 tar -xvf 1_tar.tar</p><p>例：tar -zcvf 1_tar.tar.gz 1* ，将当前目录下的以 1 开头的文件打包并压缩为1_tar.tar.gz；解压缩包 tar -zxvf 1_tar.tar.gz [-C] 指定解压缩的目录（目录必须存在）</p></blockquote></blockquote></blockquote><ul><li><p><strong>gzip/gunzip</strong> 文件名：gzip压缩文件，不保留源文件；gunzip解压文件，压缩文件为gz后缀</p></li><li><p><strong>bzip2</strong>：与 tar 命令结合实现打包压缩</p></li></ul><blockquote><p>例：tar -jcvf 1_tar.tar.bz2 1* </p></blockquote><ul><li><strong>zip/unzip</strong> [选项] 文件名：压缩文件为zip后缀</li></ul><blockquote><p>选项：</p><blockquote><p>-r：递归压缩，压缩文件目录，例：zip -r 文件名  目录/<br>-d 目录：指定解压目录，例：unzip -d /目录  文件名</p></blockquote></blockquote><h1 id="7-定时机制"><a href="#7-定时机制" class="headerlink" title="7. 定时机制"></a>7. 定时机制</h1><p><strong>crontab</strong> [选项]</p><blockquote><p>选项</p><blockquote><p>-e：开始任务<br>-r：删除所有任务<br>-l：显示当前的cron任务<br>service crond start ：重启任务调度</p></blockquote></blockquote><pre class="line-numbers language-none"><code class="language-none">例：每分钟将etc的目录内容写入到tmp的to.txt文件中1. cron -e2. 输入：\*&#x2F;1 * * * * ls -l &#x2F;etc&#x2F; &gt;&gt; &#x2F;tmp&#x2F;to.txt3. 保存退出后生效<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>corn表达式</strong></p><blockquote><p>第一个*：一小时中的第几分钟，取0-59<br>第二个*：一天的第几小时，取0-23<br>第三个*：一月中的第几天，取1-31<br>第四个*：一年中的低级月，取1-12<br>第五个*：一周中的星期几，取0-7（0、7代表星期天）<br>可用*代表任何时间，用,指定多个不连续的时间，例：1,3,6，表示仅1，3，6执行，用-表示范围，例：1-6，表示1至6都执行，用/n表示多久执行一次，例：*/1 * * * *，每分钟执行一次</p></blockquote><h1 id="8-磁盘管理"><a href="#8-磁盘管理" class="headerlink" title="8. 磁盘管理"></a>8. 磁盘管理</h1><ul><li><strong>df</strong> [选项] ：disk free，查询系统整体磁盘剩余空间</li></ul><blockquote><p>-l：以列表形式显示信息<br>-h：按照用户可理解的形式显示，带计量单位</p></blockquote><ul><li><strong>du</strong> [选项]：disk useage，查询指定目录的磁盘占用情况</li></ul><blockquote><p>-s：指定目录占用大小汇总<br>-h：按照用户可理解的形式显示，带计量单位<br>-a：含文件<br>-c：列出明细的同时，增加汇总值<br>–max-depth = 1：子目录的深度<br>例：du -ach –max-depth = 1 /opt，统计/opt目录的磁盘占用情况，深度为1</p></blockquote><ul><li><strong>常用</strong></li></ul><blockquote><p>ls -l /home | grep “^-“ | wc -l，统计home文件夹下文件的个数，“^-”表示以-开头，wc表示统计<br>ls -lR /home | grep “^-“ | wc -l，统计home文件夹及子文件下文件的个数<br>tree /home，以树状图显示home文件夹</p></blockquote><h1 id="9-进程管理"><a href="#9-进程管理" class="headerlink" title="9. 进程管理"></a>9. 进程管理</h1><h2 id="9-1-基本介绍"><a href="#9-1-基本介绍" class="headerlink" title="9.1 基本介绍"></a>9.1 基本介绍</h2><ul><li>每个执行的程序（代码）都成为一个进程，每一个进程都分配一个ID号</li><li>每一个进程都会对应一个父进程，父进程可以复制多个子进程，Linux最大的进程是init</li><li>每一个进程都能以前台和后台两种方式存在，前台进程就是用户在米钱屏幕上可以进行操作，后台进程则实际在操作，但屏幕上无法显示，一般采用后台方式执行</li><li>一般系统的服务都是以后台进程的方式存在，会常驻在系统中，知道关机结束</li></ul><h2 id="9-2-进程管理-进程"><a href="#9-2-进程管理-进程" class="headerlink" title="9.2 进程管理-进程"></a>9.2 进程管理-进程</h2><ul><li><strong>ps</strong> [选项]：process status查看当前系统中正在执行的进程和其执行情况</li></ul><blockquote><p>选项</p><blockquote><p>-a：当前终端的所有进程信息<br>-f：全格式显示<br>-u：显示进程详细状态信息<br>-x：显示后台进程<br>进程信息<br>USER：用户名<br>PID：进程识别号<br>%CPU：此进程占用CPU的百分比情况<br>%MEM：此进程占用内存的百分比情况<br>VSZ：此进程的虚拟内存占用情况<br>RSS：此进程的物理内存占用情况<br>TTY：终端机号<br>STAT：此进程的运行状态：S-休眠，s-表示此进程是会话的先导进程，R-运行，D-短期等待，Z-僵死进程，T-被跟踪或被停止的进程，N-表示此进程比普通进程的优先级更低<br>START：此进程的启动时间<br>TIME：此进程占用CPU的总时间<br>COMMAND：进程执行时的命令和参数</p><blockquote><p>查看父进程：ps -ef | more，显示的PPID为父进程进程号<br>查看指定进程的父进程：ps -ef | sshd，查看sshd的父进程</p></blockquote></blockquote></blockquote><ul><li><p><strong>top</strong> [选项]：显示正在执行的进程，top会在运行一段时间可以更新正在运行的进程</p><blockquote><p>选项</p><blockquote><p>-d n：指定n秒后自动更新，默认三秒<br>-i：不显示任何闲置或僵死进程<br>-p：通过指定进程ID进监控进程状态<br>交互说明<br>P：以CPU使用规律排序，默认选项<br>M：以内存使用率排序<br>N：以PID排序<br>q：退出top指令<br><img src="https://qizhongyi.gitee.io/images/System/Linux/Service_Info.png" alt="Service_Info"></p></blockquote><p>使用</p><blockquote><p>监控指定用户：先输入top，回车，在输入u，最后输入用户名<br>中止指定服务：先输入top，回车，在输入k，最后输入进程号</p></blockquote></blockquote></li><li><p><strong>pstree</strong> [选项]：查看进程树</p></li></ul><blockquote><p>-p：显示进程的PID<br>-u：显示进程的所属用户</p></blockquote><ul><li><strong>kill</strong> [选项] 进程号</li></ul><blockquote><p>选项：-9 强制进程立即终止</p></blockquote><ul><li><strong>killall</strong> 进程名，支持通配符</li></ul><blockquote><p>终止：当进程需要停止或消耗了大量的系统资源时执行</p></blockquote><ul><li><strong>常见进程</strong></li></ul><blockquote><p>sshd：远程登陆<br>bash：终端命令行窗口</p></blockquote><h2 id="9-3-进程管理-服务"><a href="#9-3-进程管理-服务" class="headerlink" title="9.3 进程管理-服务"></a>9.3 进程管理-服务</h2><h3 id="9-3-1-基本介绍"><a href="#9-3-1-基本介绍" class="headerlink" title="9.3.1 基本介绍"></a>9.3.1 基本介绍</h3><p>服务（Service）的本质是后台运行的进程，通常会监听某一个端口，等待其他程序的请求，又叫守护进程，每一个服务都会在0-6的Linux运行级别下通过chkconfig设置是否自启动<br><img src="https://qizhongyi.gitee.io/images/System/Linux/Service_wrok.png" alt="Service_wrok"></p><p><strong>service</strong> 服务名 start|stop|restart|reload|status</p><blockquote><p>CentOS 7.0以后使用systemctl，不再使用service</p></blockquote><pre class="line-numbers language-none"><code class="language-none">重启防火墙：service iptables restart查看防火墙状态：service iptablesstatus<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><blockquote><blockquote><p>关闭或启用防火墙后立即生效，可用telnet ip 端口进行测试<br>设置仅当次有效，系统重启后回到原有设置，可用chkconfig设置永久生效<br>查看服务<br>setup，进入系统服务，加入_*_号的服务均会自启动，可以直接修改<br>查看/etc/init.d目录下的内容<br>常见服务<br>防火墙：iptables</p></blockquote></blockquote><p><strong>chkconfig</strong>；给每个服务指定各个运行级别是否自启动</p><blockquote><p>查看所有服务：chkconfig –list<br>查看指定服务：</p><blockquote><p>chkconfig –list | grep 服务名<br>chkconfig 服务名 –list<br>修改指定服务指定运行级别的自启动状态：chkconfig –level 5 服务名 off/on，在所有运行级别下设置，直接省略–level<br>监控</p></blockquote></blockquote><p><strong>netstat</strong> [选项]：查看网络服务情况</p><blockquote><p>选项：</p><blockquote><p>-an：按照一定顺序排列输出<br>-p：显示那个进程在调用</p></blockquote></blockquote><h1 id="10-其他"><a href="#10-其他" class="headerlink" title="10. 其他"></a>10. 其他</h1><ul><li><p><strong>ntsysv</strong>：查看系统自启动服务</p></li><li><p><strong>echo</strong> [选项]  [输出内容]：输出内容到控制台，常和重定向配合使用</p></li><li><p>**&gt; / &gt;&gt;**：输出重定向；将命令执行结果输出（将原来文件的内容覆盖）或追加到指定文件中</p><blockquote><p>echo hello &gt; a.txt  ；将 hello 写到 a.txt 中<br>ls -l <strong>&gt;</strong>   a.txt：将ls -l显示的内容<strong>覆盖写</strong>入到a.txt里面，如文件不存在，则创建文件<br>ls -l <strong>&gt;&gt;</strong> a.txt：将ls -l显示的内容<strong>追加写</strong>入到a.txt里面</p></blockquote></li><li><p><strong>|</strong> 管道命令：可以将一个命令的输出作为另一个命令的输入</p></li></ul><blockquote><p>例：cat -n hello.txt | more，以cat命令打开hello.txt，将内容以分页带有行号显示</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows-基础</title>
      <link href="/202104/117798.html"/>
      <url>/202104/117798.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Windows系统 的相关基础知识</p><span id="more"></span><h1 id="1-操作命令"><a href="#1-操作命令" class="headerlink" title="1. 操作命令"></a>1. 操作命令</h1><h2 id="1-1-文件类"><a href="#1-1-文件类" class="headerlink" title="1.1 文件类"></a>1.1 文件类</h2><ul><li>dir：查看当前目录的内容</li><li>dir /s：查看当前目录文件及其子目录文件</li><li>dir /a：查看包括隐藏文件的所有文件</li><li>dir /ah：只显示隐藏文件</li><li>dir /w：粗略查看文件</li><li>dir /s|more：逐个查看</li><li>cd ..：返回至上级目录</li><li>cd /：返回根目录</li><li>tree：显示目录树</li><li>md：创建目录</li><li>rd：删除目录</li><li>copy test C:\xxx：将test复制到C盘的xxx目录下</li><li>move test.jpg C:\test.jpg：将test图片移动至C盘根目录下</li><li>del test.txt：删除test文件</li><li>deltree：删除当前目录及其子目录的所有文件</li><li>type test.txt ：查看test文本文件的内容</li><li>echo：输入内容到文件</li><li>ren test.txt t.txt：将test改名为t</li></ul><h2 id="1-2-进程管理"><a href="#1-2-进程管理" class="headerlink" title="1.2 进程管理"></a>1.2 进程管理</h2><ul><li><strong>查看正在运行的进程</strong>：netstat -ano | findstr &lt;端口号&gt;</li></ul><blockquote><p>查询结果：协议(TCP/UDP) 服务器IP及运行端口 0.0.0.0:0 监听状态(LISTENING) 进程号(PID)</p></blockquote><ul><li><strong>关闭进程</strong>：taskkill -PID &lt;进程号&gt; -F</li></ul><h2 id="1-3-其他"><a href="#1-3-其他" class="headerlink" title="1.3 其他"></a>1.3 其他</h2><ul><li>cls：清屏</li><li>exit：退出dos窗口</li></ul><h1 id="2-常见问题"><a href="#2-常见问题" class="headerlink" title="2. 常见问题"></a>2. 常见问题</h1><p><strong>问题1</strong>：命令行中文乱码</p><ul><li>解决：在 cmd 命令行窗口下通过 chcp 命令改变代码页：chcp 65001（65001为UTF-8的代码页）</li></ul><p><strong>问题2</strong>：在 cmd 命令行窗口无法Tab自动补全</p><ul><li>解决：进入注册表，修改配置；<strong>操作</strong>：同时按住 win + r，输入regedit，回车进入注册表，找到目录\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Command Processor，右键右侧的CompletionChar，修改数值数据为9，基数为十进制，最后点击确定</li></ul><p><img src="https://qizhongyi.gitee.io/images/System/Windows/CMD_Tab.png" alt="CMD_Tab"></p><p><strong>问题3</strong>：在 cmd 命令行窗口实现复制粘贴</p><ul><li>解决：打开 cmd命令行窗口，鼠标移动至在标题栏上点击鼠标右键，点击属性；在弹出的属性对话框中，切换至 选项选项卡，勾选编辑选项的全部选项；以后在 cmd 命令行窗口中使用 <strong>Ctrl + Shift + C/V</strong> 实现复制粘贴</li></ul><p><img src="https://qizhongyi.gitee.io/images/System/Windows/CMD_Copy.png" alt="CMD_Copy"></p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式-基础</title>
      <link href="/202104/1031609.html"/>
      <url>/202104/1031609.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 设计模式使用 的相关基础知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p>软件设计模式（Software Design Pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结，是解决特定问题的一系列套路，具有一定的普遍性，可以反复使用</p><h2 id="1-1-优点"><a href="#1-1-优点" class="headerlink" title="1.1 优点"></a>1.1 优点</h2><ul><li>可以提高程序员的思维能力、编程能力和设计能力</li><li>使程序设计更加标准化、代码编制更加工程化，提高软件开发效率，从而缩短软件的开发周期</li><li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强</li></ul><h2 id="1-2-基本要素"><a href="#1-2-基本要素" class="headerlink" title="1.2 基本要素"></a>1.2 基本要素</h2><ul><li>模式名称（PatternName）：根据模式的问题、特点、解决方案、功能和效果来命名。模式名称有助于理解和记忆该模式，也方便来讨论</li><li>问题（Problem）：描述该模式的应用环境，即何时使用该模式。它解释了设计问题和问题存在的前因后果，以及必须满足的一系列先决条件</li><li>解决方案（Solution）：模式问题的解决方案包括设计的组成成分、它们之间的相互关系及各自的职责和协作方式，提供设计问题的抽象描述和怎样用具有一般意义的元素组合（类或对象的组合）来解决特定问题</li><li>效果（Consequence）：描述了模式的应用效果以及使用该模式应该权衡的问题，即模式的优缺点。主要是对时间和空间的衡量，以及该模式对系统的灵活性、扩充性、可移植性的影响，也考虑其实现问题</li></ul><h1 id="2-设计原则-SOLID"><a href="#2-设计原则-SOLID" class="headerlink" title="2. 设计原则(SOLID)"></a>2. 设计原则(SOLID)</h1><ul><li><strong>单一职责原则</strong>(SRP：Single Responsibility Principle)：单个软件组件（函数、类、模块）专注于单一任务、完成单一功能</li></ul><blockquote><p>可以降低类的复杂度，一个类只负责一项职责，逻辑要比负责多项职责简单<br>提高类的可读性，提高系统的可维护性<br>降低变更引起的风险</p><blockquote><p>单一职责原则不只是面向对象编程思想所特有的，只要是模块化的程序设计，都适用单一职责原则。实际使用：Ａ.只有逻辑足够简单，才可以在代码级别上违背ＳＲＰ；Ｂ.只有类中方法数量足够少，才可以在方法级别上违背ＳＲＰ</p></blockquote></blockquote><ul><li><strong>开/闭原则</strong>(OCP：Open-Closed Principle)：在设计时必须考虑到可能的发展，但是必须最少化修改已有的代码，对扩展开放，对修改关闭</li></ul><blockquote><p>使单元测试也能够OCP<br>帮助缩小逻辑粒度，以提高可复用性<br>可以使维护人员只扩展一个类，而非修改一个类，从而提高可维护性<br>在设计之初考虑所有可能变化的因素，留下接口，从而符合面向对象开发的要求</p><blockquote><p>实际使用：封装变化：按可能变化的不同去封装变化；抽象约束：抽象层尽量保持稳定，一旦确定即不允许修改</p></blockquote></blockquote><ul><li><strong>里氏替换原则</strong>(LSP：Liskov Substitution Principle)：表明只要继承的是同一个接口，任意一个类都被其他类替换，程序仍可正常运行，使用父类的地方可以用子类来替换</li><li><strong>接口隔离原则</strong>(ISP：Interface Segregation Principle)：将大而全的接口拆分成小的更具体的接口（特定需求接口），只提供访问者需要的方法</li><li><strong>依赖反转原则</strong>(DIP：Dependency Inversion Principle)：一个方法依赖于抽象（接口）而不是一个实例（类），高层不应该依赖底层，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象</li><li><strong>迪米特原则/最少知识原则</strong>(DP：Demeter Principle)：一个对象应该对其他对象有最少的了解</li><li><strong>合成复用原则</strong>：尽量使用对象的组合/聚合，而不是继承关系达到软件复用的目的</li></ul><h1 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h1><ul><li><strong>单例模式</strong>（Singleton）：保证一个类只有一个实例，并提供一个访问它的全局访问点</li><li><strong>工厂方法模式</strong>（Factory Method）：定义一个用于创建对象的接口，让子类进行实例化，将类的实例化延迟到子类</li><li><strong>抽象工厂模式</strong>（Abstract Factory）：提供一个创建一系列相关或相互依赖对象的接口，不指定具体类</li><li><strong>建造者模式</strong>（Builder）：将一个复杂对象的构建与他的表示分离，使构建过程可以创建不同的表示</li><li><strong>原型模式</strong>（Prototype）：使用原型实例指定创建对象的种类，通过拷贝原型创建新的对象</li></ul><h1 id="4-结构型模式概述"><a href="#4-结构型模式概述" class="headerlink" title="4. 结构型模式概述"></a>4. 结构型模式概述</h1><ul><li><strong>适配器模式</strong>（Adapter）：将一类接口转换成另外一个接口，使原本由于接口不兼容不能一起工作类协同工作</li><li><strong>装饰器模式</strong>（Decrator）：动态地给对象增加一些额外的职责（相比生成子类更加灵活）</li><li><strong>代理模式</strong>（Proxy）：为其他对象提供一种代理以控制对这个对象的访问</li><li><strong>外观模式</strong>（Facade）：为子系统中的一组接口提供一致的界面，使得子系统更容易使用</li><li><strong>桥接模式</strong>（Bridge）：将抽象部分与它的实现部分分离，使他们可以独立变化</li><li><strong>组合模式</strong>（Composite）：将对象组合成树形结构以表示部分整体的关系</li><li><strong>享元模式</strong>（Flyweight）：运用共享技术有效地支持大量细粒度的对象</li></ul><h1 id="5-行为型模式概述"><a href="#5-行为型模式概述" class="headerlink" title="5. 行为型模式概述"></a>5. 行为型模式概述</h1><ul><li><strong>模板方法模式</strong>（Template Method）：定义一个操作中的算法的骨架，将具体实现延迟到子类中，可使子类不改变算法结构即可重定义该算法</li><li><strong>策略模式</strong>（Strategy）：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户</li><li><strong>命令模式</strong>（Command）：将请求封装为对象，用不同的请求对客户进行参数化，对请求进行排队和记录请求日志，支持可撤销的操作</li><li><strong>责任链模式</strong>（China of Responsibility）：使多个对象都有机会处理请求，减少请求送发者和接收者之间的耦合关系</li><li><strong>状态模式</strong>（State）：允许对象在其内部状态改变时改变他的行为</li><li><strong>观察者模式</strong>（Observer）：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新</li><li><strong>中介者模式</strong>（Mediator）：用中介对象封装一些列的对象交互</li><li><strong>迭代器模式</strong>（Iterator）：提供一个方法顺序访问一个聚合对象的各个元素，不暴露该对象的内部表示</li><li><strong>访问者模式</strong>（Visitor）：表示一个作用于某对象结构中的各元素的操作，在不改变各元素类的前提下定义作用于这个元素的新操作</li><li><strong>备忘录模式</strong>（Memento）：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存状态</li><li><strong>解释器模式</strong>（Interpreter）：给定一个语言，定义其文法的一个表示，并定义一个使用该表示来解释语言的解释器</li></ul><h1 id="6-注意事项"><a href="#6-注意事项" class="headerlink" title="6. 注意事项"></a>6. 注意事项</h1><p>方法参数尽量避免基本类型</p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络-通识</title>
      <link href="/202104/1025765.html"/>
      <url>/202104/1025765.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 计算机网络 的相关基础知识</p><span id="more"></span><h1 id="1-简单介绍"><a href="#1-简单介绍" class="headerlink" title="1. 简单介绍"></a>1. 简单介绍</h1><p><strong>计算机网络</strong>：将多台位置不同的计算机，通过通信线路链接，遵循网络通讯协议，实现信息共享和资源传递</p><h2 id="1-1-覆盖范围"><a href="#1-1-覆盖范围" class="headerlink" title="1.1 覆盖范围"></a>1.1 覆盖范围</h2><ul><li>广域网 WAN (Wide Area Network)：几十到几千km，为一个城市地区所有，10Mbps以下，误码率10^-7-10^-6之间，由高速链路相连；</li><li>城域网 MAN (Metropolitan Area Network)：5-50千米，为一个小地域所有，10-100Mbps，误码率&lt;10^-9</li><li>局域网 LAN (Local Area Network) ：10km以内，为一个单位组织所有，10Mbps以上，误码率10^-11-10^-8之间；</li><li>个人区域网 PAN (Personal Area Network) ：10m左右，将个人电子设备相连。</li></ul><h2 id="1-2-拓扑结构"><a href="#1-2-拓扑结构" class="headerlink" title="1.2 拓扑结构"></a>1.2 拓扑结构</h2><ul><li><strong>总线型</strong>：以一条公共总线为传输介质，信号沿总线广播传送（两个以上节点同时发数据会造成冲突）</li><li><strong>星型</strong>：由一台中央节点和周围节点组成，从节点通过中央节点转接进行通信（中央节点控制全网）</li><li><strong>环型</strong>：以一个硬件接口入网，首尾相连形成链路，信号沿总线广播沿一个方向单向逐点传送（一个入网接口瘫痪，会造成全网瘫痪）</li><li><strong>树型</strong>：</li></ul><h2 id="1-3-性能指标"><a href="#1-3-性能指标" class="headerlink" title="1.3 性能指标"></a>1.3 性能指标</h2><ul><li>速率：数据的传送速率</li><li>带宽：数字信道所能传送的最高数据率，单位是“ b/s（比特每秒）”</li><li>吞吐量：在单位时间内通过某个网络（或信道、接口）的数据量</li><li>时延：包括发送时延、传播时延、处理时延、排队时延等</li><li>利用率：某信道有百分之几的时间是被利用的（有数据通过）</li></ul><h2 id="1-4-冯·诺伊曼体系结构"><a href="#1-4-冯·诺伊曼体系结构" class="headerlink" title="1.4 冯·诺伊曼体系结构"></a>1.4 冯·诺伊曼体系结构</h2><ul><li><strong>应用层</strong>(application layer) ：通过应用进程间的交互完成特定的网络应用</li><li><strong>运输层</strong>(transport layer) ：为两台主机中进程之间的通信提供通用数据传输服务，向应用层传递报文</li></ul><blockquote><p>传输控制协议TCP：<br>用户数据报协议UDP：</p></blockquote><ul><li><strong>网络层</strong>(network layer) ：将运输层产生的报文段或用户数据报封装成分组或包，寻找合适的路由传输</li></ul><blockquote><p>IP协议</p></blockquote><ul><li><strong>数据链路层</strong>(data link layer) ：将网络层产生的IP数据报组装成帧,在相邻两个节点传送</li><li><strong>物理层</strong>(physical layer) ：确定与传输媒体的接口的一些特性</li></ul><h1 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h1><h2 id="2-1-解决问题"><a href="#2-1-解决问题" class="headerlink" title="2.1 解决问题"></a>2.1 解决问题</h2><blockquote><p><strong>封装成帧</strong>：在一段数据的前后分别添加首部和尾部，构成一个数据帧，确定帧的界限<br><strong>透明传输</strong>：在一个数据帧中的数据部分出现了和首部和尾部相同的数据，导致不能准确的进行帧定界。解决：在发送端给数据中出现控制字符“SOH（首）”或“EOT（尾）”的前面插入一个转义字符“ESC”(其十六进制编码是 1B)<br><strong>差错控制</strong>：比特差错：传输错误的比特占所传输比特总数的比率为误码率BER (Bit Error Rate)，与信噪比有较大关系，广泛提供循环冗余检验 CRC 检错技术</p></blockquote><h2 id="2-2-信道通信方式"><a href="#2-2-信道通信方式" class="headerlink" title="2.2 信道通信方式"></a>2.2 信道通信方式</h2><ul><li><strong>点对点信道</strong>：使用一对一的点对点通信方式(点对点协议 PPP (Point-to-Point Protocol))</li></ul><blockquote><p><strong>需求</strong></p><blockquote><p>简单——这是首要的要求<br>封装成帧<br>透明传输</p><ul><li>在同步传输时，采用硬件来完成比特填充</li></ul><blockquote><p>同步传输（STM）：面向比特，以数据帧为单位传输，数据帧开始有一组同步字符，通知数据帧到达并使双方进入同步，结束有帧结束标记，负载增值较小，传输速度快<br>比特填充：发送端在5个连续的1之后加入一个0，接收端将5个连续1之后的0删除</p></blockquote><p>在异步传输时，采用一种特殊的字符填充</p><blockquote><p>异步传输（ATM）：面向字符，以字符为单位传输，发送方可以在任何时刻发送比特组，接收方不知道比特会在什么时候到达，为方便通信增加起始位和结束位，增加了负载增值，用于低速设备<br>字符填充：将信息字段中的每一个 0x7E 字节转变成为(0x7D, 0x5E)；若信息字段中出现0x7D，则将其转成(0x7D, 0x5D)；若信息字段中出现 ASCII 码的控制字符（即数值小于 0x20 的字符），则在该字符前加入 0x7D </p></blockquote><p>多种网络层协议<br>多种类型链路<br>差错检测<br>检测连接状态<br>最大传送单元<br>网络层地址协商<br>数据压缩协商</p></blockquote><blockquote><p><strong>组成部分</strong></p><blockquote><p>一个将 IP 数据报封装到串行链路的方法<br>链路控制协议 LCP (Link Control Protocol)<br>网络控制协议 NCP (Network Control Protocol)</p></blockquote></blockquote></blockquote><ul><li><strong>广播信道</strong>：使用一对多的广播通信方式，需要使用专用的共享信道协议来协调这些主机的数据发送</li></ul><blockquote><p>CSMA/CD 协议（Carrier Sense Multiple Access with Collision Detection：载波监听，多点接入，碰撞检测），使用无连接方式和曼彻斯特编码，以太网提供最大努力交付服务</p><blockquote><p>载波监听（先听再发）：利用电子技术检测总线数据传输情况，避免碰撞<br>多点接入：表明计算机以多点接入连接到同一根总线上<br>碰撞检测（边发边听）：检测信道电压大小（多站同时发送时，总线信号电压会增大，超过一定门限值，认为有多站同时发送数据），发生碰撞，停止发送</p><blockquote><p>争用期：A、B两端单程端到端传输时延为t，在争用期2t（A先发B后发）内，存在碰撞可能<br>二进制指数退避算法：发生碰撞后，延迟一个随机时间（争用期2t）后重发</p></blockquote></blockquote></blockquote><h1 id="3-物理层"><a href="#3-物理层" class="headerlink" title="3. 物理层"></a>3. 物理层</h1><h2 id="3-1-接口特性"><a href="#3-1-接口特性" class="headerlink" title="3.1 接口特性"></a>3.1 接口特性</h2><blockquote><p>机械特性：指明接口所用接线器的形状和尺寸、引线数目和排列、固定和锁定装置等<br>电气特性：指明在接口电缆的各条线上出现的电压的范围<br>功能特性：指明某条线上出现的某一电平的电压表示何种意义<br>过程特性：指明对于不同功能的各种可能事件的出现顺序</p></blockquote><h2 id="3-2-通信模式"><a href="#3-2-通信模式" class="headerlink" title="3.2 通信模式"></a>3.2 通信模式</h2><blockquote><p>单向通信（单工通信）：只能有一个方向的通信而没有反方向的交互<br>双向交替通信（半双工通信）：通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)<br>双向同时通信（全双工通信）：通信的双方可以同时发送和接收信息</p></blockquote><h2 id="3-3-信噪比"><a href="#3-3-信噪比" class="headerlink" title="3.3 信噪比"></a>3.3 信噪比</h2><p>香农公式：计算带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率</p><pre class="line-numbers language-none"><code class="language-none">C &#x3D; W log2(1+S&#x2F;N) b&#x2F;s 信道的极限信息传输速率为 C， W 为信道的带宽（以 Hz 为单位）；S 为信道内所传信号的平均功率；N 为信道内部的高斯噪声功率信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="3-4-信道复用"><a href="#3-4-信道复用" class="headerlink" title="3.4 信道复用"></a>3.4 信道复用</h2><blockquote><p>频分复用：用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。频分复用的所有用户在同样的时间占用不同的带宽（频率带宽）资源<br>时分复用：将时间划分为一段段等长的时分复用帧（TDM 帧），每一个时分复用的用户在每一个 TDM帧中占用固定序号的时隙，所有用户是在各自的时间复用帧占用同样的频带宽度；（TDM信号也称为等时(isochronous)信号）<br>波分复用：波分复用就是光的频分复用<br>码分复用：各用户使用经过特殊挑选不会造成干扰的不同码型，常用的名词是码分多址 CDMA (Code Division Multiple Access)，这种系统发送的信号有强抗干扰能力，其频谱类似于白噪声，不易被敌人发现。 每一个比特时间划分为 m 个短的间隔，称为码片(chip)</p></blockquote><p><strong>网页访问过程</strong>：浏览器请求、服务器响应并返回所请求内容（ HTML 文档的形式），整个过程遵守HTTP 协议（超文本传输协议）</p><blockquote><ol><li>用户在浏览器内输入想要访问页面的网络地址</li><li>浏览器以 HTTP协议 标准向服务器发起 HTTP请求</li></ol><blockquote><p>请求行（ HTTP Request Line ）：包括请求方法、所请求资源的 URL 以及 HTTP协议版本号三个要素<br>请求报头（ HTTP Message Header ）：请求报头是浏览器在请求时向服务器提交的多项附加信息（每项内容被称为一个头域（ Header Field，简称为 Header），如果用户在本次页面访问之前已经到访过网站或者已经登录，会在请求头中附加一个被称为 Cookie 的数据项，记录用户上一次访问时的状态或者身份信息<br>请求正文（ HTTP Message Body ）：可选，一般为空</p></blockquote><ol start="3"><li>服务器接收并解析、处理请求，并将处理结果以 HTTP形式发回浏览器</li></ol><blockquote><p>状态行：三位数字构成的状态码标识服务器对于此次 HTTP 请求的处理结果，如代表成功响应的 200 (OK ）和代表所请求的资源在服务器端没有被找到的 404 (Not Found ）<br>响应报头：服务器在执行响应时，增加一些附加数据项，确保页面正确显示和业务正常进行<br>响应正文：可选，一般非空，包括浏览器请求的文档、图片、脚本、 HTML文档等</p></blockquote><ol start="4"><li>浏览器接收到服务器的响应内容，并将其按照文档规范展现给用户，完成一次请求</li></ol></blockquote><p><strong>域名</strong>：IP地址的别名，方便用户记忆；通过<strong>IP地址</strong>找到网络上的计算机，通过<strong>端口号</strong>找到计算机运行的程序</p>]]></content>
      
      
      <categories>
          
          <category> 通识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序设计-通识</title>
      <link href="/202104/1016033.html"/>
      <url>/202104/1016033.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 计算机程序设计 的相关通识知识</p><span id="more"></span><h1 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1. 名词解释"></a>1. 名词解释</h1><h2 id="1-1-文件路径类"><a href="#1-1-文件路径类" class="headerlink" title="1.1 文件路径类"></a>1.1 文件路径类</h2><ul><li>路径：文件存放的位置</li></ul><blockquote><p>绝对路径：从根目录/顶级目录开始定位，形成的路径，以‘/’开始，接上目录名称<br>相对路径：从当前工作目录开始定位，形成的路径</p></blockquote><ul><li>环境变量：是指在操作系统中用来指定操作系统运行环境的一些参数，运行指令时会先在当前目录检索，若找不到再通过环境变量进行检索，配置了环境变量就可以在所有目录运行指令，否则只能在软件安装目录下运行</li></ul><h2 id="1-2-程序设计类"><a href="#1-2-程序设计类" class="headerlink" title="1.2 程序设计类"></a>1.2 程序设计类</h2><ul><li>应用类型：互联网应用程序的类型</li></ul><blockquote><p>计算密集型应用：多进程 + 多线程，科学计算、挖矿，发挥多核特性<br>I/O密集型应用：单线程 + 异步I/O(协程/微线程)</p></blockquote><ul><li>程序设计方式</li></ul><blockquote><p>自顶向下</p><blockquote><ol><li>将算法表达为一系列小问题</li><li>为每个小问题设计接口</li><li>通过将算法表达为接口关联的多个小问题来细话算法</li><li>为每个小问题重复上述过程</li></ol></blockquote><p>自底向上</p></blockquote><ul><li>程序运行方式</li></ul><blockquote><p>交互式：解释器及时响应用户输入的代码，给出输出结果<br>文件式：将程序写在一个或多个文件中，批量执行文件中的代码</p></blockquote><ul><li>编程语言：</li></ul><blockquote><p>解释型语言：编译后的代码不能由机器直接运行，需要通过解释器解释执行<br>编译型语言：编译后的文件（二进制文件）可以直接被机器运行</p></blockquote><ul><li>耦合：两个事物（程序）之间的关联情况</li></ul><blockquote><p>紧耦合：尽可能合理划分功能块，功能块内部耦合紧密<br>松耦合：模块间的关系尽可能简单，功能块之间耦合程度低</p></blockquote><h2 id="1-3-字符编码"><a href="#1-3-字符编码" class="headerlink" title="1.3 字符编码"></a>1.3 字符编码</h2><p><strong>二进制</strong>：1/0，字节（8位），存储浮点数（第一位表正负，后八位表指数，最后23位表有效位数）；存储：ASCLL（8位）和Unicode（1992、16位）；布尔代数（乔治·布尔、19世纪、英国、自学成才）进行逻辑运算（或、与、非）；计算：算术逻辑单元（ALU）：算术单元：半加器（总和和进位）和全加器；逻辑单元<br><strong>ASCII码</strong>：American Standard Code for Information Interchange，美国标准信息交换码，是现在最通用的单字节编码；是一套基于拉丁字母的编码系统，用于显示现代英语；采用 7位表示，只能显示128个字符，不能完全表示所有的西方字符；增加第八位，称之为扩展 ascii码（EASCII，Extended ASCII)，可以表示256个字符，仅美国可满足<br><strong>Unicode字符集</strong>：固定大小的编码，最常用的是<strong>UCS-16编码</strong>，用 2 个字节来表示，字符汉字统一占用 2 个字节空间，浪费空间，世界上所有的符号都包含，目前已经有效保存十万以上的字符，每一个符号都有独一无二的编码，不存在乱码问题，最大能保存 65535 = 2^16-1个字符<br><strong>UTF-8字符集</strong>：是对 Unicode 的改进，可变长编码，可以使用1-6个字节表示字符，字母用 1 个字节表示，汉字用 3 个字节表示，一些扩展字符是2个字节；可以通过组成当前字符的第一个字节的大小来判断：大于等于224是三字节字符，大于等于192是两字节字符，否则是单字节字符；<strong>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码</strong><br><strong>GBK2312字符集</strong>：中国国家标准简体中文字符集，2312是标准号；在兼容ASCII的基础上，取消了扩展部分，使用2个大于127的编码表示一个汉字（0xA1-0xF7）(0xA1-0xFE)，大约可以保存不到8000个汉字字符<br><strong>GBK字符集</strong>：GB2312字符集不足以表示所有的中文字符，如：某些不常用汉字，港台地区的繁体字，亚洲其他文字字符等；字母用 1 个字节表示，汉字用 2 个字节表示；微软在gb2312的基础上，将没有用到的编码部分做了扩展编码，形成GBK，始用于win95，到现在（但是不是国家标准），范围：GBK2312 &lt; GBK<br><strong>BIG5字符集</strong>：支持繁体中文（常用于香港、台湾）<br><strong>latin1字符集</strong>：拉丁字符集</p><h2 id="1-4-数据类型"><a href="#1-4-数据类型" class="headerlink" title="1.4 数据类型"></a>1.4 数据类型</h2><p><strong>基本数据类型</strong>：bit 位是计算机的最小存储单位，byte字节是计算机的基本存储单元，1byte = 8bit</p><table><thead><tr><th>数据类型</th><th>英文名</th><th>占用字节数</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td>布尔类型</td><td>bool、boolean</td><td>1</td><td>false</td><td>true / false</td></tr><tr><td>字节型</td><td>byte</td><td>1</td><td>0</td><td>-128 ~ 127</td></tr><tr><td>短整型</td><td>short</td><td>2</td><td>0</td><td>-2^15 ~ 2^15-1</td></tr><tr><td>整型</td><td>int</td><td>4</td><td>0</td><td>-2^31 ~ 2^31-1</td></tr><tr><td>长整型</td><td>long</td><td>8</td><td>0</td><td>-2^63 ~ 2^63-1</td></tr><tr><td>字符型</td><td>char</td><td>4</td><td>\u0000</td><td>0 ~ 2^16-1</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4</td><td>0.0F</td><td>-</td></tr><tr><td>双精度浮点数</td><td>double</td><td>8</td><td>0.0D</td><td>-</td></tr></tbody></table><h1 id="2-编程语言"><a href="#2-编程语言" class="headerlink" title="2. 编程语言"></a>2. 编程语言</h1><p><strong>机器语言</strong></p><p><strong>汇编语言</strong></p><p><strong>高级语言</strong></p><ol><li><strong>静态语言</strong>：是编译时变量的数据类型就可以确定的语言，在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错；如：Java</li><li><strong>动态语言</strong>：是运行时才确定数据类型的语言，变量在使用之前无需申明类型，变量本身数据类型不固定的语言，在赋值时确定对应变量的数据类型；如：Python</li><li>超文本标记语言：HTML</li><li><strong>编译型语言</strong>：编译执行：将源码（高级语言代码）通过编译器转换为目标代码（机器语言代码），只进行一次编译；<strong>C语言</strong>：可以用来编写操作系统的贴近硬件的语言，适合开发追求运行速度、充分发挥硬件性能的程序</li><li><strong>解释型语言</strong>：<strong>Python语言</strong></li></ol><p>TIOBE排行榜：统计编程语言的流行程度</p><h2 id="2-1-函数"><a href="#2-1-函数" class="headerlink" title="2.1 函数"></a>2.1 函数</h2><p>定义：def &lt;函数名&gt;(&lt;参数列表&gt;): … return &lt;返回值列表&gt;</p><blockquote><p>参数传递</p><blockquote><ul><li>&lt;函数名&gt;(&lt;…&gt;,&lt;可选参数&gt; = &lt;默认值&gt;)</li><li>&lt;函数名&gt;(&lt;参数名&gt; = &lt;实际值&gt;)<br><strong>变量</strong>是用来存储数据的，由数据类型、变量名称和数据三个基本要素组成基本要素，相当于有内存中的数据存储空间，通过变量名和变量地址可以找到里面存储的数据，变量必须先申明再使用，数据可以在同一类型变化，再作用域内不允许重名</li><li>局部变量：函数内部使用</li><li>全局变量：函数内部使用需要global申明</li></ul></blockquote></blockquote><p>调用：函数名 (实参赋值列表)</p>]]></content>
      
      
      <categories>
          
          <category> 通识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成-通识</title>
      <link href="/202104/1052185.html"/>
      <url>/202104/1052185.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录计算机组成的基础知识等</p><span id="more"></span><h1 id="1-冯·诺依曼体系结构"><a href="#1-冯·诺依曼体系结构" class="headerlink" title="1. 冯·诺依曼体系结构"></a>1. 冯·诺依曼体系结构</h1><ul><li><p><strong>运算器</strong>：进行算术运算与逻辑运算，结果以二进制形式给出；由运算逻辑部件（ALU）和寄存器组成：ALU是具体完成算术逻辑运算的部件，寄存器用于存放操作数、操作结果和操作数地址；算术运算包括加减乘除和复合运算，逻辑运算包括位移、比较、逻辑加、逻辑乘、逻辑取反、逻辑异或</p></li><li><p><strong>控制器</strong>：协调整个计算机正常工作，由程序计数器（PC）、指令寄存器（IR）、指令译码器、脉冲源及启停控制线路、时序信号产生部件、操作控制信号形成部件、中断机制和总线控制逻辑组成</p><ol><li><strong>PC</strong> 用来存放正在执行的指令地址或下一条执行的指令地址</li><li><strong>IR</strong> 用来存放现行指令，以便实现对该指令的完全控制</li><li><strong>指令译码器</strong> 对指令寄存器中的操作码进行分析解释，产生相应的控制信号提供给操作控制信号形成部件</li><li><strong>脉冲源及启停控制线路</strong> 产生一定频率的脉冲信号，作为周期、节拍和工作脉冲的基准信号</li><li><strong>时序信号产生部件</strong> 以时钟脉冲为基础，产生指令对应的时序信号，实现时序控制</li><li><strong>操作控制信号形成部件</strong> 综合时序信号、指令译码信息、被控功能部件反馈的状态条件信号等，形成不同指令所需要的操作控制信号序列</li><li><strong>中断机制</strong> 实现异常处理</li><li><strong>总线控制逻辑</strong> 组成实现对总线信息传输的控制</li></ol></li><li><p><strong>存储器</strong>：用于存放数据和程序；分为高速缓冲存储器（Cache）、主存储器和辅助存储器</p><ol><li><strong>Cache</strong> 由双极型半导体组成，存取速度接近CPU工作速度</li><li><strong>主存储器</strong> 由MOS半导体存储器组成，用来存放计算机运行时的大量程序和数据</li><li><strong>辅助存储器</strong> 又称外部存储器，由磁表面存储器组成</li></ol></li><li><p><strong>I/O设备</strong>：各类输入/输出设备和相应的接口</p><ol><li>输入设备：键盘、鼠标</li><li>输出设备：显示器、打印机</li><li>输入\输出设备：磁盘、磁带、光盘<blockquote><p>注：计算机分为主机和外部设备，主机包括中央处理器和内存储器，外部设备包括I/O设备和外存储器，中央处理器包括运算器和控制器</p></blockquote></li></ol></li></ul><h2 id="1-1-核心元件的发展"><a href="#1-1-核心元件的发展" class="headerlink" title="1.1 核心元件的发展"></a>1.1 核心元件的发展</h2><ol><li>继电器：电磁控制、哈佛马克一号</li><li>热电子管：1904年英国约翰·安布罗斯·弗莱明发明；1906年美国李·德弗雷斯特改进（第一个真空管）（机电——电子）</li><li>晶体管：1947年贝尔实验室（1957年IBM608），计算机2.0时代，数字暴政</li><li>集成电路（IC、仙童半导体、硅）和印刷电路板（PCB）：光刻——微型处理器，计算机3.0时代</li></ol>]]></content>
      
      
      <categories>
          
          <category> 通识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机 </tag>
            
            <tag> 组成 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sublime-安装使用</title>
      <link href="/202104/0954488.html"/>
      <url>/202104/0954488.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Sublime Text 3使用 的相关基础内容</p><span id="more"></span><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><h1 id="2-基础设置"><a href="#2-基础设置" class="headerlink" title="2. 基础设置"></a>2. 基础设置</h1><ul><li><strong>设置字体</strong>：依次点击首选项(Prefereences) -&gt; 设置-用户(Setting Syntax Specific)，进入编辑弹窗，修改”font_size”: N，N为自己设定的大小，注意冒号之后有空格</li><li><strong>修改快捷键</strong>：依次点击首选项(Prefereences) -&gt; 按键绑定-默认</li></ul><h1 id="3-快捷键Shortcuts"><a href="#3-快捷键Shortcuts" class="headerlink" title="3. 快捷键Shortcuts"></a>3. 快捷键Shortcuts</h1><h2 id="3-1-文件操作"><a href="#3-1-文件操作" class="headerlink" title="3.1 文件操作"></a>3.1 文件操作</h2><ul><li>新建文件：Ctrl + N</li><li>文件切换：Ctrl + Tab</li><li>文件保存：Ctrl + S</li></ul><h2 id="3-2-文本操作"><a href="#3-2-文本操作" class="headerlink" title="3.2 文本操作"></a>3.2 文本操作</h2><ul><li>整体后移：Tab</li><li>整体后移：Shift + Tab</li></ul><h2 id="3-3-键盘输入"><a href="#3-3-键盘输入" class="headerlink" title="3.3 键盘输入"></a>3.3 键盘输入</h2><ul><li>文字剪切/复制/粘贴：Ctrl + X/C/V</li><li>撤销操作：Ctrl + Z</li><li>合并两行：Ctrl + J（光标位于上一行任意位置）</li><li>文本缩进：Ctrl + [/]（左/右移Tab，光标位于本行任意位置）</li><li>选择当前行：Ctrl + L（光标位于本行任意位置）</li><li>块选择：Shift + 鼠标右键</li><li>下方开辟新行：Ctrl + Enter（光标位于本行任意位置）</li><li>上方开辟新行：Ctrl + Shift + Enter（光标位于本行任意位置）</li></ul><h2 id="3-4-光标定位"><a href="#3-4-光标定位" class="headerlink" title="3.4 光标定位"></a>3.4 光标定位</h2><ul><li>光标左/右移：左/右箭头</li><li>光标左/右移：Alt + 左/右箭头（移动一个单词）</li><li>移动至本行行首：home</li><li>移动至本行末尾：end</li></ul><h2 id="3-5-辅助工具"><a href="#3-5-辅助工具" class="headerlink" title="3.5 辅助工具"></a>3.5 辅助工具</h2><ul><li>打开命令面板：Ctrl + Shift + p；</li></ul><h1 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h1><h2 id="4-1-编码"><a href="#4-1-编码" class="headerlink" title="4.1 编码"></a>4.1 编码</h2><p><strong>问题1</strong>：设置GBK编码<br>原因：Sublime text默认不支持GBK编码<br>解决：下载插件支持<br>步骤：</p><ol><li>打开控制面板：Ctrl + Shift + p</li><li>输入安装指令：Package Control：Install Package</li><li>选择安装插件：ConvertToUTF8，出现如下界面，则安装成功<br><img src="https://qizhongyi.gitee.io/images/Tools/Sublime/Sublime_Encoding_GBK_Install.png" alt="Sublime_Encoding_GBK_Install"></li><li>重新打开或者设置编码：依次点击File -&gt; Set File Encoding to/Reload with Encoding -&gt; GBK，如下图<br><img src="https://qizhongyi.gitee.io/images/Tools/Sublime/Sublime_Encoding_GBK_Setting.png" alt="Sublime_Encoding_GBK_Setting"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Word-常见操作</title>
      <link href="/202104/095776.html"/>
      <url>/202104/095776.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要介绍 Office-Word常见操作指令 的相关基础内容</p><span id="more"></span><h1 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h1><h2 id="1-1-选项"><a href="#1-1-选项" class="headerlink" title="1.1 选项"></a>1.1 选项</h2><h3 id="1-1-1-视图"><a href="#1-1-1-视图" class="headerlink" title="1.1.1 视图"></a>1.1.1 视图</h3><ul><li><strong>格式标记</strong>：依次点击菜单栏的文件 —&gt; 选项 —&gt; 显示，找到始终在屏幕上显示的格式标记，勾选需要现实的格式标记，常用有制表符、空格、段落标记（回车符），点击确定</li></ul><h1 id="5-引用"><a href="#5-引用" class="headerlink" title="5. 引用"></a>5. 引用</h1><h2 id="5-1-目录"><a href="#5-1-目录" class="headerlink" title="5.1 目录"></a>5.1 目录</h2><ul><li><strong>新增目录</strong>：依次点击功能区的引用 —&gt; 目录 —&gt; 自定义目录，进入自定义目录页面，可以选择前导符、显示标题级别、显示页码和对齐方式，点击确定；自动更新目录：依次点击功能区的引用 —&gt; 目录 —&gt; 更新目录，有仅更新页码和更新整个目录两个选项</li></ul><h1 id="10-快捷键"><a href="#10-快捷键" class="headerlink" title="10. 快捷键"></a>10. 快捷键</h1><h2 id="10-1-文本操作"><a href="#10-1-文本操作" class="headerlink" title="10.1 文本操作"></a>10.1 文本操作</h2><p>加粗：Ctrl + B<br>居中：Ctrl + E<br>增大字号：Ctrl + Shift + &gt;(大于号)；Ctrl + ]<br>减小字号：Ctrl + Shift + &lt;(小于号)；Ctrl + [</p><h2 id="10-2-其他操作"><a href="#10-2-其他操作" class="headerlink" title="10.2 其他操作"></a>10.2 其他操作</h2><p>复制：Ctrl + C<br>剪切：Ctrl + X<br>粘贴：Ctrl + V<br>撤销：Ctrl + Z<br>返回上一步：Ctrl + Y<br>全选：Ctrl + A</p>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PPT-常见操作</title>
      <link href="/202104/0965501.html"/>
      <url>/202104/0965501.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录 Office-PPT常见操作指令 的相关基础内容</p><span id="more"></span><h1 id="2-开始"><a href="#2-开始" class="headerlink" title="2. 开始"></a>2. 开始</h1><h2 id="2-6-设置形状格式"><a href="#2-6-设置形状格式" class="headerlink" title="2.6 设置形状格式"></a>2.6 设置形状格式</h2><h3 id="2-6-4-排列"><a href="#2-6-4-排列" class="headerlink" title="2.6.4 排列"></a>2.6.4 排列</h3><ul><li><strong>对齐</strong>：对象对齐：开始 -&gt; 排列(绘图区) -&gt; 对齐，选择合适的对齐方式</li></ul><h1 id="11-设计思路"><a href="#11-设计思路" class="headerlink" title="11. 设计思路"></a>11. 设计思路</h1><p>拆分元素</p>]]></content>
      
      
      <categories>
          
          <category> 常见操作指令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
            <tag> office </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git-安装使用</title>
      <link href="/202104/0817263.html"/>
      <url>/202104/0817263.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Git的安装使用的相关知识</p><span id="more"></span><h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h1><p><strong>Git</strong>：是目前世界上最先进的分布式版本控制系统，用C语言编写</p><p><strong>版本控制</strong>：分为集中式和分布式两种；分布式相比于集中式，安全性更高，Git拥有分支管理功能</p><ul><li>集中式（CVS、SVN）：版本库是集中存放在中央服务器中，工作时先需要联网从中央服务器下载最新版本，工作结束后再推送给中央服务器</li><li>分布式（Git）：没有中央服务器，每台电脑上都有完整的版本库，多人同时修改文件后只需把各自的修改推送给对方，就可以看到对方修改的内容；安全性更高</li></ul><h2 id="1-1-名词介绍"><a href="#1-1-名词介绍" class="headerlink" title="1.1 名词介绍"></a>1.1 名词介绍</h2><p><strong>Working Directory</strong>：git 仓库的顶级目录就是一个工作区<br><strong>Repository</strong>：版本库，工作区的隐藏目录 .git<br><strong>Stage</strong>：暂存区，也写作 Index<br><strong>Star</strong>：收藏<br><strong>Fork</strong>：复制别人的仓库到自己的仓库<br><strong>Pull Request</strong>：拉取请求</p><h1 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2. 下载安装"></a>2. 下载安装</h1><p><a href="https://git-scm.com/downloads"><font face = "微软雅黑" color = 1E90FF size = 5>Git官网</font></a>，选择合适的安装包下载</p><h2 id="2-1-Windows"><a href="#2-1-Windows" class="headerlink" title="2.1 Windows"></a>2.1 Windows</h2><ul><li>01、双击安装包，同意使用许可声明，选择安装路径，Next，</li><li>02、选择安装组件，默认选择，Next<br>创建桌面快捷方式，在所有控制台窗口中使用 TrueType 字体和是否每天检查 Git 是否有 Windows 更新</li><li>03、选择开始菜单页，默认选择，选择Git文件默认的编辑器，默认选择，Next</li><li>04、调整您的PATH环境，默认选择，Next<br>Use Git from Git Bash Only：仅从 Git Bash 使用 Git，不会修改 PATH ，不能通过第三方软件使用<br>Git from the command line and also from 3rd-party software：从命令行以及第三方软件进行 Git，能够从 Git Bash、命令提示符和 Windows PowerShell 以及在 PATH 中寻找 Git 的任何第三方软件中使用 Git ，推荐</li><li>05、选择HTTPS后端传输，默认选择，Next<br>使用 OpenSSL 库：服务器证书将使用ca-bundle.crt文件进行验证<br>使用本地 Windows 安全通道库：服务器证书将使用 Windows 证书存储验证，允许您使用公司的内部根CA证书)</li><li>06、配置行尾符号转换，默认选择，Next<br>签出Windows风格，提交Unix风格的行尾：签出文本文件时，Git会将LF转换为CRLF；提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Windows上的推荐设置（core.autocrlf设置为true）<br>按原样签出，提交Unix样式的行尾：签出文本文件时，Git不会执行任何转换。 提交文本文件时，CRLF将转换为LF。对于跨平台项目，这是Unix上的建议设置（core.autocrlf设置为input）<br>按原样签出，按原样提交：当签出或提交文本文件时，Git不会执行任何转换。不建议跨平台项目选择此选项（core.autocrlf设置为false）</li><li>07、配置终端模拟器以与Git Bash一起使用，默认选择，Next<br>使用 MinTTY（MSYS2的默认终端）：Git Bash 将使用 MinTTY 作为终端模拟器，该模拟器具有可调整大小的窗口，非矩形选择和 Unicode 字体。 Windows 控制台程序（如Python）必须通过 winpty 启动才能在 MinTTY 中运行<br>使用 Windows的默认控制台窗口： Git 将使用 Windows 的默认控制台窗口（cmd.exe），该窗口可以与 Win32 控制台程序（如交互式 Python 或 node.js）一起使用，但默认的回滚非常有限，需要配置为使用 unicode 字体以正确显示非 ASCII 字符，并且在 Windows 10 之前，其窗口不能自由调整大小，并且只允许矩形文本选择</li><li>08、安装进度指示，安装完成</li></ul><h2 id="2-2-Linux"><a href="#2-2-Linux" class="headerlink" title="2.2 Linux"></a>2.2 Linux</h2><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install git      # 或 sudo apt-get install git-core<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="3-操作"><a href="#3-操作" class="headerlink" title="3. 操作"></a>3. 操作</h1><h2 id="3-1-配置密钥"><a href="#3-1-配置密钥" class="headerlink" title="3.1 配置密钥"></a>3.1 配置密钥</h2><ol><li>设置用户、邮箱</li></ol><pre class="line-numbers language-none"><code class="language-none">设置用户：git config --global user.name &quot;用户名&quot;设置邮箱：git config --global user.email &quot;邮箱&quot;查看用户：git config user.name查看邮箱：git config user.email<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>生成密钥</li></ol><pre class="line-numbers language-none"><code class="language-none">生成密钥：ssh-keygen -t rsa查看密钥：cat ~&#x2F;.ssh&#x2F;id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="3"><li>将密钥加入 Github、Gitee 的 ssh 公钥池里面，步骤如下图：<br><img src="https://qizhongyi.gitee.io/images/Tools/Git_sshKey.png" alt="Git_sshKey"></li></ol><h2 id="3-2-推拉版本库"><a href="#3-2-推拉版本库" class="headerlink" title="3.2 推拉版本库"></a>3.2 推拉版本库</h2><ol><li>新建目录：</li></ol><pre class="line-numbers language-none"><code class="language-none">mkdir dir_name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>初始化仓库：</li></ol><pre class="line-numbers language-none"><code class="language-none">git init    # 进入目录，初始化为Git仓库，自动创建一个 master 分支；当前目录下会增加一个.git目录，用来跟踪管理版本库<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>建立远程仓库关联：推拉之前，需要建立本地仓库和远程仓库之间的联系；同时关联多个远程库时，关联时需要为每一个远程库取名</li></ol><pre class="line-numbers language-none"><code class="language-none">git remote add origin git@gitee.com:qizhongyi&#x2F;resource.git# 将本地仓库与 Github、Gitee 等远程仓库连接起来，origin是仓库名，可自定义，通常默认为 origingit remote -v：查看远程库信息git remote rm origin：删除远程库，解除本地和远程的绑定关系，并不是物理上删除远程库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>添加修改：</li></ol><pre class="line-numbers language-none"><code class="language-none">git add f_name：将 f_name 添加到本地仓库的暂存区，git add . 表示添加所有文件和文件夹git add -f f_name：强制将 f_name 添加到本地仓库的暂存区<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="5"><li>提交修改：</li></ol><pre class="line-numbers language-none"><code class="language-none">git commit -m &#39;自定义备注内容&#39;   # 将暂存区内容提交到当前分支<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="6"><li>推送：</li></ol><pre class="line-numbers language-none"><code class="language-none">git push -u origin master   # 推送代码到远程仓库的 master 分支，第一次提交需要增加 -u 参数，之后提交可以省略：git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li>拉取：</li></ol><pre class="line-numbers language-none"><code class="language-none">git pull origin master：拉取有关联远程仓库的 master 分支git clone git@gitee.com:qizhongyi&#x2F;resource.git：克隆没有关联的远程仓库到本地，git@ 采用的是 ssh 协议<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="3-3-返回版本"><a href="#3-3-返回版本" class="headerlink" title="3.3 返回版本"></a>3.3 返回版本</h2><p><strong>未添加</strong>：</p><pre class="line-numbers language-none"><code class="language-none">git checkout -- f_name撤销 f_name 文件未添加 git add 的修改；git checkout 用版本库里的版本替换工作区的版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>已添加未提交</strong>：</p><pre class="line-numbers language-none"><code class="language-none">1. git reset HEAD f_name；撤销 f_name 文件已添加未提交 git commit 的修改到工作区2. git checkout -- f_name；撤销 f_name 文件在工作区的修改添加后的新修改<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>已提交</strong>：</p><ol><li>查看更改日志：</li></ol><pre class="line-numbers language-none"><code class="language-none">git log [--pretty&#x3D;oneline --abbrev-commit]    # 查出对应的对应的版本号和版本描述，参数表示一行显示一个更改；在英文状态下输入 q 可退出 loggit log -1 ：显示最近一个提交<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol start="2"><li>恢复版本：</li></ol><pre class="line-numbers language-none"><code class="language-none">git reset --hard 版本号此时在本地文件夹中会恢复到对应版本，git上还是保留最新版本，通过 HEAD 指针指向当前版本，可以快速返回当前版本可以用 HEAD 表示，上一个版本是 HEAD^，上两个版本是 HEAD^^，上100个版本是 HEAD~100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>已退回</strong>：已经退回到历史版本，想要恢复到最版版本</p><ol><li>查看命令日志：<pre class="line-numbers language-none"><code class="language-none">git reflog    # 用来记录每一次命令<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>恢复版本：</li></ol><pre class="line-numbers language-none"><code class="language-none">git reset --hard 版本号<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="3-4-分支管理"><a href="#3-4-分支管理" class="headerlink" title="3.4 分支管理"></a>3.4 分支管理</h2><p><strong>创建分支</strong>：git branch b_name<br><strong>切换分支</strong>：git checkout b_name 或者 git switch b_name<br><strong>创建+切换分支</strong>：git checkout -b b_name 或者 git switch -c b_name<br><strong>查看分支</strong>：git branch，列出所有分支，当前分支前面会标一个 * 号<br><strong>合并分支</strong>：git merge b_name，合并指定分支 b_name 到当前分支</p><blockquote><p>Git 默认执行”快进式合并”（fast-farward merge），会直接将 Master 分支指向  Develop 分支；使用 –no-ff 参数，执行普通模式合并，创建一个新的commit；普通模式合并后的历史有分支，能看出来曾经做过合并，快进式合并看不出来曾经做过合并</p></blockquote><pre class="line-numbers language-none"><code class="language-none">合并出现冲突时，需要手动解决冲突再合并：直接在当前分支修改冲突文件，修改成希望的内容，然后添加、提交git status：可以显示冲突文件cat f_name：查看文件，通过 &lt;&lt;&lt;&lt;&lt;&lt;&lt;，&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;，&gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记不同分支的内容git log --graph：可以查看分支的合并情况； git log --graph --pretty&#x3D;oneline --abbrev-commitgit merge --no-ff -m &quot;merge with no-ff&quot; dev：本次合并要创建一个新的commit，需要加上-m参数，添加 commit描述<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>删除分支</strong>：合并完成后删除分支，则又变成一条分支</p><pre class="line-numbers language-none"><code class="language-none">git branch -d b_name：删除已合并的分支git branch -D b_name：强制删除未合并的分支<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>BUG分支</strong>：git stash，把当前工作现场“储藏”起来，等以后恢复现场后继续工作</p><pre class="line-numbers language-none"><code class="language-none">git stash list ：查看隐藏修改内容，git stash apply [stash@&#123;0&#125;]：恢复不删除 stash内容，通过 list 索引恢复特定的 stash内容git stash drop  [stash@&#123;0&#125;]：删除 stash内容git stash pop   [stash@&#123;0&#125;]：恢复、同时删除 stash内容<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>多人协作</strong></p><pre class="line-numbers language-none"><code class="language-none">1. git checkout -b dev origin&#x2F;dev：在本地创建和远程分支对应的分支，名称最好一致2. git branch --set-upstream-to&#x3D;origin&#x2F;dev dev ：建立本地分支和远程分支的关联3. git pull：拉去远端仓库的分支内容4. 修改：自己进行修改的内容5. git add：添加修改6. git commit -m &quot;xxx&quot;：提交修改7. git push origin b_name：将修改推送到远端仓库<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>整理分支</strong>：git rebase，把本地未 push 的分叉提交历史整理成直线</p><h2 id="3-5-标签管理"><a href="#3-5-标签管理" class="headerlink" title="3.5 标签管理"></a>3.5 标签管理</h2><p><strong>添加标签</strong>：发布版本前，通常先在版本库中打一个标签，唯一确定打标签时刻的版本，标签也是版本库的一个快照；先切换到需要打标签的分支，默认标签打在最新的 commit 上，创建的标签都只存储在本地，不会自动推送到远程</p><pre class="line-numbers language-none"><code class="language-none">git tag t_name [版本号]：创建名为 t_name，针对特定的版本添加标签git tag -a t_name -m &quot;xxx&quot; ：创建名为 t_name，说明为 xxx 的标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>查看标签列表</strong>：git tag，标签按字母排序，不是按时间排序<br><strong>查看标签信息</strong>：git show t_name<br><strong>推送到远端</strong>：git push origin t_name：推送  t_name 标签到远端；git push origin –tags：推送所有标签到远端<br><strong>删除标签</strong></p><pre class="line-numbers language-none"><code class="language-none">删除未推送到远端的标签：git tag -d t_name删除以推送到远端的标签：1. git tag -d t_name；先删除本地标签2. git push origin :refs&#x2F;tags&#x2F;t_name；再删除远程标签<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-6-搭建Git服务器"><a href="#3-6-搭建Git服务器" class="headerlink" title="3.6 搭建Git服务器"></a>3.6 搭建Git服务器</h2><ol><li>安装Git</li></ol><pre class="line-numbers language-none"><code class="language-none">sudo apt-get install git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>创建用户</li></ol><pre class="line-numbers language-none"><code class="language-none">sudo adduser git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="3"><li>创建证书登录：收集所有需要登录的用户的公钥 id_rsa.pub文件，导入到 /home/git/.ssh/authorized_keys 文件里，一行一个</li><li>初始化仓库：在目标目录下操作，如 /srv</li></ol><pre class="line-numbers language-none"><code class="language-none">1. sudo git init --bare p_name.git ：创建一个裸仓库没有工作区，仅为了共享2. sudo chown -R git:git p_name.git：将仓库所有者改为之前创建的用户 git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="5"><li>禁用Shell登录：编辑/etc/passwd文件</li></ol><pre class="line-numbers language-none"><code class="language-none">将   git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash改为 git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol start="6"><li>克隆远程仓库</li></ol><pre class="line-numbers language-none"><code class="language-none">git clone git@server:&#x2F;srv&#x2F;p_name.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="7"><li>即可进行推拉</li></ol><h2 id="3-7-其他"><a href="#3-7-其他" class="headerlink" title="3.7 其他"></a>3.7 其他</h2><p><strong>查询状态</strong>：git status；显示当前分支，当前工作区的文件提交状态<br><strong>查看区别</strong>：git diff HEAD [– f_name]；工作区和版本库里面 f_name 最新版本的区别<br><strong>删除文件</strong>：git rm f_name；删除 f_name 文件；确认删除可以 add、 commit，取消删除可以 checkout<br><strong>忽略文件</strong>：在 Git 工作区的根目录下创建一个特殊的 .gitignore文件，填写需要忽略的文件名，Git会自动忽略这些文件</p><blockquote><p>git check-ignore -v f_name：检查 ignore规则错误<br>.*：排除所有.开头的隐藏文件<br>!f_name：排除指定文件，f_name 满足忽略条件，但要求保留</p></blockquote><p><strong>复制提交</strong>：git cherry-pick 版本号，制一个特定的提交到当前分支<br><strong>自定义显示颜色</strong>：git config –global color.ui true<br><strong>配置命令别名</strong>：git config –global alias.n_name command；也可以直接修改当前仓库的 .git/config文件，将别名配置在 [alias] 后面，删除别名可以直接删除行后保存</p><pre class="line-numbers language-none"><code class="language-none">git config --global alias.st status ：将 status 指令简写成 stgit config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;--global 是针对当前用户起作用；如果不加，只针对当前的仓库起作用当前用户的 Git 配置文件是用户主目录下的一个隐藏文件.git&#x2F;config；别名就在[alias]后面，要删除别名，直接把对应的行删掉即可<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="4-常见问题"><a href="#4-常见问题" class="headerlink" title="4. 常见问题"></a>4. 常见问题</h1><h2 id="4-1-访问类"><a href="#4-1-访问类" class="headerlink" title="4.1 访问类"></a>4.1 访问类</h2><p><strong>问题1</strong>：密码错误，不再出现输入框</p><ul><li>解决1：Windows 自带的工具凭据管理器：进入控制面板—&gt;用户账户—&gt;管理Windows凭据，找到对应的账户密码可以进行删除或修改</li><li>解决2：清除账户密码重新登陆：git config –system –unset credential.helper</li></ul><p><strong>问题2</strong>：GitHub快速访问<br>使用加速器 FastGithub；<a href="https://github.com/dotnetcore/FastGithub.git"><font face = "微软雅黑" color = 1E90FF size = 5>Github网址</font></a>，<a href="https://github.com/dotnetcore/fastgithub/releases"><font face = "微软雅黑" color = 1E90FF size = 5>下载地址</font></a>；访问下载地址，下载对应版本到目标位置，解压文件夹，双击运行 FastGithub.exe 可执行文件；或者用管理员权限打开 cmd，执行下面两条语句</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">D:\Install\Google_Plus\win10-x64\FastGithub.exe start     # 启动fast GitHubD:\Install\Google_Plus\win10-x64\FastGithub.exe stop      # 停止fast GitHub# 注：D:\Install\Google_Plus\win10-x64 为自己 FastGithub.exe 运行程序的存放位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>问题3</strong>：远程关联已存在：remote origin already exists</p><ol><li>先删除远程 Git 仓库：git remote rm origin</li><li>再添加远程 Git 仓库：git remote add origin <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#x63;&#x6f;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#x69;&#116;&#101;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a>:qizhongyi/resource.git</li></ol><h2 id="4-2-操作类"><a href="#4-2-操作类" class="headerlink" title="4.2 操作类"></a>4.2 操作类</h2><p><strong>问题1</strong>：Please commit your changes or stash them before you merge. 拉取前先提交更新，或者隐藏；本地分支和远程文件不一致，pull 时出现冲突</p><ul><li>解决1：提交</li></ul><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m &#39;xxx&#39;git pull origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>解决2：隐藏</li></ul><pre class="line-numbers language-none"><code class="language-none">git stash         # 保存当前工作进度，能够将所有未提交的修改（工作区和暂存区）保存至堆栈中，用于后续恢复当前工作目录；git pullgit stash pop     # 把刚才stash到本地栈中的代码pop到本地（git stash apply：stash列表中的信息会继续保留；git stash pop：会将stash列表中的信息删除；可以使用 git stash list 查看本地存储的stash日志<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li>解决3：放弃本地修改，本地修改的内容会被丢弃，不可找回；不建议使用</li></ul><pre class="line-numbers language-none"><code class="language-none">git reset --hard   # 撤销工作区中所有未提交的修改内容，将暂存区与工作区都回到上一次版本，并删除之前的所有信息提交git pull<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>问题2</strong>：Updates were rejected because the tip of your current branch is behind its remote counterpart. Integrate the remote changes (e.g. ‘git pull …’) before pushing again. 本地和远程仓库两者代码文件不同步，需要先pull，进行合并然后再进行push</p><ol><li>git pull origin master</li><li>git add .</li><li>git commit -m ‘xxx’</li><li>git push origin master</li></ol><p><strong>问题3</strong>：The file will have its original line endings in your working directory(在您的工作目录中，该文件将具有其原始行结束符). windows commit代码时git会把CRLF转LF，update代码时LF换CRLF，通过修改配置禁用该功能，或者清除缓存</p><ul><li>解决1：修改配置禁用该功能</li></ul><pre class="line-numbers language-none"><code class="language-none">git config --global core.autocrlf false    # 全局配置# 或直接修改config文件： # Windows位于：C:\Users\$USER\.gitconfig 文件[core]autocrlf &#x3D; false            # 改为false# 常见配置[core]repositoryformatversion &#x3D; 0    filemode &#x3D; false    bare &#x3D; false    logallrefupdates &#x3D; true    symlinks &#x3D; false    ignorecase &#x3D; true    longpaths &#x3D; true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>解决2：清除缓存</li></ul><pre class="line-numbers language-none"><code class="language-none">git rm -r --cached .    # 注意：这里有 &quot;.&quot; ,  &quot;. &quot; 代表当前目录；或者将.git隐藏文件夹删除，会丢失一切git相关记录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>问题4</strong>：client_loop: send disconnect: Connection reset by peer.  fatal: sha1 file ‘&lt;stdout&gt;’ write error: Broken pip. 原因：git push 的文件过大，http.postBuffer默认上限为1M</p><pre class="line-numbers language-none"><code class="language-none">git config --global http.postBuffer 524288000   # 最大上限为500M# 或直接修改config文件[http]postBuffer &#x3D; 524288000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-安装使用</title>
      <link href="/202104/0754944.html"/>
      <url>/202104/0754944.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录Hexo的安装使用的相关知识</p><span id="more"></span><h1 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h1><ol><li>安装 node.js<ul><li><a href="https://nodejs.org/"><font face = "微软雅黑" color = 1E90FF size = 5>官网</font></a>，选择合适的安装包下载；</li><li>双击下载的安装包，一路默认，选择安装路径和添加环境变量 （ADD PATH）；</li></ul></li></ol><ul><li>测试安装：在cmd下输入 node -v  显示 node.js 的版本号  ；npm -v 显示 npm 安装插件的版本号</li></ul><ol start="2"><li><p>修改镜像源  ：在cmd下输入 npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> ；测试安装：cnpm -v （cnpm 是 npm 的淘宝镜像源，用于下载安装）；</p></li><li><p>安装hexo ：在cmd下输入 cnpm install -g hexo-cli ；测试 ：hexo -v ；如需卸载，在cmd下运行 npm uninstall hexo-cli -g</p></li></ol><p><strong>注</strong>：打开cmd 窗口：Win + r 打开程序搜索框，输入 cmd 回车，即可弹出 cmd命令行黑窗口</p><h1 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h1><h2 id="2-1-基础指令"><a href="#2-1-基础指令" class="headerlink" title="2.1 基础指令"></a>2.1 基础指令</h2><ul><li>初始化：hexo init [folder]<br>如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站</li><li>新建：hexo new，简写：hexo n<ul><li>新建文件夹：hexo new page page_name，如果名字里面有空格，需要用英文双引号””包裹，下面也一样，默认在source/目录下新建，可通过path参数进行修改，例：hexo new page –path xxx/xxx，同时也会生成一个index.md的文件</li><li>新建文件：hexo new post_name，默认是在当前目录下生成<br>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></li></ul></li><li>生成：hexo generate，简写：hexo g<br>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></li><li>发布：hexo server ，简写：hexo s；可以与 generate 配合，简写成 hexo s -g<br>More info: <a href="https://hexo.io/docs/server.html">Server</a></li><li>部署：hexo deploy，简写：hexo d；可以与 generate 配合，简写成 hexo d -g<br>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></li><li>清除：hexo clean，简写：hexo c</li></ul><h2 id="2-2-搭建静态博客网站"><a href="#2-2-搭建静态博客网站" class="headerlink" title="2.2 搭建静态博客网站"></a>2.2 搭建静态博客网站</h2><h3 id="2-2-1-环境"><a href="#2-2-1-环境" class="headerlink" title="2.2.1 环境"></a>2.2.1 环境</h3><ol><li>node.js：见上文安装</li><li>hexo：见上文安装</li><li>git：<a href="https://qizhongyi.gitee.io/202104/0817263.html"><font face = "微软雅黑" color = 1E90FF size = 5><strong>Git安装</strong></font></a>，需要配置好 git 上传的公钥</li></ol><h3 id="2-2-2-操作"><a href="#2-2-2-操作" class="headerlink" title="2.2.2 操作"></a>2.2.2 操作</h3><p><strong>注</strong>：以下操作都在 cmd下进行</p><ol><li>在合适的位置新建博客目录：mkdir xxx/Blog</li><li>初始化博客 ：hexo init</li><li>生成：hexo g</li><li>发布：hexo s；可以根据 localhost:4000 在本地访问</li><li>部署到远端<ul><li>在 Gitee 上新建一个仓库：仓库名要和 Gitee 账号名相同</li><li>安装git插件：npm install – save hexo-deployer-git</li><li>修改 -config.yml文件：<pre class="line-numbers language-none"><code class="language-none">deploy:type: gitrepo: git@gitee.com:qizhongyi&#x2F;qizhongyi.gitbranch: master本文采用 Gitee，也可以采用 GitHub也可以同时推到多个远端deploy:  # type: &#39;&#39;  - type: git    repo: git@gitee.com:qizhongyi&#x2F;qizhongyi.git    branch: master    ignore_hidden: false  - type: git    repo: git@github.com:qizhongyizhang&#x2F;qizhongyizhang.git    branch: master    ignore_hidden: false<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul></li><li>部署：hexo d，第一次操作需要输入 Gitee 账号、密码</li></ol><h2 id="2-3-页面设计"><a href="#2-3-页面设计" class="headerlink" title="2.3 页面设计"></a>2.3 页面设计</h2><ul><li><strong>添加标签</strong><ol><li>开启 hexo主目录下_config.yml里面的 tags 标签</li><li>在命令行（hexo主目录路径下） 输入： hexo new page tags ，会在 ./source 文件夹内创建一个名为 tags 的文件夹，里面有一个名为的 index 的md文件</li><li>在里面输入以下内容</li></ol><pre class="line-numbers language-none"><code class="language-none">title: tagsdate: xxxx-xx-xx xx:xx:xxtype: &quot;tags&quot;注：冒号后面都有一个空格，时间可以随便，推荐使用当前时间<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="4"><li>创建完成后，在命令行（hexo主目录路径下） 输入： hexo g 生成</li><li>之后在md文件按照下面格式插入标签</li></ol><pre class="line-numbers language-none"><code class="language-none">单个标签1.tags: tag_name2.tags:    - tag_name 多个标签1.tags: [tag_name1, tag_name2]2.tags:   - tag_name1  - tag_name2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h2 id="2-4-安装插件"><a href="#2-4-安装插件" class="headerlink" title="2.4 安装插件"></a>2.4 安装插件</h2><h3 id="2-4-1-字数统计"><a href="#2-4-1-字数统计" class="headerlink" title="2.4.1 字数统计"></a>2.4.1 字数统计</h3><p><strong>安装</strong>：在cmd下输入 npm i –save hexo-wordcount</p><p>主站点配置文件设置：</p><pre class="line-numbers language-none"><code class="language-none">wordCount:  enable: true          # 将这个值设置为 true 即可.  postWordCount: true   # 字数统计  min2read: true        # 阅读时间推测  totalCount: true      # 累计阅读次数统计<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-2-代码高亮"><a href="#2-4-2-代码高亮" class="headerlink" title="2.4.2 代码高亮"></a>2.4.2 代码高亮</h3><p><strong>安装</strong>：在cmd下输入 npm i -S hexo-prism-plugin</p><ol><li>禁用默认 highlight，启用 prismjs</li></ol><pre class="line-numbers language-none"><code class="language-none">highlight:  enable: false   # 禁用  ...prismjs:  enable: true    # 启用  ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol start="2"><li>配置 prismjs 高亮</li></ol><pre class="line-numbers language-none"><code class="language-none">prism_plugin:  mode: &#39;preprocess&#39;    # realtime&#x2F;preprocess  theme: &#39;tomorrow&#39;  line_number: true     # 显示代码行数  custom_css:<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-4-3-站内搜索"><a href="#2-4-3-站内搜索" class="headerlink" title="2.4.3 站内搜索"></a>2.4.3 站内搜索</h3><p><strong>安装</strong>：在cmd下输入 npm install hexo-generator-search –save</p><pre class="line-numbers language-none"><code class="language-none">search:  path: search.xml    # path：索引文件的路径，相对于站点根目录  field: post          # field：搜索范围，默认是 post，还可以选择 page、all，设置成 all 表示搜索所有页面  format: html  limit: 10000        # limit：限制搜索的条目数# 同时需要配置 jsonContentjsonContent:  meta: true  drafts: false  file: content.json  keywords: undefined  dateFormat: undefined  pages:    title: true    slug: true    date: true    updated: true    comments: true    path: true    link: true    permalink: true    excerpt: true    keywords: false    text: true    raw: false    content: false    author: true  posts:    title: true    slug: true    date: true    updated: true    comments: true    path: true    link: true    permalink: true    excerpt: true    keywords: false    text: true    raw: false    content: false    author: true    categories: true    tags: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 安装使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MD语法</title>
      <link href="/202104/0739286.html"/>
      <url>/202104/0739286.html</url>
      
        <content type="html"><![CDATA[<p>写在前面：本文主要记录MarkDown文件的编写指令</p><span id="more"></span><h1 id="1-标题"><a href="#1-标题" class="headerlink" title="1. 标题"></a>1. 标题</h1><p>标题由井号 # 标识</p><ul><li>#  一级标题</li><li>##  二级标题</li><li>###  三级标题<br>注：最多仅支持六级标题，#与内容之间至少有一个空格，后面的所有符号与内容之间都至少要有一个空格隔开，文本标识符除外</li></ul><h1 id="2-区块"><a href="#2-区块" class="headerlink" title="2. 区块"></a>2. 区块</h1><p>区块用大于号 &gt; 标识</p><blockquote><p>区块说明</p><ul><li>&gt; 父级区域</li><li>&gt;&gt; 子级区域</li></ul><blockquote><p>代码块说明 </p><ul><li>单行代码用反引号包裹，例`代码`</li><li>多行代码用三个反引号包裹，例```代码```</li></ul></blockquote></blockquote><h1 id="3-列表"><a href="#3-列表" class="headerlink" title="3. 列表"></a>3. 列表</h1><p>列表的标识符有加号 +、减号 -、星号 * （无序列表，与内容间有一个空格）和数字（数字加上英文句号 . ，与内容间有一个空格）等</p><ul><li>无序列表<br>+ 内容一<br>- 内容二<br>* 内容三<br>注：加号 +、减号 -、星号 * 可以混合使用</li><li>有序列表<ol><li>内容一</li><li>内容二</li><li>内容三</li></ol></li><li>列表嵌套<br>- 父级目录<br>  - 子级目录<br>注：列表嵌套需要在父级目录的基础上缩进两个空格的位置，再输入列表标识符</li></ul><h1 id="4-文本"><a href="#4-文本" class="headerlink" title="4. 文本"></a>4. 文本</h1><p>文本样式是由星号 *  或下划线 _ 包裹</p><ul><li>斜    体：一个星号或一个下划线，例：*内容* 或  _内容_</li><li>加    粗：两个星号或两个下划线，例：**内容** 或  __内容__</li><li>粗斜体：三个星号或三个下划线，例：***内容*** 或  ___内容___</li><li>删除线：两个波浪线包裹，例：~~内容~~</li></ul><p><strong>自定义文本样式</strong>：支持 h5语法自定义设置文本样式</p><pre class="line-numbers language-none"><code class="language-none">&lt;font face &#x3D; &quot;微软雅黑&quot; color &#x3D; 1E90FF size &#x3D; 5&gt; 内容 &lt;&#x2F;font&gt;face：设置字体color：设置颜色，支持 16进制RGB色素值和颜色名称（#1E90FF &#x2F; DoderBlue），使用时不需要 #号，不是所有的颜色都有英文名，推荐使用16进制RGB色素值size：设置大小注：&lt;font&gt;和&lt;&#x2F;font&gt; 里面的 &lt; 后面不允许有空格<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><a href="https://www.sioe.cn/yingyong/"><font face = "微软雅黑" color = 1E90FF size = 5>颜色参考网址</font></a></p><h1 id="5-表格"><a href="#5-表格" class="headerlink" title="5. 表格"></a>5. 表格</h1><p>表格由冒号 : 、竖线 | 和横线 - 标识，由冒号的位置设置文本对齐方式，左对齐 :— ，右对齐 —:，居中对齐 :–:，中间横线的个数没有规定<br>|列名1|列名2|列名3|<br>|:——-|——-:|:——:|<br>|(1 , 1)|(1 , 2)|(1 , 3)|<br>|(2 , 1)|(2 , 2)|(2 , 3)|<br>可以简化为<br>列名1|列名2|列名3<br>:——-|——-:|:——:<br>(1 , 1)|(1 , 2)|(1 , 3)<br>(2 , 1)|(2 , 2)|(2 , 3)</p><h1 id="6-引用"><a href="#6-引用" class="headerlink" title="6. 引用"></a>6. 引用</h1><p>引用是由中括号 [] 进行包裹</p><ul><li><strong>超链接</strong>： [显示内容](链接地址)，例：[百度](<a href="https://www.baidu.com/">https://www.baidu.com/</a>)</li></ul><blockquote><p>引用模式：</p><blockquote><p>[显示内容][引用名]<br>引用名可以随便取，中间至少空一行，也可以多行，可以在中间输入其他内容<br>[引用名]:链接地址</p></blockquote></blockquote><pre class="line-numbers language-none"><code class="language-none">[百度][网址]中间内容[网址]:https:&#x2F;&#x2F;www.baidu.com&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p><strong>图片</strong>： </p><ul><li>![显示内容](图片地址.图片名.文件格式)，例：![图片](C:/Test/Image.jpg)</li></ul><blockquote><p>可以引用本地图片，也可以引用网络图片</p></blockquote><ul><li>![显示内容](base64编码)，例：![图片](data:image/png;base64,iVBO….)</li></ul><blockquote><p><a href="http://www.jsons.cn/img2base64/"><font face = "微软雅黑" color = 1E90FF size = 5>在线获取图片base64编码</font></a><br>代码实现</p></blockquote><pre class="line-numbers language-none"><code class="language-none">import base64with open(&quot;C:\\Users\\Administrator\\Desktop\\1.jpg&quot;, &#39;rb&#39;) as f:    base64_data &#x3D; base64.b64encode(f.read())    s &#x3D; base64_data.decode()    print(&#39;data:image&#x2F;jpeg;base64,%s&#39;%s)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>&lt;img src=”图片地址.图片名.文件格式”  width=”50%” height=”50%” /&gt;</li></ul><pre class="line-numbers language-none"><code class="language-none">src：设置显示图像的 URL地址width：设置图像的宽度height：设置图像的高度<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><blockquote><p>引用模式：方法同上超连接引用，base64有很长一段内容，插入到中间影响编辑，可以采用引用模式将base64的编码字符串放置到文章末尾</p></blockquote><ul><li><strong>表情</strong>：由双冒号包裹表情值，如：:表情值: ； 例：:+1:<br><a href="https://www.webfx.com/tools/emoji-cheat-sheet/"><font face = "微软雅黑" color = 1E90FF size = 5>表情值参考网址</font></a></li></ul><h1 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h1><p>Typora 快速切换至源代码模式：Ctrl + / </p>]]></content>
      
      
      <categories>
          
          <category> 基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
